Eï¬€icient Computation of Quantiles over Joins
Nikolaos Tziavelis, Nofar Carmeli, Wolfgang Gatterbauer, Benny Kimelfeld,

Mirek Riedewald

To cite this version:

Nikolaos Tziavelis, Nofar Carmeli, Wolfgang Gatterbauer, Benny Kimelfeld, Mirek Riedewald. Ef-
ficient Computation of Quantiles over Joins. SIGMOD/PODS 2023 - International Conference on
Management of Data, Jun 2023, Seattle, WA, United States. pp.303-315, ï¿¿10.1145/3584372.3588670ï¿¿.
ï¿¿lirmm-04277973ï¿¿

HAL Id: lirmm-04277973

https://hal-lirmm.ccsd.cnrs.fr/lirmm-04277973

Submitted on 9 Nov 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

Lâ€™archive ouverte pluridisciplinaire HAL, est
destinÃ©e au dÃ©pÃ´t et Ã  la diffusion de documents
scientifiques de niveau recherche, publiÃ©s ou non,
Ã©manant des Ã©tablissements dâ€™enseignement et de
recherche franÃ§ais ou Ã©trangers, des laboratoires
publics ou privÃ©s.

Nikolaos Tziavelis
Northeastern University
Boston, MA, United States
tziavelis.n@northeastern.edu

Efficient Computation of Quantiles over Joins
Nofar Carmeli
Inria, LIRMM, Univ Montpellier,
CNRS
Montpellier, France
nofar.carmeli@inria.fr

Wolfgang Gatterbauer
Northeastern University
Boston, MA, United States
w.gatterbauer@northeastern.edu

Benny Kimelfeld
Technion - Israel Institute of
Technology
Haifa, Israel
bennyk@technion.ac.il

Mirek Riedewald
Northeastern University
Boston, MA, United States
m.riedewald@northeastern.edu

ABSTRACT
We present efficient algorithms for Quantile Join Queries, abbre-
viated as %JQ. A %JQ asks for the answer at a specified relative
position (e.g., 50% for the median) under some ordering over the
answers to a Join Query (JQ). Our goal is to avoid materializing the
set of all join answers, and to achieve quasilinear time in the size of
the database, regardless of the total number of answers. A recent
dichotomy result rules out the existence of such an algorithm for a
general family of queries and orders. Specifically, for acyclic JQs
without self-joins, the problem becomes intractable for ordering by
sum whenever we join more than two relations (and these joins are
not trivial intersections). Moreover, even for basic ranking func-
tions beyond sum, such as min or max over different attributes, so
far it is not known whether there is any nontrivial tractable %JQ.
In this work, we develop a new approach to solving %JQ and show
how this approach allows not just to recover known results, but also
generalize them and resolve open cases. Our solution uses two sub-
routines: The first one needs to select what we call a â€œpivot answerâ€.
The second subroutine partitions the space of query answers ac-
cording to this pivot, and continues searching in one partition that
is represented as new %JQ over a new database. For pivot selection,
we develop an algorithm that works for a large class of ranking
functions that are appropriately monotone. The second subroutine
requires a customized construction for the specific ranking function
at hand.

We show the benefit and generality of our approach by using
it to establish several new complexity results. First, we prove the
tractability of min and max for all acyclic JQs, thereby resolving
the above question. Second, we extend the previous %JQ dichotomy
for sum to all partial sums (over all subsets of the attributes). Third,
we handle the intractable cases of sum by devising a deterministic
approximation scheme that applies to every acyclic JQ.

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA
Â© 2023 Copyright held by the owner/author(s). Publication rights licensed to ACM.
This is the authorâ€™s version of the work. It is posted here for your personal use. Not
for redistribution. The definitive Version of Record was published in Proceedings of the
42nd ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems (PODS
â€™23), June 18â€“23, 2023, Seattle, WA, USA, https://doi.org/10.1145/3584372.3588670.

1

CCS CONCEPTS
â€¢ Theory of computation â†’ Database query processing and
optimization (theory); Database theory.

KEYWORDS
join queries, quantiles, median, ranking function, answer order,
pivot, approximation, inequality predicates

ACM Reference Format:
Nikolaos Tziavelis, Nofar Carmeli, Wolfgang Gatterbauer, Benny Kimelfeld,
and Mirek Riedewald. 2023. Efficient Computation of Quantiles over Joins.
In Proceedings of the 42nd ACM SIGMOD-SIGACT-SIGAI Symposium on
Principles of Database Systems (PODS â€™23), June 18â€“23, 2023, Seattle, WA, USA.
ACM, New York, NY, USA, 14 pages. https://doi.org/10.1145/3584372.3588670

1 INTRODUCTION
Quantile queries ask for the element at a given relative position
ğœ™ âˆˆ [0, 1] in a given list ğ¿ of items [21]. For example, the lower
quartile, median, and upper quartile are the elements at positions
ğœ™ = 0.25, ğœ™ = 0.5, and ğœ™ = 0.75, respectively. We investigate
quantile queries where ğ¿ is the result of a Join Query (JQ) ğ‘„ over a
database, with a ranking function that determines the order between
the answers. Importantly, the list ğ¿ can be much larger than the
input database ğ· (specifically, ğ¿ can be Î©(|ğ· |ğ‘˜ ) for some degree ğ‘˜
determined by ğ‘„), and so, ğ‘„ and ğ· form a compact representation
for ğ¿. Our main research question is when we can find the quantile
in quasilinear time. In other words, the time suffices for reading ğ·,
but we are generally prevented from materializing ğ‘„ (ğ·).

For illustration, consider a social network where users orga-
nize events, share event announcements, and declare their plans
to attend events. It has the three relations Admin(user, event),
Share(user, event, #likes), and Attend(user, event, #likes). We wish
to extract statistics about triples of users involved in events, begin-
ning by joining the three relations using the JQ

Admin(ğ‘¢1, ğ‘’) , Share(ğ‘¢2, ğ‘’, ğ‘™2) , Attend(ğ‘¢3, ğ‘’, ğ‘™3).
Now, suppose that all we do is apply a quantile query to the result
of ğ‘„, say the 0.1-quantile ordered by ğ‘™2 + ğ‘™3 (the sum of likes of the
share and the participation). The direct way of finding the quantile
is to materialize the join, sort the resulting tuples, and take the
element at position ğœ™ = 0.1. Yet, this result might be considerably
larger than the database, and prohibitively expensive to compute,
even though in the end we care only about one value. Can we do

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Nikolaos Tziavelis, Nofar Carmeli, Wolfgang Gatterbauer, Benny Kimelfeld, & Mirek Riedewald

better? This is the research question that we study in this paper.
In general, the answer depends on the JQ and order, and in this
specific example we can, actually, do considerably better.

To be more precise, we study the fine-grained data complexity of
query evaluation, where the query seeks a quantile over a JQ. We re-
fer to such a query as a Quantile Join Query and abbreviate it as %JQ.
So, the JQ ğ‘„ is fixed, and so is the ranking function (e.g., weighted
sum over a fixed subset of the variables). The input consists of ğ·
and ğœ™. In terms of the execution cost, we allow for poly-logarithmic
factors, therefore our goal is to devise evaluation algorithms that
run in time quasilinear in ğ·, that is, O (|ğ· | polylog(|ğ· |)).

To the best of our knowledge, little is known about the fine-
grained complexity of %JQ. We have previously studied this prob-
lem [7] for Conjunctive Queries (which are more general than Join
Queries since they also allow for projection) under the name â€œse-
lection problemâ€.1 Two types of orders were covered: sum of all
attributes and lexicographic orders. On the face of it, the conclu-
sion from our previous results is that we are extremely limited in
what we can do: The problem is intractable for every JQ with more
than two atoms (each having a set of variables that is not contained
in that of another atom, and assuming no self-joins), under con-
ventional conjectures in fine-grained complexity. Nevertheless, we
argue that our previous results tell only part of the story and miss
quite general opportunities for tractability:

â€¢ What if the sum involves just a subset of the variables, like in
the above social-network example? Then the lower bounds
for full sum do not apply. As it turns out, in this case we
often can achieve tractability for JQs of more than 2 atoms.
â€¢ What if we allow for some small error and not insist on the
precise ğœ™-quantile? As we argue later, this relaxation makes
the picture dramatically more positive.

In addition, there are ranking functions that have not been consid-
ered at all, notably minimum and maximum over attributes, such as
MIN(rate1, rate2) and MAX(width, height, depth). We do not see
any conclusion from past results on these, so the state of affairs
(prior to this paper) is that their complexity is an open problem.

In this work, we devise a new framework for evaluating %JQ
queries. We view the problem as a search problem in the space of
query answers, and the framework adopts a divide-and-conquer
â€œpivotingâ€ approach. For a JQ ğ‘„, we reduce the problem to two
subroutines, given ğ· and ğœ™:

â€¢ pivot: Find a pivot answer ğ‘ such that the set of answers
that precede ğ‘ and the set of answers that follow ğ‘ both
contain at least a constant fraction of the answers.

â€¢ trim: Partition the answers into three splits: less than, equal
to, and greater than ğ‘. Determine which one contains the
sought answer and, if it is not ğ‘, produce a new %JQ within
the relevant split using new ğ‘„ â€², ğ·â€² and ğœ™ â€². We view this
operation as trimming the split condition by updating the
database so that the remaining answers satisfy the condition.

We begin by showing that we can select a pivot in linear time for
every acyclic join query and every ranking function that satisfies

1To be precise, in the selection problem, the position of this answer is given as an
absolute index ğ‘– rather than a relative position ğœ™. (This problem is sometimes referred
to as unranking [18].) This difference is nonessential as far as this work concerns: all
our previous lower and upper bounds for selection on JQs apply to %JQs.

2

a monotonicity assumption (also used in the problem of ranked
enumeration [15, 23]), which all functions considered here satisfy.
Note that the assumption of acyclicity is required since, otherwise,
it is impossible to even determine whether the join query has any
answer in quasilinear time, under conventional conjectures in fine-
grained complexity [6]. Hence, the challenge really lies in trimming.

Contributions. Using our approach, we establish efficient algo-
rithms for several classes of queries and ranking functions, where
we show how to solve the trimming problem.

(1) We establish tractability for all acyclic JQs under the ranking

functions MIN and MAX.

(2) We recover (up to logarithmic factors) all past tractable

cases [7] for lexicographic orders and SUM.

(3) For self-join-free JQs and SUM, we complete the picture by
extending the previous dichotomy [7] (restricted to JQs) to
all partial sums.

We then turn our attention to approximate answers. Precisely,
we find an answer at a position within (1 Â± ğœ–)ğœ™ for an allowed error
ğœ–. (This is a standard notion of approximation for quantiles [9, 17].)
To obtain an efficient randomized approximation, it suffices to be
able to construct in quasilinear time a direct-access structure for
the underlying JQ, regardless of the answer ordering; if so, then
one can use a standard median-of-samples approach (with Hoeffd-
ingâ€™s inequality to guarantee the error bounds). Such algorithms
for direct-access structures have been established in the past for
arbitrary acyclic JQs [6, 8]. Instead, we take on the challenge of
deterministic approximation. Our final contribution is that:

(4) We show that with an adjustment of our pivoting framework,
we can establish a deterministic approximation scheme in
time quadratic in 1/ğœ– and quasilinear in database size.
In contrast to the randomized case, we found the task of determin-
istic approximation challenging, and our algorithm is indeed quite
involved. Again, the main challenge is in the trimming phase.

The remainder of the paper is organized as follows: We give pre-
liminary definitions in Section 2. We describe the general pivoting
framework in Section 3. In Section 4, we describe the pivot-selection
algorithm. The main results are in Sections 5 and 6 where we devise
exact and approximate trimmings, respectively, and establish the
corresponding tractability results. We conclude in Section 7.

2 PRELIMINARIES
2.1 Basic Notions
Sets. We use [ğ‘Ÿ ] to denote the set of integers {1, . . . , ğ‘Ÿ }. A multiset
ğ¿ is described by a 2-tuple (ğ‘, ğ›½), where ğ‘ is the set of its distinct
elements and ğ›½ : ğ‘ â†’ N is a multiplicity function. The set of all
possible multisets with elements ğ‘ is denoted by Nğ‘ .

Relational databases. A schema S is a set of relational symbols
{ğ‘…1, . . . , ğ‘…ğ‘š }. A database ğ· contains a finite relation ğ‘…ğ· âŠ† domğ‘ğ‘…
for each ğ‘… âˆˆ S, where dom is a set of constants called the domain,
and ğ‘ğ‘… is the arity of symbol ğ‘…. If ğ· is clear, we simply use ğ‘… instead
of ğ‘…ğ· . The size of ğ· is the total number of tuples, denoted by ğ‘›.

Join Queries. A Join Query (JQ) ğ‘„ over schema S is an expres-
sion of the form ğ‘…1 (X1), . . . , ğ‘…â„“ (Xâ„“ ), where {ğ‘…1, . . . , ğ‘…â„“ } âŠ† S and
the variables of ğ‘„ are var(ğ‘„) = âˆªğ‘– âˆˆ [â„“ ] Xğ‘– , sometimes interpreted
as a tuple instead of a set. Each ğ‘…ğ‘– (Xğ‘– ), ğ‘– âˆˆ [â„“] is called an atom of

Efficient Computation of Quantiles over Joins

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

ğ‘„. A repeated occurrence of a relational symbol is a self-join and a
JQ without self-joins is self-join-free. A query answer is a homomor-
phism from ğ‘„ to the database ğ·, i.e. a mapping from var(ğ‘„) to dom
constants, such that every atom ğ‘…ğ‘– (Xğ‘– ), ğ‘– âˆˆ [â„“] maps to a tuple of
ğ‘…ğ·
. The set of query answers to ğ‘„ over ğ· is denoted by ğ‘„ (ğ·) and
ğ‘–
we often represent a query answer ğ‘ âˆˆ ğ‘„ (ğ·) as a tuple of values
assigned to var(ğ‘„). For an atom ğ‘…ğ‘– (Xğ‘– ) of a JQ and database ğ·, we
say that tuple ğ‘¡ âˆˆ ğ‘…ğ·
ğ‘– assigns value ğ‘ to variable ğ‘¥, and write it as
ğ‘¡ [ğ‘¥] = ğ‘, if for every index ğ‘— such that Xğ‘– [ ğ‘—] = ğ‘¥ we have ğ‘¡ [ ğ‘—] = ğ‘.
For a predicate ğ‘ƒ (Xğ‘ƒ ) over variables Xğ‘ƒ âŠ† var(ğ‘„), we denote by
(ğ‘„ âˆ§ ğ‘ƒ)(ğ·) the subset of query answers ğ‘„ (ğ·) that satisfy ğ‘ƒ (Xğ‘ƒ ).
Hypergraphs. A hypergraph H = (ğ‘‰ , ğ¸) is a set ğ‘‰ of ver-
tices and a set ğ¸ âŠ† 2ğ‘‰ of hyperedges. A path in H is a sequence
of vertices such that every two consecutive vertices appear to-
gether in a hyperedge. A chordless path is a path in which no two
non-consecutive ones appear in the same hyperedge (in particular,
no vertex appears twice). The number of maximal hyperedges is
mh(H ) = |{ğ‘’ âˆˆ ğ¸ | (cid:154)ğ‘’â€² âˆˆ ğ¸ : ğ‘’ âŠ‚ ğ‘’â€²}|. A set of vertices ğ‘ˆ âŠ† ğ‘‰ is in-
dependent if no pair appears in a hyperedge, i.e., |ğ‘ˆ âˆ© ğ‘’ | â‰¤ 1, âˆ€ğ‘’ âˆˆ ğ¸.
Join trees. A join tree of a hypergraph H = (ğ‘‰ , ğ¸) is a tree ğ‘‡
where its nodes2 are the hyperedges of H and the running intersec-
tion property holds, namely: for all ğ‘¢ âˆˆ ğ‘‰ the set {ğ‘’ âˆˆ ğ¸ | ğ‘¢ âˆˆ ğ‘’}
forms a (connected) subtree in ğ‘‡ . We associate a hypergraph
H (ğ‘„) = (ğ‘‰ , ğ¸) to a JQ ğ‘„ where the vertices are the variables
of ğ‘„, and every atom of ğ‘„ corresponds to a hyperedge with the
same set of variables. With a slight abuse of notation, we identify
atoms of ğ‘„ with hyperedges of H (ğ‘„). A JQ ğ‘„ is acyclic if there
exists a join tree for H (ğ‘„), otherwise it is cyclic. If we root the join
tree, the subtree rooted at a node ğ‘ˆ defines a subquery, i.e., a JQ
that contains only the atoms of descendants of ğ‘ˆ . A partial query
answer (for the subtree) rooted at ğ‘ˆ is an answer to the subquery.
If we materialize a relation ğ‘…ğ‘ˆ for node ğ‘ˆ , a partial query answer
(for the subtree) rooted at ğ‘¡ âˆˆ ğ‘…ğ‘ˆ must additionally agree with ğ‘¡.

Complexity. We measure complexity in the database size ğ‘›,
while query size is considered constant. The model of computation
is the standard RAM model with uniform cost measure. In particular,
it allows for linear-time construction of lookup tables, which can
be accessed in constant time. Following our prior work [7], we only
consider comparison-based sorting, which takes quasilinear time.

2.2 Orders over Query Answers
To define %JQs, we assume an ordering of the query answers by
a given ranking function. The ranking function is described by a
2-tuple (ğ‘¤, âª¯) where a weight function ğ‘¤ : ğ‘„ (ğ·) â†’ domğ‘¤ maps
the answers to a weight domain domğ‘¤ equipped with a total order
âª¯. We denote the strict version of the total order by â‰º. Assuming
consistent tie-breaking, the total order extends to query answers,
i.e., for ğ‘1, ğ‘2 âˆˆ ğ‘„ (ğ·), ğ‘1 âª¯ ğ‘2 iff ğ‘¤ (ğ‘1) â‰º ğ‘¤ (ğ‘2) or ğ‘¤ (ğ‘1) = ğ‘¤ (ğ‘2)
and ğ‘1 is (arbitrarily but consistently) chosen to break the tie.

Weight aggregation model. We focus on the case of aggregate
ranking functions where the query answer weights are computed by
aggregating weights are assigned to the input database. In particular,
an input-weight function ğ‘¤ğ‘¥ : dom â†’ domğ‘¤ associates each value
of variable ğ‘¥ with a weight in domğ‘¤. An aggregate function aggğ‘¤ :
Ndomğ‘¤ â†’ domğ‘¤ takes a multiset of weights and produces a single

2To avoid confusion, we use the terms hypergraph vertices and tree nodes.

weight. Aggregate ranking functions are typically not sensitive to
the order in which the input weights are given [11, 12], captured
by the fact that their input is a multiset. Query answers map to
domğ‘¤ by aggregating the weights of values assigned to a subset
of the input variables ğ‘ˆğ‘¤ âŠ† var(ğ‘„) with an aggregate function
aggğ‘¤. Thus, the weight of a query answer ğ‘ âˆˆ ğ‘„ (ğ·) is ğ‘¤ (ğ‘) =
aggğ‘¤ ({ğ‘¤ğ‘¥ (ğ‘[ğ‘¥]) | ğ‘¥ âˆˆ ğ‘ˆğ‘¤ }). When we do not have a specific
assignment from variables to values, we use ğ‘¤ (ğ‘ˆğ‘¤) to refer to the
expression aggğ‘¤ ({ğ‘¤ğ‘¥ (ğ‘¥) | ğ‘¥ âˆˆ ğ‘ˆğ‘¤ }). For example, if var(ğ‘„) =
{ğ‘¥1, ğ‘¥2, ğ‘¥3}, ğ‘ˆğ‘¤ = {ğ‘¥1, ğ‘¥3}, ğ‘¤ğ‘¥ (ğ‘¥) is the identity function for all
varaibles ğ‘¥, and aggğ‘¤ is summation, then ğ‘¤ (ğ‘ˆğ‘¤) = ğ‘¥1 + ğ‘¥3.

Concrete ranking functions. In this paper, we discuss three

types of ranking functions:

(1) SUM: domğ‘¤ is R and aggğ‘¤ is summation. We use the term
full SUM when ğ‘ˆğ‘¤ = var(ğ‘„) and partial SUM otherwise.

(2) MIN/ MAX: domğ‘¤ is R and aggğ‘¤ is min or max.
(3) LEX: Lexicographic orders fit into our framework by letting
the domain domğ‘¤ consist of tuples in N|ğ‘ˆğ‘¤ | . Every variable
ğ‘¥ âˆˆ ğ‘ˆğ‘¤ is mapped to domğ‘¤ as a tuple (0, . . . , ğ‘¤ â€²
ğ‘¥ (ğ‘¥), . . . , 0)
where ğ‘¤ â€²
ğ‘¥ (ğ‘¥) occupies the position of ğ‘¥ in the lexicographic
order and ğ‘¤ â€²
ğ‘¥ : dom â†’ N that orders the
domain of ğ‘¥ by mapping it to natural numbers. The aggregate
function aggğ‘¤ is then element-wise addition, while the order
âª¯ compares these tuples lexicographically.

ğ‘¥ is a function ğ‘¤ â€²

Problem definition. Let ğ‘„ be a JQ and (ğ‘¤, âª¯) a ranking function.
Given a database ğ·, a query answer ğ‘ âˆˆ ğ‘„ (ğ·) is a ğœ™-quantile [21]
of ğ‘„ (ğ·) for some ğœ™ âˆˆ [0, 1] if there exists a valid ordering of
ğ‘„ (ğ·) where there are âŒˆğœ™ |ğ‘„ (ğ·)|âŒ‰ answers less-than or equal-to ğ‘
and âŒŠ(1 âˆ’ ğœ™)|ğ‘„ (ğ·)|âŒ‹ answers greater than ğ‘. A %JQ asks for a ğœ™-
quantile given ğ· and ğœ™. Similarly, an ğœ–-approximate %JQ asks for a
(ğœ™ Â± ğœ–)-quantile for a given ğ·, ğœ™, and ğœ– âˆˆ (0, 1).

Monotonicity. Let âŠ be multiset union. An (aggregate) ranking
function is subset-monotone [23] if aggğ‘¤ (ğ¿1) âª¯ aggğ‘¤ (ğ¿2) implies
that aggğ‘¤ (ğ¿ âŠ ğ¿1) âª¯ aggğ‘¤ (ğ¿ âŠ ğ¿2) for all multisets ğ¿, ğ¿1, ğ¿2. All
ranking functions we consider in this work have this property. We
note that subset-monotonicity has been used as an assumption in
ranked enumeration [15, 23] and is a stronger requirement than
the more well-known monotonicity notion of Fagin et al. [10].

Tuple weights. Our ranking function definition uses attribute-
weights but some of our algorithms are easier to describe when
dealing with tuple weights. We can convert the former to the latter
in linear time. First, we eliminate self-joins by materializing a fresh
relation for every repeated symbol in the query ğ‘„. Second, to avoid
giving the weight of a variable to tuples of multiple relations, we
define a mapping ğœ‡ that assigns each variable ğ‘¥ âˆˆ ğ‘ˆğ‘¤ to a relation
ğ‘… such that ğ‘¥ occurs in the ğ‘…-atom of ğ‘„. The weight of a tuple
ğ‘¡ âˆˆ ğ‘… is then the multiset of weights for variables assigned to ğ‘…:
ğ‘¤ğ‘… (ğ‘¡) = {ğ‘¤ğ‘¥ (ğ‘¡ [ğ‘¥]) | ğ‘¥ âˆˆ ğ‘ˆğ‘¤, ğœ‡ (ğ‘¥) = ğ‘…}. 3 The total order âª¯ can be
extended to sets of tuples (ğ‘¡1, . . . , ğ‘¡ğ‘Ÿ ) (and thus query answers) by
aggregating all individual weights contained in the tuple weights.

3The reason that we maintain the attribute weights as a set instead of aggregating
them is that the aggregate ranking function can be holistic [11], in which case we
lose the ability to further aggregate. If, on the other hand, the ranking function is
distributive [11] like SUM, then we can aggregate to obtain a single weight for a tuple.

3

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Nikolaos Tziavelis, Nofar Carmeli, Wolfgang Gatterbauer, Benny Kimelfeld, & Mirek Riedewald

2.3 Known Bounds
Certain upper and (conditional) lower bounds for %JQ follow from
our previous work [7] on the selection problem which asks for the
query answer at index ğ‘˜. The two problems are equivalent for
acyclic JQs, since an index can be translated into a fraction ğœ™, and
vice-versa, by knowing |ğ‘„ (ğ·)|, which can be computed in linear
time as we explain in Section 2.4.

The lower bounds are based on two hypotheses:
(1) Hypercliqe [1, 16]: Let a (ğ‘˜+1, ğ‘˜)-hyperclique be a set of
ğ‘˜+1 vertices such that every subset of ğ‘˜ elements is a hyper-
edge. For every ğ‘˜ â‰¥ 2, there is no ğ‘‚ (ğ‘š polylog ğ‘š) algorithm
for deciding the existence of a (ğ‘˜+1, ğ‘˜)-hyperclique in a ğ‘˜-
uniform hypergraph with ğ‘š hyperedges.

(2) 3sum [4, 19]: For any ğœ– > 0, we cannot decide in time
ğ‘‚ (ğ‘š2âˆ’ğœ– ) whether there exist ğ‘ âˆˆ ğ´, ğ‘ âˆˆ ğµ, ğ‘ âˆˆ ğ¶ from three
integer sets ğ´, ğµ, ğ¶, each of size Î©(ğ‘š), such that ğ‘ +ğ‘ + ğ‘ = 0.
Hypercliqe implies that we cannot decide in O (ğ‘› polylog ğ‘›) if a
cyclic, self-join-free JQ has any answer [6]. For LEX, an acyclic %JQ
can be answered in O (ğ‘›) [7]. For full SUM, an acyclic %JQ can be
answered in O (ğ‘› log ğ‘›) if its maximal hyperedges are at most 2, and
the converse is true if it is also self-join-free, assuming 3sum [7].

2.4 Message Passing
Message passing is a common algorithmic pattern that many al-
gorithms for acyclic JQs follow. For example, it allows us to count
the number of answers to an acyclic JQ in linear time [3, 20]. Some
of the algorithms that we develop also follow this pattern, that we
abstractly describe below.

Preprocessing. Choose an arbitrary root for a join tree ğ‘‡ of
the JQ, and materialize a distinct relation for every ğ‘‡ -node. For
every parent node ğ‘‰ğ‘ and child node ğ‘‰ğ‘ , group the ğ‘‰ğ‘ -relation by
the ğ‘‰ğ‘ âˆ© ğ‘‰ğ‘ variables. We will refer to these groups of tuples as join
groups; a join group shares the same values for variables that appear
in the parent node. The algorithm visits the relations in a bottom-
up order of ğ‘‡ , sending children-to-parent messages. The goal is to
compute a value val(ğ‘¡) for each tuple ğ‘¡ of these relations, initialized
according to the specific algorithm. Sometimes, it is convenient to
add an artificial root node ğ‘‰0 = âˆ… to the join tree, which refers to a
zero-arity relation with a single tuple ğ‘¡0 = (). Tuple ğ‘¡0 joins with
all tuples of the previous root and its purpose is only to gather the
final result at the end of the bottom-up pass.

Messages. As we traverse the relations in bottom-up order, every
tuple ğ‘¡ emits its val(ğ‘¡). These messages are aggregated as follows:
(1) Messages emitted by tuples ğ‘¡ â€² in a join group are aggregated
with an operator âŠ•. The result is sent to all parent-relation
tuples that agree with the join values of the group.

(2) A tuple ğ‘¡ computes val(ğ‘¡) by aggregating the messages re-
ceived from all children in the join tree, together with the
initial value of val(ğ‘¡), with an operator âŠ—.

Example 2.1 (Count). To count the JQ answers, we initialize
cnt(ğ‘¡) = 1 for all tuples ğ‘¡, set âŠ• to product ((cid:206)), and âŠ— to sum ((cid:205)).
Figure 1 illustrates how messages are aggregated so that cnt(ğ‘¡) is
the number of partial answers for the subtree rooted at ğ‘¡. To get
the final count, we sum the counts in the root relation (9 + 4 = 13 in
the example), e.g., by introducing the artificial root-node tuple ğ‘¡0.

(a) Example database and final
counts of subtree answers.

(b) Messages received and aggre-
gated by an ğ‘…-tuple.

Figure 1: Message passing for counting the answers to the JQ
ğ‘…(ğ‘¥1, ğ‘¥2), ğ‘† (ğ‘¥1, ğ‘¥3),ğ‘‡ (ğ‘¥2, ğ‘¥4), ğ‘ˆ (ğ‘¥4, ğ‘¥5).

3 DIVIDE-AND-CONQUER FRAMEWORK
We describe a general divide-and-conquer framework for acyclic
%JQs that applies to different ranking functions. It follows roughly
the same structure as linear-time selection [5] in a given array
of elements. This classic algorithm searches for the element at a
desired index ğ‘˜ in the array by â€œpivotingâ€. In every iteration, it
selects a pivot element and creates three array partitions: elements
that are lower, equal, and higher than the pivot. Depending on
the partition sizes and the value of ğ‘˜, it chooses one partition and
continues with that, thereby reducing the number of candidate
elements. We adapt the high-level steps of this algorithm to our
setting. The crucial challenge is that we do not have access to the
materialized array of query answers (which can be very large),
but only to the input database and JQ that produce them. In the
following, we discuss the general structure of the algorithm and
the subroutines that are required for it to work. In later sections,
we then concretely specify these subroutines.

Pivot selection. We define what constitutes a â€œgoodâ€ pivot. In-
tuitively, it is an element whose position is roughly in the middle of
the ordering. With such a pivot, the partitioning step is guaranteed
to eliminate a significant number of elements, resulting in quick
convergence. Ideally, we would want to have the true median as
our pivot because it is guaranteed to eliminate the largest fraction
( 1
2 ) of elements. However, to achieve convergence in a logarith-
mic number of iterations, it is sufficient to choose any pivot that
eliminates any constant fraction ğ‘ > 0 of elements.

Definition 3.1 (ğ‘-pivot). For a constant ğ‘ âˆˆ (0, 1) and a set ğ‘
equipped with a total order âª¯, a ğ‘-pivot ğ‘ for ğ‘ is an element of ğ‘
such that |{ğ‘§ âˆˆ ğ‘ | ğ‘ âª¯ ğ‘§}| â‰¥ ğ‘ |ğ‘ | and |{ğ‘§ âˆˆ ğ‘ | ğ‘ âª° ğ‘§}| â‰¥ ğ‘ |ğ‘ |.

Our goal is to find such a ğ‘-pivot for the set of query answers

ğ‘„ (ğ·) ordered by the given ranking function.

Partitioning. Assuming an appropriate query answer ğ‘ as our
pivot, we use it to partition the query answers. This means that we
want to separate the answers into those whose weight is less than,
equal to, and greater than the weight of the pivot. Since we do not
have access to the query answers, this partitioning step must be
performed on the input database and JQ. The less-than and greater-
than partitions can be described by the original JQ, together with
inequality predicates: (1) ğ‘¤ (ğ‘ˆğ‘¤) â‰º ğ‘¤ (ğ‘) and (2) ğ‘¤ (ğ‘ˆğ‘¤) â‰» ğ‘¤ (ğ‘)

4

ğ‘†(ğ‘¥1,ğ‘¥3)cnt131141151231241ğ‘…(ğ‘¥1,ğ‘¥2)cnt119224ğ‘‡(ğ‘¥2,ğ‘¥4)cnt162171262ğ‘ˆ(ğ‘¥4,ğ‘¥5)cnt6816917911,11,31,41,51,61,7ğ‘…(ğ‘¥1,ğ‘¥2)ğ‘†(ğ‘¥1,ğ‘¥3)ğ‘‡(ğ‘¥2,ğ‘¥4)111211+1+1=32+1=33Ã—3Ã—1=9Efficient Computation of Quantiles over Joins

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

respectively. The equal-to partition can be assumed to contain all
answers that do not fall into either of the other two.

Trimming inequalities. If we materialize as database relations
the inequalities that arise from the partitioning step, their size can
be very large. For example, the inequality ğ‘¥1 + ğ‘¥2 + ğ‘¥3 < 0 for
three variables ğ‘¥1, ğ‘¥2, ğ‘¥3 has a listing representation of size O (ğ‘›3).
However, in certain cases it is possible to represent them more
efficiently, e.g., in space O (ğ‘› polylog ğ‘›), by modifying the original
JQ and database. We call this process â€œtrimming.â€

Definition 3.2 (Predicate Trimming). Given a JQ ğ‘„ and a predicate
ğ‘ƒ (ğ‘ˆ ) with variables ğ‘ˆ âŠ† var(ğ‘„), a trimming of ğ‘ƒ (ğ‘ˆ ) from ğ‘„
receives a database ğ· and returns a JQ ğ‘„ â€² of size O (|ğ‘„ |) and with
var(ğ‘„) âŠ† var(ğ‘„ â€²), and a database ğ·â€² for which there exists an
O (1)-computable bijection from ğ‘„ â€² (ğ·â€²) to (ğ‘„ âˆ§ ğ‘ƒ)(ğ·). Trimming
time is the time required to construct ğ‘„ â€² and ğ·â€².

Efficient trimmings of predicates are for instance known for ad-
ditive inequalities when the sum variables are found in adjacent JQ
atoms [22] and for not-all-equals predicates [14], which are a gen-
eralization of non-equality (â‰ ). Ultimately, our ability to partition
and the success of our approach relies on the existence of efficient
trimmings of inequalities that involve the aggregate function.

Choosing a partition. After we obtain three new JQs and cor-
responding databases by trimming, we count their query answers
to determine where the desired index (calculated from the given
percentage) falls into. To ensure that this can be done in linear
time, we want all JQs to be acyclic, and so we restrict ourselves to
trimmings that do not alter the acyclicity of the JQs. To keep track
of the candidate query answers, we maintain two weights low and
high as bounds, which define a contiguous region in the sorted
array of query answers. Every iteration then applies trimming for
two additional inequalities ğ‘¤ (ğ‘ˆğ‘¤) â‰» low and ğ‘¤ (ğ‘ˆğ‘¤) â‰º high in
order to restrict the search to the current candidate set.

Termination. The algorithm terminates when the desired index
falls into the equal partition since any of its answers, including
our pivot, is a ğœ™-quantile.4 It also terminates when the number of
candidate answers is sufficiently small, by calling the Yannakakis
algorithm [24] to materialize them and then applying linear-time
selection [5]. With ğ‘-pivots, we eliminate at least ğ‘ |ğ‘„ (ğ·)| answers
in every iteration; hence, the candidate query answers will be O (ğ‘›)
after a logarithmic number of iterations. Notice that our trimming
definition allows the new database to be larger than the starting
one, so the database size may increase across iterations. However,
the number of JQ answers decreases, ensuring termination.

Summary. Our algorithm repeats the above steps (selecting
pivot, partitioning, trimming) iteratively. It requires the implemen-
tation of two subroutines: (1) selecting a ğ‘-pivot among the JQ
answers, which we call â€œpivotâ€, and (2) trimming of inequalities,
which we call â€œtrimâ€. The pseudocode is in Appendix B.

Lemma 3.3 (Exact Quantiles). Let Q be a class of acyclic JQs

and (ğ‘¤, âª¯) a ranking function. If for all ğ‘„ â€² âˆˆ Q

(1) there exists a constant ğ‘ such that for any database ğ·, a ğ‘-
pivot for ğ‘„ â€² (ğ·) can be computed in time O (ğ‘”ğ‘ (ğ‘›)) for some
function ğ‘”ğ‘ , and

4If we want to enforce the same tie-breaking scheme across different calls to our
algorithm, we could continue searching within the equal partition with a LEX order,
but this requires also trimming for equality-type predicates.

5

(2) for all ğœ† âˆˆ domğ‘¤, there exist trimmings of ğ‘¤ (ğ‘ˆğ‘¤) â‰º ğœ† and
ğ‘¤ (ğ‘ˆğ‘¤) â‰» ğœ† from ğ‘„ â€² that return ğ‘„ â€²â€² âˆˆ Q in time O (ğ‘”ğ‘¡ (ğ‘›))
for some function ğ‘”ğ‘¡ ,

then a %JQ can be answered for all ğ‘„
O (max{ğ‘”ğ‘ (ğ‘›), ğ‘”ğ‘¡ (ğ‘›)} log ğ‘›).

âˆˆ Q in time

Notice that trimming can result in a different query than the one
we start with. This is why pivot-selection and trimming need to
applicable not just to the input query ğ‘„, but to all queries that we
may obtain from trimming (referred to as a class in Lemma 3.3).

Example 3.4. Suppose that ğ‘„ is ğ‘…1 (ğ‘¥1, ğ‘¥2), ğ‘…2 (ğ‘¥2, ğ‘¥3) over a data-
base ğ· and we want to compute the median by SUM with at-
tribute weights equal to their values. First, we call pivot to ob-
tain a pivot answer ğ‘, which we use to create two partitions: one
with ğ‘¥1 + ğ‘¥2 + ğ‘¥3 < ğ‘¤ (ğ‘), and one with ğ‘¥1 + ğ‘¥2 + ğ‘¥3 > ğ‘¤ (ğ‘).
Second, we call trim on these inequalities. By a known con-
struction [22], these inequalities can be trimmed in O (ğ‘› log ğ‘›).
This construction adds a new column and variable ğ‘£ to both re-
lations. We now have two JQs ğ‘„lt and ğ‘„gt, over databases ğ·lt,
ğ·gt. For example, ğ‘„lt is ğ‘…1lt (ğ‘¥1, ğ‘¥2, ğ‘£), ğ‘…2lt (ğ‘£, ğ‘¥2, ğ‘¥3). Suppose that
|ğ‘„ (ğ·)| = 1001, hence the desired index is ğ‘˜ = 500 (with zero-
indexing). If |ğ‘„lt (ğ·lt)| = 400 and |ğ‘„gt (ğ·gt)| = 600, we can infer
that the middle partition contains 1 one answer with weight ğ‘¤ (ğ‘).
Thus, we have to continue searching in the index range from 401 to
1000 with ğ‘˜â€² = 500 âˆ’ 400 âˆ’ 1 = 99. To create less-than and greater-
than partitions in the next iteration, we will start with the original
ğ‘„ and ğ· and apply inequalities ğ‘¤ (ğ‘) â‰¤ ğ‘¥1 + ğ‘¥2 + ğ‘¥3 < ğ‘¤ (ğ‘â€²) and
ğ‘¤ (ğ‘â€²) < ğ‘¥1 + ğ‘¥2 + ğ‘¥3 < âˆ with some new pivot ğ‘â€².

In Section 4, we will show that an efficient algorithm for pivot
exists for any subset-monotone ranking function. For trim, the
situation is more tricky and no generic solution is known. For
each ranking function, we design a trimming algorithm tailored
to it. This is precisely where we encounter the known conditional
hardness of SUM [7]. For example, a quasilinear trimming for
ğ‘„ (ğ‘¥1, ğ‘¥2, ğ‘¥3) :âˆ’ ğ‘…1 (ğ‘¥1), ğ‘…2 (ğ‘¥2), ğ‘…3 (ğ‘¥3) and ğ‘¥1 + ğ‘¥2 + ğ‘¥3 < 0 would
violate our 3sum hypothesis (see Section 2.3) because it would allow
us to count the number of answers in the less-than and greater-than
partitions. In Section 5, we will show that efficient trimmings exist
for MIN/MAX and LEX, as well as (partial) SUM in certain cases.

3.1 Adaptation for Approximate Quantiles
Since %JQ can be intractable (under our efficiency yardstick) for
some ranking functions such as SUM [7], we aim for ğœ–-approximate
quantiles. We can obtain a randomized approximation by the stan-
dard technique of sampling answers uniformly and taking as es-
timate the ğœ™-quantile of the sample (e.g., as done by Doleschal et
al. [9] for quantile queries in a different model). Concentration
theorems such as Hoeffding Inequality imply that it suffices to
collect ğ‘‚ (1/ğœ–2) samples and repeat the process ğ‘‚ (log(1/ğ›¿)) times
(and select the median of the estimates) to get an ğœ–-approximation
with probability 1 âˆ’ ğ›¿. So, it suffices to be able to efficiently sam-
ple uniformly a random answer of an acyclic JQ; we can do so
using linear-time algorithms for constructing a logarithmic-time
random-access structure for the answers [6, 8].

We will show that with our pivoting approach, we can obtain
a deterministic approximation, which we found to be much more

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Nikolaos Tziavelis, Nofar Carmeli, Wolfgang Gatterbauer, Benny Kimelfeld, & Mirek Riedewald

challenging than the randomized one. Pivot selection remains the
same as in the exact algorithm, while for trimming (which as we ex-
plained is the missing piece for SUM), we introduce an approximate
solution based on the notion of a lossy trimming. Intuitively, a lossy
trimming does not retain all the JQ answers that satisfy a given
predicate. Such a trimming results in some valid query answers
being lost in each iteration and causes inaccuracy in the final index
of the returned query answer. However, if the number of lost query
answers is bounded, then we can also bound the error on the index.

Definition 3.5 (Lossy Predicate Trimming). Given a JQ ğ‘„, a predi-
cate ğ‘ƒ (ğ‘ˆ ) with variables ğ‘ˆ âŠ† var(ğ‘„), and a constant ğœ– âˆˆ [0, 1), an
ğœ–-lossy trimming of ğ‘ƒ (ğ‘ˆ ) from ğ‘„ receives a database ğ· and returns
a JQ ğ‘„ â€² of size O (|ğ‘„ |) and with var(ğ‘„) âŠ† var(ğ‘„ â€²), and a data-
base ğ·â€² for which there exists an O (1)-computable injection from
ğ‘„ â€² (ğ·â€²) to (ğ‘„ âˆ§ ğ‘ƒ)(ğ·), and also |ğ‘„ â€² (ğ·â€²)| â‰¥ (1 âˆ’ ğœ–)|(ğ‘„ âˆ§ ğ‘ƒ)(ğ·)|.
Trimming time is the time required to construct ğ‘„ â€² and ğ·â€².

The injection in the definition above implies that some query
answers that satisfy the given predicate do not correspond to any
answers in the new instance we construct, but we also ask their
ratio to be bounded by ğœ–. For ğœ– = 0, we obtain an exact predicate
trimming (Definition 3.2) as a special case.5

Lemma 3.6 (Approximate Quantiles). Let Q be a class of acyclic

JQs and (ğ‘¤, âª¯) a ranking function. If for all ğ‘„ â€² âˆˆ Q

(1) there exists a constant ğ‘ such that for any database ğ·, a ğ‘-
pivot for ğ‘„ â€² (ğ·) can be computed in time O (ğ‘”ğ‘ (ğ‘›)) for some
function ğ‘”ğ‘ , and

(2) for all ğœ† âˆˆ domğ‘¤ and ğœ–â€² > 0, there exist ğœ–â€²-lossy trimmings of
ğ‘¤ (ğ‘ˆğ‘¤) â‰º ğœ† and ğ‘¤ (ğ‘ˆğ‘¤) â‰» ğœ† from ğ‘„ â€² that return ğ‘„ â€²â€² âˆˆ Q in
time O (ğ‘”ğ‘¡ (ğ‘›, ğœ–â€²)) for some function ğ‘”ğ‘¡ ,

then an ğœ–-approximate %JQ can be answered for all ğ‘„ âˆˆ Q in time
O (cid:0) max(cid:8)ğ‘”ğ‘ (ğ‘›), ğ‘”ğ‘¡ (cid:0)ğ‘›,
(cid:1) (cid:9) log ğ‘›(cid:1), where â„“ is the number
of atoms of ğ‘„.

ğœ–
2âŒˆâ„“ log1/(1âˆ’ğ‘ )

ğ‘›âŒ‰

In Section 6 we will give an ğœ–-lossy trimming for additive in-
equalities, which, combined with the pivot algorithm of Section 4,
will give us an ğœ–-approximate quantile algorithm for SUM.

4 GENERIC PIVOT SELECTION
We describe a pivot algorithm for choosing a pivot element among
the answers to an acyclic JQ. This is one of the two main subroutines
of our quantile algorithm. We show that a ğ‘-pivot can be computed
in linear time for a large class of ranking functions.

Lemma 4.1 (Pivot Selection). Given an acyclic JQ ğ‘„ over a
database ğ· of size ğ‘› and a subset-monotone ranking function, a ğ‘-
pivot of ğ‘„ (ğ·) together with ğ‘ âˆˆ (0, 1) can be computed in time O (ğ‘›).

4.1 Algorithm
The key idea of our algorithm is the â€œmedian-of-mediansâ€, in similar
spirit to classic linear-time selection [5] or selection for the ğ‘‹ + ğ‘Œ
problem [13]. The main difference is that we apply the median-
of-medians idea iteratively using message passing. The detailed
pseudocode is given in Appendix C.

Weighted median. An important operation for our algorithm is
the weighted median, which selects the median of a set, assuming
that every element appears a number of times equal to an assigned
weight.6 More formally, for a totally-ordered (âª¯) set ğ‘ and a multi-
plicity function ğ›½ : ğ‘ â†’ N+, the weighted median wmedâª¯ (ğ‘, ğ›½) is
the element at position âŒŠ |ğµ |
2 âŒ‹ in the multiset ğµ = (ğ‘, ğ›½) ordered by
âª¯. The weighted median can be computed in time linear in |ğ‘ | [13].
Message passing. Our algorithm employs the message-passing
framework as outlined in Section 2.4 to compute pivot(ğ‘¡) for each
tuple ğ‘¡ bottom-up. The computed pivot(ğ‘¡) is a partial query answer
for the subtree rooted at ğ‘¡ and serves as a ğ‘â€²-pivot for these partial
answers, for some ğ‘â€² â‰¥ ğ‘. Messages are aggregated as follows: (1)
The âŠ• operator that combines pivots within a join group is the
weighted median. The multiplicity function is given by the count of
subtree answers and the order by the ranking function. The counts
are also computed using message passing (see Section 2.4). (2) The
âŠ— operator that combines pivots from different children is simply
the union of (partial) assignments to variables.

Example 4.2. Consider the binary-join ğ‘…1 (ğ‘¥1, ğ‘¥2), ğ‘…2 (ğ‘¥2, ğ‘¥3) un-
der full SUM. Assume ğ‘…1 is the parent in the join tree with tuple
weights ğ‘¥1 + ğ‘¥2, while ğ‘…2 is the child with tuple weights ğ‘¥3. First,
pivot groups the ğ‘…2 tuples by ğ‘¥2 and, for each group, it finds the
median ğ‘¥3 value. The message from ğ‘…2 to ğ‘…1 is a mapping from
ğ‘¥2 values to (1) the count of ğ‘…2 tuples that contain the ğ‘¥2 value
and (2) the median ğ‘¥3 value over these tuples. Then, every tuple
ğ‘Ÿ1 âˆˆ ğ‘…1 unions its ğ‘¥1, ğ‘¥2 values with the incoming ğ‘¥3, obtaining
a pivot(ğ‘Ÿ1) = (ğ‘¥1, ğ‘¥2, ğ‘¥3) tuple. To compute the final pivot, pivot
takes the median of these pivot(ğ‘Ÿ1) tuples, ranked by ğ‘¥1 + ğ‘¥2 + ğ‘¥3,
and weighted by the count of ğ‘…2 tuples that contain the ğ‘¥2 value.

Example 4.3. Figure 2 shows how an ğ‘…-tuple computes its pivot
under full SUM for the example of Figure 1. Green values in brackets
[.] represent the counts, while the orange assignments are the
computed pivots for each tuple or join group. From a leaf node
like ğ‘† or ğ‘ˆ , messages are simply the relation tuples, each with
multiplicity 1. To see how a pivot is computed within a join group,
consider the ğ‘‡ -node group. The pivot of tuple (1, 6) is smaller than
the pivot of tuple (1, 7) according to the ranking function because
1 + 6 + 8 < 1 + 7 + 9. The weighted median selects the latter because
it has multiplicity 2 (that is the group size for ğ‘¥4 = 6 in the child ğ‘ˆ ).

Pivot accuracy. As we will show, applying our two operations
(weighted median, union) results in a loss of accuracy for the pivots,
captured by the ğ‘ parameter. The pivots computed for the leaf
relations are the true medians (thus 1
2 -pivots), but the ğ‘ parameter
decreases as we go up the join tree. Fortunately, this can be bounded
by a function of the query size, making our final result a ğ‘-pivot
with a ğ‘ value that is independent of the data size ğ‘›. The algorithm
keeps track of the ğ‘ value for every node and upon termination, the
ğ‘ value of the root is returned.

Running time. The time is linear in the database size. The
weighted median and count operations are only performed once for
every join group and both take linear time. Each tuple is visited only
once, and all operations per tuple (e.g., number of child relations,
finding the joining group, union) depend only on the query size.

5An imprecise trimming, which retains more JQ answers than it should, would also
work for our quantile algorithm.

6This weight is not the same as the weight assigned by the ranking function, thus we
simply call it multiplicity.

6

Efficient Computation of Quantiles over Joins

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Figure 2: Message passing for computing pivots on the ex-
ample JQ and database of Figure 1 under SUM with weights
equal to attribute values.

4.2 Correctness
First, we show that pivot returns a valid query answer. The concern
is that a variable ğ‘¥ may be assigned to different values in the pivots
that are unioned from different branches of the tree. As we show
next, this cannot happen because of the join tree properties.

Lemma 4.4. Let ğ‘‰ be a join-tree node and ğ‘…ğ‘‰ the corresponding
relation. For all ğ‘¡ âˆˆ ğ‘…ğ‘‰ , the variable assignment pivot(ğ‘¡) computed
by pivot is a partial query answer for the subtree rooted at ğ‘‰ .

Next, we show how the accuracy of the pivot is affected by

repeated weighted median and union operations.

Lemma 4.5. Given ğ‘Ÿ disjoint sets ğ‘1, . . . , ğ‘ğ‘Ÿ equipped with
then
2 -pivot

a total order âª¯ and corresponding ğ‘-pivots ğ‘1, . . . , ğ‘ğ‘Ÿ ,
wmed({ğ‘1, . . . , ğ‘ğ‘Ÿ }, ğ›½) with ğ›½ (ğ‘ğ‘– ) = |ğ‘ğ‘– |, for all ğ‘– âˆˆ [ğ‘Ÿ ] is a ğ‘
for ğ‘1 âˆª Â· Â· Â· âˆª ğ‘ğ‘Ÿ .

Lemma 4.6. Assume a join-tree node ğ‘‰ , its corresponding relation
ğ‘…ğ‘‰ , its children ğ‘‰1, . . . , ğ‘‰ğ‘Ÿ , a subset-monotone ranking function, and
ğ‘-pivots ğ‘ğ‘–, ğ‘– âˆˆ ğ‘Ÿ for the partial answers which are rooted at ğ‘‰ğ‘– and
restricted to those that agree with ğ‘¡. Then, ğ‘¡ âˆªğ‘1 âˆª . . . âˆªğ‘ğ‘Ÿ is a ğ‘ğ‘Ÿ -pivot
for the partial answers rooted at ğ‘¡.

With the three above lemmas, we can complete the proof of

Lemma 4.1 by induction on the join tree.

5 EXACT TRIMMINGS
We now look into trimmings for different types of inequality predi-
cates that arise in the partitioning step of our quantile algorithm
(i.e., the trim subroutine). Our construction essentially removes
these predicates from the query, while ensuring that the modified
query can only produce answers that satisfy them.

5.1 MIN/MAX
When the ranking function is MIN or MAX, then we need to trim
predicates of the type min{ğ‘ˆğ‘¤ } < ğœ†, ğœ† âˆˆ R.

Example 5.1. Suppose the ranking function is MAX, the weighted
variables are ğ‘ˆğ‘¤ = {ğ‘¥1, ğ‘¥2, ğ‘¥3}, attribute weights are equal to
database values, and our pivot has weight 10. To create the ap-
propriate partitions, we trim predicates max{ğ‘¥1, ğ‘¥2, ğ‘¥3} < 10 and
max{ğ‘¥1, ğ‘¥2, ğ‘¥3} > 10. Enforcing max{ğ‘¥1, ğ‘¥2, ğ‘¥3} < 10 is straight-
forward by removing from the database all tuples with values
greater than or equal to 10 for either of the three variables. For

Figure 3: Trimming max{ğ‘¥1, ğ‘¥2, ğ‘¥3} > 10 by expressing it as
three disjoint partitions of the space of ğ‘¥1, ğ‘¥2, ğ‘¥3 combina-
tions, each one described by unary predicates (e.g., ğ‘¥1 > 10).

max{ğ‘¥1, ğ‘¥2, ğ‘¥3} > 10, there are three ways to satisfy the predicate:
(1) ğ‘¥1 > 10, (2) ğ‘¥1 â‰¤ 10 âˆ§ğ‘¥2 > 10, or (3) ğ‘¥1 â‰¤ 10 âˆ§ğ‘¥2 â‰¤ 10 âˆ§ğ‘¥3 > 10.
These three cases are disjoint and cover all possibilities. For each
case, we create a fresh copy of the database and then enforce the
predicates in linear time by filtering the tuples. Our JQ over one
of these three databases produces a partition of the answers that
satisfy the original inequality. To return a single database and JQ,
we union the corresponding relations and distinguish between the
three partitions by appending a partition identifier to every relation.

Generalizing our example in a straightforward way, we show

that trimmings of such inequalities exist for all acyclic JQs.

Lemma 5.2. Given an acyclic JQ ğ‘„, variables ğ‘ˆğ‘¤ âŠ† var(ğ‘„),
weight functions ğ‘¤ğ‘¥ : dom â†’ R for ğ‘¥ âˆˆ ğ‘ˆğ‘¤, and ğœ† âˆˆ R, a trimming of
minğ‘¥ âˆˆğ‘ˆğ‘¤ ğ‘¤ğ‘¥ (ğ‘¥) < ğœ†, minğ‘¥ âˆˆğ‘ˆğ‘¤ ğ‘¤ğ‘¥ (ğ‘¥) > ğœ†, maxğ‘¥ âˆˆğ‘ˆğ‘¤ ğ‘¤ğ‘¥ (ğ‘¥) < ğœ†,
or maxğ‘¥ âˆˆğ‘ˆğ‘¤ ğ‘¤ğ‘¥ (ğ‘¥) > ğœ† takes time O (ğ‘›) and returns an acyclic JQ.
Combining Lemma 5.2 together with Lemma 4.1 and Lemma 3.3

gives us the following result:

Theorem 5.3. Given an acyclic JQ over a database ğ· of size ğ‘›,
MIN or MAX ranking function, and ğœ™ âˆˆ [0, 1], the %JQ can be
answered in time O (ğ‘› log ğ‘›).

5.2 LEX
For lexicographic orders, we provided [7] an O (ğ‘›) selection al-
gorithm that can also be used for %JQs. Our divide-and-conquer
approach can recover this result up to a logarithmic factor, i.e., our
%JQ algorithm runs in time O (ğ‘› log ğ‘›). To achieve that, we trim
lexicographic inequalities, similarly to the case of MIN and MAX.

Lemma 5.4. Given an acyclic JQ ğ‘„, variables ğ‘ˆğ‘¤ = {ğ‘¥1, . . . , ğ‘¥ğ‘Ÿ } âŠ†
: dom â†’ R for ğ‘¥ âˆˆ ğ‘ˆğ‘¤, and
ğ‘¥1 (ğ‘¥1), . . . , ğ‘¤ â€²
ğ‘¥ğ‘Ÿ (ğ‘¥ğ‘Ÿ )) <LEX ğœ† or
ğ‘¥ğ‘Ÿ (ğ‘¥ğ‘Ÿ )) >LEX ğœ† takes time O (ğ‘›) and returns an

var(ğ‘„), weight functions ğ‘¤ â€²
ğ‘¥
ğœ† âˆˆ Rğ‘Ÿ , a trimming of (ğ‘¤ â€²
(ğ‘¤ â€²
acyclic JQ.

ğ‘¥1 (ğ‘¥1), . . . , ğ‘¤ â€²

5.3 Partial SUM
We now consider the case of SUM. While we previously gave a
dichotomy [7] for all self-join-free JQs, this result is limited to
full SUM. We now provide a more fine-grained dichotomy where
certain variables may not participate in the ranking. For example,
the 3-path JQ ğ‘…1 (ğ‘¥1, ğ‘¥2), ğ‘…2 (ğ‘¥2, ğ‘¥3), ğ‘…3 (ğ‘¥3, ğ‘¥4) would be classified
as intractable by the prior dichotomy, yet with weighted variables
ğ‘ˆğ‘¤ = {ğ‘¥1, ğ‘¥2, ğ‘¥3}, we show that it is in fact tractable.

The positive side of our dichotomy requires a trimming of addi-
tive inequalities. We rely on a known algorithm that can be applied
whenever the SUM variables appear in adjacent join-tree nodes.

7

1,11,31,41,51,61,7ğ‘…(ğ‘¥1,ğ‘¥2)ğ‘†(ğ‘¥1,ğ‘¥3)ğ‘‡(ğ‘¥2,ğ‘¥4)[1][1][1][2][1]x1:1x3:3[9]x1:1x3:4x1:1x3:5x2:1x4:6x5:8x2:1x4:7x5:9x1:1x3:4x2:1x4:6x5:8x1:1x2:1x3:4x4:6x5:8max(ğ‘¥1,ğ‘¥2,ğ‘¥3)>10ğ‘¥1ğ‘¥2ğ‘¥3â‰¤10>10ğ‘¥1ğ‘¥2ğ‘¥3ğ‘¥1ğ‘¥2ğ‘¥3Partition 1Partition 2Partition 3PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Nikolaos Tziavelis, Nofar Carmeli, Wolfgang Gatterbauer, Benny Kimelfeld, & Mirek Riedewald

Lemma 5.5 ([22]). Given a set of variables ğ‘ˆğ‘¤, let Q be the class of
acyclic JQs ğ‘„ for which there exists a join tree where ğ‘ˆğ‘¤ âŠ† var(ğ‘„)
belong to adjacent join-tree nodes. Then, for all ğ‘„ âˆˆ Q, weight
functions ğ‘¤ğ‘¥ : dom â†’ R for ğ‘¥ âˆˆ ğ‘ˆğ‘¤, and ğœ† âˆˆ R, a trimming of
(cid:205)ğ‘¥ âˆˆğ‘ˆğ‘¤
ğ‘¤ğ‘¥ (ğ‘¥) > ğœ† takes time O (ğ‘› log ğ‘›) and
returns a JQ ğ‘„ â€² âˆˆ Q.

ğ‘¤ğ‘¥ (ğ‘¥) < ğœ† or (cid:205)ğ‘¥ âˆˆğ‘ˆğ‘¤

We are now in a position to state our dichotomy:

Theorem 5.6. Let ğ‘„ be a self-join-free JQ, H (ğ‘„) its hypergraph,

and ğ‘ˆğ‘¤ âŠ† var(ğ‘„) the variables of a SUM ranking function.

â€¢ If H (ğ‘„) is acyclic, any set of independent variables of ğ‘ˆğ‘¤
is of size at most 2, and any chordless path between two ğ‘ˆğ‘¤
variables is of length at most 3, then %JQ can be answered in
O (ğ‘› log2 ğ‘›).

â€¢ Otherwise, %JQ cannot be answered in O (ğ‘› polylog ğ‘›), assum-

ing 3sum and Hyperclique.

We note that the positive side also applies to JQs with self-joins.

6 APPROXIMATE TRIMMING FOR SUM
We now move on to devise an ğœ–-lossy trimming for additive in-
equalities in order to get a deterministic approximation for SUM
and JQs beyond those covered by Theorem 5.6.

Lemma 6.1. Given an acyclic JQ ğ‘„, variables ğ‘ˆğ‘¤ âŠ† var(ğ‘„),
weight functions ğ‘¤ğ‘¥ : dom â†’ R for ğ‘¥ âˆˆ ğ‘ˆğ‘¤, ğœ† âˆˆ R, and ğœ– âˆˆ (0, 1), an
ğœ–-lossy trimming of (cid:205)ğ‘¥ âˆˆğ‘ˆğ‘¤
ğ‘¤ğ‘¥ (ğ‘¥) > ğœ† takes
time O ( 1

ğ‘¤ğ‘¥ (ğ‘¥) < ğœ† or (cid:205)ğ‘¥ âˆˆğ‘ˆğ‘¤
ğœ– ) and returns an acyclic JQ.

ğœ– 2 ğ‘› log2 ğ‘› log ğ‘›

This, together with Lemmas 3.6 and 4.1 gives us the following:

Theorem 6.2. Given an acyclic JQ ğ‘„ over a database ğ· of size ğ‘›,
SUM ranking function, ğœ™ âˆˆ [0, 1], and ğœ– âˆˆ (0, 1), the ğœ–-approximate
%JQ can be answered in time O ( 1

ğœ– 2 ğ‘› log5 ğ‘› log ğ‘›
ğœ– ).

To achieve the trimming, we adapt an algorithm of Abo-Khamis
et al. [2], which we refer to as ApxCnt. It computes an approximate
count (or more generally, a semiring aggregate) over the answers to
acyclic JQs with additive inequalities. In contrast, we need not only
the count of answers, but an efficient relational representation of
them as JQ answers over a new database. We only discuss the case
of less-than (<), since the case of greater-than (>) is symmetric.
The detailed pseudocode is given in Appendix E.

Message passing. ApxCnt uses message passing (see Sec-
tion 2.4). We first describe the exact, but costly, version of the
algorithm. The message sent by a tuple is a multiset containing the
(partial) sums of partial query answers in its subtree. Messages are
aggregated as follows: (1) The âŠ• operator that combines multisets
within a join group is multiset union (âŠ). (2) The âŠ— operator that
combines multisets from different children is pairwise summation
(applied as a binary operator). The messages emitted by the root-
node tuples contain all query-answer sums, which can be leveraged
to count the number of answers that satisfy the inequality.

Sketching. Sending all possible sums up the join tree is in-
tractable since, in the worst case, their number is equal to the
number of JQ answers. For this reason, ApxCnt applies sketching
to compress the messages. The basic idea is to replace different
elements in a multiset with the same element; the efficiency gain
is due to the fact that an element ğ‘  that appears ğ‘Ÿ times can be

8

Figure 4: Example of how we use the message passing frame-
work [2] to create a relational representation of the query
answers that satisfy an inequality ğ‘¥ + ğ‘¦ + ğ‘§ < ğœ†.

represented as ğ‘  Ã— ğ‘Ÿ . In more detail, the multiset elements are split
into buckets, and subsequently, each element within a bucket is
replaced by the maximum element of the bucket. A sketched multi-
set ğ¿ is denoted by Sğœ– (ğ¿), where ğœ– is a parameter that determines
the number of buckets. Let â†“ğœ†(ğ¿) be the number of elements of ğ¿
that are less than ğœ† âˆˆ R. By choosing buckets appropriately, we can
guarantee that â†“ğœ†(Sğœ– (ğ¿)) is close to â†“ğœ†(ğ¿) for all possible ğœ†.

Lemma 6.3 (ğœ–-Sketch [2]). For a multiset ğ¿ âˆˆ NR and ğœ– âˆˆ (0, 1),
we can construct a sketch Sğœ– (ğ¿) with O (log1+ğœ– |ğ¿|) distinct elements
such that for all ğœ† âˆˆ R, we have (1 âˆ’ ğœ–) â†“ğœ†(ğ¿) â‰¤â†“ğœ†(Sğœ– (ğ¿)) â‰¤â†“ğœ†(ğ¿).

ApxCnt sketches all messages and bounds the error incurred by

the two message-passing operations (âŠ•, âŠ—).

Relational representation. Our goal is to construct a relational
representation of the JQ answers which satisfy the inequality that
we want to trim. The key idea is to embed the sums contained in the
messages of ApxCnt into the database relations so that each tuple
stores a unique sum and all answers in its subtree approximately
have that sum. The reasoning behind this is that we can then remove
from the database the root tuples whose associated sum does not
satisfy the inequality. However, in ApxCnt a message is a multiset
of sums, and hence the main technical challenge we address below
is how to achieve a unique sum per tuple (and its subtree).

Separating sums. Let ğœ (ğ‘¡ â€²) be the message sent by a tuple ğ‘¡ â€² in
a child relation ğ‘†. Then, according to ApxCnt, a tuple ğ‘¡ in the parent
relation ğ‘… receives a message ğœ (ğ‘) = Sğœ– â€² (âŠğ‘¡ â€² âˆˆğ‘ğœ (ğ‘¡ â€²)) for some ğœ–â€²
and join group ğ‘. We separate the sums in this multiset by creating
a number of copies of ğ‘¡, equal to the number of distinct sums in
ğœ (ğ‘). Each ğ‘¡-copy is associated with a unique bucket ğ‘’, described
by a sum value ğ‘’ğ‘  and a multiplicity ğ‘’ğ‘š. To avoid duplicating query
answers, we restrict each ğ‘¡-copy to join only with the source tuples
of its associated bucket ğ‘’, i.e., the child tuples ğ‘¡ â€² âˆˆ ğ‘† whose messages
were assigned to bucket ğ‘’ during sketching.

Example 6.4. Figure 4 illustrates how we embed messages into
the database relations for a leaf relation ğ‘† and a parent relation ğ‘…
with no other children, and assuming weights equal to attribute
values. The messages from ğ‘† (ğ‘¥, ğ‘¦) to ğ‘…(ğ‘¦, ğ‘§) are the sums ğ‘¥ + ğ‘¦
(because ğ‘¦-weights are assigned to ğ‘†). After sketching their union
using two buckets, sums 4 and 5 are both mapped to 5; we keep
track of this with a multiplicity counter (shown as Ã—2), reflecting
the number of answers in the subtree. Upon reaching relation ğ‘…,
the weight of the ğ‘…-tuple (which is the ğ‘§-value) is added to all sums.
For our relational representation, we duplicate the ğ‘…-tuple and

2,13,14,11,6Sketch{3Ã—1}ğ‘…(ğ‘¦,ğ’›)ğ‘†(ğ’™,ğ’š){9Ã—1, 11Ã—2}2,1,3Ã—13,1,5Ã—24,1,5Ã—21,6,3Ã—1ğ‘…â€²(ğ‘¦,ğ‘§,ğ‘£ğ‘…ğ‘†)ğ‘†â€²(ğ‘¥,ğ‘¦,ğ‘£ğ‘…ğ‘†)1,6,5Ã—2Message PassingRelational Representationx+y+zx+y{9Ã—1}{11Ã—2}{3Ã—1}{4Ã—1}{5Ã—1}{5Ã—2}Efficient Computation of Quantiles over Joins

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

associate each copy with a unique sum. A copy corresponds to a
bucket in the sketch, so we can trace its â€œsourceâ€ ğ‘†-tuples, i.e., those
that belong to that bucket. Instead of joining with all ğ‘†-tuples like
before, a copy now only joins with the source ğ‘†-tuples of the bucket
via a new variable ğ‘£ğ‘…ğ‘† that stores the sum and the multiplicity.

Adjusting the sketch buckets. An issue we run into with
the approach above is that the sum sent by a single tuple may be
assigned to more than one bucket during sketching. To see why this
is problematic, consider a tuple ğ‘¡ â€² that sends ğœ (ğ‘¡ â€²) = 5 Ã— 10. For
simplicity, assume these are the only values to be sketched and that
the two buckets contain 5 Ã— 3 and 5 Ã— 7. With these buckets, we will
create two copies of a tuple ğ‘¡ in the parent and both will join with ğ‘¡ â€²,
because ğ‘¡ â€² is the source tuple for both buckets. By doing so, we have
effectively doubled the number of (partial) query answers since
there are now 10 answers in the subtree of each copy. To resolve this
issue, we need to guarantee that all elements in ğœ (ğ‘¡ â€²) are assigned
to the same bucket. We adjust the sketching Sğœ– (ğ¿) of a multiset ğ¿
as follows. The ğ‘Ÿ buckets are determined by an increasing sequence
of ğ‘Ÿ + 1 indexes on an array that contains ğ¿ sorted. The first index is
0 and the last index is equal to |ğ¿| âˆ’ 1 (where |ğ¿| takes into account
the multiplicities). Consider three consecutive indexes ğ‘–, ğ‘—, ğ‘˜ which
define two consecutive buckets where the values at the borders
are the same, i.e., ğ¿[ ğ‘— âˆ’ 1] = ğ¿[ ğ‘—]. Let ğ‘— â€² and ğ‘— â€²â€² be the smallest
and largest indexes that contain ğ¿[ ğ‘—] in the buckets ğ‘– âˆ’ ğ‘— and ğ‘— âˆ’ ğ‘˜,
respectively. We replace the indexes ğ‘–, ğ‘—, ğ‘˜ with ğ‘–, ğ‘— â€², ğ‘— â€²â€² + 1, ğ‘˜ (and
if 2 consecutive indexes are the same, then we remove that bucket).
As a result, all values ğ¿[ ğ‘—] from these two buckets now fall into
the same bucket. We repeat this process for every two consecutive
buckets. This can at most double the number of buckets, which, as
we show, does not affect the guarantee of Lemma 6.3.

Binary join tree. The running time of our algorithm (in par-
ticular the logarithmic-factor exponent) depends on the maximum
number of children of a join-tree node. This is because we handle
each parent-child node pair separately, and each child results in
the parent relation growing by the size of the messages, which is
logarithmic. To achieve the time bound stated in Lemma 6.1, we
impose a binary join tree, i.e., every node has at most two children.
Such a join tree can be constructed by creating copies of a node
that has multiple children, connecting these copies in a chain, and
distributing the original children among them. In the worst case,
this doubles the number of nodes in the join tree (hence the num-
ber of relations that we materialize), but it does not affect the data
complexity.

7 CONCLUSIONS
We can often answer quantile queries over joins of multiple relations
much more efficiently than it takes to materialize the result of
the join. Here, we adopted quasilinear time as our yardstick of
efficiency. With our divide-and-conquer technique, we recovered
known results (for lexicographic orders) and established new ones
(for partial sums, minimum, and maximum). We also showed how
the approach can be adapted for deterministic approximations.

We restricted the discussion to JQs, that is, full Conjunctive
Queries (CQs), and left open the treatment of non-full CQs (i.e.,
joins with projection). Most of our algorithms apply to CQs that
are acyclic and free-connex, but it is not yet clear to us whether our

9

results cover all tractable cases (under complexity assumptions).
More general open directions are the generalization of the challenge
to unions of CQs, and the establishment of nontrivial algorithms
for general CQs beyond the acyclic ones.

ACKNOWLEDGMENTS
This work was supported in part by NSF under award numbers
IIS-1762268 and IIS-1956096. Benny Kimelfeld was supported by the
German Research Foundation (DFG) Project 412400621. Nikolaos
Tziavelis was supported by a Google PhD fellowship.

REFERENCES
[1] Amir Abboud and Virginia Vassilevska Williams. 2014. Popular Conjectures
Imply Strong Lower Bounds for Dynamic Problems. In FOCS. 434â€“443. https:
//doi.org/10.1109/FOCS.2014.53

[2] Mahmoud Abo-Khamis, Sungjin Im, Benjamin Moseley, Kirk Pruhs, and Alireza
Samadian. 2021. Approximate Aggregate Queries Under Additive Inequalities. In
APOCS. SIAM, 85â€“99. https://doi.org/10.1137/1.9781611976489.7

[3] Mahmoud Abo Khamis, Hung Q. Ngo, and Atri Rudra. 2016. FAQ: Questions
Asked Frequently. In PODS. 13â€“28. https://doi.org/10.1145/2902251.2902280
[4] Ilya Baran, Erik D. Demaine, and Mihai PË‡atraÅŸcu. 2005. Subquadratic Algorithms
for 3SUM. In Algorithms and Data Structures. 409â€“421. https://doi.org/10.1007/
11534273_36

[5] Manuel Blum, Robert W. Floyd, Vaughan Pratt, Ronald L. Rivest, and Robert E.
Tarjan. 1973. Time bounds for selection. JCSS 7, 4 (1973), 448 â€“ 461. https:
//doi.org/10.1016/S0022-0000(73)80033-9

[6] Johann Brault-Baron. 2013. De la pertinence de lâ€™Ã©numÃ©ration: complexitÃ© en
logiques propositionnelle et du premier ordre. Ph. D. Dissertation. U. de Caen.
https://hal.archives-ouvertes.fr/tel-01081392

[7] Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and
Mirek Riedewald. 2023. Tractable Orders for Direct Access to Ranked Answers
of Conjunctive Queries. TODS 48, 1, Article 1 (2023), 45 pages. https://doi.org/
10.1145/3578517

[8] Nofar Carmeli, Shai Zeevi, Christoph Berkholz, Alessio Conte, Benny Kimelfeld,
and Nicole Schweikardt. 2022. Answering (Unions of) Conjunctive Queries Using
Random Access and Random-Order Enumeration. TODS 47, 3, Article 9 (2022),
49 pages. https://doi.org/10.1145/3531055

[9] Johannes Doleschal, Noa Bratman, Benny Kimelfeld, and Wim Martens. 2021.
The Complexity of Aggregates over Extractions by Regular Expressions. In ICDT,
Vol. 186. 10:1â€“10:20. https://doi.org/10.4230/LIPIcs.ICDT.2021.10

[10] Ronald Fagin, Amnon Lotem, and Moni Naor. 2003. Optimal aggregation algo-
rithms for middleware. JCSS 66, 4 (2003), 614â€“656. https://doi.org/10.1016/S0022-
0000(03)00026-6

[11] Jim Gray, Surajit Chaudhuri, Adam Bosworth, Andrew Layman, Don Reichart,
Murali Venkatrao, Frank Pellow, and Hamid Pirahesh. 1997. Data Cube: A Re-
lational Aggregation Operator Generalizing Group-by, Cross-Tab, and Sub To-
tals. Data Min. Knowl. Discov. 1, 1 (1997), 29â€“53. https://doi.org/10.1023/A:
1009726021843

[12] Paulo Jesus, Carlos Baquero, and Paulo Sergio Almeida. 2015. A Survey of
IEEE Communications Surveys &

Distributed Data Aggregation Algorithms.
Tutorials 17, 1 (2015), 381â€“404. https://doi.org/10.1109/COMST.2014.2354398

[13] Donald B Johnson and Tetsuo Mizoguchi. 1978. Selecting the Kth element in
ğ‘‹ + ğ‘Œ and ğ‘‹1 + ğ‘‹2 + Â· Â· Â· + ğ‘‹ğ‘š . SIAM J. Comput. 7, 2 (1978), 147â€“153. https:
//doi.org/10.1137/0207013

[14] Mahmoud Abo Khamis, Hung Q. Ngo, Dan Olteanu, and Dan Suciu. 2019. Boolean
Tensor Decomposition for Conjunctive Queries with Negation. In ICDT, Vol. 127.
21:1â€“21:19. https://doi.org/10.4230/LIPIcs.ICDT.2019.21

[15] Benny Kimelfeld and Yehoshua Sagiv. 2006. Incrementally Computing Ordered
Answers of Acyclic Conjunctive Queries. In International Workshop on Next
Generation Information Technologies and Systems (NGITS). 141â€“152. https://doi.
org/10.1007/11780991_13

[16] Andrea Lincoln, Virginia Vassilevska Williams, and R. Ryan Williams. 2018. Tight
Hardness for Shortest Cycles and Paths in Sparse Graphs. In SODA. 1236â€“1252.
https://doi.org/10.1137/1.9781611975031.80

[17] Gurmeet Singh Manku, Sridhar Rajagopalan, and Bruce G. Lindsay. 1998. Ap-
proximate Medians and other Quantiles in One Pass and with Limited Memory.
In SIGMOD. 426â€“435. https://doi.org/10.1145/276305.276342

[18] Wendy J. Myrvold and Frank Ruskey. 2001. Ranking and unranking permutations
in linear time. Inf. Process. Lett. 79, 6 (2001), 281â€“284. https://doi.org/10.1016/
S0020-0190(01)00141-7

[19] Mihai Patrascu. 2010. Towards polynomial lower bounds for dynamic problems.

In STOC. 603â€“610. https://doi.org/10.1145/1806689.1806772

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Nikolaos Tziavelis, Nofar Carmeli, Wolfgang Gatterbauer, Benny Kimelfeld, & Mirek Riedewald

[20] Reinhard Pichler and Sebastian Skritek. 2013. Tractable counting of the answers
to conjunctive queries. JCSS 79, 6 (2013), 984â€“1001. https://doi.org/10.1016/j.
jcss.2013.01.012

[21] John A. Rice. 2007. Mathematical Statistics and Data Analysis (3rd ed.). Duxbury

Press, Belmont, CA.

[22] Nikolaos Tziavelis, Wolfgang Gatterbauer, and Mirek Riedewald. 2021. Beyond
Equi-joins: Ranking, Enumeration and Factorization. PVLDB 14, 11 (2021), 2599â€“
2612. https://doi.org/10.14778/3476249.3476306

[23] Nikolaos Tziavelis, Wolfgang Gatterbauer, and Mirek Riedewald. 2022. Any-k
Algorithms for Enumerating Ranked Answers to Conjunctive Queries. CoRR
abs/2205.05649 (2022). https://doi.org/10.48550/arXiv.2205.05649

[24] Mihalis Yannakakis. 1981. Algorithms for Acyclic Database Schemes. In VLDB.

82â€“94. https://dl.acm.org/doi/10.5555/1286831.1286840

A NOMENCLATURE

Definition
generic set
generic multiset
relation
atom/hyperedge/node of join tree
schema
database (instance)
size of ğ· (number of tuples)
database domain
tuple
variable
Join Query (JQ)
number of atoms in a JQ
variables contained in ğ‘„
set of answers of ğ‘„ over ğ·
subset of ğ‘„ (ğ· ) answers that satisfy a predicate ğ‘ƒ
query answer

Symbol
ğ‘
ğ¿
ğ‘…, ğ‘†,ğ‘‡ , ğ‘…1, ğ‘…2
ğ‘‰ , ğ‘‰1, ğ‘‰2
S
ğ·
ğ‘›
dom
ğ‘¡
ğ‘¥, ğ‘¦, ğ‘§, ğ‘¢, ğ‘£
ğ‘„
â„“
var(ğ‘„ )
ğ‘„ (ğ· )
(ğ‘„ âˆ§ ğ‘ƒ ) (ğ· )
ğ‘ âˆˆ ğ‘„ (ğ· )
H (ğ‘„ ) = (ğ‘‰ , ğ¸ ) hypergraph associated with query ğ‘„
ğ‘‡
ğœ™
ğ‘¤
domğ‘¤
ğ‘ˆğ‘¤
ğ‘¤ğ‘¥
ğ‘¤ğ‘…

join tree
fraction in [0, 1] used to ask for a quantile
weight function for query answers
domain of weights
subset of variables that participate in the ranking
input weight function for variable ğ‘¥: dom â†’ domğ‘¤
input weight function for tuples of relation ğ‘…: domar(ğ‘…) â†’
domğ‘¤ where ar(ğ‘…) is the arity of ğ‘…
aggregate function that combines input weights to derive
weights for query answers
aggregate function applied on the weighted variables, i.e.,
aggğ‘¤ ( {ğ‘¤ğ‘¥ (ğ‘¥ ) |ğ‘¥ âˆˆ ğ‘ˆğ‘¤ } )
a weight from domğ‘¤

aggğ‘¤

ğ‘¤ (ğ‘ˆğ‘¤ )

ğœ†

B DETAILS OF DIVIDE-AND-CONQUER

FRAMEWORK

Algorithm 1 returns the desired (approximate) quantile for a given
JQ, database, and ranking function, as presented in Section 3. The
exact version is obtained by simply setting ğœ– = 0.

B.1 Proof of Lemma 3.6
Let ğ‘„ğ‘– and ğ·ğ‘– be the JQ and database at the start of iteration ğ‘–,
with ğ‘– â‰¥ 0 (these are the variables ğ‘„ â€² and ğ·â€² in Algorithm 1). Even
though trimmings may increase the size of our queries by a constant
factor (by the definition of trimming), all queries ğ‘„ğ‘– have constant
size. This is because we start every iteration with the original query

ğ‘„ and every other query we construct is the result of applying at
most two consecutive trimmings.

First, we bound the number of iterations. Iteration ğ‘– is guaranteed
to eliminate at least ğ‘ |ğ‘„ğ‘– (ğ·ğ‘– )| query answers because (i) we select
a ğ‘-pivot to partition and (ii) the lossy trimmings may result in
more query answers being eliminated than they should, but never
less. Consequently, at the beginning of iteration ğ‘–, we have at most
(1 âˆ’ ğ‘)ğ‘– |ğ‘„ (ğ·)| query answers remaining. The number of query
answers is bounded by ğ‘›â„“ where â„“ is the number of atoms in ğ‘„. If
ğ¼ is the total number of iterations, then ğ¼ â‰¤ âŒˆlog1/(1âˆ’ğ‘ ) |ğ‘„ (ğ·)|âŒ‰ â‰¤
âŒˆâ„“ log1/(1âˆ’ğ‘ ) ğ‘›âŒ‰ = O (log ğ‘›) since ğ‘ and â„“ are constants.

Second, we show that the returned answer is an ğœ–-approximate
quantile. The less-than partition ğ‘„lt (ğ·lt) is constructed by trim-
ming the inequalities ğ‘¤ (ğ‘ˆğ‘¤) â‰º ğ‘¤ (ğ‘) and ğ‘¤ (ğ‘ˆğ‘¤) â‰» low with some
error ğœ–â€², where low lower-bounds the weights of the candidate
query answers. Because these two trimmings are lossy, we â€œloseâ€
a number of query answers which are at most 2ğœ–â€²|ğ‘„ (ğ·)|. These
are the answers that satisfy the inequalities, but do not appear in
ğ‘„lt (ğ·lt). As Figure 5 illustrates, all answers not contained in the
less-than or greater-than partition, including these lost query an-
swers, are assumed to be contained in the equal-to partition which
we do not explicitly count. We now bound the distance between the
desired index and the index of the answer that our algorithm returns.
Each iteration ğ‘– starts with an index ğ‘˜ğ‘– and results in a new index
ğ‘˜â€²
ğ‘– , which the following iteration is asked to retrieve (or, in case this
is the last iteration, the index that is returned). Note that in Algo-
rithm 1 the variable ğ‘˜ indexes the subarray of query answers that
are currently candidates; thus it is offset by the index of the answer
with weight low. Here, the indexes ğ‘˜ğ‘– and ğ‘˜â€²
ğ‘– refer to the original
array that contains all the query answers. Suppose that ğ‘˜ğ‘– falls into
the less-than partition at the beginning of the iteration. Then, if ğ‘˜â€²
ğ‘–
is different than ğ‘˜ğ‘– , it has to be a higher index because of lost query
answers that precede it and which are moved to the middle equal-to
partition (see Figure 5). Thus, |ğ‘˜ğ‘– âˆ’ ğ‘˜â€²
ğ‘– | â‰¤ 2ğœ–â€²|ğ‘„ (ğ·)|. If ğ‘˜ğ‘– falls into
the equal-to partition, then we still choose that partition and return
the pivot because the size of the partition can only increase from the
lossy trimmings. For the greater-than partition, the analysis is sym-
metric to lower-than since the lossy trimmings of the latter do not
affect the indexes of the former. To conclude, the accumulated ab-
solute error is ğ¼ Â· 2ğœ–â€²|ğ‘„ (ğ·)| â‰¤ 2âŒˆâ„“ log1/(1âˆ’ğ‘ ) ğ‘›âŒ‰ğœ–â€²|ğ‘„ (ğ·)|. To obtain
an ğœ–-approximate quantile of ğ‘„ (ğ·), we set ğœ–â€² =

.

ğœ–
2âŒˆâ„“ log1/(1âˆ’ğ‘ )

ğ‘›âŒ‰

Finally, we prove the running time. Since our trimmings return
acyclic JQs, the answers of all queries we construct can be counted
in linear time. Thus, the running time per iteration is O (ğ‘”ğ‘ (ğ‘›) +
4ğ‘”ğ‘¡ (ğ‘›, ğœ–â€²) + ğ‘›) which is O (max{ğ‘”ğ‘ (ğ‘›), ğ‘”ğ‘¡ (ğ‘›, ğœ–â€²)} since ğ‘”ğ‘ (ğ‘›) and
ğ‘”ğ‘¡ (ğ‘›, ğœ–â€²) are necessarily Î©(ğ‘›).

We note that this proof also covers Lemma 3.3 since Lemma 3.6

is a stronger version of it.

C DETAILS OF CHOOSING A PIVOT
Algorithm 2 shows the algorithm that returns a ğ‘-pivot for a given
JQ, database, and ranking function, as presented in Section 4.

C.1 Proof of Lemma 4.4
Let ğ‘1, . . . , ğ‘ğ‘Ÿ be the joining groups from the children ğ‘‰1, . . . , ğ‘‰ğ‘Ÿ of ğ‘‰ ,
We show by induction on the join tree that pivot(ğ‘1), . . . , pivot(ğ‘ğ‘Ÿ ),

10

Efficient Computation of Quantiles over Joins

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Algorithm 1: Pivoting Algorithm

1 Input: acyclic JQ ğ‘„, database ğ·, ranking function (ğ‘¤, âª¯ ), quantile ğœ™,

approximation bound ğœ–

2 Output: the ğœ™-th quantile of ğ‘„ (ğ· )
3 //Calculate desired index
4 Determine |ğ‘„ (ğ· ) | and set ğ‘˜ = âŒŠğœ™ Â· |ğ‘„ (ğ· ) | âŒ‹ (with zero-indexing)
5 //Calculate parameter for trimming (ğœ– = ğœ– â€² = 0 for exact)
6 ğœ– â€² =
7 //Each iteration modifies ğ‘„ â€² (ğ· â€² ) by bringing low and high closer
8
9 while |ğ‘„ â€² (ğ· â€² ) | > |ğ· | do
10

(ğ‘„ â€², ğ· â€², low, high) = (ğ‘„, ğ·, âŠ¥, âŠ¤)

ğœ–
2âŒˆâ„“ log1/(1âˆ’ğ‘ ) ğ‘›âŒ‰

//Select a ğ‘-pivot ğ‘
(ğ‘, ğ‘ ) = pivot(ğ‘„ â€², ğ· â€², (ğ‘¤, âª¯ ) )
//Partition
(ğ‘„lt, ğ·lt ) = trim(ğ‘„, ğ·, ğ‘¤ (ğ‘ˆğ‘¤ ) â‰º ğ‘¤ (ğ‘ ), ğœ– â€² )
(ğ‘„lt, ğ·lt ) = trim(ğ‘„lt, ğ·lt, ğ‘¤ (ğ‘ˆğ‘¤ ) â‰» low, ğœ– â€² )
(ğ‘„gt, ğ·gt ) = trim(ğ‘„, ğ·, ğ‘¤ (ğ‘ˆğ‘¤ ) â‰» ğ‘¤ (ğ‘ ), ğœ– â€² )
(ğ‘„gt, ğ·gt ) = trim(ğ‘„gt, ğ·gt, ğ‘¤ (ğ‘ˆğ‘¤ ) â‰º high, ğœ– â€² )
//Choose partition
Set |ğ‘„eq (ğ·eq ) | to |ğ‘„ â€² (ğ· â€² ) | âˆ’ |ğ‘„lt (ğ·lt ) | âˆ’ |ğ‘„gt (ğ·gt ) |
if ğ‘˜ < |ğ‘„lt (ğ·lt ) | then

(ğ‘„ â€², ğ· â€², high) = (ğ‘„lt, ğ·lt, ğ‘¤ (ğ‘ ) )
else if ğ‘˜ < |ğ‘„lt (ğ·lt ) | + |ğ‘„eq (ğ·eq ) | then

return ğ‘

else

(ğ‘„ â€², ğ· â€², lt) = (ğ‘„gt, ğ·gt, ğ‘¤ (ğ‘ ) )
ğ‘˜ = ğ‘˜ âˆ’ |ğ‘„lt (ğ·lt ) | âˆ’ |ğ‘„eq (ğ·eq ) |

25
26 Materialize and sort ğ‘„ â€² (ğ· â€² )
27 return answer at index ğ‘˜ in ğ‘„ â€² (ğ· â€² )

11

12

13

14

15

16

17

18

19

20

21

22

23

24

Figure 5: Proof of Lemma 3.6: Query answers that are â€œlostâ€
due to lossy trimmings are implicitly moved to the equal-to
partition (middle). Consequently, index ğ‘˜ğ‘– in the less-than
partition contains an element that was previously at a higher
index ğ‘˜â€²
ğ‘– âˆ’ğ‘˜ğ‘– is bounded by the number of lost answers.

ğ‘– , but ğ‘˜â€²

and ğ‘¡ all agree on their common variables. For the leaf relations, we
have no children and pivot(ğ‘¡) is initialized to ğ‘¡. For the inductive
step, let ğ‘¥ be a common variable between two children ğ‘‰ğ‘– and ğ‘‰ğ‘— of
ğ‘‰ , ğ‘–, ğ‘— âˆˆ [ğ‘Ÿ ]. Because of the running intersection property of the join
tree, ğ‘¥ also needs to appear in the parent ğ‘‰ . Since the groups ğ‘ğ‘–, ğ‘ ğ‘—
join with ğ‘¡, all their tuples necessarily assign value ğ‘¡ [ğ‘¥] to variable
ğ‘¥. We show that pivot(ğ‘ğ‘– ) also assigns ğ‘¡ [ğ‘¥] to ğ‘¥ and the case of
pivot(ğ‘ ğ‘— ) is similar. We have that pivot(ğ‘ğ‘– ) = pivot(ğ‘¡ğ‘– ) for some
tuple ğ‘¡ğ‘– âˆˆ ğ‘ğ‘– where pivot(ğ‘¡ğ‘– ) is picked as the weighted median of
the group. From the inductive hypothesis, pivot(ğ‘¡ğ‘– ) needs to agree
with ğ‘¡ğ‘– on the value of ğ‘¥ which we argued is equal to ğ‘¡ [ğ‘¥].

C.2 Proof of Lemma 4.5
Without loss of generality, let the indexing of the ğ‘Ÿ sets be consistent
with the ordering of their ğ‘-pivots, i.e., ğ‘ğ‘– âª¯ ğ‘ ğ‘— for ğ‘ğ‘–, ğ‘ ğ‘— , 1 â‰¤
ğ‘– â‰¤ ğ‘— â‰¤ ğ‘Ÿ . Let ğ‘ğ‘š be the weighted median, selected from set ğ‘ğ‘š

11

for some ğ‘š âˆˆ [ğ‘Ÿ ]. We prove that ğ‘ğ‘š is greater than or equal to
(according to âª¯) at least ğ‘
2 |ğ‘1 âˆª ğ‘2 âˆª . . . âˆª ğ‘ğ‘Ÿ | elements, and the
case of less than or equal to is symmetric. Because of the indexing
we enforced, we know that ğ‘ğ‘– âª¯ ğ‘ğ‘š for all ğ‘– âˆˆ [ğ‘š]. Combining that
with the definition of a ğ‘-pivot (for ğ‘ğ‘– ), we obtain that ğ‘ğ‘š is greater
than or equal to at least ğ‘ |ğ‘ğ‘– | elements of |ğ‘ğ‘– |, or ğ‘ (cid:205)ğ‘– âˆˆ [1,ğ‘š] |ğ‘ğ‘– |
in total. Now, because the median is weighted by the set sizes
and there is no overlap between their elements, (cid:205)ğ‘– âˆˆ [1,ğ‘š] |ğ‘ğ‘– | â‰¥
|ğ‘1 âˆª ğ‘2 âˆª . . . âˆª ğ‘ğ‘Ÿ |/2. Thus, ğ‘ğ‘š is greater than or equal to at least
ğ‘ |ğ‘1 âˆª ğ‘2 âˆª . . . âˆª ğ‘ğ‘Ÿ |/2 elements of ğ‘1 âˆª ğ‘2 âˆª . . . âˆª ğ‘ğ‘Ÿ .

C.3 Proof of Lemma 4.6
Let ğ‘€ be the partial answers rooted at ğ‘¡, and let ğ‘€ğ‘– be the partial
answers rooted at ğ‘‰ğ‘– and restricted to those that agree with ğ‘¡ for all
ğ‘– âˆˆ [ğ‘Ÿ ]. We only show that ğ‘¡ âˆª ğ‘1 âˆª . . . âˆª ğ‘ğ‘Ÿ is greater than or equal
to at least ğ‘ğ‘Ÿ |ğ‘€ | partial answers, since the case of less than or equal
to is symmetric. For ğ‘– âˆˆ [ğ‘Ÿ ], let ğ¿ğ‘– be the subset of ğ‘€ğ‘– answers that
are less than or equal to ğ‘ğ‘– .

We first show that ğ‘¤ (ğ‘¡ âˆª ğ‘1 âˆª . . . âˆª ğ‘ğ‘Ÿ ) âª¯ ğ‘¤ (ğ‘¡ âˆª ğ‘1 âˆª . . . âˆª ğ‘ğ‘Ÿ )
whenever ğ‘ğ‘– âˆˆ ğ¿ğ‘–, ğ‘– âˆˆ [ğ‘Ÿ ]. We know that ğ‘¤ (ğ‘ğ‘– ) âª¯ ğ‘¤ (ğ‘ğ‘– ) for all
ğ‘– âˆˆ [ğ‘Ÿ ]. We proceed inductively in ğ‘–, showing that ğ‘¤ (ğ‘1 âˆª . . . âˆªğ‘ğ‘– ) âª¯
ğ‘¤ (ğ‘1âˆª. . .âˆªğ‘ğ‘– ). The inductive hypothesis is that ğ‘¤ (ğ‘1âˆª. . .âˆªğ‘ğ‘– âˆ’1) âª¯
ğ‘¤ (ğ‘1 âˆª . . . âˆª ğ‘ğ‘– âˆ’1). Each of these two terms is an aggregate over
the values of variables ğ‘ˆ1 âˆª . . . âˆª ğ‘ˆğ‘– âˆ’1 mapped to their weights,
where ğ‘ˆğ‘– is the subset of weighted variables ğ‘ˆğ‘¤ that appear in
the subtree rooteed at node ğ‘‰ğ‘– . For example, ğ‘¤ (ğ‘1 âˆª . . . âˆª ğ‘ğ‘– âˆ’1)
is aggğ‘¤ ({ğ‘¤ğ‘¥ ((ğ‘1 âˆª . . . âˆª ğ‘ğ‘– âˆ’1) [ğ‘¥]) | ğ‘¥ âˆˆ ğ‘ˆ1 âˆª . . . âˆª ğ‘ˆğ‘– âˆ’1}). By
subset-monotonicity, we can add to both aggregates the weighted
values of ğ‘ğ‘– without changing the inequality, i.e., we obtain ğ‘¤ (ğ‘1 âˆª
. . . âˆª ğ‘ğ‘– âˆ’1 âˆª ğ‘ğ‘– ) âª¯ ğ‘¤ (ğ‘1 âˆª . . . âˆª ğ‘ğ‘– âˆ’1 âˆª ğ‘ğ‘– ) (A). With a similar
argument of subset-monotonicity, we start from ğ‘¤ (ğ‘ğ‘– ) âª¯ ğ‘¤ (ğ‘ğ‘– )
and add to both sides the weighted values of ğ‘1 âˆª . . . âˆª ğ‘ğ‘– âˆ’1 to
obtain ğ‘¤ (ğ‘1 âˆª . . . âˆª ğ‘ğ‘– âˆ’1 âˆª ğ‘ğ‘– ) âª¯ ğ‘¤ (ğ‘1 âˆª . . . âˆª ğ‘ğ‘– âˆ’1 âˆª ğ‘ğ‘– ) (B). (A)
and (B) together prove the inductive step. To complete the first part
of the proof, we add to both aggregates the weighted values of ğ‘¡
(that do not appear in any child) to obtain ğ‘¤ (ğ‘¡ âˆª ğ‘1 âˆª . . . âˆª ğ‘ğ‘Ÿ ) âª¯
ğ‘¤ (ğ‘¡ âˆª ğ‘1 âˆª . . . âˆª ğ‘ğ‘Ÿ ), again by subset-monotonicity.

Next, notice that there are |ğ¿1 Ã— . . . Ã— ğ¿ğ‘Ÿ | partial answers of the
form ğ‘¡ âˆª ğ‘1 âˆª . . . âˆª ğ‘ğ‘Ÿ with ğ‘ğ‘– âˆˆ ğ¿ğ‘–, ğ‘– âˆˆ [ğ‘Ÿ ]. Since every ğ¿ğ‘– comprises
of elements that are less than or equal to a ğ‘-pivot, we have |ğ¿ğ‘– | â‰¥
ğ‘ |ğ‘€ğ‘– |. Also notice that |ğ‘€ | = (cid:206)ğ‘– âˆˆ [ğ‘Ÿ ] |ğ‘€ğ‘– |. Overall, we have that
|ğ¿1 Ã— . . . Ã— ğ¿ğ‘Ÿ | â‰¥ (cid:206)ğ‘– âˆˆ [ğ‘Ÿ ] ğ‘ |ğ‘€ğ‘– | = ğ‘ğ‘Ÿ |ğ‘€ |, and so ğ‘¡ âˆª ğ‘1 âˆª . . . âˆª ğ‘ğ‘Ÿ is
greater than or equal to at least ğ‘ğ‘Ÿ |ğ‘€ | partial answers.

D DETAILS OF EXACT TRIMMINGS
D.1 Proof of Lemma 5.2
We always start by creating fresh copies of relations to eliminate self-
joins from ğ‘„. This ensures that every column in the database corre-
sponds to a unique variable, avoiding situations like ğ‘…(ğ‘¥, ğ‘¦), ğ‘…(ğ‘¦, ğ‘¥).
First, consider maxğ‘¥ âˆˆğ‘ˆğ‘¤ ğ‘¤ğ‘¥ (ğ‘¥) < ğœ†. We scan the given database
ğ· once and if a tuple ğ‘¡ contains a value ğ‘¡ [ğ‘¥] with ğ‘¤ğ‘¥ (ğ‘¡ [ğ‘¥]) â‰¥ ğœ†
for a variable ğ‘¥ âˆˆ ğ‘ˆğ‘¤, then we remove ğ‘¡ from the database. This
process removes precisely the answers ğ‘ âˆˆ ğ‘„ (ğ·) that do not satisfy
the predicate, since, for the maximum to be greater than or equal
to ğœ†, at least one variable needs to map to such a weight. The JQ
we return is ğ‘„ itself. The case of minğ‘¥ âˆˆğ‘ˆ ğ‘¤ğ‘¥ (ğ‘¥) > ğœ† is symmetric.

ğ‘˜ğ‘–ğ‘˜ğ‘–â€²â€œLostâ€ query answersLess-thanEqual-toGreater-thanPODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Nikolaos Tziavelis, Nofar Carmeli, Wolfgang Gatterbauer, Benny Kimelfeld, & Mirek Riedewald

10

11

12

13

14

15

16

17

18

19

11

12

13

Algorithm 2: pivot

1 Input: acyclic JQ ğ‘„, database ğ·, ranking function (ğ‘¤, âª¯ )
2 Output: a ğ‘-pivot of ğ‘„ (ğ· ) ordered by âª¯, and the value of ğ‘
3 Convert attribute weights to tuple weights
4 Construct a join tree ğ‘‡ of ğ‘„ with artificial root ğ‘‰0 = {ğ‘¡0 }
5 Materialize a relation for every ğ‘‡ -node and group it by the variables it has in

common with its parent node

6 Initialize pivot(ğ‘¡ ) = ğ‘¡, cnt(ğ‘¡ ) = 1 for all tuples ğ‘¡ of all relations
7 Initialize ğ‘ (ğ‘…) = 1 for leaf relations ğ‘…
8 for relation ğ‘… in bottom-up order of ğ‘‡ do
9

if ğ‘… is not leaf then

ğ‘†1, . . . , ğ‘†ğ‘Ÿ = children of ğ‘…
ğ‘ (ğ‘…) =

ğ‘ (ğ‘†ğ‘Ÿ )
2
for tuple ğ‘¡ âˆˆ ğ‘…, child ğ‘† of ğ‘… do

2 Ã— . . . Ã—

ğ‘ (ğ‘†1 )

ğ‘ = join group of ğ‘† that agrees with the values of ğ‘¡
//Compute the weighted median (and the count of subtree answers)

the first time we visit this group

if pivot(ğ‘ ) not already computed then

pivot(ğ‘ ) = wmedâª¯ ( {pivot(ğ‘¡ â€² ) | ğ‘¡ â€² âˆˆ ğ‘ }, ğ›½ ) with
ğ›½ (pivot(ğ‘¡ â€² ) ) = cnt(ğ‘¡ â€² )
cnt(ğ‘ ) = (cid:205)ğ‘¡ â€² âˆˆğ‘ cnt(ğ‘¡ â€² )

//Combine results from different branches of the join tree
pivot(ğ‘¡ ) = pivot(ğ‘¡ ) âˆª pivot(ğ‘ )
cnt(ğ‘¡ ) = cnt(ğ‘¡ ) Ã— cnt(ğ‘ )

20
21 return pivot(ğ‘¡0 ), ğ‘ (ğ‘‰0 )

Algorithm 3: trim for MAX

1 Input: acyclic JQ ğ‘„, database ğ·, predicate max(ğ‘ˆğ‘¤ ) > ğœ†
2 Output: acyclic JQ ğ‘„ â€², database ğ· â€²
3 ğ‘¥1, . . . , ğ‘¥ğ‘Ÿ = ğ‘ˆğ‘¤
(ğ‘„ â€², ğ· â€² ) = (ğ‘„, âˆ…)
4
5 //Construct the new JQ
6 Eliminate self-joins from ğ‘„ â€² by materializing new relations in ğ·
7 Add the same variable ğ‘¥ğ‘ to all the atoms and the head of ğ‘„ â€²
8 //Create ğ‘Ÿ databases
9 for ğ‘– from 1 to ğ‘Ÿ do
10

//Each ğ‘ƒğ‘– is a conjuntion of unary predicates
ğ‘ƒğ‘– = {ğ‘¤ğ‘¥1 (ğ‘¥1 ) â‰¤ ğœ†, . . . , ğ‘¤ğ‘¥ğ‘– âˆ’1 (ğ‘¥ğ‘– âˆ’1 ) â‰¤ ğœ†, ğ‘¤ğ‘¥ğ‘– (ğ‘¥ğ‘– ) > ğœ†}
ğ·ğ‘– = copy of ğ· with conditions ğ‘ƒğ‘– applied
//An identifier separates the answers from different ğ·ğ‘– after the union
Add the column ğ‘¥ğ‘ with value ğ‘– to all relations of ğ·ğ‘–

14
15 //Union the databases into one
16 for relation ğ‘…ğ· in ğ· do

Add to ğ· â€² relation ğ‘…ğ·â€²

17
18 return (ğ‘„ â€², ğ· â€² )

= (cid:208)ğ‘– âˆˆ [ğ‘Ÿ ] ğ‘…ğ·ğ‘– of database ğ·ğ‘–

Second, consider maxğ‘¥ âˆˆğ‘ˆğ‘¤ ğ‘¤ğ‘¥ (ğ‘¥) > ğœ†. Algorithm 3 shows the
pseudocode of trim for this case. If there are ğ‘Ÿ variables in ğ‘ˆğ‘¤,
then we create ğ‘Ÿ databases, each enforcing condition ğ‘ƒğ‘– , which
is a conjunction of unary predicates. The conditions ğ‘ƒğ‘– partition
the space of possible ğ‘ˆğ‘¤ values that satisfy maxğ‘¥ âˆˆğ‘ˆğ‘¤ ğ‘¤ğ‘¥ (ğ‘¥) > ğœ†.
To return a single database ğ·â€², we union together the copies of
each relation and separate the different databases with a partition
identifier ğ‘– âˆˆ [ğ‘Ÿ ]. This identifier is added as a variable ğ‘¥ğ‘ to all
atoms of the returned JQ ğ‘„ â€². As a consequence, each query answer
of the returned ğ‘„ â€² can only draw values from database tuples that
belong to the same partition. The bijection from ğ‘„ â€² (ğ·â€²) to ğ‘„ (ğ·)
simply removes the variable ğ‘¥ğ‘ . Since ğ‘Ÿ does not depend on ğ·, the
entire process can be done in linear time. Furthermore, ğ‘„ â€² remains
acyclic because every join tree of ğ‘„ is also a join tree of ğ‘„ â€² by adding
ğ‘¥ğ‘ to all nodes. The case of minğ‘¥ âˆˆğ‘ˆğ‘¤ ğ‘¤ğ‘¥ (ğ‘¥) < ğœ† is symmetric.

12

D.2 Proof of Lemma 5.4
Let ğœ† = (ğœ†1, . . . , ğœ†ğ‘Ÿ ). The proof is the same as in the case of
MIN/MAX (Appendix D.1), except that the conditions we enforce
in the ğ‘–th of the ğ‘Ÿ copies of the database ğ· are ğ‘ƒğ‘– = {ğ‘¤ â€²
ğ‘¥1 (ğ‘¥1) =
ğœ†1, . . . , ğ‘¤ â€²
ğ‘¥ğ‘– (ğ‘¥ğ‘– ) < ğœ†ğ‘– } for â‰¤LEX and ğ‘ƒğ‘– =
{ğ‘¤ â€²

ğ‘¥ğ‘– âˆ’1 (ğ‘¥ğ‘– âˆ’1) = ğœ†ğ‘– âˆ’1, ğ‘¤ â€²

ğ‘¥ğ‘– (ğ‘¥ğ‘– ) > ğœ†ğ‘– } for â‰¥LEX.

ğ‘¥1 (ğ‘¥1) = ğœ†1, . . . , ğ‘¤ â€²

ğ‘¥ğ‘– âˆ’1 (ğ‘¥ğ‘– âˆ’1) = ğœ†ğ‘– âˆ’1, ğ‘¤ â€²

D.3 Proof of Theorem 5.6
First, we prove that the condition in our dichotomy is equivalent to
having the SUM variables on one or two adjacent join tree nodes.
Lemma D.1. Consider the hypergraph H (ğ‘„) of a JQ ğ‘„ and a set
of variables ğ‘ˆğ‘¤. If H (ğ‘„) is acyclic, any set of independent variables
of ğ‘ˆğ‘¤ is of size at most 2, and any chordless path between two ğ‘ˆğ‘¤
variables is of length at most 3, then there exists a join tree for ğ‘„
where ğ‘ˆ appears on one or two adjacent nodes.

Proof. If there is one query atom that contains all ğ‘ˆğ‘¤ variables,
then we are done. Otherwise, since any set of independent variables
of ğ‘ˆğ‘¤ is of size at most 2, then there are 2 atoms that together
contain all ğ‘ˆğ‘¤ variables. Indeed, consider any 3 atoms. If each
of them has a ğ‘ˆğ‘¤ variable that does not appear in the other two,
then these three variables are an independent set of size 3, which
contradicts our condition. Thus, 2 of these atoms contain all ğ‘ˆğ‘¤
variables that appear in the 3 atoms. By applying this repeatedly
to the selected 2 atoms and an untreated atom until all atoms are
treated, we get 2 atoms that contain all of ğ‘ˆğ‘¤ variables.

Since ğ‘„ is acyclic, it has a join tree. Let ğ‘…â€² and ğ‘† â€² be two join-tree
nodes that together contain all of ğ‘ˆğ‘¤. Consider the path ğ‘ƒ â€² from
ğ‘…â€² to ğ‘† â€² in the join tree. Let ğ‘… be the last node on ğ‘ƒ â€² that contains
all ğ‘ˆğ‘¤ variables that are in ğ‘…â€², and let ğ‘† be the first node on ğ‘ƒ â€² that
contains all ğ‘ˆğ‘¤ variables that are in ğ‘† â€². If ğ‘… and ğ‘† are neighbors,
we are done. Otherwise, we show we can find an alternative join
tree where they are neighbors. Consider the path ğ‘ƒ from ğ‘… to ğ‘†
in the join tree. Let ğ‘‰ be all the variables that appear on the path
between ğ‘… and ğ‘† (not including ğ‘… and ğ‘†), such that each variable in
ğ‘‰ appears in either ğ‘… or ğ‘† (or both). We consider three cases. The
first case is ğ‘‰ âŠ† ğ‘…. We directly connect ğ‘… and ğ‘† and remove the
edge connecting ğ‘† to the node preceding it on the path from ğ‘…. The
running intersection property is maintained as for each variable,
the nodes containing this variable remain connected. The second
case is ğ‘‰ âŠ† ğ‘†. It is handled similarly by directly connecting ğ‘… to ğ‘†
and removing the edge from ğ‘… to its succeeding node on the path
to ğ‘†. The third case is that a variable ğ‘¢ âˆˆ ğ‘‰ appears in ğ‘… but not
in ğ‘† and another variable ğ‘£ âˆˆ ğ‘‰ appears in ğ‘† but not in ğ‘…. Since ğ‘…
is the last in ğ‘ƒ to contain all ğ‘ˆğ‘¤ variables of ğ‘…â€², there is a variable
ğ‘¥ âˆˆ ğ‘ˆğ‘¤ that appears in ğ‘… but nowhere else in ğ‘ƒ. Similarly, there
is a variable ğ‘¦ âˆˆ ğ‘ˆğ‘¤ that appears in ğ‘† and nowhere else in ğ‘ƒ. If
every two consecutive nodes on ğ‘ƒ share a variable, then we have a
chordless path ğ‘¥ âˆ’ ğ‘¢ âˆ’ . . . âˆ’ ğ‘£ âˆ’ ğ‘¦ of length at least 4, contradicting
our condition. Otherwise, we remove the edge between the two
nodes that do not share a variable, and add an edge between ğ‘… and
â–¡
ğ‘†, which preserves the running intersection property.

We now show the dichotomy of Theorem 5.6.
For the positive side, we apply Lemma D.1. When all ğ‘ˆğ‘¤ vari-
ables are contained in a single join-tree node, trimming can be
done in linear time by filtering the corresponding relation. When

Efficient Computation of Quantiles over Joins

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Algorithm 4: Approximate trim for SUM
1 Input: acyclic JQ ğ‘„ with â„“ atoms, database ğ·, predicate

(cid:205)ğ‘¥ âˆˆğ‘ˆğ‘¤ ğ‘¤ğ‘¥ (ğ‘¥ ) < ğœ†, approximation bound ğœ–

2 Output: acyclic JQ ğ‘„ â€², database ğ· â€²
3 Convert attribute weights to tuple weights
4 Construct a binary join tree ğ‘‡ of ğ‘„, set an arbitrary root
5 Materialize a relation for every ğ‘‡ -node and group it by the variables it has in

common with its parent node

6 Initialize ğœ (ğ‘¡ ) = (ğœğ‘  (ğ‘¡ ), ğœğ‘š (ğ‘¡ ) ) = (ğ‘¤ (ğ‘¡ ), 1) for all tuples ğ‘¡ of all relations
7 ğœ– â€² = 1
8 for relation ğ‘… in bottom-up order of ğ‘‡ do
9

for child ğ‘† of ğ‘… do

4â„“ ğœ–

Add variable ğ‘£ğ‘…ğ‘† to ğ‘… and ğ‘† in ğ‘„, and corresponding columns in ğ·

10

11

12

13

14

15

16

17

18

19

20

21

22

23

for tuple ğ‘¡ âˆˆ ğ‘…, child ğ‘† of ğ‘… do

ğ‘ = join group of ğ‘† that agrees with the values of ğ‘¡
//Sketch messages the first time we visit this group
if ğœ (ğ‘ ) not already computed then

ğœ (ğ‘ ) = Sğœ–â€² (âˆªğ‘¡ â€² âˆˆğ‘ğœ (ğ‘¡ â€² ) ) such that each value falls into a
single bucket

//A bucket ğ‘’ in the sketch is described by a sum ğ‘’ğ‘  ,
multiplicity ğ‘’ğ‘š , and a set of source tuples from ğ‘†
for bucket ğ‘’ âˆˆ ğœ (ğ‘ ) with source tuples ğ‘†ğ‘’ âŠ† ğ‘† do
//Add the bucket values to the child column
ğ‘¡ğ‘’ [ğ‘£ğ‘…ğ‘† ] = (ğ‘’ğ‘ , ğ‘’ğ‘š ) for all ğ‘¡ğ‘’ âˆˆ ğ‘†ğ‘’

for bucket ğ‘’ âˆˆ ğœ (ğ‘ ) do

//Add the bucket values to the parent column
Create a copy ğ‘¡ğ‘’ of ğ‘¡ in ğ‘… with ğ‘¡ğ‘’ [ğ‘£ğ‘…ğ‘† ] = (ğ‘’ğ‘ , ğ‘’ğ‘š )
ğœ (ğ‘¡ğ‘’ ) = (ğœğ‘  (ğ‘¡ ) + ğ‘’ğ‘ , ğœğ‘š (ğ‘¡ ) Ã— ğ‘’ğ‘š )

Remove ğ‘¡ from ğ‘…

24
25 Remove all tuples ğ‘¡ from the root relation with ğœğ‘  (ğ‘¡ ) â‰¥ ğœ†
26 return ğ‘„, ğ·

they are contained in two adjacent join-tree nodes, O (ğ‘› log ğ‘›) trim-
ming follows from Lemma 5.5. Combining these two cases with
Lemmas 3.3 and 4.1 completes the proof of the positive side.

For the negative side, there are 3 cases. 1) If ğ‘„ is cyclic, an an-
swer to %JQ would also answer the decision problem of whether
ğ‘„ has any answer, which precludes time O (ğ‘› polylog ğ‘›) assuming
Hypercliqe [6]. Assume ğ‘„ is acyclic. 2) If there exists a set of
independent variables of ğ‘ˆğ‘¤ of size 3, selection by SUM is not
possible in O (ğ‘›2âˆ’ğœ€ ) for all ğœ€ > 0 assuming 3sum [7, Corollary 7.11].
Since we can count the answers to an acyclic JQ in linear time, the
selection problem and %JQ are equivalent. 3) If there is a chordless
path between two ğ‘ˆğ‘¤ variables of length 4 or more, we apply a
known reduction [7, Lemma 7.13] to show that solving %JQ in quasi-
linear time can be used to detect a triangle in a graph in quasilinear
time, which is not possible assuming Hypercliqe. There are two
ways in which the statement of that lemma differs from our needs:
first, all variables there were allowed to participate in the ranking.
However, the reduction only assigns non-zero weights to the first
and last variables in the path, so this difference is non-essential.
Second, the path there contains exactly 3 atoms (i.e., 4 variables);
if our path is longer, we simply make the the remaining relations
equality, and the rest of the proof is the same.

E DETAILS OF APPROXIMATE TRIMMING

FOR SUM

Algorithm 4 shows the pseudocode of our lossy trimming for SUM.

13

E.1 Proof of Lemma 6.1
Preservation of JQ answers. Let ğ‘„ â€² and ğ·â€² be the returned JQ
and database. We argue that, before removing the root tuples that
violate the inequality (Line 25), the JQ answers are preserved in
the sense that there exists a bijection from ğ‘„ â€² (ğ·â€²) to ğ‘„ (ğ·) which
simply removes the new variables. Consider the step where we
introduce variable ğ‘£ğ‘…ğ‘† between parent ğ‘… and child ğ‘†. Let ğ‘¡ âˆˆ ğ‘… be
a tuple in the original database ğ· and ğ‘ the join group in ğ‘† that
agrees with ğ‘¡. Then, every tuple ğ‘¡ â€² âˆˆ ğ‘ joins with exactly one copy
of ğ‘¡ after the introduction of ğ‘£ğ‘…ğ‘† . This is because there is a copy of
ğ‘¡ for each bucket (with the bucket identifier in ğ‘£ğ‘…ğ‘† ) and our bucket
adjustment guarantees that the weight of ğ‘¡ â€² is assigned to precisely
one bucket.

Error from sketch adjustment. Recall that in our sketch Sğœ– (ğ¿)
of a multiset ğ¿ we made the adjustment that if ğ‘–, ğ‘—, ğ‘˜ are three
consecutive indexes in the bucketization, ğ¿[ ğ‘— âˆ’ 1] = ğ¿[ ğ‘—], and
ğ‘— â€², ğ‘— â€²â€² are the smallest and largest indexes that contain ğ¿[ ğ‘—] in the
two consecutive buckets, then we replace ğ‘–, ğ‘—, ğ‘˜ with ğ‘–, ğ‘— â€², ğ‘— â€²â€² + 1, ğ‘˜.
We say that a multiset is an ğœ–-sketch of another multiset if it satisfies
the guarantee of Lemma 6.3. Also, let S be the original sketch with
approximation error ğœ– (see Lemma 6.3) and Sâ€² be the resulting
sketch. What we will show is that Sâ€² is an ğœ–-sketch of ğ¿. In particular,
we claim that â†“ğœ† (S) â‰¤â†“ğœ† (Sâ€²) â‰¤â†“ğœ† (ğ¿) for all values of ğœ†. Our
adjustment can only change elements in the index ranges [ğ‘–, ğ‘— â€²)
and [ ğ‘—, ğ‘— â€²â€²), while all other elements stay the same since the largest
element in their bucket continues to be the same. The elements
that can potentially change may only decrease in value because
the upper index of their bucket is now smaller (but they may not
decrease beyond ğ¿[ğ‘–] and ğ¿[ ğ‘—] respectively). Consequently, if ğœ† <
ğ¿[ğ‘–] or ğœ† â‰¥ ğ¿[ ğ‘— â€²â€²] then â†“ğœ† (S) =â†“ğœ† (Sâ€²). If ğ¿[ğ‘–] â‰¤ ğœ† < ğ¿[ ğ‘—], then
â†“ğœ†(S) â‰¤â†“ğœ†(Sâ€²) because all elements in this bucket were mapped to
ğ‘ [ ğ‘—] in S but now they are mapped to a number that can only be
smaller, and thus closer to their original value. If ğ¿[ ğ‘—] â‰¤ ğœ† < ğ¿[ ğ‘— â€²],
all elements in that bucket are equal to ğ¿[ ğ‘—], thus â†“ğœ†(Sâ€²) =â†“ğœ†(ğ¿).
Approximation guarantee. Let us introduce the notation and
tools we need. Recall that each tuple ğ‘¡ computes ğœ (ğ‘¡) that represents
the approximate sum of partial query answers in its subtree. Let
cp(ğ‘¡) = {ğ‘¡1, . . . , ğ‘¡ğ‘Ÿ } be the copies of ğ‘¡ that we create in our algorithm,
ğ‘Šğ‘¡ be the partial query answers in the subtree of ğ‘¡ mapped to their
weights, jgğ‘† (ğ‘¡) be the join group of relation ğ‘† that joins with a
tuple ğ‘¡ of the parent relation, and âŠ— be the pairwise summation
operator for multisets. Abo-Khamis et al. [2] have shown that if ğ¿â€²
1
is an ğœ–1-sketch of ğ¿1 and ğ¿â€²
2 is a
max{ğœ–1, ğœ–2}-sketch of ğ¿1âŠğ¿2 and ğ¿â€²
2 is an (ğœ–1+ğœ–2)-sketch of ğ¿1 âŠ—
ğ¿2. Additionally, an ğœ–1-sketch of an ğœ–2-sketch is a (2 max{ğœ–1, ğœ–2})-
sketch (using the definition and that (1 âˆ’ ğœ–)2 â‰¥ 1 âˆ’ 2ğœ–). With these,
we will show that the removal of root-node tuples (Line 25) removes
the JQ answers that fall into buckets with values greater than or
equal to ğœ† in an ğœ–-sketch of the multiset {ğ‘¤ (ğ‘)|ğ‘ âˆˆ ğ‘„ (ğ·)}. Note
that in the algorithm, we apply sketching with ğœ–â€² â‰¤ ğœ– (Line 15).

2 is an ğœ–2-sketch of ğ¿2, then ğ¿â€²

1 âŠ ğ¿â€²

1 âŠ—ğ¿â€²

First, we prove inductively that for a tuple ğ‘¡ âˆˆ ğ‘… where ğ‘… is a
relation at level ğ‘‘ (i.e., the maximum-length path from ğ‘… to a leaf
node is ğ‘‘), âŠğ‘¡ğ‘– âˆˆcp(ğ‘¡ )ğœ (ğ‘¡ğ‘– ) is a (4ğ‘‘ğœ–â€²)-sketch of ğ‘Šğ‘¡ . Each weight in
ğ‘Šğ‘¡ is the sum of the weight of ğ‘¡ and the weights of the joining
partial answers (in the original database ğ·) from the child relations,
i.e., ğ‘Šğ‘¡ = {ğ‘¤ (ğ‘¡)} âŠ— ((cid:203)
(cid:208)ğ‘¡ â€² âˆˆjgğ‘† (ğ‘¡ ) ğ‘Šğ‘¡ â€² )). If ğ‘¡ joins with a tuple ğ‘¡ â€²
ğ‘†

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Nikolaos Tziavelis, Nofar Carmeli, Wolfgang Gatterbauer, Benny Kimelfeld, & Mirek Riedewald

we introduce appears in two adjacent nodes of the join tree of ğ‘„.
Therefore, ğ‘„ â€² also has a join tree.

Running time. The size of any relation is initially bounded by ğ‘›.
Consider the step where we handle a relation and increase its size by
creating copies of its tuples. The sizes of the child relations (which
have already been handled) have size bounded by ğ‘›â€² â‰¥ ğ‘›. The
total size of the messages sent from the children is O (log1+ğœ– â€² ğ‘›â€²)
because the messages are sketched. The parent relation receives the
messages of a child and creates copies of its tuples whose number is
equal to the message size. Since we have at most 2 children, the size
of the parent relation becomes O (ğ‘›(log1+ğœ– â€² ğ‘›â€²)2). Applying this for
every relation bottom-up, we can conclude that all relations after
the algorithm terminates have size O (ğ‘›(log1+ğœ– â€² ğ‘›)2) (because the
double-logarithmic terms are dominated). Changing base, this is
O (ğ‘› log2 ğ‘›
ğœ– 2 ğ‘› log2 ğ‘›) since ğœ–â€² = Î˜(ğœ–) and also log(1 +ğœ–)
log2 (1+ğœ– â€² )
is very close to ğœ– for small ğœ–. All other operations of the algorithm
are linear in this size, except for sketching, which is only done
once for each join group. A sketch of a multiset ğ¿ = (ğ‘, ğ›½) can be
computed in O (|ğ‘ | log |ğ‘ |) by sorting. Since O (log( 1
ğœ– 2 ğ‘› log2 ğ‘›)) =
ğœ– ), we get the desired time bound O ( 1
ğœ– 2 ğ‘› log2 ğ‘› log ğ‘›
O (log ğ‘›
ğœ– ).

) or O ( 1

of a child relation ğ‘†, then it needs to join with all copies cp(ğ‘¡ â€²) that
were created when we handled ğ‘† and its children. The algorithm
computes the values ğœ (ğ‘¡ğ‘– ) as follows: âŠğ‘¡ğ‘– âˆˆcp(ğ‘¡ )ğœ (ğ‘¡ğ‘– ) = {ğ‘¤ (ğ‘¡)} âŠ—
((cid:203)
ğ‘— ))). We know inductively that
ğ‘— ) is a (4ğ‘‘ âˆ’1ğœ–â€²)-sketch of ğ‘Šğ‘¡ â€² . The error bound of
(cid:210)ğ‘¡ â€²
the sketch remains 4ğ‘‘ âˆ’1ğœ–â€² after the union, then becomes 2 Â· 4ğ‘‘ âˆ’1ğœ–â€²
after applying the ğœ–â€²-sketch, and finally 2 Â· 2 Â· 4ğ‘‘ âˆ’1ğœ–â€² = 4ğ‘‘ğœ–â€² after
taking the pairwise sums between the two children.

ğ‘† Sğœ– â€² ((cid:210)ğ‘¡ â€² âˆˆjgğ‘† (ğ‘¡ )
ğ‘— âˆˆcp(ğ‘¡ â€² ) ğœ (ğ‘¡ â€²

ğ‘— âˆˆcp(ğ‘¡ â€² ) ğœ (ğ‘¡ â€²

(cid:210)ğ‘¡ â€²

Second, we claim that the height of the binary join tree we
construct is no more than â„“, where â„“ is the number of atoms of ğ‘„.
To see why, note that the new nodes we introduce in order to make
the tree binary cannot be leaves and will always have 2 children.
Suppose that there exists a root-to-leaf path of length greater than
â„“. For every new node on the path, there must be an original node
that is a descendant of it, but not on this path. This implies that
the number of original nodes would be greater than â„“, which is a
contradiction. To conclude, we get ğœ–-sketches of ğ‘Šğ‘¡ for tuples ğ‘¡
at the root level if we set ğœ–â€² = 1
4â„“ ğœ–. Their union is an ğœ–-sketch of
{ğ‘¤ (ğ‘)|ğ‘ âˆˆ ğ‘„ (ğ·)}.

Returned JQ properties. The fact that the JQ ğ‘„ â€² that we re-
turn is acyclic is evident from the fact that every variable ğ‘£ğ‘…ğ‘† that

14

