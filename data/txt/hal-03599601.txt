A Journey to the Frontiers of Query Rewritability
Piotr Ostropolski-Nalewaja, Jerzy Marcinkowski, David Carral, Sebastian

Rudolph

To cite this version:

Piotr Ostropolski-Nalewaja, Jerzy Marcinkowski, David Carral, Sebastian Rudolph. A Journey to
the Frontiers of Query Rewritability. PODS 2022 - 41st ACM SIGMOD-SIGACT-SIGAI Sym-
posium on Principles of Database Systems, Jun 2022, Philadelphia, United States. pp.359-367,
ï¿¿10.1145/3517804.3524163ï¿¿. ï¿¿hal-03599601ï¿¿

HAL Id: hal-03599601

https://hal.science/hal-03599601

Submitted on 14 Mar 2022

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

Lâ€™archive ouverte pluridisciplinaire HAL, est
destinÃ©e au dÃ©pÃ´t et Ã  la diffusion de documents
scientifiques de niveau recherche, publiÃ©s ou non,
Ã©manant des Ã©tablissements dâ€™enseignement et de
recherche franÃ§ais ou Ã©trangers, des laboratoires
publics ou privÃ©s.

A Journey to the Frontiers of Query Rewritability
(Extended Technical Report)

Piotr Ostropolski-Nalewaja
University of WrocÅ‚aw, Institute of Computer Science

Jerzy Marcinkowski
University of WrocÅ‚aw, Institute of Computer Science

David Carral
LIRMM, Inria, University of Montpellier, CNRS

Sebastian Rudolph
TU Dresden, Computational Logic Group

ABSTRACT
We consider (first-order) query rewritability in the context of theory-
mediated query answering. The starting point of our journey is the
FUS/FES conjecture, which states that any theory that is a finite
expansion set (FES) and admits query rewriting (BDD, FUS) must be
uniformly bounded. We show that this conjecture holds for a large
class of BDD theories, which we call â€œlocalâ€. Upon investigating how
â€œnon-localâ€ BDD theories can actually get, we discover unexpected
phenomena that, we think, are at odds with prevailing intuitions
about BDD theories.

1 INTRODUCTION
The scenario we consider in this paper has been studied extensively
both in database theory and in knowledge representation: consider
a database instance D (also called fact set, or structure) and a theory
T (or rule set) that consists of tuple generating dependencies (or
rules). For a given conjunctive query ğœ™, we ask if D and T together
logically entail ğœ™, written: D, T |= ğœ™. This problem is also referred
to as ontology-mediated query answering.
The chase. The notion of the chase is fundamental in this context.
It denotes a structure obtained from D via the chase procedure,
which iteratively adds new terms and atoms in order to satisfy the
constraints from T , producing a growing sequence of structures
D=ğ¶â„0 (D, T ), ğ¶â„1 (D, T ), ğ¶â„2 (D, T ), . . .. The chase ğ¶â„(D, T ) is
then obtained as the corresponding fixpoint (cid:208)ğ‘– âˆˆN ğ¶â„ğ‘– (D, T ).

It is known [1] that a conjunctive query is entailed if and only
if it holds in the corresponding chase, which allows for reducing
entailment to model checking:

âˆ€T âˆ€D âˆ€ğœ™ (cid:0)ğ¶â„(D, T ) |= ğœ™ â‡” D, T |= ğœ™ (cid:1).

Finite expansion sets. We say T enjoys the finite expansion set
property [2] (or simply is FES) if, for every D, all conjunctive queries
satisfied in ğ¶â„(D, T ) are already jointly satisfied after finitely many
chase steps. More precisely, T is FES if:

âˆ€D âˆƒğ‘– âˆˆ N âˆ€ğœ™ (cid:0)ğ¶â„(D, T ) |= ğœ™ â‡” ğ¶â„ğ‘– (D, T ) |= ğœ™ (cid:1)

(FES)

This is an important property, since ğ¶â„(D, T ) is typically an
infinite structure, only existing as an abstract mathematical object,
and impossible to query, whereas ğ¶â„ğ‘– (D, T ) is always finite and so
in principle it can be computed and queried.
Bounded derivation depth. An arguably even more beneficial
property a theory can enjoy in this context is the following: We say
T has the bounded derivation depth property (or is BDD) if

âˆ€ğœ™ âˆƒğ‘– âˆˆ N âˆ€D (cid:0)ğ¶â„ (D, T) |= ğœ™ â‡” ğ¶â„ğ‘– (D, T) |= ğœ™ (cid:1),

(BDD)

which means that, in order to evaluate ğœ™, it is enough to run only
the first ğ‘– steps of the chase, with ğ‘– depending on ğœ™ but not on D.
As it turns out, BDD is equivalent [3] to FUS (finite unifica-
tion set) [2]. FUS is the class ensuring that conjunctive queries
always rewrite: for each ğœ™ one can compute a query ğœ™ T , being a
union of conjunctive queries, such that for each D we have that
ğ¶â„(D, T ) |= ğœ™ exactly if D |= ğœ™ T â€” this is known to be equivalent
to the existence of an arbitrary first-order rewriting [4].

Behold the extreme usefulness of this property: instead of query-
ing ğ¶â„(D, T ), an elusive infinite structure, we can equivalently
query D, the only structure we have immediate access to.

No wonder the BDD/FUS property has been considered in liter-
ally hundreds of papers. Numerous classes of BDD theories have
been identified and intensively studied, among them subclasses
with decidable membership like:
â€¢ linear theories, where rules have at most one body atom;
â€¢ guarded BDD theories (while not all guarded theories are BDD, it
is decidable to determine if a guarded theory is BDD [5, 6]), gener-
alizing linear theories;
â€¢ sticky theories, defined by a reasonably natural syntactic restric-
tion on the use of joins [7].

Apart from the decidable subclasses of BDD, there are also natu-

ral undecidable subclasses:
â€¢ bounded Datalog theories, already studied decades before the
class BDD itself was discovered [8];
â€¢ binary BDD theories, where the arity of relation symbols is at
most 2 (also studied in the context of description logics [9]);
â€¢ backward shy theories [10], a superclass of sticky theories.

As we expose in this paper, despite this extensive body of work,
we still understand very little about the deeper mathematical prop-
erties of BDD theories. In particular, we are going to show that the
intuition of BDD theories as being â€œlocalâ€, â€œonly depending on the
small pieces of Dâ€, and â€œunable to look too farâ€ while (more or less)
correct for all aforementioned classes of BDD theories is blatantly
incorrect for BDD theories in general.

The FUS/FES conjecture. There is a striking similarity between
formulas (BDD) and (FES), inspiring a natural conjecture, which
we call the FUS/FES conjecture: For any BDD theory that is also FES,
it should be possible to choose the number ğ‘– in a uniform way,
independently from both D and ğœ™. In other words, the conjecture
says that if T is both BDD and FES then:

âˆƒğ‘– âˆˆ N âˆ€ğœ™ âˆ€D (cid:0)ğ¶â„(D, T ) |= ğœ™ â‡” ğ¶â„ğ‘– (D, T ) |= ğœ™ (cid:1)

(UBDD)

This conjecture was studied earlier [11] and a proof was proposed,
which however turned out to be incorrect and was later withdrawn.

Later, it was shown that the conjecture would hold if the assumption
that T is FES were replaced by a stronger property [12].

Main results. We identify the new, generic class of local BDD
theories. Informally, such theories enforce that the creation of every
chase atom depends only on a constant number of facts from the
database. Importantly, this new class not only includes most of the
aforementioned subclasses of BDD (with sticky and backward shy
being notable exceptions) but also all BDD theories over signatures
with a maximum predicate arity of 2.

With this new class of theories defined (and the above inclusions
proved), we present our three main results: First that the FUS/FES
conjecture holds for local theories (Theorem 2). Second that the
conjecture holds for every BDD theory over a binary signature
(Corollary 1) â€“ an immediate consequence of the fact that such
theories are local (Theorem 1).

Yet, as least as interesting as these insights we find our third
result (reflected in Theorem 3): the discovery of very much non-
local (and not even what we call bounded-degree local) theories that
are still BDD. Such theories not only defy many of the popular
intuitions about the BDD class, but also shows that all previous
investigations into that class have probably barely scratched its
surface and that there is a lot of room for new decidable/syntactic
classes of BDD theories, richer than all hitherto considered. One
plausible reason why this new world exhibits counterintuitive phe-
nomena and has gone entirely unnoticed is that it requires theories
of arity higher than 2. Binary theories are much easier to imagine
and they are mainly responsible for shaping our intuitions.

Summarizing, the main message of this paper is: even if a
(finite) counterexample to the FUS/FES conjecture should exist, it
is going to be found nowhere near the familiar avenues of the BDD
class. But we also show that the known avenues only reach a small
part of the BDD class and there is a lot of uncharted territory left.
Organisation of this paper. Apart from its preliminary sections
(Sections 2â€“7), the paper is organized as follows:

In Section 8 we define local theories. Later we state our first

result Theorem 1 and present a brief insight into its proof.

In Section 9 we state our second result â€“ that the FUS/FES con-
jecture holds for local theories (Theorem 2) â€“ and prove it. Also we
note that the conjecture holds for theories over binary signatures
(Corollary 1).

In Section 10, we notice that sticky theories, while BDD, are not
always local. We define another, weaker, notion, of bounded-degree-
local theories (or bd-local) and note that it covers sticky. Later we
discuss properties of this newly defined class.

In Section 11 we examine the intuition that â€œBDD theories are
unable to look too farâ€. We define the notion of distancing theories,
and show that if a theory is local then it is also distancing. We also
notice that backward shy theories are distancing, so that most of the
previously known examples of BDD theories are indeed distancing.
We show however, that there exists a BDD theory Tğ‘‘ that is not
distancing. As a corollary we get that, for this BDD theory, the
rewriting ğœ™ Tğ‘‘
(which is a disjunction of conjunctive queries) of a
query ğœ™ can require disjuncts of exponential size with respect to the
size of ğœ™. This is in stark contrast to any BDD theories previously
considered.

Finally in Section 12, we conclude and discuss future work.

Piotr Ostropolski-Nalewaja, Jerzy Marcinkowski, David Carral, and Sebastian Rudolph

This is an extended technical report of an article with the same
title published at PODS 2022. It includes the complete formal proofs
for all results in the appendix.

2 PRELIMINARIES
Queries and TGDs. A conjunctive query (CQ) is a formula ğœ“ ( Â¯ğ‘¦) =
âˆƒ Â¯ğ‘¥ ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦) with ğ›½ being a non-empty conjunction of atomic for-
mulas over some signature (or schema) Î£ (which is a finite set of
relation symbols) and over some set of variables and set of constants.
So, for example âˆƒğ‘¥ ğ‘†ğ‘–ğ‘ğ‘™ğ‘–ğ‘›ğ‘”ğ‘  (ğ´ğ‘ğ‘’ğ‘™, ğ‘¥), ğ¹ğ‘’ğ‘šğ‘ğ‘™ğ‘’ (ğ‘¥) is a CQ.

A boolean CQ (short: BCQ) is a CQ with all variables quantified
(as in the preceding example). We refer to ğ›½ as the body of ğœ“ ( Â¯ğ‘¦).
By a union of conjunctive queries (UCQ) we mean a formula being a
disjunction of CQs. By the size of a CQ, denoted |ğœ“ ( Â¯ğ‘¦)|, we mean the
number of atomic formulas it is built of. By the width of a UCQ we
will mean the size of its greatest disjunct. Also, we will sometimes
treat UCQs as sets of CQs.

A theory or a rule set is a finite set of tuple generating dependencies
(TGDs, often just referred to as rules). A rule is a first-order logic
formula of the form âˆ€Â¯ğ‘¥, Â¯ğ‘¦ (cid:0)ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦) â‡’ âˆƒ Â¯ğ‘¤ ğ›¼ ( Â¯ğ‘¦, Â¯ğ‘¤)(cid:1), where Â¯ğ‘¥, Â¯ğ‘¦ and
Â¯ğ‘¤ are pairwise disjoint lists of variables, ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦) (the ruleâ€™s body) is
a conjunction of atomic formulas and ğ›¼ ( Â¯ğ‘¦, Â¯ğ‘¤) (the ruleâ€™s head) is
an atomic formula. The frontier Â¯ğ‘¦ of a rule ğœŒ, denoted fr (ğœŒ), is the
set of all variables that occur both in the body and the head of the
rule. We omit universal quantifiers when writing rules and treat
conjunctions of atoms (such as ğ›½) as sets of atoms.

Note that, in database theory terminology, our rules are â€œsingle
headâ€ TGDs. This is the only reasonable choice in this context,
since we want to talk about theories over a binary signature: if
we allowed rule heads to comprise several atoms, then rules with
predicates of any arity could be easily simulated using only arity
2 predicates. On the other hand, this does not restrict our results
in the cases where we do not assume that the signature is binary,
since every multi-head theory can be rewritten into a single-head
one, using higher-arity auxiliary predicates, and this rewriting does
not affect the property of being FUS or FES.
Structures and entailment. A database instance (or structure or
fact set) is a set of facts â€“ atomic formulas over Î£. For a structure F
over Î£ we let ğ‘‘ğ‘œğ‘š(F) denote its active domain â€“ the set of all terms
that appear in the facts of F. For ğ‘, ğ‘ â€² âˆˆ ğ‘‘ğ‘œğ‘š(F), we let ğ‘‘ğ‘–ğ‘ ğ‘¡F (ğ‘, ğ‘ â€²)
denote the distance between ğ‘ and ğ‘ â€² in the Gaifman graph of F:
the vertices of this graph are elements of ğ‘‘ğ‘œğ‘š(F) and two vertices
are connected by an edge if and only if they appear in the same
fact. We define the degree of F as the degree of Fâ€™s Gaifman graph.
F is a model of T (written: F |= T ) if F satisfies all TGDs from
T . For a pair T , D, a CQ ğœ™ ( Â¯ğ‘¦), and a tuple Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘¦ |, we
write T , D |= ğœ™ ( Â¯ğ‘) (or T , D, Â¯ğ‘ |= ğœ™ ( Â¯ğ‘¦)) to indicate that T and D
jointly entail ğœ™ ( Â¯ğ‘), which means that ğœ™ ( Â¯ğ‘) holds in each structure F
satisfying F |= T , D, which serves as a shortcut for F |= T âˆ§ D âŠ† F.
Example 1. Consider the instance Dğ‘ = {ğ»ğ‘¢ğ‘šğ‘ğ‘›(ğ´ğ‘ğ‘’ğ‘™)} and the

theory Tğ‘ consisting of the following two rules:

ğ»ğ‘¢ğ‘šğ‘ğ‘›(ğ‘¦) â‡’ âˆƒğ‘§ ğ‘€ğ‘œğ‘¡â„ğ‘’ğ‘Ÿ (ğ‘¦, ğ‘§)

ğ‘€ğ‘œğ‘¡â„ğ‘’ğ‘Ÿ (ğ‘¥, ğ‘¦) â‡’ ğ»ğ‘¢ğ‘šğ‘ğ‘›(ğ‘¦)

Then Tğ‘, Dğ‘ |= âˆƒğ‘¦, ğ‘§ ğ‘€ğ‘œğ‘¡â„ğ‘’ğ‘Ÿ (ğ´ğ‘ğ‘’ğ‘™, ğ‘¦), ğ‘€ğ‘œğ‘¡â„ğ‘’ğ‘Ÿ (ğ‘¦, ğ‘§).
Homomorphisms and query containment. For structures D, F,
a homomorphism from D to F is a function â„ : ğ‘‘ğ‘œğ‘š(D) â†’ ğ‘‘ğ‘œğ‘š(F)

A Journey to the Frontiers of Query Rewritability
(Extended Technical Report)

such that ğ´(â„( (cid:174)ğ‘¥)) âˆˆ F for each fact ğ´( (cid:174)ğ‘¥) âˆˆ D and that â„(ğ‘) = ğ‘ for
any constant ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D). Given a fact ğ›¼ = ğ´( (cid:174)ğ‘¥) âˆˆ D, we will use
â„(ğ›¼) to denote ğ´(â„( (cid:174)ğ‘¥)).

For two CQs ğœ™ ( Â¯ğ‘¦) and ğœ“ ( Â¯ğ‘¦), with the same set of free variables,
we say that ğœ™ ( Â¯ğ‘¦) contains ğœ“ ( Â¯ğ‘¦) if for every structure D and for
every tuple Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘¦ | if D |= ğœ“ ( Â¯ğ‘) than also D |= ğœ™ ( Â¯ğ‘). It
is well known that ğœ™ ( Â¯ğ‘¦) contains ğœ“ ( Â¯ğ‘¦) if and only if there is a
homomorphism1 from ğœ™ ( Â¯ğ‘¦) to ğœ“ ( Â¯ğ‘¦) that is the identity on Â¯ğ‘¦.
Core of a structure. A substructure H of a finite structure G is
a core of G (see [13]) if there exists a homomorphism â„ : G â†’ H
but there is no homomorphism from G to Hâ€² where Hâ€² is a proper
substructure of H. Note that the definition of homomorphisms
ensures that â„(ğ‘) = ğ‘ for every constant ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(G).

It is well known that [13]:

(1) Every finite structure has a core.
(2) Cores of a finite structure are unique up to isomorphism.
(3) If H is a core (of any structure) then it is a core of itself.

Given a (finite) structure G, we let ğ¶ğ‘œğ‘Ÿğ‘’ (G) denote a function

that returns some induced substructure of G that is a core.
Connected queries, rules and theories. For a CQ, one can define
its Gaifman graph in the natural way: Variables are the vertices of
this graph and two variables are connected by an edge if and only if
they both appear in the same atomic formula. A conjunctive query
is connected if its Gaifman graph is connected. A TGD is connected
if its body is. A theory is connected if each of its rules is.

All the theories we consider in this paper are connected
with the important exception of theories over a binary signature.
Forcing theories to be connected will help us to better express
the nuances of the BDD class in Sections 10â€“11. This assumption
does not reduce the expressive power of such theories due to the
following trivial trick: add a fresh variable as an additional, first
variable in all the atoms appearing in the rules of the theory. This
will make the theory connected, and it will obviously preserve its
BDD and FES status. But it will increase the arity â€“ so if we care
about the arity we do not get connectivity for free.

Note that after applying the trivial trick to an instance F the
distance between each ğ‘ and ğ‘ â€² from ğ‘‘ğ‘œğ‘š(F) will be at most 2. Also,
applying this trick turns any instance with a Gaifman graph of a
low (bounded) degree into one with a high degree Gaifman graph.

3 THE SKOLEM CHASE.
The chase procedure is a standard algorithm, studied in a plethora
of papers. It can be used to semi-decide whether T , D |= ğœ™ ( Â¯ğ‘) for
given theory T , instance D, CQ ğœ™ ( Â¯ğ‘¦) and tuple Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘¦ |. In
fact the algorithm comes in many variants and flavors. The best way
to present our results is by using a variant of the the semi-oblivious
Skolem chase, which we define in this section.

We say that two CQs have the same isomorphism type when one
can be obtained from the other by means of bijective renaming of
variables. For a CQ Î¦ define ğœ (Î¦) as the isomorphism type of Î¦.

For each possible isomorphism type ğœ = ğœ (ğœ™ ( Â¯ğ‘¦)) of some atomic
conjunctive query ğœ™ ( Â¯ğ‘¦), and for each natural number 1 â‰¤ ğ‘– â‰¤
ğ‘ğ‘Ÿğ‘–ğ‘¡ğ‘¦ (ğ¸), where ğ¸ is the relation symbol of ğœ™ ( Â¯ğ‘¦), let ğ‘“ ğœ
ğ‘– be a function

1The queries ğœ™ ( Â¯ğ‘¦) and ğœ“ ( Â¯ğ‘¦) are seen as structures here: the active domains of these
structures are the sets of variables of ğœ™ ( Â¯ğ‘¦) and ğœ“ ( Â¯ğ‘¦).

symbol, with arity equal to | Â¯ğ‘¦|, that is the number of free variables
in ğœ™ ( Â¯ğ‘¦).

Definition 2 (Skolemization). For a given TGD ğœŒ, of the form
ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦) â‡’ âˆƒ Â¯ğ‘¤ ğ›¼ ( Â¯ğ‘¥, Â¯ğ‘¤) by sh(ğœŒ) we denote the Skolemization of
the head of ğœŒ, that is the atom ğ›¼ ( Â¯ğ‘¥, Â¯ğ‘¤), with each variable ğ‘¤ âˆˆ Â¯ğ‘¤
replaced by the term ğ‘“ ğœ
ğ‘– ( Â¯ğ‘¥), where ğ‘– is the earliest position in ğ›¼ ( Â¯ğ‘¥, Â¯ğ‘¤)
where the variable ğ‘¤ occurs.

Let, for example ğœŒ be ğ¸ (ğ‘¥, ğ‘¦, ğ‘§), ğ‘ƒ (ğ‘¥) â‡’ âˆƒğ‘£ ğ‘…(ğ‘¦, ğ‘£, ğ‘§, ğ‘£). Then sh(ğœŒ)
will be the atom ğ‘…(ğ‘¦, ğ‘“ ğœ
2 (ğ‘¦, ğ‘§)) where ğœ is the isomor-
phism type of âˆƒğ‘£ ğ‘…(ğ‘¦, ğ‘£, ğ‘§, ğ‘£). Notice that sh(ğœŒ) does not depend on
the body of ğœŒ, only on its head. In particular it does not depend on
the non-frontier variables2 of the body of ğœŒ.

2 (ğ‘¦, ğ‘§), ğ‘§, ğ‘“ ğœ

Now we can define the procedure of rule application. Parameters
of this procedure are an instance F, a rule ğœŒ, and a mapping ğœ
assigning elements of the active domain of F to the variables that
occur in the body of ğœŒ:

Definition 3 (Rule application). Let ğœŒ be a rule of the form

ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦) â‡’ âˆƒ Â¯ğ‘¤ ğ›¼ ( Â¯ğ‘¦, Â¯ğ‘¤), and let F be a fact set.

â€¢ Define Hğ‘œğ‘š(ğœŒ, F) as the set of all mappings ğœ from variables
in Â¯ğ‘¥ âˆª Â¯ğ‘¦ to ğ‘‘ğ‘œğ‘š(F) such that ğœ (ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦)) âŠ† F (which means
that all the atoms from ğ›½ are in F after we apply ğœ to them).

â€¢ For ğœ âˆˆ Hğ‘œğ‘š(ğœŒ, F), define ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ) = ğœ (sh(ğœŒ)).

With these notions in place, we can now define the chase proce-
dure as a whole. Given an instance D and a theory T , it produces a
sequence (Chğ‘– (T , D))ğ‘– âˆˆN of instances and the structure Ch(T , D),
according to the following definition.

Definition 4 (Semi-oblivious Skolem chase procedure).

â€¢ Ch0 (T , D) = D,
â€¢ Chğ‘–+1 (T , D) = Chğ‘– (T , D) âˆª

â€¢

Ch(T , D) = (cid:208)ğ‘– âˆˆN Chğ‘– (T , D).

{ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ) | ğœŒ âˆˆ T , ğœ âˆˆ Hğ‘œğ‘š(ğœŒ, Chğ‘– (T , D))},

It is well known that Ch(T , D) is a universal model for T and D
(i.e., a model that can be homomorphically mapped into any other
model). Thus, this structure can be used to solve CQ entailment: for
any theory T , CQ ğœ™ ( Â¯ğ‘¦), instance D and Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘¦ |, we have:
ğ¶â„(T , D) |= ğœ™ ( Â¯ğ‘) â‡” D, T |= ğœ™ ( Â¯ğ‘)

Example 5. Let Tğ‘ and Dğ‘ be as in Example 1, then

â€¢ Ch0 (Tğ‘, Dğ‘) = Dğ‘ = {ğ»ğ‘¢ğ‘šğ‘ğ‘›(ğ´ğ‘ğ‘’ğ‘™)},
â€¢ Ch1 (Tğ‘, Dğ‘) = Ch0 (Tğ‘, Dğ‘) âˆª {ğ‘€ğ‘œğ‘¡â„ğ‘’ğ‘Ÿ (ğ´ğ‘ğ‘’ğ‘™, ğ‘šğ‘¢ğ‘š(ğ´ğ‘ğ‘’ğ‘™))},
â€¢ Ch2 (Tğ‘, Dğ‘) = Ch1 (Tğ‘, Dğ‘) âˆª

{ğ‘€ğ‘œğ‘¡â„ğ‘’ğ‘Ÿ (ğ‘šğ‘¢ğ‘š(ğ´ğ‘ğ‘’ğ‘™), ğ‘šğ‘¢ğ‘š(ğ‘šğ‘¢ğ‘š(ğ´ğ‘ğ‘’ğ‘™)))},
and so on (we use the function symbol â€œmumâ€ as an alias for the ugly
Skolem function symbol from Definition 2).

Now note that there is nothing in Definition 4 that could prevent
us from taking D = Ch2 (Tğ‘, Dğ‘) and running the chase for such D.
It is easy to see that in that case we obtain Ch(Tğ‘, D) = Ch(Tğ‘, Dğ‘).
This leads to the following easy insight:

Observation 6. If D âŠ† F âŠ† Ch(T, D) then Ch(T, F) = Ch(T, D).

2Including non-frontier variables as arguments of the functions ğ‘“ ğœ
(like ğ‘¥ in the
ğ‘–
current example) would lead to the oblivious chase. Also note that the names of the
terms do not identify ğœŒ (their â€œrule of originâ€). This is going to be important in the
proof of Theorem 1.

Note that that equality in Observation 6 is to be understood
literally (rather than â€œup to isomorphismâ€). This is crucial for our
treatise and it constitutes the main reason why we use the Skolem
naming convention.

Finally, let us state another property of the chase â€“ a direct

consequence of the fact that Ch(T , D) is a universal model.

Property 7. Let T be a theory and let D and F be fact sets sat-
isfying D âŠ† F âŠ† Ch(T , D) as well as F |= T . Then there exists a
homomorphism from Ch(T , D) to F that is the identity on ğ‘‘ğ‘œğ‘š(F).

Frontier and birth atoms. Let ğ›¼ be an atom from ğ¶â„(T , D) \ D,
created as ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ) for some ğœŒ âˆˆ T and ğœ âˆˆ ğ»ğ‘œğ‘š(ğœŒ, D). We let
the frontier of ğ›¼ (written: fr (ğ›¼)) denote the set of terms ğœ (fr (ğœŒ)).
Notice that there may be more than one rule application creating
the same atom ğ›¼, but:

Observation 8. For every ğœŒ, ğœŒ â€² âˆˆ T and every ğœ âˆˆ ğ»ğ‘œğ‘š(ğœŒ, D)
if ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ) = ğ‘ğ‘ğ‘ğ‘™ (ğœŒ â€², ğœ â€²) then heads of ğœŒ and ğœŒ â€² when treated as
CQs have the same isomorphism type.

Clearly, for each ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(T , D)) either ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(D) or
ğ‘¡ was created by the chase procedure as a Skolem term. Notice
that, despite the name of the rule of T that created ğ‘¡ not being
indicated in the name of ğ‘¡ (as per our Skolem naming convention),
the following still holds:

Observation 9. Suppose ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(T , D)) \ ğ‘‘ğ‘œğ‘š(D). Then
there exists exactly one atom ğ›¼ âˆˆ ğ¶â„(T , D) such that ğ‘¡ appears in ğ›¼,
but ğ‘¡ âˆ‰ fr (ğ›¼).

We will refer to such an atom ğ›¼ as the birth atom of ğ‘¡.
For the proof of the last observation notice that one can uniquely
reconstruct ğ›¼ using only ğ‘¡. This is because ğ‘¡ contains both the
isomorphism type of ğ›¼ (so that one can reconstruct ğ›¼ up to bijective
renaming of its terms) and its frontier terms.

4 THE THREE CLASSES
For a theory T , an instance D, a natural number ğ‘› and a conjunctive
query ğœ™ (ğ‘¦) we will write ğ¸ğ‘›ğ‘œğ‘¢ğ‘”â„(ğ‘›, ğœ™ (ğ‘¦), D, T ) as a shorthand for:

âˆ€Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘¦ |
Meaning that â€œit is enough to run ğ‘› steps of the T -chase on D to
fully evaluate ğœ™â€.

(cid:0) ğ¶â„(T , D) |= ğœ™ ( Â¯ğ‘) â‡” ğ¶â„ğ‘› (T , D) |= ğœ™ ( Â¯ğ‘) (cid:1).

Now we will provide definitions for three separate classes: BDD,

FES, and UBDD [2, 14].

Definition 10 (BDD). A theory T has the bounded derivation

depth property if:

âˆ€Î¦ âˆƒğ‘›Î¦ âˆ€D ğ¸ğ‘›ğ‘œğ‘¢ğ‘”â„(ğ‘›Î¦, Î¦, D, T )

Definition 11 (FES). A theory T has the finite expansion set

property if:

âˆ€D âˆƒğ‘›D âˆ€Î¦ ğ¸ğ‘›ğ‘œğ‘¢ğ‘”â„(ğ‘›D, Î¦, D, T )

Definition 12 (UBDD). Theory T is uniformly BDD if:

âˆƒğ‘ T âˆ€D âˆ€Î¦ ğ¸ğ‘›ğ‘œğ‘¢ğ‘”â„(ğ‘ T, Î¦, D, T )
Notice the striking similarity between the above expressions.
Connections between those classes will be discussed later in Sec-
tion 7, but before we need to explore BDD and FES in greater detail.

Piotr Ostropolski-Nalewaja, Jerzy Marcinkowski, David Carral, and Sebastian Rudolph

5 BDD AND FINITE UNIFICATION SETS
As with many important notions, it happens that the same concept
is defined by multiple communities using different properties. This
is exactly the case with finite unification set property [2] and BDD.

Definition 13 (FUS). A theory T has the finite unification set
property if every conjunctive query ğœ“ ( Â¯ğ‘¦) has a rewriting â€” a UCQ,
denoted ğœ“ rew ( Â¯ğ‘¦), such that the following holds:
For each instance D and each tuple Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘¦ | we have

ğ¶â„(T , D), Â¯ğ‘ |= ğœ“ ( Â¯ğ‘¦) â‡â‡’ D, Â¯ğ‘ |= ğ‘Ÿğ‘’ğ‘¤ (ğœ“ ( Â¯ğ‘¦)).

It is well known that T is BDD if and only if it is FUS [3], so
we will use the two terms interchangeably. For simplicity of our
arguments and without loss of generality, we will require the set
ğ‘Ÿğ‘’ğ‘¤ (ğœ“ ( Â¯ğ‘¦)) to be minimal: If ğœ™ ( Â¯ğ‘¦) â‰  ğœ™ â€²( Â¯ğ‘¦) are two elements of
ğ‘Ÿğ‘’ğ‘¤ (ğœ“ ( Â¯ğ‘¦)) then ğœ™ ( Â¯ğ‘¦) is not contained in ğœ™ â€²( Â¯ğ‘¦).

The BDD/FUS class admits several interesting properties. The
following will be used later: facts about terms are produced by the
chase soon after the terms are created (with only a constant delay).

Observation 14. There exists a natural number ğ‘›ğ‘ğ‘¡ (depending
only on T ) such that for any instance D, for any ğ‘– âˆˆ N, for any
tuple Â¯ğ‘¡ of domain elements from ğ‘‘ğ‘œğ‘š(ğ¶â„ğ‘– (T , D)) and for any ğ‘… âˆˆ Î£,
ğ¶â„(T , D) |= ğ‘…(Â¯ğ‘¡) implies ğ¶â„ğ‘–+ğ‘›ğ‘ğ‘¡ (T , D) |= ğ‘…(Â¯ğ‘¡).

Proof (sketch). For any query ğœ™, let ğ‘›ğœ™ denote the constant
from Definition 10. Note, that there is only a finite number of
non-isomorphic atomic queries. Therefore, we can obtain ğ‘›ğ‘ğ‘¡ as
â–¡
max({ğ‘›ğœ™ | ğœ™ is an atomic query}).

The BDD property â€“ exercises. Now, we would like to encourage
the reader to solve a few exercises. While they are not part of the
actual proofs, we believe they might provide valuable insights.

Exercise 15. Consider the theory Tğ‘ over schema {ğ¸} consisting
of just one rule ğ¸ (ğ‘¥, ğ‘¦) â‡’ âˆƒğ‘§ ğ¸ (ğ‘¦, ğ‘§). Show that this theory is BDD.

Comment: This can be easily generalized: it is well known that all
linear theories are BDD [14] (a theory is linear if each rule only has
one atom in its body).

Exercise 16. Show that, if T is BDD and connected then there
exists some ğ‘‘ âˆˆ N such that for each D and for each two terms ğ‘, ğ‘ â€²
of ğ‘‘ğ‘œğ‘š(D), if ğ‘‘ğ‘–ğ‘ ğ‘¡ğ¶â„ ( T,D) (ğ‘, ğ‘ â€²) = 1 then ğ‘‘ğ‘–ğ‘ ğ‘¡D (ğ‘, ğ‘ â€²) â‰¤ ğ‘‘.
Comment: the didactic purpose of Exercise 16 is to evoke or reinforce
the intuition of BDD as a â€œlocalityâ€ property: if terms from ğ‘‘ğ‘œğ‘š(D)
appear in one atom somewhere in ğ¶â„(T , D) then they could not
possibly be far away from each other already in D.

6 FES AND CORE TERMINATION
FES theories always (regardless of the initial structure D) produce
all the positive information present in ğ¶â„(T , D) already after a
finite number of chase steps (this number can depend on D though).
This is, as well, the case with the core termination [1, 2]:

Definition 17. A theory T is core-terminating if for each fact

set D there exists a ğ‘˜ âˆˆ N such that for each ğ‘– â‰¥ ğ‘˜:

ğ¶ğ‘œğ‘Ÿğ‘’ (Chğ‘– (T , D)) is isomorphic to ğ¶ğ‘œğ‘Ÿğ‘’ (Chğ‘–+1 (T , D)).

A Journey to the Frontiers of Query Rewritability
(Extended Technical Report)

It is well known that T is core-terminating if and only if it is
FES [15], so we will use the two terms interchangeably. Moreover,
the smallest numbers ğ‘›D and ğ‘˜ satisfying Definitions 11 and 17
(respectively) are equal; from now on this number will be denoted
with ğ‘ T,D. It is also known [1] that ğ¶ğ‘œğ‘Ÿğ‘’ (Chğ‘T,D (T , D)) |= T , D.

Definition 18. Given a FES theory T and an instance D, we let

ğ¶ğ‘œğ‘Ÿğ‘’ (T , D) denote ğ¶ğ‘œğ‘Ÿğ‘’ (Chğ‘T,D (T , D)).

Exercises Also this section comes with a few exercises. Again, we
expect them to provide valuable insight, but they are not required
for our subsequent proofs.

Exercise 19. Show that the theory from Exercise 15 is not FES.

Exercise 20. Show that the theory consisting of two rules

ğ¸ (ğ‘¥, ğ‘¦) â‡’ âˆƒğ‘§ ğ¸ (ğ‘¦, ğ‘§) and ğ¸ (ğ‘¥, ğ‘¥ â€²) â‡’ ğ¸ (ğ‘¥, ğ‘¥) is FES.

7 THE FUS/FES CONJECTURE
It is very easy to produce examples of BDD theories that are not
UBDD (see Exercise 15). However, all examples we could produce
are not core-terminating. Likewise, it is easy to produce examples
of core-terminating theories that are not UBDD, but they are not
BDD either (all unbounded Datalog theories will be very happy to
serve as examples). This gives rise to the following conjecture.

Conjecture 1 (The FUS/FES conjecture). Any theory that is

both FUS and FES is also UBDD.

This conjecture was studied in [11] where an incorrect proof was
proposed, and in [12] where it was proved that it would hold true
if the assumption that T is FES was replaced by the significantly
stronger assumption that it is all-instances Skolem chase terminat-
ing. Note that the conjecture would be false if infinite theories, over
infinite (yet just binary) schemas were allowed:

Example 21. Suppose a relation symbol ğ¸ğ‘– for every ğ‘– âˆˆ N. Let the
theory Tâˆ consist of all rules of the form ğ¸ğ‘– (ğ‘¥, ğ‘¦) â‡’ âˆƒğ‘§ ğ¸ğ‘–âˆ’1 (ğ‘¦, ğ‘§)
for ğ‘– âˆˆ N+. Then Tâˆ is BDD and core-terminating, but it is not UBDD.
To see why this is the case, notice that only facts from a finite number
of relations can appear in every given finite instance.

8 LOCAL THEORIES.
We are now ready to introduce the central notion of local theories.
As it will turn out, not only the FUS/FES conjecture holds for these
(Theorem 2) but they also subsume all BDD theories over binary
signatures (Theorem 1). Notwithstanding, as we will argue near
the end of the paper, there exists an untapped potential within the
BDD class beyond the veils of locality (Theorem 3).

Proof (sketch). Given a local theory T and a CQ Î¦, we show
that there exists a natural number ğ‘›Î¦ satisfying Definition 10. Due
to T being local, we can, for every F with F |= Î¦, identify some
D âŠ† F with D |= Î¦ and |D| â‰¤ ğ‘™ T |Î¦|. Therefore, we let F =
{D | Ch(T , D) |= Î¦ âˆ§ |D| â‰¤ ğ‘™ T |Î¦|}. For any D âˆˆ F , define ğ‘›D as
the minimal natural number such that Chğ‘›D (T , D) |= Î¦. As F
contains just a finite number of non-isomorphic instances, picking
â–¡
ğ‘›Î¦ = max{ğ‘›D | D âˆˆ F } witnesses that Definition 10 applies.

We defer any further discussion about locality until later sections.

And now, let us state our first result.

Theorem 1. Every BDD theory over binary signature is local.

The detailed proof will be presented in Appendix A. Here, we
just outline the proof idea. We start by observing that the atoms
created in the chase by rules that contain existentially quantified
variables form a forest. This is a crucial property of single-head rule
sets over binary signatures as any such rule must have a frontier of
size â‰¤1. (Obviously, this property ceases to hold for signatures of
higher arities.) Essentially, as the chase progresses, the existential
atoms (those produced through â€œproperâ€ existential rules) are cre-
ated further and further away from the instance. If we were able
to bound the number of each such atomâ€™s ancestors â€” the atom
set required for its creation â€” then we could finish the proof by
slightly extending Observation 14. The forest shape, however, is not
immediately sufficient to bound the ancestors of its atoms. To over-
come this issue, we propose a normalization technique, that, given
a BDD theory T over binary signature, produces a new theory Tğ‘ ğ¹ ,
which might no longer be BDD but admits two important proper-
ties: First, the sets of existential atoms produced by T and by Tğ‘ ğ¹
on any instance coincide (Lemma 48). Second, it is straightforward
to find the mentioned bound on the number of ancestors for every
atom produced by Tğ‘ ğ¹ (Lemma 57). These two properties grant us
Theorem 1. But how does such a normalization work? In simple
words, it relies on the fact that T is BDD. In the absence of both
disconnected and Datalog rules, the normalization would be rather
simple: we could take any existential rule ğ›½ â‡’ ğ›¼ âˆˆ T and replace
it with rules ğ›¾ â‡’ ğ›¼ for all ğ›¾ âˆˆ ğ‘Ÿğ‘’ğ‘¤ (ğ›½). Dealing with disconnected
bodies and Datalog rules complicates matters somewhat.

We are very confident that our proof can be generalized to all
frontier-guarded BDD theories. As this is not yet spelled out in full
detail, we prefer to be cautious and formulate it as conjecture.

Conjecture 2. Every frontier-guarded BDD theory is local.

9 THE FUS/FES CONJECTURE IS TRUE FOR

LOCAL THEORIES

Definition 22. A theory T is local if there exists some number

We proceed by presenting the second of our three main results.

ğ‘™ T âˆˆ N such that for every instance D the following holds:

Ch(T , D) =

(cid:216)

FâŠ†D, |F| â‰¤ğ‘™T

Ch(T , F)

Note that the Skolem naming convention is important here. With-
out it, it would be unclear or at least ambiguous what a union of
Importantly, we obtain that locality
chases is supposed to mean.
implies the BDD property.

Theorem 2. If a theory T is FES and local then it is UBDD.

This means that the FUS/FES conjecture holds for local theories.
Before we start our proof, let us note that by Theorem 1 and The-
orem 2, we can immediately conclude that Conjecture 1 holds for
theories over binary signatures:

Corollary 1. If a theory T over a binary signature is both FES

Observation 23. If a theory is local then it is BDD.

and BDD then it is UBDD.

Also, Theorem 1 implies that any counterexample to the conjec-
ture â€“ should it exist â€“ would have to be outside the realm of local
classes. We explore this uncharted lands in Section 11.

Proof of Theorem 2
As any UBDD theory is core-terminating as well, it is easy to see
that a theory T is UBDD if and only if there exists some ğ‘ T âˆˆ N
such that ğ¶ğ‘œğ‘Ÿğ‘’ (T , D) âŠ† Chğ‘T (T , D) holds for any instance D. Note
that the numbers ğ‘ T here and in Definition 12 are equal. Thus we
can reformulate Theorem 2 as follows:

Theorem 2 (alternative). Let T be a core-terminating local the-
ory. Then there exists a ğ‘ T âˆˆ N such that ğ¶ğ‘œğ‘Ÿğ‘’ (T , D) âŠ† Chğ‘T (T , D)
holds for any instance D .

Until the end of this section, we will consider T a fixed theory
that is both core-terminating and local (so also BDD). To simplify
notation, Ch(T , D) will be shortened to Ch(D).

Definition 24. For an instance D define ID as the family of sets

{F | F âŠ† D, |F| â‰¤ ğ‘™ T }. Define CD = (cid:208)FâˆˆID

ğ¶ğ‘œğ‘Ÿğ‘’ (T , F).

Lemma 25. There exists a ğ‘˜ T âˆˆ N depending only on T (but not

on D), such that CD âŠ† Chğ‘˜T (D).
Proof. The set A = {F |

|F| â‰¤ ğ‘™ T } of all instances (over Î£)
of size at most ğ‘™ T is finite (up to isomorphisms). Recall that T is
â–¡
core-terminating and let ğ‘˜ T = max{ğ‘ T,D | D âˆˆ A}.

If we were able able to find a homomorphism Â¯â„D from ğ¶â„(D) to
CD, the alternative formulation of Theorem 2 would be proved. Also,
since T is core-terminating, we know that for each F âˆˆ ID there
exists a homomorphism â„F from ğ¶â„(F) to CD and we know that
ğ¶â„(F) = ğ¶â„(D). So canâ€™t we just define Â¯â„D = (cid:208)FâˆˆID
(cid:208)FâˆˆID
â„F?
Unfortunately not, because the domains of â„F and â„Fâ€² may overlap
(for some F â‰  Fâ€²) and there is no guarantee that â„F and â„Fâ€² will
agree on the terms that are in both domains. If Â¯â„D could be produced
this way, CD |= T would always hold. Yet, we found an example
(not included here) of a pair D, T for which CD Ì¸|= T .

Luckily, the idea to build a global homomorphism Â¯â„D using the
local homomorphisms â„F can be put to use in a different way, and
the set of facts CD will indeed prove very useful in this context.
The following lemma will be crucial in this endeavor:

Lemma 26. For any instance D there exists a homomorphism Â¯â„D
from ğ¶â„(D) to ğ¶â„(D) such that for each ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(D)) there is
Â¯â„D (ğ‘¡) âˆˆ ğ‘‘ğ‘œğ‘š(CD).
Let us first discuss how Theorem 2 can be concluded from Lemma 26.
Suppose some D is fixed and Â¯â„D is a homomorphism as in Lemma 26.
We know that ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(D)) implies Â¯â„D (ğ‘¡) âˆˆ ğ‘‘ğ‘œğ‘š(CD) and we
know that CD âŠ† ğ¶â„ğ‘˜T (D). So one might be tempted to immediately
conclude Â¯â„D (Ch(D)) âŠ† ğ¶â„ğ‘˜T (D). But it is not quite that simple.
Admittedly, Lemma 26 tells us that all the terms of Â¯â„D (Ch(D))
will indeed appear in ğ¶â„ğ‘˜T (D). But it says nothing like that about
the atoms of Â¯â„D (Ch(D)). Rather, it might be that there are atoms
in Â¯â„D (Ch(D)) that, despite having all their terms in ğ‘‘ğ‘œğ‘š(CD) are
not themselves in CD. To overcome this little problem, we recall
Observation 14 and let ğ‘ T = ğ‘˜ T +ğ‘›ğ‘ğ‘¡ . Then Â¯â„D (Ch(D)) âŠ† ğ¶â„ğ‘T (D)
follows as desired.

Piotr Ostropolski-Nalewaja, Jerzy Marcinkowski, David Carral, and Sebastian Rudolph

This means what remains to be presented in this section is the

proof of Lemma 26:

Definition 27. Let D be a set of facts and let F âŠ† D. We let
ğ‘€F denote3 the substructure of Ch(D) induced by the set of terms
ğ‘‘ğ‘œğ‘š(Ch(D)) \ (cid:0)ğ‘‘ğ‘œğ‘š(Ch(F)) \ ğ‘‘ğ‘œğ‘š(ğ¶ğ‘œğ‘Ÿğ‘’ (T , F)) (cid:1).

In the following, the terms of ğ‘‘ğ‘œğ‘š(Ch(F)) \ ğ‘‘ğ‘œğ‘š(ğ¶ğ‘œğ‘Ÿğ‘’ (T , F)

will be referred to as banned terms.

Lemma 28. For any instance D and for any F âŠ† D, the structure

ğ‘€F is a model of T and D.

Proof. Clearly ğ‘€F |= D. In order to prove ğ‘€F |= T , consider any
ğœŒ âˆˆ T and any ğœ âˆˆ Hğ‘œğ‘š(ğœŒ, ğ‘€F). Of course, ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ) âˆˆ Ch(D),
since Ch(D) is by definition closed under rule applications.

In the following, the atom ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ) will be mentioned often

enough to deserve a shorter name, so we will call it ğ›¼.

It is now sufficient (and necessary) to prove that there exists a
homomorphism from ğ›¼ to some atom ğ›¼ â€² âˆˆ ğ‘€F, that is the identity
on fr (ğ›¼). In other words, we need to show that if the body of the
rule ğœŒ matches ğ‘€F (via mapping ğœ), then we can find an atom in
ğ‘€F that witnesses satisfaction of ğœŒ. Such an ğ›¼ â€² needs to have the
same terms as ğ›¼ in the frontier positions and may have arbitrary
terms in the positions of the existentially quantified variables in
â„ğ‘’ğ‘ğ‘‘ (ğœŒ), except that if ğ›¼ had equal terms on two such positions
then the respective terms in ğ›¼ â€² must also be equal.

If ğ›¼ âˆˆ ğ‘€F then of course we pick ğ›¼ â€² = ğ›¼. So, for the rest of the
proof, assume ğ›¼ âˆ‰ ğ‘€F. Note that the only reason for ğ›¼ to be in
Ch(D) but not in ğ‘€F is that ğ›¼ contains some banned term ğ‘¡.

But ğœ (ğ‘ğ‘œğ‘‘ğ‘¦ (ğœŒ)) âŠ† ğ‘€F. Thus fr (ğ›¼) âŠ† ğ‘‘ğ‘œğ‘š(ğ‘€F) and so ğ‘¡ âˆ‰ fr (ğ›¼).
At this point, we can be sure that ğœŒ is not a Datalog rule â€“ atoms
derived via a Datalog rule do not have non-frontier terms.

Term ğ‘¡ being a non-frontier term of ğ›¼ means that ğ›¼ is the birth
atom of ğ‘¡ in Ch(D). But ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(Ch(F)) so from Observation 9, we
know that ğ›¼ is the birth atom of ğ‘¡ in Ch(F) and thus ğ›¼ âˆˆ Ch(F).

Note that fr (ğ›¼) âŠ† ğ‘‘ğ‘œğ‘š(ğ¶ğ‘œğ‘Ÿğ‘’ (T , F)) (âˆ—), as fr (ğ›¼) âŠ† ğ‘‘ğ‘œğ‘š(Ch(F))

and none of the terms in fr (ğ›¼) are banned.

Now let â„âˆ—

F (ğ›¼) âˆˆ ğ‘€F. As â„âˆ—

Property 7. Since ğ›¼ âˆˆ Ch(F), we obtain â„âˆ—
thus â„âˆ—
F is a retraction, â„âˆ—
from (âˆ—). Hence, â„âˆ—

F : Ch(F) â†’ ğ¶ğ‘œğ‘Ÿğ‘’ (T , F) be a homomorphism as in
F (ğ›¼) âˆˆ ğ¶ğ‘œğ‘Ÿğ‘’ (T , F) and
F (fr (ğ›¼)) = fr (ğ›¼) follows
F (ğ›¼) can serve as our ğ›¼ â€², concluding the proof. â–¡
Lemma 29. For any instance D and any F âŠ† D there exists a
from Ch(D) to itself that maps all terms to

homomorphism â„âˆ—
ğ‘‘ğ‘œğ‘š(ğ‘€F) and is the identity on ğ‘‘ğ‘œğ‘š(ğ‘€F).

ğ‘€F

Proof. Note that ğ‘€F |= T (Lemma 28) and D âŠ† ğ‘€F. Then
Property 7 ensures the existence of the claimed homomorphism. â–¡

ğ‘€F

ğ‘€F

for F âˆˆ ID.

Let HD be the set of all homomorphisms â„âˆ—
Each â„âˆ—

âˆˆ HD has as its domain the set ğ‘‘ğ‘œğ‘š(Ch(ğ‘€F)), that is
equal to ğ‘‘ğ‘œğ‘š(Ch(D)), and has as its image a subset of this domain.
This means that one can compose such homomorphisms, and the
resulting function will also be a homomorphism from Ch(D) to
Ch(D) (and it will be the identity on ğ‘‘ğ‘œğ‘š(D), since each â„ğ‘€F is).
Now the rabbit is going to be pulled out of the hat: let us compose

3To be precise we should call this new structure ğ‘€D,F, but D will be fixed and clear
from the context.

A Journey to the Frontiers of Query Rewritability
(Extended Technical Report)

all homomorphisms â„ğ‘€F âˆˆ HD, in any order. Call the resulting
(â€œglobalâ€) homomorphism Â¯â„D.

Now recall that the proof of Lemma 26 (and thus also of Theo-
rem 2) will be finished once we can show that Â¯â„D (ğ‘¡) âˆˆ ğ‘‘ğ‘œğ‘š(CD)
does indeed hold for each term ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(D)).

Recall our notion of banned terms. Now F is no longer fixed, i.e.,
for each F âˆˆ ID there is a set ğ‘ğ‘ğ‘›F of terms that occur somewhere
in Ch(F) but not in ğ¶ğ‘œğ‘Ÿğ‘’ (T , F). Each â„âˆ—
âˆˆ HD is the identity on
all terms except those of ğ‘ğ‘ğ‘›F, and maps the terms from ğ‘ğ‘ğ‘›F into
ğ‘‘ğ‘œğ‘š(ğ¶ğ‘œğ‘Ÿğ‘’ (T , F)), which means into ğ‘‘ğ‘œğ‘š(CD).

Now suppose we apply Â¯â„D to any ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(D)). If there is
(ğ‘¡) â‰  ğ‘¡ then of course Â¯â„D (ğ‘¡) âˆˆ ğ‘‘ğ‘œğ‘š(CD).
, consider any Fğ‘¡ âˆˆ ID for which

any â„âˆ—
In case â„âˆ—
ğ‘€F
ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(Fğ‘¡ )). Then ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶ğ‘œğ‘Ÿğ‘’ (T , Fğ‘¡ )) âŠ† ğ‘‘ğ‘œğ‘š(CD).

(ğ‘¡) = ğ‘¡ for each â„âˆ—

âˆˆ HD with â„âˆ—

ğ‘€F

ğ‘€F

ğ‘€F

ğ‘€F

10 SLIGHTLY BEYOND LOCALITY: STICKY

THEORIES

Unfortunately, our notion of locality fails to characterize the entire
BDD class, as demonstrated in the following example.

Example 30. Let ğ¸ be a relation of arity 4 and ğ‘… one of arity 2.
Read ğ¸ (ğ‘, ğ‘, ğ‘ â€², ğ‘) as â€œğ‘ sees an edge from ğ‘ to ğ‘ â€² colored with color ğ‘â€
and ğ‘…(ğ‘, ğ‘) as â€œğ‘ considers ğ‘ a colorâ€. The following one-rule sticky
theory T is not local:

ğ¸ (ğ‘¥, ğ‘¦, ğ‘¦ â€², ğ‘¡), ğ‘…(ğ‘¥, ğ‘¡ â€²) â‡’ âˆƒğ‘¦ â€²â€² ğ¸ (ğ‘¥, ğ‘¦ â€², ğ‘¦ â€²â€², ğ‘¡ â€²)
(meaning â€œif ğ‘¥ sees an edge from ğ‘¦ to ğ‘¦ â€² and considers ğ‘¡ â€² a color, then
ğ‘¥ must also see another edge from ğ‘¦ â€² to some ğ‘¦ â€²â€² of color ğ‘¡ â€²â€).

To see that it is indeed not local, suppose it were and let ğ‘™ T be the
corresponding constant as in Definition 22. Now take an instance D
consisting of ğ‘™ T +1 atoms: one atom ğ¸ (ğ‘, ğ‘1, ğ‘2, ğ‘1) and atoms ğ‘…(ğ‘, ğ‘ğ‘– )
for 1 â‰¤ ğ‘– â‰¤ ğ‘™ T . It is not hard to see that there are atoms in ğ¶â„(T , D)
that require all the atoms from D to be produced.

The only reason, however, for connected sticky theories to be
non-local are high-degree vertices, like the ğ‘ in the example. This
leads to a natural generalization of the notion of locality:

Definition 31. A theory T will be called bounded-degree local
(or bd-local) if for any ğ‘˜ âˆˆ N there exists a constant ğ‘™ T (ğ‘˜) such that
for every instance D having degree at most ğ‘˜, the following holds:

(cid:216)

Ch(T , F) = Ch(T , D)

FâŠ†D, |F | â‰¤ğ‘™T (ğ‘˜)

As of yet, we have been unable to show that the FUS/FES conjecture
holds for bounded-degree local theories, but we believe that with
some additional effort, the ideas from Section 9 could probably be
adapted to work also for such theories. And of course they do work
if only instances of fixed degree are considered.

It is not hard to show that sticky theories are indeed bd-local (cf.
Appendix E). Hence, in view of Conjecture 2, it seems that most
known decidable BDD classes are bounded-degree local. Perhaps
surprisingly, unlike local theories, not all bounded-degree local
theories are BDD:

Example 32. It is easy to see that the following single-rule theory

is bounded-degree local but not BDD: ğ¸ (ğ‘¥, ğ‘¦, ğ‘§), ğ‘…(ğ‘¥, ğ‘§) â‡’ ğ‘…(ğ‘¦, ğ‘§).

natural question arises: are there BDD theories that are not local in
this generalized sense? We found it quite surprising to realize that
the answer is positive:

Example 33. The following BDD theory Tğ‘ is not bd-local:

ğ¸ (ğ‘¥, ğ‘¦) â‡’ âˆƒğ‘¥ â€², ğ‘¦ â€² ğ‘…(ğ‘¥, ğ‘¦, ğ‘¥ â€², ğ‘¦ â€²)

ğ‘…(ğ‘¥, ğ‘¦, ğ‘¥ â€², ğ‘¦ â€²), ğ¸ (ğ‘¦, ğ‘§) â‡’ âˆƒğ‘§ â€² ğ‘…(ğ‘¦, ğ‘§, ğ‘¦ â€², ğ‘§ â€²)

To prove that it is BDD one can notice that if Tğ‘, D |= ğœ™ ( Â¯ğ‘), for some D
and some Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘ | then ğ¶â„ |ğœ™ ( Â¯ğ‘¦) |
|= ğœ™ ( Â¯ğ‘). In order to prove that
it is not bd-local consider, for each ğ‘› âˆˆ N, the instance Dğ‘› consisting
of atoms ğ¸ (ğ‘1, ğ‘2), ğ¸ (ğ‘2, ğ‘3) . . ., ğ¸ (ğ‘ğ‘›, ğ‘1). The degree of this instance
is 2. And there are atoms in ğ¶â„ğ‘› (Tğ‘, Dğ‘›) that are not in ğ¶â„ğ‘› (Tğ‘, F)
for any proper subset F of Dğ‘›.

We were, however, not able to find an example of a theory that
would be hereditary BDD â€” a BDD theory such that every its sub-
sets is BDD as well â€” but not bd-local. We think it reasonable to
conjecture that there are no such theories.

11 FAR BEYOND LOCALITY: BDD THEORIES

WITHOUT SMALL REWRITINGS

As we know, any local theory is also BDD. Additionally, local theo-
ries admit rewritings of linear width:

Observation 34. For each local theory T and for each CQ Î¨, the

size of the greatest disjunct in the rewriting is at most ğ‘™ T |Î¨|.

Clearly, the linear bound on the width of ğ‘Ÿğ‘’ğ‘¤ (Î¨) gives us an
immediate exponential upper bound on the number of its disjuncts.
A matching lower bound is trivial to obtain:

Observation 35. Let T consist of the two rules: ğ¸ (ğ‘¥, ğ‘¦) â‡’ ğ‘…(ğ‘¥, ğ‘¦)
and ğ¸ â€²(ğ‘¥, ğ‘¦) â‡’ ğ‘…(ğ‘¥, ğ‘¦). Then T is BDD and the number of disjuncts
in ğ‘Ÿğ‘’ğ‘¤ (Î¨) can be exponential in the size of Î¨.

Recall the notion of backwards shy theories [10] â€“ these are BDD
theories such that, for every query ğœ“ ( Â¯ğ‘¦) if ğœ™ ( Â¯ğ‘¦) âˆˆ ğ‘Ÿğ‘’ğ‘¤ (ğœ“ ( Â¯ğ‘¦)) then
only variables from Â¯ğ‘¦ can occur more than once in ğœ™ ( Â¯ğ‘¦). Sticky the-
ories are backward shy. It is easy to see that backward shy theories
admit rewritings of linear width as well and, in consequence, also
all sticky theories do. This is related to another notion of locality:

Definition 36. We call a theory T distancing if there is a ğ‘‘ T âˆˆ N
such that for any instance D, any ğ‘, ğ‘ â€² âˆˆ ğ‘‘ğ‘œğ‘š(D), and any ğ‘› âˆˆ N if
ğ‘‘ğ‘–ğ‘ ğ‘¡ğ¶â„ ( T,D) (ğ‘, ğ‘ â€²) â‰¤ ğ‘› then ğ‘‘ğ‘–ğ‘ ğ‘¡D (ğ‘, ğ‘ â€²) â‰¤ ğ‘‘ Tğ‘›.

Is every BDD theory distancing? It might seem that this can
be shown using Exercise 16. However, this is not the case, since
the path from ğ‘ to ğ‘ â€² in ğ¶â„(T , D) might lead through atoms not
containing any constants from the original D. What can be proven
is the following correspondency:

Observation 37. If a BDD theory admits rewritings of linear

width, then it is distancing.

Assuming Conjecture 2, this implies that all theories from previ-
ously known BDD classes are distancing. The converse of Observa-
tion 37 does not hold, and such theories can be easily found:

But even if not all bd-local theories are BDD, it is not straight-
forward to come up with a BDD theory that is not bd-local. So a

Observation 38. The theory consisting of the single Datalog rule

ğ´(ğ‘¥), ğ¸ (ğ‘¥, ğ‘¦) â‡’ ğ´(ğ‘¦) is distancing but not BDD.

So do there exist non-distancing BDD theories at all? Do there
exist BDD theories that do not admit rewritings of linear width?
The answer is given by Theorem 3, which constitutes the third
main result of this paper:

Theorem 3. There exists a BDD theory that is non-distancing and

does not even admit rewritings of polynomial width.

To see how this is possible, consider the following theory:

Definition 39. Consider a signature with two binary predicates

ğ‘… and ğº. Let the theory Tğ‘‘ consist of the following rules:
(loop)
(pins)
(grid)

ğ‘¡ğ‘Ÿğ‘¢ğ‘’ â‡’ âˆƒğ‘¥ ğ‘…(ğ‘¥, ğ‘¥), ğº (ğ‘¥, ğ‘¥)
âˆ€ğ‘¥ (ğ‘¡ğ‘Ÿğ‘¢ğ‘’ â‡’ âˆƒğ‘§, ğ‘§ â€² ğ‘…(ğ‘¥, ğ‘§), ğº (ğ‘¥, ğ‘§ â€²))

ğ‘…(ğ‘¥, ğ‘¥ â€²), ğº (ğ‘¥, ğ‘¢), ğº (ğ‘¢, ğ‘¢ â€²) â‡’ âˆƒğ‘§ ğ‘…(ğ‘¢ â€², ğ‘§), ğº (ğ‘¥ â€², ğ‘§)

Note that the rules of Tğ‘‘ are not single-head and some of them have
empty bodies. One could easily reformulate them to avoid this at
the cost of readability (see Appendix D).

We will think of instances over our signature (and of bodies of
queries) as graphs with edges colored in red or green. For ğ‘› âˆˆ N, let
ğºğ‘› (ğ‘¥0, ğ‘¥ğ‘›) denote the CQ âˆƒğ‘¥1 . . . ğ‘¥ğ‘›âˆ’1ğº (ğ‘¥0, ğ‘¥1), . . . , ğº (ğ‘¥ğ‘›âˆ’1, ğ‘¥ğ‘›)
and ğ‘…ğ‘› (ğ‘¥0, ğ‘¥ğ‘›) likewise. Define conjunctive queries ğœ™ğ‘›
ğ‘… (ğ‘¥, ğ‘¦) by
âˆƒğ‘¥ â€², ğ‘¦ â€²ğ‘…ğ‘› (ğ‘¥, ğ‘¥ â€²), ğ‘…ğ‘› (ğ‘¦, ğ‘¦ â€²), ğº (ğ‘¥ â€², ğ‘¦ â€²) and let Gğ‘› (ğ‘, ğ‘) be a path of ğ‘›
green edges, with ğ‘ as the first vertex and ğ‘ as the last.

The following technical lemma substantiates Theorem 3:

Lemma 40. (A) The theory Tğ‘‘ is BDD.

(B) ğº 2ğ‘›

(ğ‘¥, ğ‘¦) âˆˆ ğ‘Ÿğ‘’ğ‘¤ Tğ‘‘ (ğœ™ğ‘›

ğ‘… (ğ‘¥, ğ‘¦)) holds for every ğ‘› âˆˆ N.

(ğ‘, ğ‘)) |= ğœ™ğ‘›
(ğ‘, ğ‘) then ğ¶â„(Tğ‘‘, D) Ì¸|= ğœ™ğ‘›

Let us first prove claim (B) of the theorem, which implies that
Tğ‘‘ is not distancing. The claim follows once we notice that: (i)
Ch(Tğ‘‘, G2ğ‘›
ğ‘… (ğ‘, ğ‘) and (ii) if D is a proper subset of
G2ğ‘›
ğ‘… (ğ‘, ğ‘). Establishing (i) is immediate,
as exemplified in Fig. 1 displaying the case ğ‘› = 3. To show (ii), we
note that if D is a proper subset of G2ğ‘›
(ğ‘, ğ‘) then ğ‘ and ğ‘ are in two
different connected components of D and, since Tğ‘‘ is connected,
they are in two different connected components of ğ¶â„(Tğ‘‘, D).

Figure 1: Fragment of ğ¶â„(Tğ‘‘, G8 (ğ‘0, ğ‘8)) (print in colors!)
The proof of claim (A) is much harder (see Appendix B). It defines
a rewriting procedure in the spirit of [4, 16], whose termination
for any given query ğœ™ (ğ‘¦) is shown, via an invariant defined by a
complicated multiset ordering.

As our final exercise illustrates, the reasons why Tğ‘‘ is BDD are

quite subtle indeed:

Exercise 41. Show that without rule (loop), Tğ‘‘ would not be BDD.

Hint: Consider the CQ âˆƒğ‘¥, ğ‘¦ ğ‘…(ğ‘¥, ğ‘¦), ğº (ğ‘¥, ğ‘¦).

A remark on Theorem 3. A folklore belief seems to be that the
existence of BDD theories that enforce rewritings of unbounded
width is a consequence of the the fact that it is undecidable to
check if a theory is BDD (see e.g. a recent stackexchange post

Piotr Ostropolski-Nalewaja, Jerzy Marcinkowski, David Carral, and Sebastian Rudolph

[17]). Our results call this belief into question, because being BDD
is undecidable for theories with a binary signature, and yet such
theories, if BDD, are local and thus admit rewritings of linear width.
Remark on distancing and linear width rewritings. One may
ask whether distancing is the same as admitting rewritings of linear
width. The answer is no. While Observation 37 shows one implica-
tion, the converse is not true. Consider theory Tğ‘‘ from Definition 39,
but with every predicateâ€™s arity increased by one, and the new vari-
able ğ‘Ÿ occurring in the last position in every atom. Then the new
theory is distancing (unlike Tğ‘‘ ), but it still requires exponential size
rewritings (and, of course, it will remain BDD).

12 CONCLUSIONS AND FUTURE WORK
Our major motivation to embark on this journey was the pending
status of the FUS/FES conjecture. On our way, we realized that
any progress in that direction requires to significantly advance
our understanding of the BDD class, seperating folklore beliefs
from hard facts. To this end, we introduced several new notions,
characterizing specific properties of theories, and investigated their
correspondencies. Most notably, we defined local theories, a BDD
subclass. Our major results are the following:

â€¢ We show that the FUS/FES conjecture holds for all local
theories (Theorem 2), which include all theories over binary
signatures (Corollary 1). If the conjecture holds in the general
case, then our work may provide the basis for a complete
proof. If it does not, we now know that we must look for
counter-examples of higher arity to disprove it.

â€¢ We show that there are BDD theories that are non-distancing
and even necessitate rewritings of exponential width (Theo-
rem 3). This result highlights the limitations of existing BDD
classes [7, 9, 10], which can only characterise rule sets that
admit rewritings of polynomial width.

As for future work, we intend to explore the following:

â€¢ Study the relation between distancing and bd-local. More
precisely, find out if there are theories that are BDD and
bd-local but are not distancing.

â€¢ Extend the proof of Theorem 1 to show Conjecture 2, i.e.,
that all BDD frontier-guarded theories [2] are local and thus
the FUS/FES conjecture holds for them. Also, show if the
FUS/FES conjecture holds for bd-local theories and then, of
course, try to show the conjecture in the general case!
â€¢ Define a class of BDD theories that contains rule sets such
as the one from Definition 39. Also, define an expressive
class that captures the intuitive notion of locality, contains
all known BDD classes, and implies BDD membership.
â€¢ Even though we extend Theorem 3 in the appendix (see
Lemma 40), we wonder if there is a theory that does not
admit an elementary bound on the width of its rewritings.
Acknowledgements. Ostropolski-Nalewaja and Marcinkowski
were supported by the Polish National Science Centre (NCN) grant
2016/23/B/ST6/01438. Carral was supported by the ANR project
CQFD (ANR-18-CE23-0003), the DFG project 389792660 (TRR 248,
Center for Perspicuous Systems) and by the BMBF in the Center
for Scalable Data Analytics and Artificial Intelligence (ScaDS.AI).
Rudolph was supported by the European Research Council through
the ERC Consolidator Grant DeciGUT (project number 771779).

A Journey to the Frontiers of Query Rewritability
(Extended Technical Report)

REFERENCES
[1] A. Deutsch, A. Nash, and J. B. Remmel, â€œThe chase revisited,â€ in Proc. of the 27th
ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems,
PODS 2008, (M. Lenzerini and D. Lembo, eds.), pp. 149â€“158, ACM, 2008.

[2] J. Baget, M. LeclÃ¨re, M. Mugnier, and E. Salvat, â€œOn rules with existential variables:
Walking the decidability line,â€ Artif. Intell., vol. 175, no. 9-10, pp. 1620â€“1654, 2011.
[3] A. CalÃ¬, G. Gottlob, and T. Lukasiewicz, â€œDatalogÂ±: a unified approach to on-
tologies and integrity constraints,â€ in Proc. of the 12th International Conference
on Database Theory, ICDT 2009, (R. Fagin, ed.), vol. 361 of ACM International
Conference Proceeding Series, pp. 14â€“30, ACM, 2009.

[4] M. KÃ¶nig, M. LeclÃ¨re, M. Mugnier, and M. Thomazo, â€œSound, complete and
minimal UCQ-rewriting for existential rules,â€ Semantic Web, vol. 6, no. 5, pp. 451â€“
475, 2015.

[5] P. BarcelÃ³, G. Berger, C. Lutz, and A. Pieris, â€œFirst-order rewritability of frontier-
guarded ontology-mediated queries,â€ in Proc. of the 27th International Joint Con-
ference on Artificial Intelligence, IJCAI 2018,, pp. 1707â€“1713, 2018.

[6] C. Civili and R. Rosati, â€œOn the first-order rewritability of conjunctive queries
over binary guarded existential rules,â€ in Proc. of the 30th Italian Conference on
Computational Logic, (D. Ancona, M. Maratea, and V. Mascardi, eds.), vol. 1459 of
CEUR Workshop Proceedings, pp. 25â€“30, CEUR-WS.org, 2015.

[7] A. CalÃ¬, G. Gottlob, and A. Pieris, â€œAdvanced processing for ontological queries,â€

Proc. VLDB Endow., vol. 3, no. 1, pp. 554â€“565, 2010.

[8] H. Gaifman, H. G. Mairson, Y. Sagiv, and M. Y. Vardi, â€œUndecidable optimization
problems for database logic programs,â€ J. ACM, vol. 40, no. 3, pp. 683â€“713, 1993.
[9] A. Artale, D. Calvanese, R. Kontchakov, and M. Zakharyaschev, â€œThe DL-Lite

family and relations,â€ J. Artif. Intell. Res., vol. 36, pp. 1â€“69, 2009.

[10] M. Thomazo, Conjunctive Query Answering Under Existential Rules - Decidability,
Complexity, and Algorithms. PhD thesis, Montpellier 2 University, France, 2013.
[11] S. Delivorias, M. LeclÃ¨re, M. Mugnier, and F. Ulliana, â€œOn the k-boundedness
for existential rules,â€ in Proc. of 2nd International Joint Conference on Rules and
Reasoning, RuleML+RR 2018, (C. BenzmÃ¼ller, F. Ricca, X. Parent, and D. Roman,
eds.), vol. 11092 of Lecture Notes in Computer Science, pp. 48â€“64, Springer, 2018.
[12] P. Bourhis, M. LeclÃ¨re, M. Mugnier, S. Tison, F. Ulliana, and L. Gallois, â€œObliv-
ious and semi-oblivious boundedness for existential rules,â€ in Proc. of the 28th
International Joint Conference on Artificial Intelligence, IJCAI 2019, (S. Kraus, ed.),
pp. 1581â€“1587, ijcai.org, 2019.

[13] P. Hell and J. Nesetril, â€œThe core of a graph,â€ Discret. Math., vol. 109, no. 1-3,

pp. 117â€“126, 1992.

[14] A. CalÃ¬, G. Gottlob, and T. Lukasiewicz, â€œA general datalog-based framework for
tractable query answering over ontologies,â€ J. Web Semant., vol. 14, pp. 57â€“83,
2012.

[15] J. Baget, F. Garreau, M. Mugnier, and S. Rocher, â€œRevisiting chase termina-
tion for existential rules and their extension to nonmonotonic negation,â€ CoRR,
vol. abs/1405.1071, 2014.

[16] G. Gottlob, G. Orsi, and A. Pieris, â€œQuery rewriting and optimization for ontolog-

ical databases,â€ vol. 39, Oct. 2014.

[17] M. KrÃ¶tzsch,

â€œWhat

rewritable (and fo-query)?.â€ https:
//cstheory.stackexchange.com/questions/4859/what-is-first-order-rewritable-
and-fo-query. Accessed: 2020-11-27.

is first-order

[18] J. Baget, M. LeclÃ¨re, M. Mugnier, and E. Salvat, â€œExtending decidable cases for
rules with existential variables,â€ in Proc. of the 21st International Joint Conference
on Artificial Intelligence, IJCAI 2009, (C. Boutilier, ed.), pp. 677â€“682, 2009.
[19] N. Dershowitz and Z. Manna, â€œProving termination with multiset orderings,â€

Commun. ACM, vol. 22, no. 8, pp. 465â€“476, 1979.

Appendices

Appendix A PROOF OF THEOREM 1
Let us now fix a binary signature Î£ and a BDD theory T over Î£.
By Tğ·ğ¿ we will denote the Datalog rules of T and by Tâˆƒ its proper
existential rules.

First we will need to distinguish, among all elements of Tâˆƒ, de-
tached4 rules that are of the form ğœ™ ( Â¯ğ‘¥) â†’ âˆƒğ‘¦, ğ‘§ğœ“ (ğ‘¦, ğ‘§) or ğœ™ ( Â¯ğ‘¥) â†’
âˆƒğ‘¦ğœ“ (ğ‘¦), that is, rules having empty frontier. Note that when firing a
detached rule, the newly created atom, has no common terms with
the rest of the chase. Notice that, since we only consider binary
schemas, the non-empty frontier of an existential rule always con-
sists of exactly one variable5. Rules from Tâˆƒ which are not detached
will be called sensible

Clearly, whatever fact set D we consider, the structure Ch(T , D)
is a disjoint union of three sets of atoms. One set consists of the
original facts from D. Second contains existential atoms, that is facts
created in the process of the chase, by rules of Tâˆƒ. The third set
consists of atoms that are created by the rules of Tğ·ğ¿ which be
called Datalog atoms. We will denote the set of existential atoms of
Ch(T , D) together with atoms of D with Châˆƒ (T , D).

Let us now concentrate on the structure of Châˆƒ (T , D). Notice
that there are again two kinds of atoms there: detached atoms,
created by detached rules and sensible atoms, created by sensible
rules. Notice also that our taxonomy of atoms implies a taxonomy
of the terms of Châˆƒ (T , D) (that is the elements of ğ‘‘ğ‘œğ‘š(Ch(T , D)) \
ğ‘‘ğ‘œğ‘š(D)): there are sensible terms, created by sensible rules and
detached terms, created by detached rules. The set of detached
terms will be called ğ‘‘ğ‘’ğ‘¡ (Ch(T , D)).

Observation 42. The graph whose vertices are the terms from
ğ‘‘ğ‘œğ‘š(Ch(T , D)) and whose edges are sensible atoms of Châˆƒ (T , D)
is a forest. The set of the roots of the trees of this forest is equal
to ğ‘‘ğ‘œğ‘š(D) âˆª ğ‘‘ğ‘’ğ‘¡ (Ch(T , D)). The number of children of any of the
vertices of this forest is bounded by the number of existential rules in
T .

For any ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) âˆª ğ‘‘ğ‘’ğ‘¡ (Ch(T , D)) let S(ğ‘) be the set of
all atoms of Châˆƒ (T , D) which are edges of the tree rooted in ğ‘.
Following the naming convention, we call trees that are rooted in
detached terms detached trees.

A.1 First (failed) attempt at the Crucial Lemma
For any given set of facts D let a parent function ğ‘ğ‘ğ‘Ÿ T be any
function from Ch(T , D) \ D to the power set of Ch(T , D) such that
for any atom ğ›¼ âˆˆ Ch(T , D) there exists a rule ğœŒ and a mapping ğœ
satisfying:

â€¢ ğ›¼ = ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ),
â€¢ ğœ (ğ‘ğ‘œğ‘‘ğ‘¦ (ğœŒ)) = ğ‘ğ‘ğ‘Ÿ T (ğ›¼).

The parent function points to some (arbitrarily chosen) set of
atoms that leads to the creation of ğ›¼. Note that there may be more

4Such rules are called disconnected in [18], however we think that calling those rules
detached might help the reader to distinguish those from rules that have disconnected
bodies.
5Actually, the assumption we really use in the proof of Theorem 1 is not that relations
are at most binary, but that the existential rules are â€œfrontier oneâ€.

than one such function as ğ›¼ could be created in more than one way
during the chase.

Let D be any set of facts and let ğ‘ğ‘ğ‘Ÿ T be some parent function.

Then we define an ancestor function ğ‘ğ‘›ğ‘ T as follows:

â€¢ ğ‘ğ‘›ğ‘ T (ğ›¼) = {ğ›¼ } for an atom ğ›¼ âˆˆ D,
â€¢ ğ‘ğ‘›ğ‘ T (ğ›¼) = (cid:208)ğ›¼ â€² âˆˆğ‘ğ‘ğ‘ŸT (ğ›¼) ğ‘ğ‘›ğ‘ T (ğ›¼ â€²) for atoms of Ch(T , D) \

D.

Intuitively the set ğ‘ğ‘›ğ‘ T (ğ›¼) consists of facts from D which were
used during the chase, to prove ğ›¼. Of course there might be more
than one ancestor function for any given set of facts as that func-
tion is strictly associated with a particular parent function. This
freedom in taking parents, and so in picking ancestors, leads to
some problems, as we will soon discover.

We would be one step from proving Theorem 1 if we had:

Lemma 43 (Crucial Lemma, first attempt, false). There is a
natural number ğ‘€, depending on the rule set T but not on the fact
set D, such that for every ancestor function ğ‘ğ‘›ğ‘ T , for each constant
and any detached term ğ‘¡ in Ch(T , D) holds:

(cid:12)
(cid:216)
(cid:12)
(cid:12)

ğ›¼ âˆˆS(ğ‘¡ )

ğ‘ğ‘›ğ‘ T (ğ›¼)

(cid:12)
(cid:12)
(cid:12)

â‰¤ ğ‘€

Piotr Ostropolski-Nalewaja, Jerzy Marcinkowski, David Carral, and Sebastian Rudolph

While body rewriting can be applied both to existential rules
and Datalog rules, the second procedure will only be applied to
existential rules. It separates the disconnected fragment of body of
given existential rule and â€œencapsulatesâ€ that fragment in a single
nullary predicate from M. That is, given a rule, the procedure re-
turns a pair of rules. One being almost the original rule, but with
its body changed to consist of nullary predicate and a connected
conjunction of atoms. The second being a rule whose job is to prove
the aforementioned nullary predicate.

Definition 46 (Body separation). If ğœŒ is an existential rule of

the form ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦) âˆ§ ğœ™ ( Â¯ğ‘§) â‡’ âˆƒ Â¯ğ‘¢ğ›¾ ( Â¯ğ‘¦, Â¯ğ‘¢) such that:

â€¢ ( Â¯ğ‘¥ âˆª Â¯ğ‘¦) âˆ© Â¯ğ‘§ = âˆ…,
â€¢ ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦) is connected,

then

â€¢ ğ‘ ğ‘’ğ‘ğ‘ğ‘ (ğœŒ) = ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦) âˆ§ ğ‘€ğœ™ â‡’ âˆƒ Â¯ğ‘¢ ğ›¾ ( Â¯ğ‘¦, Â¯ğ‘¢)
â€¢ ğ‘ ğ‘’ğ‘ğ‘€ (ğœŒ) = ğœ™ ( Â¯ğ‘§) â‡’ ğ‘€ğœ™

If the body of ğœŒ is connected, we assume that ğœ™ ( Â¯ğ‘§) is empty. And

we have a nullary predicate ğ‘€âˆ… âˆˆ Î£â€² for this occasion.

The normalization algorithm is performed in three steps:

But that lemma is unfortunately not true. For a counterexample

Normalization Algorithm

see:

Example 44. Let T consist of two rules:

â€¢
â€¢

ğ¸ (ğ‘¥, ğ‘¦), ğ‘…(ğ‘§, ğ‘¦)
ğ¸ (ğ‘¥, ğ‘¦), ğ‘ƒ (ğ‘§)

â†’
â†’

âˆƒğ‘£ ğ¸ (ğ‘¦, ğ‘£)
ğ‘…(ğ‘§, ğ‘¦)

Suppose that ğ‘€ as in the lemma exists and that D consists of atom

ğ¸ (ğ‘0, ğ‘1) and atoms ğ‘ƒ (ğ‘ğ‘– ) for each 1 â‰¤ ğ‘– â‰¤ ğ‘€.

Then Ch(T , D) will consist of an infinite number of new facts
ğ¸ (ğ‘1, ğ‘2), ğ¸ (ğ‘2, ğ‘3),ğ¸ (ğ‘3, ğ‘4) . . .. In order to build them, however,
some facts about relation ğ‘… will need to be proven by the second rule
using a number of ğ‘ƒ atoms from D. And it might happen (Skolem/semi-
oblivious chase is non-deterministic in that aspect) that the proven
ğ‘…-facts will be ğ‘…(ğ‘1, ğ‘1), ğ‘…(ğ‘2, ğ‘2), . . . ğ‘…(ğ‘ğ‘€, ğ‘ğ‘€ ), meaning that S(ğ‘1)
uses during its creation all the ğ‘€ + 1 facts of D. But of course this is
for irrelevant reasons: the same chase could be built if ğ‘ƒ (ğ‘1) was used
each time some ğ‘ƒ was needed.

A.2 The normalization of T
In order to circumvent the problems highlighted by Example 44, we
will now transform the rule set T into another rule set Tğ‘ ğ¹ which,
apart from some other useful properties, will satisfy the equality
(âˆ—) Châˆƒ (Tğ‘ ğ¹ , D) = Châˆƒ (T , D).

First we will define the signature of Tğ‘ ğ¹ . Let us take a fresh set
of nullary predicates M = {ğ‘€ğœ™ | ğœ™ is a boolean CQ over Î£}. Then
our new signature6 Î£â€² is Î£ âˆª M.

Two procedures will be used during the normalization: body

Step One: Tğ¼ = (cid:208)ğœŒ âˆˆ Tâˆƒ

ğ‘…ğ‘’ğ‘¤ (ğœŒ)

Step two: Tğ¼ ğ¼ = {ğ‘ ğ‘’ğ‘ğ‘ğ‘ (ğœŒ) : ğœŒ âˆˆ Tğ¼ }

Step three: Tğ¼ ğ¼ ğ¼ = (cid:208)ğœŒ âˆˆ Tğ¼

ğ‘…ğ‘’ğ‘¤ (ğ‘ ğ‘’ğ‘ğ‘€ (ğœŒ))

Return: Tğ‘ ğ¹ = Tğ¼ ğ¼ âˆª Tğ¼ ğ¼ ğ¼

The normalization allows us to attack the source of the problem
highlighted in the previous section by separating the â€œdisconnected
ancestors" required by existential rules and encapsulating those
ancestors within rules producing nullary predicates.

Observation 47. Let ğœŒ be a rule that creates a detached atom
in Ch(Tğ‘ ğ¹ , D) for some fact set D. Then ğœŒ is a rule from Tğ¼ ğ¼ and its
body consists of a single nullary atom.

Lemma 48. For any set of facts D over Î£:

Châˆƒ (T , D) = Châˆƒ (Tğ‘ ğ¹ , D)

Here, our choice of the Skolem naming convention can be ex-
plained. We want to show equality of the structures in Lemma 48
and so if we choose our Skolem naming convention to be dependent
on rule names then Lemma 48 would obviously be false.

rewriting and body separation.

Definition 45 (Body rewriting). Let ğœŒ be some rule with body
ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦) over Î£ and a head ğ›¾ ( Â¯ğ‘¦) which is an atom from Î£â€² possibly
preceded with the existential quantifier (or two). Then by ğ‘…ğ‘’ğ‘¤ (ğœŒ) we
denote the set:

{ğ›½ â€²( Â¯ğ‘¥, Â¯ğ‘¦) â‡’ ğ›¾ ( Â¯ğ‘¦) : ğ›½ â€²( Â¯ğ‘¥, Â¯ğ‘¦) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ Â¯ğ‘¥ ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦))}
6We briefly forget here about our promise that signatures would be finite.

A.3 Proof of Lemma 48
This entire subsection is devoted to the proof of Lemma 48, which
will follow directly from Lemma 52 and Lemma 55. But first, as a
warm-up, notice that:

Exercise 49. Let D be any instance and let Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(T , D)) | Â¯ğ‘¦ |.
Let ğœ™ ( Â¯ğ‘¦) âˆˆ ğ‘Ÿğ‘’ğ‘¤ (ğœ“ ( Â¯ğ‘¦)) (whereğœ“ ( Â¯ğ‘¦) is some CQ) and suppose ğ¶â„(T , D) |=
ğœ™ ( Â¯ğ‘). Then ğ¶â„(T , D) |= ğœ“ ( Â¯ğ‘).

A Journey to the Frontiers of Query Rewritability
(Extended Technical Report)

Hint: Recall that ğ¶â„(T , ğ¶â„(T , D)) = ğ¶â„(T , D).

Exercise 50. Let ğœ“ ( Â¯ğ‘¦) be any CQ and ğœ™ ( Â¯ğ‘¦) âˆˆ ğ‘Ÿğ‘’ğ‘¤ (ğœ“ ( Â¯ğ‘¦)). Let
D be any instance and Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘¦ |. Suppose ğ¶â„(T , D) |= ğœ™ ( Â¯ğ‘).
Then there exists query ğœ™ â€²( Â¯ğ‘¦) âˆˆ ğ‘Ÿğ‘’ğ‘¤ (ğœ“ ( Â¯ğ‘¦)) such that D |= ğœ™ â€²( Â¯ğ‘).

Hint: Notice that ğ¶â„(T , ğ¶â„(T , D)) = ğ¶â„(T , D).

Exercise 51. Suppose (âˆƒÂ¯ğ‘¡, Â¯ğ‘¢ ğœ™ (Â¯ğ‘¡, Â¯ğ‘¦) âˆ§ ğ›¾ ( Â¯ğ‘¢)) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ Â¯ğ‘¥ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦))
for some CQs ğœ™, ğ›¾ and ğ›½, where the tuples of variables Â¯ğ‘¡ âˆª Â¯ğ‘¦ and
Â¯ğ‘¢ are disjoint. And suppose âˆƒÂ¯ğ‘£ ğœ ( Â¯ğ‘£) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ Â¯ğ‘¢ ğ›¾ ( Â¯ğ‘¢)). Then there
exists a query âˆƒÂ¯ğ‘§ ğœš ( Â¯ğ‘§, Â¯ğ‘¦) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ Â¯ğ‘¥ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦)) which is contained in
(âˆƒÂ¯ğ‘¡, Â¯ğ‘£ ğœ™ (Â¯ğ‘¡, Â¯ğ‘¦) âˆ§ ğœ ( Â¯ğ‘£)).

Hint: Let database D be a frozen body of âˆƒÂ¯ğ‘¡, Â¯ğ‘£ ğœ™ (Â¯ğ‘¡, Â¯ğ‘¦) âˆ§ ğœ ( Â¯ğ‘£) and
observe that D |= ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ Â¯ğ‘¥ ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦))

Notice that the only existential rules in Tğ‘ ğ¹ are the ones in
Tğ¼ ğ¼ . Notice also that the only Datalog rules in Tğ‘ ğ¹ are the ones in
Tğ¼ ğ¼ ğ¼ and hence the only atoms which are in Ch(Tğ‘ ğ¹ , D) but not in
Châˆƒ (Tğ‘ ğ¹ , D) are the nullary atoms from the set M.

By Chğ‘–,âˆƒ (T , D) we denote the intersection of Chğ‘– (T , D) and

Châˆƒ (T , D).

Lemma 52. For each fact set D over Î£ and each ğ‘˜ âˆˆ N:

Chğ‘˜,âˆƒ (Tğ‘ ğ¹ , D) âŠ† Châˆƒ (T , D).

Proof. We will show this by induction on ğ‘˜. The case for ğ‘˜ = 0
is trivial. Assume the claim is true for some ğ‘˜ âˆˆ N. We are going to
show that it is also true for ğ‘˜ + 1.

Let ğ›¼ be an atom from Chğ‘˜+1,âˆƒ (Tğ‘ ğ¹ , D), which is not in

Chğ‘˜,âˆƒ (Tğ‘ ğ¹ , D). Then ğ›¼ = ğ‘ğ‘ğ‘ğ‘™ (ğœŒğ›¼, ğœğ›¼ ) for some:

â€“ ğœŒğ›¼ âˆˆ Tğ¼ ğ¼ , the rule which actually created ğ›¼, of the form ğœ™ (Â¯ğ‘¡, Â¯ğ‘¦) âˆ§
ğ‘€ğ›¾ â‡’ âˆƒÂ¯ğ‘§ ğ›¼0 ( Â¯ğ‘¦, Â¯ğ‘§),
â€“ ğœğ›¼ such that ğœğ›¼ (ğœ™ (Â¯ğ‘¡, Â¯ğ‘¦)) âŠ† Chğ‘˜,âˆƒ (Tğ‘ ğ¹ , D),
â€“ ğ‘€ğ›¾ such that Chğ‘˜,âˆƒ (Tğ‘ ğ¹ , D) |= ğ‘€ğ›¾ .

(â™¥)

It follows from the construction of Tğ‘ ğ¹ that there must exist:

(1) A rule ğœŒ â€² âˆˆ Tğ¼ of the form:

ğœ™ (Â¯ğ‘¡, Â¯ğ‘¦) âˆ§ ğ›¾ ( Â¯ğ‘¢) â‡’ âˆƒÂ¯ğ‘§ ğ›¼0 ( Â¯ğ‘¦, Â¯ğ‘§)

which, by Step II of the normalization algorithm, led to the
creation of ğœŒğ›¼ , such that the tuple Â¯ğ‘¢ of variables is disjoint
with Â¯ğ‘¦ and with Â¯ğ‘¡, and that ğœ™ (Â¯ğ‘¡, Â¯ğ‘¦) is a connected query.

(2) A rule ğœŒ âˆˆ Tâˆƒ of the form:

ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦) â‡’ âˆƒÂ¯ğ‘§ ğ›¼0 ( Â¯ğ‘¦, Â¯ğ‘§)

which, by Step I of the normalization algorithm, led to the
creation of ğœŒ â€², such that:

(âˆƒÂ¯ğ‘¡, Â¯ğ‘¢ ğœ™ (Â¯ğ‘¡, Â¯ğ‘¦) âˆ§ ğ›¾ ( Â¯ğ‘¢)) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ Â¯ğ‘¥ ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦))

(â™£)

(3) A rule ğœŒğ‘€ğ›¾

in Tğ¼ ğ¼ ğ¼ of the form ğœ ( Â¯ğ‘¢) â‡’ ğ‘€ğ›¾ such that âˆƒ Â¯ğ‘¢ ğœ ( Â¯ğ‘¢) âˆˆ
ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ Â¯ğ‘¢ ğ›¾ ( Â¯ğ‘¢)) and a substitution ğœğœ from the variables in
Â¯ğ‘¢ to ğ‘‘ğ‘œğ‘š(Chğ‘˜âˆ’1,âˆƒ (Tğ‘ ğ¹ , D)) such that ğœğœ (ğœ ( Â¯ğ‘¢)) âŠ†
Chğ‘˜âˆ’1,âˆƒ (Tğ‘ ğ¹ , D). This is because, for ğœŒğ›¼ to be applicable
in Chğ‘˜,âˆƒ (Tğ‘ ğ¹ , D), there must be Chğ‘˜,âˆƒ (Tğ‘ ğ¹ , D) |= ğ‘€ğ›¾ , and
since D Ì¸|= ğ‘€ğ›¾ , a rule able to produce ğ‘€ğ›¾ must have earlier
been applied.

In order to complete the induction step, we need to show that
ğ›¼ âˆˆ Châˆƒ (T , D). Since ğœŒ is a rule of T this claim will follow once
we can prove that:

Châˆƒ (T , D) |= âˆƒ Â¯ğ‘¥ ğ›½ ( Â¯ğ‘¥, ğœğ›¼ ( Â¯ğ‘¦))
And (â™¦) will follow (using Exercise 49) once we can show that

(â™¦)

for some query ğœš ( Â¯ğ‘¦) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ Â¯ğ‘¥ ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦)) there is:

Châˆƒ (T , D) |= ğœš (ğœğ›¼ ( Â¯ğ‘¦))

(â™ )

Recall that from (â™¥) we know that:

Chğ‘˜,âˆƒ (Tğ‘ ğ¹ , D) |= âˆƒÂ¯ğ‘¡ ğœ™ (Â¯ğ‘¡, ğœğ›¼ ( Â¯ğ‘¦)).

By hypothesis this implies that:

Châˆƒ (T , D) |= âˆƒÂ¯ğ‘¡ ğœ™ (Â¯ğ‘¡, ğœğ›¼ ( Â¯ğ‘¦)).
The claim (â™ ) would be now proven, using (â™£), if we could also
show that:

Châˆƒ (T , D) |= âˆƒ Â¯ğ‘¢ ğ›¾ ( Â¯ğ‘¢),

But this may not be the case. All we know is that:

Chğ‘˜,âˆƒ (Tğ‘ ğ¹ , D) |= âˆƒ Â¯ğ‘¢ ğœ ( Â¯ğ‘¢)

and therefore (using the hypothesis again) that:

Châˆƒ (T , D) |= âˆƒ Â¯ğ‘¢ ğœ ( Â¯ğ‘¢).
So we get that Châˆƒ (T , D) |= âˆƒÂ¯ğ‘ , Â¯ğ‘¡ ğœ™ (Â¯ğ‘¡, ğœğ›¼ ( Â¯ğ‘¦)) âˆ§ ğœ (Â¯ğ‘ ). Now use
â–¡
Exercise 51 to get (â™ ).

The proof of the following lemma seems overly complicated.
Why doesnâ€™t it just follow from Exercise 50? This is because, while
we assume that T is BDD, we never proved that Tğ‘ ğ¹ is BDD too.

Lemma 53. Suppose Ch(Tğ‘ ğ¹ , D) |= ğ‘€ğœ™ for some nullary fact ğ‘€ğœ™ .

Then ğ¶â„1 (Tğ‘ ğ¹ , D) |= ğ‘€ğœ™ .

Proof. Suppose Ch(Tğ‘ ğ¹ , D) |= ğ‘€ğœ™ and let ğ›½ ( Â¯ğ‘¥) be the body of

the rule from Tğ¼ ğ¼ ğ¼ that created ğ‘€ğœ™ .

Recall that ğ›½ ( Â¯ğ‘¥) does not contain nullary predicates and that Tğ‘ ğ¹
consists only of existential rules (from Tğ¼ ğ¼ ) and of Datalog rules that
prove nullary facts (from Tğ¼ ğ¼ ğ¼ ). This means that Châˆƒ (Tğ‘ ğ¹ , D) |=
âˆƒ Â¯ğ‘¥ ğ›½ ( Â¯ğ‘¥).

Now we can use Lemma 52 and get: Châˆƒ (T , D) |= âˆƒ Â¯ğ‘¥ ğ›½ ( Â¯ğ‘¥).
Now recall that âˆƒ Â¯ğ‘¥ ğ›½ ( Â¯ğ‘¥) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (ğœ™). From Exercise 50 we get
that there exists another boolean query ğ›½0 such that ğ›½0 âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (ğœ™)
and that D |= ğ›½0. And from this we can immediately conclude that
â–¡
Ch1 (Tğ‘ ğ¹ , D) |= ğ‘€ğœ™ .

Combining Lemma 53 and Observation 47 we get:

Corollary 54. If Ch(Tğ‘ ğ¹ , D) |= ğ›¼ for some detached atom ğ›¼

then ğ¶â„2 (Tğ‘ ğ¹ , D) |= ğ›¼.

The last lemma we need for the proof of Lemma 48 is:

Lemma 55. Chğ‘–,âˆƒ (T , D) âŠ† Chğ‘–+2,âˆƒ (Tğ‘ ğ¹ , D)

Proof. The induction base D âŠ† Ch2,âˆƒ (Tğ‘ ğ¹ , D) is clearly true.

And so let us move to the induction step.

Let ğ›¼ be an atom produced by an existential rule during the
ğ‘– + 1-th step of Ch(T , D). Let a rule ğœŒ âˆˆ T and a mapping ğœ be such
that ğ›¼ = ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ) and let ğ›¾ ( Â¯ğ‘¥, Â¯ğ‘¦) be a body of ğœŒ where Â¯ğ‘¦ are the
frontier variables.

While we know that Chğ‘– (T , D) |= ğœ (ğ›¾ ( Â¯ğ‘¥, Â¯ğ‘¦)) we are not sure if
Chğ‘–,âˆƒ (T , D) |= ğœ (ğ›¾ ( Â¯ğ‘¥, Â¯ğ‘¦)): some of the atoms in ğœ (ğ›¾ ( Â¯ğ‘¥, Â¯ğ‘¦)) could
be produced by Datalog rules of T .

But ğ¶â„(T , D) = ğ¶â„(T , Chğ‘–,âˆƒ (T , D)), so if Chğ‘– (T , D) |= ğœ (ğ›¾ ( Â¯ğ‘¥, Â¯ğ‘¦))

then we can be sure that there exists a query âˆƒÂ¯ğ‘§ğ›½ ( Â¯ğ‘§, Â¯ğ‘¦) âˆˆ
ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ Â¯ğ‘¥ğ›¾ ( Â¯ğ‘¥, Â¯ğ‘¦)) such that Chğ‘–,âˆƒ (T , D) |= âˆƒÂ¯ğ‘§ğ›½ ( Â¯ğ‘§, Â¯ğœ (ğ‘¦)) or, in other
words, Chğ‘–,âˆƒ (T , D) |= ğ›½ (ğœğ›½ ( Â¯ğ‘§), Â¯ğœ ( Â¯ğ‘¦)) for some substitution ğœğ›½ .
Observe that from the induction hypothesis we know that

Chğ‘–+2,âˆƒ (Tğ‘ ğ¹ , D) |= ğ›½ (ğœğ›½ ( Â¯ğ‘§), Â¯ğœ ( Â¯ğ‘¦)).

Let now ğœŒ â€² be the rule from Tğ‘ ğ¹ (or, to be more precise, from
Tğ¼ ğ¼ ), such that â„ğ‘’ğ‘ğ‘‘ (ğœŒ â€²) = â„ğ‘’ğ‘ğ‘‘ (ğœŒ) and that the body of ğœŒ â€² is of
the form ğ›½0 ( Â¯ğ‘¢, Â¯ğ‘¦) âˆ§ ğ‘€ğœ™ , where ğ›½ ( Â¯ğ‘§, Â¯ğ‘¦) = ğ›½0 ( Â¯ğ‘¢, Â¯ğ‘¦) âˆ§ ğœ™ ( Â¯ğ‘£) for some
Â¯ğ‘£ disjoint from Â¯ğ‘¢ âˆª Â¯ğ‘¦. It follows from the construction of Tğ‘ ğ¹ that
such a ğœŒ â€² exits.

Let us consider the second case. Note that Chğ‘–+2,âˆƒ (Tğ‘ ğ¹ , D) |=
ğœğ›½ (ğ›½ â€²( Â¯ğ‘¥, Â¯ğ‘¦)) and so all we need to show in order to complete our
induction step is that Chğ‘–+2 (Tğ‘ ğ¹ , D) |= ğ‘€ğœ™ .

Clearly Chğ‘–+2,âˆƒ (Tğ‘ ğ¹ , D) |= âˆƒÂ¯ğ‘§ğœ™ ( Â¯ğ‘§) as we know that ğœ™ âŠ† ğ›½.
From this we can conclude that D |= ğ‘Ÿğ‘’ğ‘¤ T (ğœ™) and thus ğ‘€ğœ™ âˆˆ
Ch2,âˆƒ (Tğ‘ ğ¹ , D).

This ends the proof of Lemma 55 and therefore of Lemma 48. â–¡

Note that this implies that the sensible and non-nullary atoms
of Ch(Tğ‘ ğ¹ , D) form a set of trees having a tree S(ğ‘¡) for each term ğ‘¡
that is a constant of D or detached term of Châˆƒ (Tğ‘ ğ¹ , D). And that
this set of trees is exactly this same set of trees as in the case of rule
set T . Also, note that having Lemma 48 we get a very important:

Corollary 56. For any set of facts D:

Ch(Tğ·ğ¿, Châˆƒ (Tğ‘ ğ¹ , D) âˆª D) = Ch(T , D)

A.4 The Crucial Lemma
In this section, we state and prove the Crucial Lemma. Recall, that
we want to prove, that for any term ğ‘¡ being a constant of D or
a detached term of Châˆƒ (Tğ‘ ğ¹ , D), the tree S(ğ‘¡) rooted in ğ‘¡ and
consisting of sensible atoms of Châˆƒ (Tğ‘ ğ¹ , D) requires only a small
subset of D to be built by the chase Ch(Tğ‘ ğ¹ , D).

First let us distinguish, among the parents and ancestors of some
atom in Ch(Tğ‘ ğ¹ , D), its connected parents and connected ancestors:
for Ch(Tğ‘ ğ¹ , D) and an atom ğ›¼
given some parent function ğ‘ğ‘ğ‘Ÿ Tğ‘ ğ¹
of Ch(Tğ‘ ğ¹ , D) we define the set of connected parents ğ‘ğ‘ğ‘ğ‘Ÿ (ğ›¼) as
the set of all the non-nullary atoms of ğ‘ğ‘ğ‘Ÿ Tğ‘ ğ¹ (ğ›¼). Then for atoms of
Ch(Tğ‘ ğ¹ , D) we define their respective sets of connected ancestors
as follows:

â€¢ ğ‘ğ‘ğ‘›ğ‘ (ğ›¼) = {ğ›¼ } for an atom ğ›¼ âˆˆ D,
â€¢ ğ‘ğ‘ğ‘›ğ‘ (ğ›¼) = (cid:208)ğ›¼ â€² âˆˆğ‘ğ‘ğ‘ğ‘Ÿ (ğ›¼) ğ‘ğ‘ğ‘›ğ‘ (ğ›¼ â€²), otherwise.
Before proceeding, let us define a number of measures, depending

on Tğ‘ ğ¹ .

â€¢ Let ğ‘˜ be the number of nullary predicates in Tğ‘ ğ¹ .
â€¢ Let â„ be the maximal number of atoms in the body of a rule

from Tğ‘ ğ¹ .

â€¢ Let ğ‘› be the number of rules in Tğ‘ ğ¹ .
â€¢ Let ğ‘ be the number of elements of a full ğ‘›-ary tree of depth

â„.

Piotr Ostropolski-Nalewaja, Jerzy Marcinkowski, David Carral, and Sebastian Rudolph

â€¢ Let ğ‘€ = ğ‘â„ + ğ‘˜â„

Now having prepared everything we are going to prove the

Crucial Lemma:

Lemma 57 (crucial). For every set of facts D, every term ğ‘¡ that is
constant of D or detached term of Châˆƒ (Tğ‘ ğ¹ , D) and every ancestor
function ğ‘ğ‘›ğ‘ Tğ‘ ğ¹

:

(cid:12)
(cid:216)
(cid:12)
(cid:12)

ğ›¼ âˆˆS(ğ‘¡ )

ğ‘ğ‘›ğ‘ Tğ‘ ğ¹ (ğ›¼)

(cid:12)
(cid:12)
(cid:12)

â‰¤ ğ‘€

Notice that we now count ancestors with respect to Tğ‘ ğ¹ instead
of ancestors with respect to T . This is, in fact, the only difference
between this lemma and the (false) Lemma 43.

Proof. The atoms of S(ğ‘¡) are all produced by the rules of Tğ¼ ğ¼ .
Recall that bodies of those rules consist of one connected ğ¶ğ‘„ and
one nullary atom. The number of atoms that are ancestors of nullary
atoms can easily be bounded by ğ‘˜â„ using Lemma 53.

What is left to be bound is the number of connected ancestors of
S(ğ‘¡). Recall that for ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(D) âˆª ğ‘‘ğ‘’ğ‘¡ (Ch(Tğ‘ ğ¹ , D)) the set of facts
S(ğ‘¡) is a tree with ğ‘¡ as its root. This gives us a natural notion of
depth of atoms in S(ğ‘¡), with atoms containing ğ‘¡ being at depth one.
First we will consider the easier case when ğ‘¡ âˆˆ ğ‘‘ğ‘’ğ‘¡ (Ch(T , D)).
Then S(ğ‘¡) is a detached tree, not connected by atoms of Ch(Tğ‘ ğ¹ , D))
to D. Moreover the connected parents and connected ancestors are
defined in such a way that every atom is in one connected compo-
nent of Ch(Tğ‘ ğ¹ , D)) with all its connected ancestors. So, no atom
in S(ğ‘¡) has any connected ancestors, and thus the entire S(ğ‘¡) has
in total at most ğ‘˜â„ ancestors.

Let us now move to the case when ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(D). Clearly, to be
a connected ancestor of someone in S(ğ‘¡) an atom in D must be a
connected parent of someone in S(ğ‘¡):

(cid:216)

ğ›¼ âˆˆS(ğ‘¡ )

ğ‘ğ‘ğ‘›ğ‘ (ğ›¼) =

(cid:16)(cid:216)

ğ›¼ âˆˆS(ğ‘¡ )

ğ‘ğ‘ğ‘ğ‘Ÿ (ğ›¼)

(cid:17)

âˆ© D.

Using the above equality, one can bound the number of ancestors
of atoms in the connected ancestors of someone in S(ğ‘¡) in the
following way:

(cid:12)
(cid:12)
(cid:12)

(cid:16)(cid:216)

ğ›¼ âˆˆS(ğ‘¡ )

ğ‘ğ‘ğ‘ğ‘Ÿ (ğ›¼)

(cid:17)

âˆ© D

(cid:12)
(cid:12)
(cid:12)

â‰¤

(cid:213)

ğ›¼ âˆˆS(ğ‘¡ )

|ğ‘ğ‘ğ‘ğ‘Ÿ (ğ›¼) âˆ© D| .

Now, we can easily bound |ğ‘ğ‘ğ‘ğ‘Ÿ (ğ›¼) âˆ© D| with â„ for any atom ğ›¼
of Ch(Tğ‘ ğ¹ , D). Finally we are going to show that only a finite (and
bounded) number of atoms of S(ğ‘¡) have any connected parents in
D. Observe that, if an application of an existential rule ğœŒ created an
atom at depth greater than â„ then the connected part of the body
ğœŒ, of size at most â„, could not â€œreachâ€ the atoms of D. From this
we get ğ‘â„ as bound for the number of connected ancestors of S(ğ‘¡)
which implies that ğ‘€ is a bound on the number of ancestors of S(ğ‘¡)
â–¡
for any ğ‘¡.

A.5 Proving Theorem 1
Now we can finally prove Theorem 1. The following is an easy
corollary of Lemma 57 and Corollary 56:

Corollary 58. For any term ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(D) âˆª ğ‘‘ğ‘’ğ‘¡ (Ch(Tğ‘ ğ¹ , D))
there exists a subset Dâ€² of D of size at most ğ‘€ such that S(ğ‘¡) âŠ†
Ch(T , Dâ€²).

A Journey to the Frontiers of Query Rewritability
(Extended Technical Report)

This is almost Theorem 1, but only for existential atoms of

Ch(T , D). However, observe that:

Observation 59. There exists a constant ğ‘‘ T such that for any set
of facts D and for any atom ğ›¼ of Ch(Tğ·ğ¿, D) there exists a subset Dâ€²
of D such that |Dâ€²| < ğ‘‘ T and ğ›¼ âˆˆ Ch(T , Dâ€²).

Proof. From Observation 14 the size of Dâ€² can easily be bounded
by â„ğ‘›ğ‘ğ‘¡ where â„ is the maximal number of atoms in a rule of T and
â–¡
ğ‘›ğ‘ğ‘¡ is the constant from Observation 14.

Thus ğ‘€ğ‘‘ T is a locality constant for Datalog atoms of Ch(T , D).

This concludes the proof of Theorem 1.

Appendix B PROOF OF LEMMA 40 (A).
THE HIGH-LEVEL VIEW.

Since Tğ‘‘ is fixed, we will use the notation ğ¶â„(F) instead of ğ¶â„(Tğ‘‘, F)
Clearly, to prove that Tğ‘‘ is BDD, it is enough to consider only
connected queries, since a bound for any non-connected query can
be derived from bounds of its connected components. Additionally,
notice that due to the rule (loop), if ğœ™ is a boolean query and if D
is any instance then ğ¶â„1 (D) |= ğœ™. So for the rest of the proof of
Lemma 40 (A) we will consider only connected non-boolean
queries. Let us start with:

Definition 60 (Marked qery). We define a marked query as
a pair âŸ¨ğœ™ ( Â¯ğ‘¦), ğ‘‰ âŸ© where ğœ™ ( Â¯ğ‘¦) = âˆƒ Â¯ğ‘¥ğ›½ ( Â¯ğ‘¥, Â¯ğ‘¦) is a CQ and ğ‘‰ is a subset
of variables of ğœ™ ( Â¯ğ‘¦) such that Â¯ğ‘¦ âŠ† ğ‘‰ âŠ† Â¯ğ‘¦ âˆª Â¯ğ‘¥.

We say that the variables in ğ‘‰ are marked. It will often be more
convenient to refer to a marked query without (or before) specifying
its components. The letter ğ‘„ will be used for that. If ğ‘„ = âŸ¨ğœ™ ( Â¯ğ‘¦), ğ‘‰ âŸ©
then by ğ‘‰ (ğ‘„) we mean ğ‘‰ , and ğ‘(ğ‘„) denotes ğœ™ ( Â¯ğ‘¦). By ğ‘£ğ‘ğ‘Ÿ (ğ‘„) we
mean the set of all variables of ğ‘(ğ‘„), and ğ‘„R (ğ‘„G) is the set of red
(green) atoms in ğ‘(ğ‘„).

For a marked query ğ‘„ the intention behind the set of marked
variables ğ‘‰ (ğ‘„) is that the variables of ğ‘‰ (ğ‘„) should not be mapped
onto the chase-produced Skolem terms:

Definition 61. For a marked query ğ‘„ = âŸ¨ğœ™ ( Â¯ğ‘¦), ğ‘‰ âŸ©, a fact set
D, and Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘¦ | we say that ğ¶â„(D) |= ğ‘„ ( Â¯ğ‘) if there exists a
homomorphism â„ : ğ‘£ğ‘ğ‘Ÿ (ğ‘„) â†’ ğ‘‘ğ‘œğ‘š(ğ¶â„(D)) witnessing ğ¶â„(D) |=
ğœ™ ( Â¯ğ‘) such that for every ğ‘£ there is â„(ğ‘£) âˆˆ ğ‘‘ğ‘œğ‘š(D) if and only if
ğ‘£ âˆˆ ğ‘‰ .

Some marked queries are false â€“ it follows directly from Defini-

tion 39 that they cannot be satisfied in any ğ¶â„(D):

Observation 62. For any instance D

â€¢ if ğ‘…(ğ‘, ğ‘) or ğº (ğ‘, ğ‘) is an edge in ğ¶â„(D) and if ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D)

then ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D);

â€¢ if C = {ğ¸0 (ğ‘0, ğ‘1), ğ¸1 (ğ‘1, ğ‘2) . . . ğ¸ğ‘˜ (ğ‘ğ‘˜, ğ‘0)} is a cycle in ğ¶â„(D)

(where each ğ¸ğ‘– âˆˆ {ğ‘…, ğº }) then C âŠ† D;

â€¢ if ğ¸ (ğ‘1, ğ‘) and ğ¸ (ğ‘2, ğ‘) are two atoms in ğ¶â„(D) (where ğ¸ âˆˆ

{ğ‘…, ğº }) and ğ‘1 âˆˆ ğ‘‘ğ‘œğ‘š(D) then also ğ‘2 âˆˆ ğ‘‘ğ‘œğ‘š(D).

Then it follows from Observation 62 that:

Observation 63. Suppose ğ¶â„(D) |= ğ‘„. Then:
(i) if ğ‘…(ğ‘§, ğ‘§ â€²) or ğº (ğ‘§, ğ‘§ â€²) is an atom in ğ‘(ğ‘„) and ğ‘§ â€² âˆˆ ğ‘‰ (ğ‘„) then

also ğ‘§ âˆˆ ğ‘‰ (ğ‘„);

(ii) if {ğ¸0 (ğ‘§0, ğ‘§1), ğ¸1 (ğ‘§1, ğ‘§2) . . . ğ¸ğ‘˜ (ğ‘§ğ‘˜, ğ‘§0)} is a cycle in ğ‘(ğ‘„) (where
each ğ¸ğ‘– âˆˆ {ğ‘…, ğº }) then ğ‘§ğ‘– âˆˆ ğ‘‰ (ğ‘„) for each ğ‘– âˆˆ {0, . . . ğ‘˜ };
(iii) if ğ¸ (ğ‘§1, ğ‘¢) and ğ¸ (ğ‘§2, ğ‘¢) are two atoms in ğ‘(ğ‘‰ ) (where ğ¸ âˆˆ

{ğ‘…, ğº }) and ğ‘§1 âˆˆ ğ‘‰ (ğ‘„)) then also ğ‘§2 âˆˆ ğ‘‰ (ğ‘„).

Marked queries satisfying conditions (i)-(iii) of Observation 63
will be called properly marked. Marked queries whose all variables
are marked will be called totally marked. Properly marked queries
that are not totally marked will be called live. Notice that for a totally
marked query âŸ¨ğœ™ ( Â¯ğ‘), ğ‘‰ âŸ©, an instance D and a tuple Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘¦ |
there is ğ¶â„(D) |= âŸ¨ğœ™ ( Â¯ğ‘), ğ‘‰ âŸ© if and only if D |= ğœ™ ( Â¯ğ‘).

B.1 High-level proof of claim (A). The process.
Now we get some conjunctive query ğœ™ ( Â¯ğ‘¦), that will be fixed
till the end of this proof, and we want to show that there exists a
rewriting of ğœ™, i.e. a finite set ğ‘Ÿğ‘’ğ‘¤ (ğœ™ ( Â¯ğ‘¦)) of CQs such that for each
D and Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘¦ | there is ğ¶â„(D) |= ğœ™ ( Â¯ğ‘) if and only if there
exists a ğœ“ ( Â¯ğ‘¦) âˆˆ ğ‘Ÿğ‘’ğ‘¤ (ğœ™ ( Â¯ğ‘¦)) such that D |= ğœ“ ( Â¯ğ‘).

Notice that ğ‘Ÿğ‘’ğ‘¤ (ğœ™ ( Â¯ğ‘¦)) will be constructed if we can produce a

finite set S of marked queries, such that:
(â™ ) for each D and each Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘¦ | we have ğ¶â„(D) |= ğœ™ ( Â¯ğ‘) if
and only if ğ¶â„(D) |= ğ‘„ ( Â¯ğ‘) holds for some ğ‘„ âˆˆ S;
(â™£) there are no live queries in S.

S will be constructed as the result of some process. As the starting
point of this process let S0 = {ğ‘„ : ğ‘(ğ‘„) = ğœ™ ( Â¯ğ‘¦)}, the set of all
possible markings of ğœ™ ( Â¯ğ‘¦). One can easily see that S0 satisfies
Condition (â™ ) above, but there is no reason to think that it also
satisfies Condition (â™£).

Now, the plan is as follows. Five operations are going to be defined
in Appendix B.3, called cut-red, cut-green, fuse-red, fuse-green, and
reduce. Each of them will:
â€¢ take, as an input, some marked query ğ‘„;
â€¢ remove from ğ‘(ğ‘„), one variable and some atoms (operation reduce
will remove one red atom and one green) ;
â€¢ keep the marking of the surviving variables unchanged;
â€¢ in one case (of operation reduce) add two new variables, one red
atom, and two green atoms);
â€¢ return the resulting marked query (except for operation reduce
which will return four marked queries: one for each of the four
possible markings of the two new variables).
It will be shown in Appendix B.3 that:

Lemma 64 (Completness). If a query is live then at least one of

the five operations can be applied to it.

At this point we can define our process, which is supposed to
ultimately create S. Start from S0. Once Sğ‘– is defined, which does
not satisfy condition (â™£), take any live query ğ‘„ âˆˆ Sğ‘– , apply one
of the five operations to this query, and define Sğ‘–+1 as Sğ‘– with ğ‘„
replaced by the query (or queries) resulting from this application.
Clearly, for the process to make sense we will need to prove (in
Appendix B.4):

Lemma 65 (Soundness). Suppose an application of one of the five
operations to some marked query ğ‘„0 returns a set Q consisting of one
or several marked queries. Then, for any D and any Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘ |
we have ğ¶â„(D) |= ğ‘„0 ( Â¯ğ‘) if and only if there exists a ğ‘„ âˆˆ Q such that
ğ¶â„(D) |= ğ‘„ ( Â¯ğ‘).

It follows from the above lemma that each Sğ‘– satisfies Condition
(â™ ). What we still need to show is that the process terminates: at
some point we will get Sğ‘– without live queries. To this end, we are
going to use ranks.

B.2 High-level proof of claim (A).

Termination.

For a marked query ğ‘„ and an atom ğ›¼ âˆˆ ğ‘„G the edge rank ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„)
will be defined (Definition 75) as some natural number, reflecting
â€œthe minimal cost of hiking from a marked variable to ğ›¼â€. Then we
will prove that:

Lemma 66. Suppose a marked query ğ‘„ â€² is returned as a result of

applying one of the five operations to ğ‘„. Then:

(i) If the operation is cut-red or fuse-red then |ğ‘„R| > |ğ‘„ â€²
R |.
(ii) If the operation is cut-green then |ğ‘„R| = |ğ‘„ â€²
ğ›¼ âˆˆ ğ‘„G there is ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) â‰¥ ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„ â€²).
(iii) If the operation is fuse-green then |ğ‘„R| > |ğ‘„ â€²
and ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) â‰¥ ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„ â€²) for each ğ›¼ âˆˆ ğ‘„G.

R | or |ğ‘„R| â‰¥ |ğ‘„ â€²
R |

R | and for each

(iv) If the operation is reduce and if ğ›¼ âˆˆ ğ‘„G is the green atom
removed by the operation and if ğ›¼ â€² âˆˆ ğ‘(ğ‘„ â€²) is any of the two
green atoms added by the operation then:
(a) |ğ‘„R| = |ğ‘„ â€²
R |;
(b) ğ‘’ğ‘Ÿğ‘˜ (ğ›¼ â€², ğ‘„ â€²) < ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„);
(c) if ğ›½ âˆˆ ğ‘„G âˆ© ğ‘„ â€²

G then ğ‘’ğ‘Ÿğ‘˜ (ğ›½, ğ‘„ â€²) â‰¤ ğ‘’ğ‘Ÿğ‘˜ (ğ›½, ğ‘„).

Recall that all the operations except for reduce will decrease the

number of variables and of atoms in ğ‘„.
Multisets. Using Lemma 66 we are going to prove that our process
indeed terminates. To this end we borrow a technique from the
term rewriting community. We will use the notation {. . .}ğ‘š to
denote a multiset. ğ‘€ (ğ´) will denote the family of all finite multisets
with elements from ğ´. By <ğ‘š we will denote the (strict) mutiset
ordering on ğ‘€ (N). By R we will mean the set of all possible pairs
âŸ¨ğ‘˜, ğ´âŸ© where ğ‘˜ âˆˆ N and ğ´ âˆˆ ğ‘€ (N). For âŸ¨ğ‘˜, ğ´âŸ©, âŸ¨ğ‘˜ â€², ğ´â€²âŸ© âˆˆ R define
âŸ¨ğ‘˜, ğ´âŸ© <R âŸ¨ğ‘˜ â€², ğ´â€²âŸ© if ğ‘˜ < ğ‘˜ â€², or ğ‘˜ = ğ‘˜ â€² and ğ´ <ğ‘š ğ´â€². Finally, let <ğ‘€
be the (strict) multiset ordering on ğ‘€ (R). It is well known ([19])
that (â™¥) if ğ´ is well-ordered then the multiset ordering on ğ‘€ (ğ´)
is also a well-ordering. So <ğ‘š is a well-ordering. In consequence
<R , which is the lexicographic ordering on the Cartesian product
of two well-ordered sets is a well-ordering too. And, again using
(â™¥), we get that <ğ‘€ is a well-ordering.

Definition 67.

â€¢ For a marked query ğ‘„ define its rank

ğ‘ğ‘Ÿğ‘˜ (ğ‘„) âˆˆ R as âŸ¨|ğ‘„R|, {ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) : ğ›¼ âˆˆ ğ‘„G}ğ‘šâŸ©.

â€¢ For a set of marked queries S define its rank ğ‘ ğ‘Ÿğ‘˜ (S) âˆˆ ğ‘€ (R)

as the multiset {ğ‘ğ‘Ÿğ‘˜ (ğ‘„) : ğ‘„ âˆˆ S}ğ‘š.

Now, since the set ğ‘€ (R) is well-ordered by <ğ‘€ , to prove termi-
nation of our process it is enough to show that whenever it produces
two subsequent sets Sğ‘– and Sğ‘–+1 there must be (âˆ—) ğ‘ ğ‘Ÿğ‘˜ (Sğ‘–+1) <ğ‘€
ğ‘ ğ‘Ÿğ‘˜ (Sğ‘– ). But recall that Sğ‘–+1 is Sğ‘– with one marked query, call it ğ‘„,
replaced by one of the five operations, with a set Q consisting of
one or several marked queries. So (this is how the multiset order-
ing works) in order to show (âˆ—) it is enough to show that for each
ğ‘„ â€² âˆˆ Q we have ğ‘„ â€² <R ğ‘„.

But this follows immediately from Lemma 66, from the definition
of the lexicographic ordering <R (if the operation in question is

Piotr Ostropolski-Nalewaja, Jerzy Marcinkowski, David Carral, and Sebastian Rudolph

cut-red or fuse-red) and from the definition of the multiset ordering
<ğ‘š (for the remaining three operations).

B.3 Proof of Lemma 40 (A).
Five operations.

It easily follows from Observation 63 that for every live query ğ‘„
there must exist a maximal variable ğ‘¥ âˆˆ ğ‘£ğ‘ğ‘Ÿ (ğ‘„). By this we mean
that ğ‘¥ âˆ‰ ğ‘‰ and that no atom of the form ğ¸ (ğ‘¥, ğ‘§) occurs in ğ‘(ğ‘„) for
ğ¸ âˆˆ {ğº, ğ‘…}. Note that:

Lemma 68. Let ğ‘¥ be a maximal variable of a live query âŸ¨ğœ™ ( Â¯ğ‘¦), ğ‘‰ âŸ©.

Then one of the following condition holds:

(i) ğ‘¥ occurs in exactly one atom ğ¸ (ğ‘§, ğ‘¥), with ğ¸ âˆˆ {ğº, ğ‘…};
(ii) ğ‘¥ occurs in exactly two atoms ğ‘…(ğ‘¥ğ‘Ÿ , ğ‘¥) and ğº (ğ‘¥ğ‘”, ğ‘¥) for some

ğ‘¥ğ‘Ÿ , ğ‘¥ğ‘”;

(iii) there exist at least two vertices ğ‘§ â‰  ğ‘§ â€² and ğ¸ âˆˆ {ğº, ğ‘…} such

that ğ¸ (ğ‘§, ğ‘¥) and ğ¸ (ğ‘§ â€², ğ‘¥) are atoms of ğœ™ ( Â¯ğ‘¦).

As promised, now we can define the five operations.

Suppose ğ‘„ = âŸ¨ğœ™ ( Â¯ğ‘¦), ğ‘‰ âŸ© is a live query and ğ‘¥ âˆˆ ğ‘£ğ‘ğ‘Ÿ (ğ‘„).

Definition 69 (cut-red). Suppose ğ‘¥ is as in Lemma 68(i), with
ğ¸ = ğ‘…. Define cut-red(ğ‘„, ğ‘¥) as âŸ¨ğœ™ â€²( Â¯ğ‘¦), ğ‘‰ (ğ‘„)âŸ© where ğœ™ â€²( Â¯ğ‘¦) is created
from ğœ™ ( Â¯ğ‘¦) by removing the sole atom containing ğ‘¥.

Operation cut-green is defined in an analogous way.

Definition 70 (fuse-red). Let ğ‘¥, ğ‘§ and ğ‘§ â€² be as in Lemma 68 (iii),
with ğ¸ = ğ‘…. Then fuse-red(ğ‘„, ğ‘¥, ğ‘§, ğ‘§ â€²) = âŸ¨ğœ™ â€²( Â¯ğ‘¦), ğ‘‰ âŸ© where ğœ™ â€²( Â¯ğ‘¦) is
ğœ™ ( Â¯ğ‘¦) with all occurences of ğ‘§ â€² renamed7 as ğ‘§.

Operation fuse-green is defined in an analogous way.

Definition 71 (reduce). Suppose ğ‘¥ is as in Lemma 68 (ii). Let
ğœ™ â€²( Â¯ğ‘¦) be a query obtained from ğœ™ ( Â¯ğ‘¦) by removing atoms ğ‘…(ğ‘¥ğ‘Ÿ , ğ‘¥) and
ğº (ğ‘¥ğ‘”, ğ‘¥) and replacing them with atoms ğº (ğ‘¥ â€², ğ‘¥ â€²â€²), ğº (ğ‘¥ â€²â€², ğ‘¥ğ‘Ÿ ), ğ‘…(ğ‘¥ â€², ğ‘¥ğ‘”)
where ğ‘¥ â€² and ğ‘¥ â€²â€² are fresh variables. Then define reduce(ğ‘„, ğ‘¥) as
the set of four marked queries âŸ¨ğœ™ â€²( Â¯ğ‘¦), ğ‘‰ (ğ‘„)âŸ©, âŸ¨ğœ™ â€²( Â¯ğ‘¦), ğ‘‰ (ğ‘„) âˆª {ğ‘¥ â€²}âŸ©,
âŸ¨ğœ™ â€²( Â¯ğ‘¦), ğ‘‰ (ğ‘„) âˆª {ğ‘¥ â€², ğ‘¥ â€²â€²}âŸ© and âŸ¨ğœ™ â€²( Â¯ğ‘¦), ğ‘‰ (ğ‘„) âˆª {ğ‘¥ â€²â€²}âŸ©8.

Now, Lemma 64 easily follows from Lemma 68 and from Defini-

tions 69â€“71.

The next thing left to be proven in this section is Lemma 66.
Notice that claim (i) of the Lemma is now obvious: cut-red just
removes a single red edge and fuse-red merges two red edges into
one. In order to prove claims (ii)-(iv) however one needs to work a
little bit harder.

Ranks. We are now going to define the rank ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) for a
live query ğ‘„ and an atom ğ›¼ âˆˆ ğ‘„G. To this end we consider paths,
from some marked variable to ğ›¼, traversing edges of ğ‘(ğ‘„) (in both
directions). To be more precise:

Definition 72. Given a live query ğ‘„ an ğ‘…-path is a finite sequence

ğ‘ƒ such that:
â€¢ each of the elements of ğ‘ƒ is either ğ¸ (ğ‘¡, ğ‘§) or ğ¸-1 (ğ‘§, ğ‘¡) for some ğ¸ (ğ‘¡, ğ‘§)
from ğ‘(ğ‘„), where ğ¸ âˆˆ {ğº, ğ‘…} (obviously, ğ¸-1 (ğ‘§, ğ‘¡) means that we
traverse ğ¸ (ğ‘¡, ğ‘§) backwards);

7One could wonder what happens if one of the two variables we unify is in ğ‘‰ and the
other is not in ğ‘‰ . But this is prohibited by Observation 63 (iii).
8Note that âŸ¨ğœ™â€² ( Â¯ğ‘¦), ğ‘‰ (ğ‘„) âˆª {ğ‘¥ â€²â€² }âŸ© is not properly marked, and thus not live, and it
will in no way contribute to our process any more.

A Journey to the Frontiers of Query Rewritability
(Extended Technical Report)

â€¢ if ğ¸ (ğ‘ , ğ‘¡) and ğ¸ â€²(ğ‘¢, ğ‘§) are two consecutive elements of ğ‘ƒ then ğ‘¡ = ğ‘¢
(where ğ¸, ğ¸ â€² âˆˆ {ğº, ğ‘…, ğº -1, ğ‘…-1});
(â˜…) if ğ‘…(ğ‘¡, ğ‘§) is an atom of ğ‘(ğ‘„) then only one of ğ‘…(ğ‘¡, ğ‘§) or ğ‘…-1 (ğ‘§, ğ‘¡)
can appear in ğ‘ƒ and it can appear at most once.

Notice that an atom ğº (ğ‘¡, ğ‘§) of ğ‘(ğ‘„), as well as ğº -1 (ğ‘§, ğ‘¡), can ap-
pear any number of times in a ğ‘…-path. Each ğ‘…-path has its elevation
and its cost9:

Definition 73 (elevation and cost). For an empty ğ‘…-path âˆ…
we define ğ‘ğ‘œğ‘ ğ‘¡ (âˆ…) = 0 and ğ‘’ğ‘™ğ‘’ğ‘£ (âˆ…) = 3|ğ‘„R |. For a path ğ‘ƒ = ğ‘ƒ â€²ğ¸ (ğ‘¥, ğ‘§)
we define:

â€¢ ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ) = ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ â€²) if ğ¸ âˆ‰ {ğ‘…, ğ‘…-1}
â€¢ ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ) = 3 Â· ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ â€²) if ğ¸ = ğ‘…
â€¢ ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ) = 1
3 Â· ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ â€²) if ğ¸ = ğ‘…-1
â€¢ ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€²) + ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ â€²) if ğ¸ âˆˆ {ğº, ğº -1}
â€¢ ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€²) if ğ¸ âˆ‰ {ğº, ğº -1}

Notice that it follows from condition (â˜…) of Definition 72 that

ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ) is always a positive natural number.

Definition 74. For an atom ğ›¼ = ğº (ğ‘¢, ğ‘¢ â€²) in ğ‘(ğ‘„) by an ğ›¼-hike

we mean an ğ‘…-path such that:
â€¢ if ğ¸ (ğ‘¡, ğ‘§) or ğ¸-1 (ğ‘¡, ğ‘§) is the first atom of ğ‘ƒ then ğ‘¡ âˆˆ ğ‘‰ (ğ‘„);
â€¢ the last element of ğ‘ƒ is either ğº (ğ‘¢, ğ‘¢ â€²) or ğº -1 (ğ‘¢ â€², ğ‘¢).
For ğ›¼ âˆˆ ğ‘„G we denote the set of all ğ›¼-hikes as â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„).

Definition 75. For an atom ğ›¼ âˆˆ ğ‘„G its rank is defined as:

ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) = ğ‘šğ‘–ğ‘›({ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) : ğ‘ƒ âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„)}).

It is easy to see that:

Observation 76. For a marked query ğ‘„ and for ğ›¼ = ğº (ğ‘¢, ğ‘¢ â€²)
in ğ‘„G, if ğ‘ƒ âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„) and ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) then any of ğ›¼ or
ğº -1 (ğ‘¢ â€², ğ‘¢) can occur only as the last atom of ğ‘ƒ.

Now we can finally prove Lemma 66.

Proof of Lemma 66 (ii). Let ğ‘„ â€² = cut-green(ğ‘„, ğ‘¥). It follows di-
rectly from the construction that |ğ‘„R| = |ğ‘„ â€²
R|. Now take any ğ›¼ âˆˆ ğ‘„ â€²
G.
We need to show that ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) â‰¥ ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„ â€²). Let ğ‘§ âˆˆ ğ‘£ğ‘ğ‘Ÿ (ğ‘„) be
such that ğº (ğ‘§, ğ‘¥) is an atom of ğ‘(ğ‘„). Consider any ğ‘ƒ âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„).
Let ğ‘ƒ â€² be a path obtained from ğ‘ƒ by deleting each occurrence
of ğº (ğ‘§, ğ‘¥) and ğº -1 (ğ‘¥, ğ‘§). Then ğ‘ƒ â€² âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„ â€²) and ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€²) â‰¤
â–¡
ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ).
Proof of Lemma 66 (iii). Let ğ‘„ â€² = fuse-green(ğ‘„, ğ‘¥, ğ‘§, ğ‘§ â€²).

If (âˆ—) there exists a variable ğ‘¢ âˆˆ ğ‘£ğ‘ğ‘Ÿ (ğ‘„) such that atoms ğ‘…(ğ‘§, ğ‘¢)
and ğ‘…(ğ‘§ â€², ğ‘¢) are in ğ‘(ğ‘„), or that ğ‘…(ğ‘¢, ğ‘§) and ğ‘…(ğ‘¢, ğ‘§ â€²) are in ğ‘(ğ‘„),
then the two red edges merge in ğ‘(ğ‘„ â€²) and |ğ‘„R| > |ğ‘„ â€²
R|. Also, if (âˆ—âˆ—)
at least two of the atoms ğ‘…(ğ‘§, ğ‘§ â€²), ğ‘…(ğ‘§ â€², ğ‘§), ğ‘…(ğ‘§, ğ‘§), and ğ‘…(ğ‘§ â€², ğ‘§ â€²) are
in ğ‘(ğ‘„) then |ğ‘„R| > |ğ‘„ â€²
R|.

So suppose there is neither (âˆ—) nor (âˆ—âˆ—). Take any ğ›¼ âˆˆ ğ‘„ â€²
G and
ğ‘ƒ âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„). Consider path ğ‘ƒ â€² obtained from ğ‘ƒ by replacing
each occurrence of ğ‘§ â€² in ğ‘ƒ with ğ‘§. Obviously, ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€²).
We now will show that ğ‘ƒ â€² âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„ â€²). Clearly, one only needs
to worry if condition (â˜…) of Definition 72 holds. Suppose towards
contradiction that it does not. It can only happen when there exist
ğ‘ , ğ‘¡ âˆˆ ğ‘£ğ‘ğ‘Ÿ (ğ‘„ â€²) such that two atoms from {ğ‘…(ğ‘ , ğ‘¡), ğ‘…-1 (ğ‘¡, ğ‘ )} appear
in ğ‘ƒ.

9The cost of making a step depends on the current elevation. Current elevation depends
on the difference between the total ascent and total descent.

Let us assume that ğ‘…(ğ‘ , ğ‘¡) (other cases are analogous) appears
twice in ğ‘ƒ â€². But of course ğ‘…(ğ‘ , ğ‘¡) could not appear twice in ğ‘ƒ, which
is an ğ‘…-path. So at least one occurrence of ğ‘…(ğ‘ , ğ‘¡) in ğ‘ƒ â€² results from
the unification of ğ‘§ and ğ‘§ â€².

There are two cases: either (a) ğ‘  = ğ‘¡ = ğ‘§ or (b) exactly one of ğ‘ , ğ‘¡
equals ğ‘§. So suppose (b) happened and without loss of generality
assume that ğ‘  = ğ‘§. We know that there was ğ‘…(ğ‘§, ğ‘¡) and ğ‘…(ğ‘§ â€², ğ‘¡) in
ğ‘ƒ and they both unified to ğ‘…(ğ‘§, ğ‘¡) in ğ‘ƒ â€². But this would imply (âˆ—),
leading to a contradiction. The remaining case (a) is that ğ‘…(ğ‘§, ğ‘§)
occurs twice in ğ‘ƒ â€². But this would need (âˆ—âˆ—) to be true, which is a
contradiction again.

So ğ‘ƒ â€² âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„ â€²) and ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) â‰¥ ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„ â€²).

â–¡

Proof of Lemma 66 (iv). Let ğ‘„ â€² be any of the marked queries in
reduce(ğ‘„, ğ‘¥). Let ğ‘¥ğ‘Ÿ and ğ‘¥ğ‘” be variables of ğ‘„ such that ğº (ğ‘¥ğ‘”, ğ‘¥) and
ğ‘…(ğ‘¥ğ‘Ÿ , ğ‘¥) are atoms of ğ‘(ğ‘„). Recall that ğ‘¥ â€², ğ‘¥ â€²â€² âˆˆ ğ‘£ğ‘ğ‘Ÿ (ğ‘„ â€²) are two
new variables added by reduce.

Clearly, |ğ‘„ â€²

R| = |ğ‘„R|, since when creating ğ‘(ğ‘„ â€²) from ğ‘(ğ‘„) we

have just replaced one red edge with another.

Let us first show claim (c). Take some ğ›½ âˆˆ ğ‘„G âˆ© ğ‘„ â€²

G and ğ‘ƒ âˆˆ
â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›½, ğ‘„) such that ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘’ğ‘Ÿğ‘˜ (ğ›½, ğ‘„). Our goal is to find ğ‘ƒ â€² âˆˆ
â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›½, ğ‘„ â€²) such that ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€²) â‰¤ ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ).

Obviously, one can assume that ğ‘ƒ does not contain, as a con-
nected subsequence, ğº (ğ‘¥ğ‘”, ğ‘¥)ğº -1 (ğ‘¥, ğ‘¥ğ‘”). If it did, we could remove
such subsequence to get a new ğ‘ƒ with lower cost. And, as an R-path,
ğ‘ƒ does not contain subsequence ğ‘…(ğ‘¥ğ‘Ÿ , ğ‘¥)ğ‘…-1 (ğ‘¥, ğ‘¥ğ‘Ÿ ) either.

If no atom of ğ‘ƒ contains ğ‘¥ then ğ‘ƒ âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›½, ğ‘„ â€²) and thus we
set ğ‘ƒ â€² = ğ‘ƒ. Otherwise it contains exactly one of ğ‘…(ğ‘¥ğ‘Ÿ , ğ‘¥)ğº -1 (ğ‘¥, ğ‘¥ğ‘”)
or ğº (ğ‘¥ğ‘”, ğ‘¥)ğ‘…-1 (ğ‘¥, ğ‘¥ğ‘Ÿ ) as a connected subsequence. Suppose ğ‘ƒ =
ğ‘ƒ0ğ‘…(ğ‘¥ğ‘Ÿ , ğ‘¥)ğº -1 (ğ‘¥, ğ‘¥ğ‘”)ğ‘ƒ1. Let ğ´ = ğº -1 (ğ‘¥ğ‘Ÿ , ğ‘¥ â€²â€²)ğº -1 (ğ‘¥ â€²â€², ğ‘¥ â€²)ğ‘…(ğ‘¥ â€², ğ‘¥ğ‘”) and
consider path ğ‘ƒ â€² = ğ‘ƒ0ğ´ğ‘ƒ1. Note that ğ‘ƒ â€² âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›½, ğ‘„). Now we
need to show that ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) > ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€²). But:
ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ0) + 3 Â· ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ0) + 3 Â· ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ0) Â· ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ1)
ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€²) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ0) + 2 Â· ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ0) + 3 Â· ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ0) Â· ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ1)
The case when ğ‘ƒ = ğ‘ƒ0ğº (ğ‘¥ğ‘”, ğ‘¥)ğ‘…-1 (ğ‘¥, ğ‘¥ğ‘Ÿ )ğ‘ƒ1, is similar.
Let us now move to claim (b). Take ğ‘ƒ âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„) such that
ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„). We are going to build a path ğ‘ƒ â€² âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼ â€², ğ‘„ â€²)
such that ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€²) < ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ).

There are two cases depending on the last atom of ğ‘ƒ:
In the first case ğ‘ƒ is ğ‘ƒ0ğº (ğ‘¥ğ‘”, ğ‘¥). Let then ğ‘ƒ â€² be

ğ‘ƒ0ğ‘…-1 (ğ‘¥ğ‘”, ğ‘¥ â€²)ğº (ğ‘¥ â€², ğ‘¥ â€²â€²) or ğ‘ƒ0ğ‘…-1 (ğ‘¥ğ‘”, ğ‘¥ â€²)ğº (ğ‘¥ â€², ğ‘¥ â€²â€²)ğº (ğ‘¥ â€²â€², ğ‘¥ğ‘Ÿ ) (depend-
ing on whether ğ›¼ â€² is ğº (ğ‘¥ â€², ğ‘¥ â€²â€²) or ğº (ğ‘¥ â€²â€², ğ‘¥ğ‘Ÿ )). Then of course ğ‘ƒ â€² âˆˆ
â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼ â€², ğ‘„) and ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ0) + ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ0) while ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€²) â‰¤
ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ0) + 2

3 Â· ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ0).

The second case is that ğ‘ƒ = ğ‘ƒ0ğ‘…(ğ‘¥ğ‘Ÿ , ğ‘¥)ğº -1 (ğ‘¥, ğ‘¥ğ‘”). Here the argu-

ment is similar. Now we take ğ‘ƒ â€² = ğ‘ƒ0ğº -1 (ğ‘¥ğ‘Ÿ , ğ‘¥ â€²â€²) or
ğ‘ƒ â€² = ğ‘ƒ0ğº -1 (ğ‘¥ğ‘Ÿ , ğ‘¥ â€²â€²)ğº -1 (ğ‘¥ â€²â€², ğ‘¥ â€²) (again depending on whether ğ›¼ â€² is
ğº (ğ‘¥ â€², ğ‘¥ â€²â€²) or ğº (ğ‘¥ â€²â€², ğ‘¥ğ‘Ÿ )). Then ğ‘ƒ â€² âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼ â€², ğ‘„) and ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) =
ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ0) + 3 Â· ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ0) while ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€²) â‰¤ ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ0) + 2 Â· ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ0) . â–¡

B.4 Proof of Lemma 65
Let ğ‘„ = âŸ¨ğœ™ ( Â¯ğ‘¦), ğ‘‰ âŸ© be any live marked query.

Lemma 65 will follow directly from Lemmas 77â€“79:

Lemma 77. For any set of facts D, tuple Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘¦ | and ğ‘¥
such that ğ‘„ â€² = cut-green(ğ‘„, ğ‘¥) (or ğ‘„ â€² = cut-red(ğ‘„, ğ‘¥)) the following

holds:

Ch(Tğ‘‘, D) |= ğ‘„ ( Â¯ğ‘) â‡â‡’ Ch(Tğ‘‘, D) |= ğ‘„ â€²( Â¯ğ‘).

Proof. Let ğº (ğ‘§, ğ‘¥) be the atom removed from ğ‘(ğ‘„) by cut-green.
(â‡’). It follows immediately as ğ‘(ğ‘„ â€²) is a subset of ğ‘(ğ‘„) and

ğ‘‰ (ğ‘„ â€²) = ğ‘‰ (ğ‘„).

(â‡). Let â„â€² be a homomorphism witnessing that Ch(Tğ‘‘, D) |=
ğ‘„ â€²( Â¯ğ‘). Due to the rule (ğ‘ğ‘–ğ‘›ğ‘ ) of ğ‘Ÿğ‘¢ğ‘™ğ‘’ğ‘ ğ‘’ğ‘¡ğ‘‘ there must exist ğ‘¡ âˆˆ
ğ‘‘ğ‘œğ‘š(Ch(Tğ‘‘, D)) such that ğº (â„â€²(ğ‘§), ğ‘) âˆˆ Ch(Tğ‘‘, D). Define a new
homomorphism â„ as â„â€² âˆª âŸ¨ğ‘¥, ğ‘¡âŸ©. Then â„ is a homomorphism wit-
nessing that Ch(Tğ‘‘, D) |= ğ‘„ ( Â¯ğ‘).

The proof for cut-red is analogous.

â–¡

Lemma 78. For any set of facts D, tuple Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘¦ | and ğ‘¥, ğ‘§, ğ‘§ â€²
such that ğ‘„ â€² = fuse-green(ğ‘„, ğ‘¥, ğ‘§, ğ‘§ â€²) (or ğ‘„ â€² = fuse-red(ğ‘„, ğ‘¥, ğ‘§, ğ‘§ â€²))
the following holds:

Ch(Tğ‘‘, D) |= ğ‘„ ( Â¯ğ‘) â‡â‡’ Ch(Tğ‘‘, D) |= ğ‘„ â€²( Â¯ğ‘).

Proof. Note that there exists a homomorphism (the one that
identifies ğ‘§ â€² with ğ‘§) from ğ‘(ğ‘„) to ğ‘(ğ‘„ â€²) which preserves markings
of variables. Thus (â‡) is trivial.

(â‡’). Let â„ be a homomorphism witnessing that Ch(Tğ‘‘, D) |=
ğ‘„ ( Â¯ğ‘). If we can show that â„(ğ‘§) = â„(ğ‘§ â€²) then â„ will witness that
Ch(Tğ‘‘, D) |= ğ‘„ â€²( Â¯ğ‘) as well. First recall that, since ğ‘¥ âˆ‰ ğ‘‰ (ğ‘„) we
can be sure that â„(ğ‘¥) âˆˆ ğ‘‘ğ‘œğ‘š(Ch(Tğ‘‘, D) \ ğ‘‘ğ‘œğ‘š(D). Then notice
that it follows from the rules of Tğ‘‘ that the in-degree, with respect
to relation ğº, of any term of ğ‘‘ğ‘œğ‘š(Ch(Tğ‘‘, D) \ ğ‘‘ğ‘œğ‘š(D) is at most
one. Thus the only way for Ch(Tğ‘‘, D) |= ğ‘„ ( Â¯ğ‘) to happen is that
â„(ğ‘§) = â„(ğ‘§ â€²) thus Ch(Tğ‘‘, D) |= ğ‘„ â€²( Â¯ğ‘). The proof for fuse-red is
â–¡
analogous.

Lemma 79. For any set of facts D, tuple Â¯ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) | Â¯ğ‘¦ | and ğ‘¥ such

that Q = reduce(ğ‘„, ğ‘¥) the following holds:

Ch(Tğ‘‘, D) |= ğ‘„ ( Â¯ğ‘) â‡â‡’ âˆƒğ‘„ â€² âˆˆ Q Ch(Tğ‘‘, D) |= ğ‘„ â€²( Â¯ğ‘).

Proof. Let ğ‘¥ â€², ğ‘¥ â€²â€², ğ‘¥ğ‘Ÿ , and ğ‘¥ğ‘” be variables of ğ‘(ğ‘„) such that
ğ‘…(ğ‘¥ğ‘Ÿ , ğ‘¥), ğº (ğ‘¥ğ‘”, ğ‘¥) âˆˆ ğ‘(ğ‘„) and that ğ‘…(ğ‘¥ â€², ğ‘¥ğ‘”), ğº (ğ‘¥ â€², ğ‘¥ â€²â€²), ğº (ğ‘¥ â€²â€², ğ‘¥ğ‘Ÿ ) âˆˆ
ğ‘(ğ‘„ â€²).

(â‡). Let ğ‘„ â€² âˆˆ Q be such that Ch(Tğ‘‘, D) |= ğ‘„ â€²( Â¯ğ‘) and let â„â€² be a
homomorphism witnessing that. We need to show that there exists
a homomorphism â„ witnessing Ch(Tğ‘‘, D) |= ğ‘„ ( Â¯ğ‘).

Since ğ‘…(ğ‘¥ â€², ğ‘¥ğ‘”), ğº (ğ‘¥ â€², ğ‘¥ â€²â€²), ğº (ğ‘¥ â€²â€², ğ‘¥ğ‘Ÿ ) are atoms of ğ‘(ğ‘„), and â„â€² is
a homomorphism, we know that ğ‘…(â„â€²(ğ‘¥ğ‘”), â„â€²(ğ‘¥ â€²)), ğº (â„â€²(ğ‘¥ â€²), â„â€²(ğ‘¥ â€²â€²))
and ğº (â„â€²(ğ‘¥ â€²â€²), â„â€²(ğ‘¥ğ‘Ÿ )) are atoms of Ch(Tğ‘‘, D). But, since (ğ‘”ğ‘Ÿğ‘–ğ‘‘) is
a rule of Tğ‘‘ , this implies that there exists an element ğ‘¡ âˆˆ Ch(Tğ‘‘, D),
such that ğº (â„â€²(ğ‘¥ğ‘”), â„â€²(ğ‘¡)) and ğ‘…(â„â€²(ğ‘¥ğ‘Ÿ ), â„â€²(ğ‘¡)) are also in Ch(Tğ‘‘, D).

Define â„ by:

â€¢ â„(ğ‘¢) = â„â€²(ğ‘¢) for ğ‘¢ âˆˆ ğ‘£ğ‘ğ‘Ÿ (ğ‘„) \ {ğ‘¥ }.
â€¢ â„(ğ‘¥) = ğ‘¡.

(â‡’). Let â„ be a homomorphism witnessing that Ch(Tğ‘‘, D) |=
ğ‘„ ( Â¯ğ‘). We will show that there exist ğ‘„ â€² âˆˆ Q and a homomorphism
â„â€² such that â„â€² is witnessing Ch(Tğ‘‘, D) |= ğ‘„ â€²( Â¯ğ‘). Again recall that
ğ‘¥ is an unmarked variable and so let us find parents of â„(ğ‘¥) in
Ch(Tğ‘‘, D). Note that â„(ğ‘¥) could be created only by rule (ğ‘”ğ‘Ÿğ‘–ğ‘‘) as
it has an in-degree of two. Let ğœ be such that ğ‘ğ‘ğ‘ğ‘™ ((ğ‘”ğ‘Ÿğ‘–ğ‘‘), ğœ) =
ğ‘…(â„(ğ‘¥ğ‘Ÿ ), â„(ğ‘¥)), ğº (â„(ğ‘¥ğ‘”), â„(ğ‘¥)). We set:

â„â€² = â„ \ {ğ‘¥, â„(ğ‘¥)} âˆª {âŸ¨ğ‘¥ â€², ğœ (ğ‘¥)âŸ©, âŸ¨ğ‘¥ â€²â€², ğœ (ğ‘¦)âŸ©}.

Piotr Ostropolski-Nalewaja, Jerzy Marcinkowski, David Carral, and Sebastian Rudolph

There are four possible picks for ğ‘„ â€² from Q. While homomorphism
â„â€² works for any of them as elements of Q differ only by markings,
we need to make sure that the marking of ğ‘„ â€² agrees with â„â€². Ob-
viously for every variable of ğ‘„ this is the case. However we have
two new variables to consider, namely ğ‘¥ â€² and ğ‘¥ â€²â€². Thus we need to
take ğ‘„ â€² such that it satisfies:

â€¢ â„â€²(ğ‘¥ â€²) is a constant of D if and only if ğ‘¥ â€² âˆˆ ğ‘‰ (ğ‘„ â€²).
â€¢ â„â€²(ğ‘¥ â€²â€²) is a constant of D if and only if ğ‘¥ â€²â€² âˆˆ ğ‘‰ (ğ‘„ â€²).

This is trivially possible due to Definition 71.

â–¡

Appendix C GENERALIZATION OF LEMMA 40
For ğ¾ âˆˆ N define T ğ¾
as the theory, over Î£ğ¾ = {ğ¼ğ¾ , ğ¼ğ¾âˆ’1, . . . ğ¼1}
ğ‘‘
(each ğ¼ğ‘˜ is a binary relation symbol), comprising, for each 1 â‰¤ ğ‘– < ğ¾
and each 1 â‰¤ ğ‘˜ â‰¤ ğ¾ the following 2ğ¾ + 1 rules:
(ğ‘™ğ‘œğ‘œğ‘)
(ğ‘ğ‘–ğ‘›ğ‘˜ )
(ğ‘”ğ‘Ÿğ‘–ğ‘‘ğ‘– )

ğ¼ğ‘–+1 (ğ‘¥, ğ‘¥ â€²), ğ¼ğ‘– (ğ‘¥, ğ‘¢), ğ¼ğ‘– (ğ‘¢, ğ‘¢ â€²) â‡’ âˆƒğ‘§ ğ¼ğ‘–+1 (ğ‘¢ â€², ğ‘§), ğ¼ğ‘– (ğ‘¥ â€², ğ‘§)

ğ‘¡ğ‘Ÿğ‘¢ğ‘’ â‡’ âˆƒğ‘¥ ğ¼ğ¾ (ğ‘¥, ğ‘¥), ğ¼ğ¾âˆ’1 (ğ‘¥, ğ‘¥), . . . ğ¼1 (ğ‘¥, ğ‘¥)

âˆ€ğ‘¥ ( ğ‘¡ğ‘Ÿğ‘¢ğ‘’ â‡’ âˆƒğ‘§ ğ¼ğ‘˜ (ğ‘¥, ğ‘§) )

Using the ideas from Appendix B one can now show that:

Lemma 80. For each ğ¾ âˆˆ N:

is BDD;

A. theory T ğ¾
ğ‘‘
B. there is a query ğœ“ (ğ‘¦, ğ‘¦ â€²) such that ğ‘Ÿğ‘’ğ‘¤
of size (ğ¾-1)-fold exponential in the size of ğœ“ .

Tğ¾
ğ‘‘

(ğœ“ (ğ‘¦, ğ‘¦ â€²)) contains a CQ

Like in the case of Lemma 40, claim B of Lemma 80 is relatively

easy to prove.

For the proof of claim A, properly marked queries first need to be
slightly redefined (but let us skip it here). Then the five operations
need to be generalized in the natural way: we will now have ğ¾ cut
operations, ğ¾ fuse operations, and ğ¾-1 reduce operations.

The non-obvious part is how to modify the ranks ğ‘’ğ‘Ÿğ‘˜ and ğ‘ğ‘Ÿğ‘˜
so that they do their job correctly in the new circumstances. For
that ğ¼ğ‘– -paths need to be defined (for 1 â‰¤ ğ‘– < ğ¾), analogous to
ğ‘…-paths in Definition 72. But now the condition (â˜…) will apply to
atoms of the relation ğ¼ğ‘– (including ğ¼ -1
ğ‘– ). Then ğ‘–-elevation (ğ‘’ğ‘™ğ‘’ğ‘£ğ‘– ) will
be defined, like in Definition 73. And finally, we will need ğ‘ğ‘œğ‘ ğ‘¡ğ‘– of
a path, calculated almost like the cost of the path in Definition 73:
for a path ğ‘ƒ = ğ‘ƒ â€²ğ¸ (ğ‘¥, ğ‘§) we have ğ‘ğ‘œğ‘ ğ‘¡ğ‘– (ğ‘ƒ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€²) + ğ‘’ğ‘™ğ‘’ğ‘£ğ‘– (ğ‘ƒ â€²) if
ğ‘–âˆ’1 and ğ‘ğ‘œğ‘ ğ‘¡ğ‘– (ğ‘ƒ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€²) otherwise. Notice that ğ¼ğ‘–
ğ¸ = ğ¼ğ‘–âˆ’1 or ğ¼ -1
is the new red and ğ¼ğ‘–âˆ’1 is the new green. Note also that we have a
new situation: ğ¸ may now very well be neither â€œgreenâ€ nor â€œredâ€.
And that is fine, in such case it neither contributes to the elevation
nor to the cost of the path.

Having the function ğ‘ğ‘œğ‘ ğ‘¡ğ‘– , rank ğ‘’ğ‘Ÿğ‘˜ (ğ›¼) of an atom ğ›¼ of the re-
lation ğ¼ğ‘–âˆ’1 is (like in Appendix B.3) defined as minimal ğ‘ğ‘œğ‘ ğ‘¡ğ‘– of
an ğ¼ğ‘– -path from some marked variable to ğ›¼, and rank ğ‘ğ‘Ÿğ‘˜ğ‘– (ğ‘„) is
the multiset of all ranks ğ‘’ğ‘Ÿğ‘˜ (ğ›¼) of all atoms ğ›¼ of ğ¼ğ‘–âˆ’1 in ğ‘„. Finally,
ğ‘ğ‘Ÿğ‘˜ (ğ‘„) is the tuple:

âŸ¨|ğ‘„ğ¾ |, ğ‘ğ‘Ÿğ‘˜ğ¾ (ğ‘„), |ğ‘„ğ¾âˆ’1|, ğ‘ğ‘Ÿğ‘˜ğ¾âˆ’1 (ğ‘„), . . . |ğ‘„2|, ğ‘ğ‘Ÿğ‘˜2 (ğ‘„)âŸ©
where |ğ‘„ğ‘– | is the number of the atoms of the relation ğ¼ğ‘– in ğ‘„. Clearly,
the lexicographic ordering on the set of such ranks is a well order-
ing. Now, a careful case inspection shows that each of the 3ğ¾-1
operations decreases the rank of a query.

Appendix D REMARKS ON Tğ‘‘
There are two technical problems one needs to deal with here:

A Journey to the Frontiers of Query Rewritability
(Extended Technical Report)

(1) There are conjunctions in the heads of rules (loop) and (grid)
(notice that the rule (pins) can be simply split into two single-
head rules).

(2) we have predicate "true" in the bodies of rules (loop) and

(pins)

To deal with the first problem we could introduce a new ternary

predicate ğ‘‡ , and rewrite the rules as:

(ğ‘™ğ‘œğ‘œğ‘)
(ğ‘”ğ‘Ÿğ‘–ğ‘‘)

ğ‘¡ğ‘Ÿğ‘¢ğ‘’ â‡’ âˆƒğ‘¥ğ‘‡ (ğ‘¥, ğ‘¥, ğ‘¥)
ğ‘…(ğ‘¥, ğ‘¥ â€²), ğº (ğ‘¥, ğ‘¢), ğº (ğ‘¢, ğ‘¢ â€²) â‡’ âˆƒğ‘§ğ‘‡ (ğ‘¢ â€², ğ‘¥ â€², ğ‘§)

Then add Datalog rules:

ğ‘‡ (ğ‘¥, ğ‘¦, ğ‘§) â‡’ ğ‘…(ğ‘¥, ğ‘§)
ğ‘‡ (ğ‘¥, ğ‘¦, ğ‘§) â‡’ ğº (ğ‘¦, ğ‘§)

ğ‘…(ğ‘¥, ğ‘§), ğº (ğ‘¦, ğ‘§) â‡’ ğ‘‡ (ğ‘¥, ğ‘¦, ğ‘§)

In this way ğ‘‡ (ğ‘¥, ğ‘¦, ğ‘§) is just a macro for ğ‘…(ğ‘¥, ğ‘§) and ğº (ğ‘¦, ğ‘§) and
clearly the transformation does not change the BDD status of the
theory.

To deal with the second problem we need to replace the predicate
"true" with something like "if anything at all exists". For rule (loop)
it would mean that it should be replaced with three rules:

ğ‘…(ğ‘¦, ğ‘§) â‡’ âˆƒğ‘¥ğ‘‡ (ğ‘¥, ğ‘¥, ğ‘¥)
ğº (ğ‘¦, ğ‘§) â‡’ âˆƒğ‘¥ğ‘‡ (ğ‘¥, ğ‘¥, ğ‘¥)
ğ‘‡ (ğ‘¡, ğ‘¦, ğ‘§) â‡’ âˆƒğ‘¥ğ‘‡ (ğ‘¥, ğ‘¥, ğ‘¥)

This transformation leads to a theory which is equivalent to our
Tğ‘‘ on all nonempty instances, but this is of course good enough.
An analogous (albeit slightly more complicated) trick works for

(pins).

Appendix E STICKY AND BD-LOCAL
Here we prove the following observation:

Observation 81. Every connected sticky theory is bd-local

Proof. Let T be a connected sticky theory and D be any in-
stance with ğ‘˜ being its degree. Let ğ´( (cid:174)ğ‘) be an atom of Ch(T , D)
and F be the minimal subset of D such that ğ´( (cid:174)ğ‘) âˆˆ Ch(T , F). We
show that |F| depends only on T and ğ‘˜. As T is connected and
sticky we know that if |F| > 1 then every fact of F needs to contain
some term of (cid:174)ğ‘. From this we conclude that |F| â‰¤ | (cid:174)ğ‘|ğ‘˜, thus we
â–¡
know that T is local.

