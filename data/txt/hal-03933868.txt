A study of the discovery and redundancy of link keys
between two RDF datasets based on partition pattern
structures
Nacira Abbas, Alexandre Bazin, JÃ©rÃ´me David, Amedeo Napoli

To cite this version:

Nacira Abbas, Alexandre Bazin, JÃ©rÃ´me David, Amedeo Napoli. A study of the discovery and redun-
dancy of link keys between two RDF datasets based on partition pattern structures. CLA 2022 - 16th
International Conference on Concept Lattices and Their Applications, Jun 2022, Tallinn, Estonia.
pp.175-189. ï¿¿hal-03933868ï¿¿

HAL Id: hal-03933868

https://hal.science/hal-03933868

Submitted on 10 Jan 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

Lâ€™archive ouverte pluridisciplinaire HAL, est
destinÃ©e au dÃ©pÃ´t et Ã  la diffusion de documents
scientifiques de niveau recherche, publiÃ©s ou non,
Ã©manant des Ã©tablissements dâ€™enseignement et de
recherche franÃ§ais ou Ã©trangers, des laboratoires
publics ou privÃ©s.

Distributed under a Creative Commons Attribution 4.0 International License

A Study of the Discovery and Redundancy of Link
Keys Between Two RDF Datasets Based on Partition
Pattern Structures

Nacira Abbas1, Alexandre Bazin2, JÃ©rÃ´me David3 and Amedeo Napoli1,âˆ—

1UniversitÃ© de Lorraine, CNRS, Inria, Loria, F-54000 Nancy, France
2UniversitÃ© de Montpellier, CNRS, LIRMM, F-34095 Montpellier, France
3UniversitÃ© Grenoble Alpes, Inria, CNRS, Grenoble INP, LIG, F-38000 Grenoble, France

Abstract
A link key between two RDF datasets ğ·1 and ğ·2 is a set of pairs of properties allowing to identify pairs
of individuals ğ‘¥1 and ğ‘¥2 through an identity link such as x1 owl âˆ¶ sameAs x2. In this paper, relying on
and extending previous work, we introduce an original formalization of link key discovery based on the
framework of Partition Pattern Structures (pps). Our objective is to study and evaluate the redundancy
of link keys based on the fact that owl:sameAs is an equivalence relation. In the pps concept lattice,
every concept has an extent representing a link key candidate and an intent representing a partition of
instances into sets of equivalent instances. Experiments show three main results. Firstly redundancy of
link keys is not so significant in real-world datasets. Nevertheless, the link key discovery approach based
on pps returns a reduced number of non redundant link key candidates when compared to a standard
approach. Moreover, the pps-based approach is efficient and returns link keys of high quality.

1. Introduction

In this paper, we are interested in data interlinking whose objective is to discover identity
links across two RDF datasets over the web of data [1, 2, 3]. The same real world entity
can be represented in two RDF datasets by different subjects in RDF triples having the form
(subject, property, object). Then, for cleaning data and providing data of better quality,
it is meaningful to detect such identities. There are both numerical and logical approaches
for discovering these identities. For example, interlinking methods have been implemented in
systems such as LIMES [4] and SILK [5]. These systems use link specifications, i.e. rules that
declare whether two IRIs should be linked. Link specifications can also be specified by users or
learned from data [6, 7, 8].

In particular, link keys which are under investigation in this paper are special kinds of
rules allowing to infer identity links between two RDF datasets. More formally, a link key
is composed of two sets of pairs of properties ({(ğ‘ğ‘–, ğ‘ğ‘–)}ğ‘–, {(ğ‘â€²
ğ‘— )}ğ‘—) associated with a pair of

ğ‘— , ğ‘â€²

Published in Pablo Cordero, Ondrej Kridlo (Eds.): The 16ğ‘¡â„ International Conference on Concept Lattices and Their
Applications, CLA 2022, Tallinn, Estonia, June 20â€“22, 2022, Proceedings, pp. 175â€“189.
âˆ—Corresponding author.
Envelope-Open Nacira.Abbas@inria.fr (N. Abbas); Alexandre.Bazin@umontpellier.fr (A. Bazin); Jerome.David@inria.fr
(J. David); Amedeo.Napoli@loria.fr (A. Napoli)

Â© 2022 Copyright for this paper by its authors. Use permitted under Creative Commons License Attribution 4.0 International (CC BY 4.0).
CEUR Workshop Proceedings (CEUR-WS.org)

CEURWorkshopProceedingshttp://ceur-ws.orgISSN 1613-0073classes (ğ‘1, ğ‘2). Then, whenever an instance ğ‘1 of class ğ‘1 has the same (non empty) set of
values as an instance ğ‘1 of class ğ‘2, i.e. ğ‘ğ‘–(ğ‘1) = ğ‘ğ‘–(ğ‘1) for all pairs of properties in the first set
(universal quantification), and shares at least one value for all pairs of properties in the second
set (existential quantification), i.e. ğ‘â€²
ğ‘— (ğ‘1) â‰  âˆ…, then ğ‘1 and ğ‘1 denote the same entity, i.e.,
an owl:sameAs relation can be established between ğ‘1 and ğ‘1. More concretely, the expression
k=({(designation,title)},{(designation,title),(creator,author)}, (Book,Novel))
states that whenever an instance ğ‘ of class Book has the same non empty values for the property
designation as an instance ğ‘ of the class Novel for title, and that ğ‘ and ğ‘ share at least one
value for the properties creator and author, then ğ‘ and ğ‘ denote the same entity a owl:sameAs
link can be established between ğ‘ and ğ‘.

ğ‘— (ğ‘1) âˆ© ğ‘â€²

Link keys are not provided with the datasets and algorithms are designed for automatically
discovering such link keys [9, 10, 11]. Given two RDF datasets, these algorithms reduce the
search space and focus on the discovery of â€œlink key candidatesâ€ instead of checking every
combination of pairs of properties and pairs of classes. The notion of a link key candidate
â€“made precise belowâ€“ involves maximality and closure. Following this line, natural links were
established in [10, 11] between link key discovery and Formal Concept Analysis (FCA [12]).
Indeed, FCA appeared as a suitable framework for the discovery of link key candidates, which
are then evaluated thanks to appropriate quality measures [9].

Given two RDF datasets, FCA is applied in [10] to a binary table where rows correspond
to pairs of individuals and columns to pairs of properties. The intent of a resulting concept
corresponds to a link key candidate, which remains to be validated thanks to suitable quality
measures. The extent of the concept includes the potential identity links between individuals. A
generalization of the former approach is proposed in [11], which is based on pattern structures
[13] and which takes into account different pairs of classes at the same time in the discovery of
link keys.

Actually, â€œgoodâ€ link key candidates over two RDF datasets have to generate different and
maximal link sets, i.e., a mapping between individuals which is â€œclose to a bijectionâ€. However
it appears that two different link key candidates may generate the same link set when the link
set is considered as a partition w.r.t. the owl:sameAs equivalence relation. This means that
these two link key candidates present a certain redundancy, and then they can be considered as
equivalent and merged in a way to be defined. This redundancy can be detected thanks to the
properties of owl:sameAs as an equivalence relation, i.e. reflexivity, symmetry, and transitivity.
Then, the owl:sameAs relation generates partitions among pairs of individuals that can be used
for reducing the number of potential link key candidates. Indeed, two candidates relying on
the same partition are considered as redundant and can be merged. However, we do not have
a concrete idea of the importance of such redundancy and we should find a way to measure
it. This is one objective of this paper to try to materialize this redundancy and to measure its
importance.

For doing so, taking inspiration from the work carried out in [14] on the discovery of
functional dependencies, we provide a formalization of link key discovery based on â€œpartition
pattern structuresâ€ (pps), which allow us to take into account sets of equivalent individuals
w.r.t. owl:sameAs as partitions. Then, a pattern concept represents a link key candidate and
the related partition induced by the candidate. This approach is able to retrieve all link key
candidates as a set of â€œnon redundantâ€ link keys. Moreover, this link key discovery process

based on pps is operational and original1. Actually, this is the first time that the characteristics
of owl:sameAs as an equivalence relation are considered, and that the related partitions of pairs
of individuals are directly used for defining link key candidates. Thanks to pps, we are able to
define redundancy of link key candidates and we also introduce a new measure based on the size
of partitions for evaluating the quality of the discovered candidates. Finally, the experiments
proposed in the last part of this paper provide three main results. Firstly, the redundancy of link
keys in real-world datasets appears to be not so significant. Nevertheless, the current link key
discovery approach based on pps is efficient and returns a reduced number of non redundant
link key candidates. Moreover, this pps-based approach returns link keys of very high quality
when compared to competitors.

The summary of the paper is as follows. Section 2 presents some basics about link keys. Then
the discovery of non-redundant link keys based on pattern structures and partition pattern
structures is made precise in Section 3. A running example illustrates all these constructions.
New quality measures related to non redundant link keys are defined in Section 4. Finally,
experiments in Section 5 show the capability and efficiency of the pps-based approach in link
key discovery.

2. Preliminaries

This section introduces the basic definitions relative to data interlinking with link keys. We
recall what an RDF dataset is and then we introduce two forms of link keys, namely link key
expressions and link key candidates.

2.1. RDF Data

Definition 1 (RDF Dataset). Let ğ‘ˆ denote a set of IRIs, i.e., â€œInternationalized Resource Identifiersâ€,
ğµ a set of blank nodes, i.e., â€œanonymous resourcesâ€, and ğ¿ a set of literals, i.e., â€œstring valuesâ€.

An RDF dataset is a set of triples (ğ‘ , ğ‘, ğ‘œ) âˆˆ (ğ‘ˆ âˆª ğµ) Ã— ğ‘ˆ Ã— (ğ‘ˆ âˆª ğµ âˆª ğ¿).

Let ğ· be an RDF dataset, ğ‘†(ğ·) = {ğ‘  | âˆƒ ğ‘, ğ‘œ (ğ‘ , ğ‘, ğ‘œ) âˆˆ ğ·} denotes the set of individual identifiers,
ğ‘ƒ(ğ·) = {ğ‘ | âˆƒ ğ‘ , ğ‘œ (ğ‘ , ğ‘, ğ‘œ) âˆˆ ğ·} the set of property identifiers, and ğ¶(ğ·) = {ğ‘ | âˆƒ ğ‘  (ğ‘ , rdf:type, ğ‘) âˆˆ
ğ·} the set of class identifiers.

Moreover, ğ¼ (ğ‘) = {ğ‘  | âˆƒ ğ‘  (ğ‘ , rdf:type, ğ‘) âˆˆ ğ·} denotes the set of instances of ğ‘ âˆˆ ğ¶(ğ·) while
ğ‘(ğ‘ ) = {ğ‘œ | (ğ‘ , ğ‘, ğ‘œ) âˆˆ ğ·} denotes the set of objects â€“or valuesâ€“ associated with ğ‘  through property
ğ‘.

An identity link is an RDF triple of the form (ğ‘, owl:sameAs, ğ‘) stating that the IRIs ğ‘ and ğ‘

are referring to the same entity, alternatively ğ‘ and ğ‘ are denoting the same individual.

Example 1. In Figure 1, the RDF datasets ğ·1 and ğ·2 include ğ‘ƒ(ğ·1) = {ğ‘1, ğ‘2, ğ‘3, ğ‘4} and ğ‘ƒ(ğ·2) =
{ğ‘1, ğ‘2, ğ‘3, ğ‘4} as sets of property identifiers, and ğ¶(ğ·1) = {ğ‘1} and ğ¶(ğ·2) = {ğ‘2} as class identifiers.
In addition, ğ¼ (ğ‘1) = {ğ‘1, ğ‘2, ğ‘3, ğ‘4, ğ‘5} and ğ¼ (ğ‘2) = {ğ‘1, ğ‘2, ğ‘3, ğ‘4, ğ‘5} denote respectively the sets of
instances of class ğ‘1 and class ğ‘2. Finally, considering subject ğ‘3 and property ğ‘2, the related set
of objects or the â€œvalueâ€ of ğ‘3 for property ğ‘2 is ğ‘2(ğ‘3) = {ğ‘œ8, ğ‘œ9}.

1The present paper extends a short preliminary version published in [15].

ğ‘1

ğ‘1

ğ‘2

ğ‘3

ğ‘4

ğ‘5

ğ‘
1
ğ‘ 2
ğ‘2

ğ‘ 1
ğ‘2
ğ‘1

ğ‘1
ğ‘2

ğ‘3

ğ‘
4

ğ‘4
ğ‘
3

ğ‘œ1

ğ‘œ2

ğ‘œ3
ğ‘œ4

ğ‘œ5

ğ‘œ6

ğ‘œ7

ğ‘œ8

ğ‘œ9

ğ‘œ10

ğ‘œ11
ğ‘œ12

ğ‘œ13

ğ‘2

ğ‘1

ğ‘2

ğ‘3

ğ‘4

ğ‘5

ğ‘
1
ğ‘2

ğ‘ 1
ğ‘2

ğ‘2
ğ‘ 1

ğ‘1
ğ‘ 2
ğ‘
2

ğ‘ 3

ğ‘ 4
ğ‘ 4

ğ‘

3

ğ·1

ğ·2

Figure 1: An example of two related RDF datasets. On the left-hand side, the dataset ğ·1 is populated
with instances of class ğ‘1 while on the right-hand side the dataset ğ·2 is populated with instances of
class ğ‘2.

2.2. Link Keys

Link keys are logical constructions allowing to infer identity links between instances of two
classes lying in two RDF datasets. In the following we introduce two syntactic definitions of
link keys, namely â€œlink key expressionsâ€ and â€œlink key candidatesâ€. A definition of a link key
and its semantics using Description Logics interpretation is proposed in [16]. However, in this
paper we will stick to these two syntactic definitions for the sake of simplicity.

Intuitively, a link key expression ğ‘˜ = (ğ¸ğ‘, ğ¼ ğ‘›, (ğ‘1, ğ‘2)) is composed of two sets of pairs of
properties, i.e., ğ¸ğ‘ and ğ¼ ğ‘›, where ğ¸ğ‘ is based on equality and ğ¼ ğ‘› on non empty intersection, while
links are generated between instances of classes ğ‘1 and ğ‘2. More formally we have:

Definition 2 (Link key expression). Let ğ·1 and ğ·2 be two RDF datasets, ğ‘˜ = (ğ¸ğ‘, ğ¼ ğ‘›, (ğ‘1, ğ‘2)) is a
link key expression over ğ·1 and ğ·2 iff ğ¼ ğ‘› âŠ† ğ‘ƒ(ğ·1) Ã— ğ‘ƒ(ğ·2), ğ¸ğ‘ âŠ† ğ¼ ğ‘›, ğ‘1 âˆˆ ğ¶(ğ·1) and ğ‘2 âˆˆ ğ¶(ğ·2).
The set of links generated by ğ‘˜ is denoted by ğ¿(ğ‘˜) and includes a set of pairs of instances

(ğ‘, ğ‘) âˆˆ ğ¼ (ğ‘1) Ã— ğ¼ (ğ‘2) satisfying:

(i) for all (ğ‘, ğ‘) âˆˆ ğ¸ğ‘, ğ‘(ğ‘) = ğ‘(ğ‘) and ğ‘(ğ‘) â‰  âˆ…,
(ii) for all (ğ‘, ğ‘) âˆˆ ğ¼ ğ‘› â§µ ğ¸ğ‘, ğ‘(ğ‘) âˆ© ğ‘(ğ‘) â‰  âˆ….

The number of link key expressions may be exponential w.r.t. the number of properties. To
reduce the search space, algorithms for link key discovery only consider â€œlink key candidatesâ€,
i.e., link key expressions which generate at least one link and which are â€œmaximalâ€ among the
set of link key expressions.

PS objects (g)
(ğ‘1, ğ‘1)
(ğ‘1, ğ‘2)
(ğ‘2, ğ‘1)
(ğ‘2, ğ‘2)
(ğ‘3, ğ‘3)
(ğ‘4, ğ‘4)
(ğ‘4, ğ‘5)
(ğ‘5, ğ‘4)
(ğ‘5, ğ‘5)

descriptions (ğ›¿(ğ‘”))
{âˆƒ(ğ‘1, ğ‘1), âˆƒ(ğ‘2, ğ‘2)}
{âˆƒ(ğ‘2, ğ‘2)}
{âˆƒ(ğ‘1, ğ‘1)}
{âˆƒ(ğ‘1, ğ‘1), âˆƒ(ğ‘2, ğ‘2)}
{âˆ€(ğ‘1, ğ‘1), âˆƒ(ğ‘1, ğ‘1), âˆƒ(ğ‘2, ğ‘2)}
{âˆ€(ğ‘3, ğ‘3), âˆƒ(ğ‘3, ğ‘3)}
{âˆ€(ğ‘4, ğ‘4), âˆƒ(ğ‘4, ğ‘4)}
{âˆ€(ğ‘4, ğ‘4), âˆƒ(ğ‘4, ğ‘4)}
{âˆ€(ğ‘3, ğ‘3), âˆƒ(ğ‘3, ğ‘3)}

Table 1
The pattern structure related to datasets ğ·1 and ğ·2 given in Fig. 1.

Definition 3 (Link key candidate). A link key expression ğ‘˜1 = (ğ¸ğ‘1, ğ¼ ğ‘›1, (ğ‘1, ğ‘2)) is a link key
candidate if:

(i) ğ¿(ğ‘˜1) â‰  âˆ…,
(ii) there does not exist another link key expression ğ‘˜2 = (ğ¸ğ‘2, ğ¼ ğ‘›2, (ğ‘1, ğ‘2)) over ğ·1 and ğ·2 such

that ğ¸ğ‘1 âŠ‚ ğ¸ğ‘2, ğ¼ ğ‘›1 âŠ‚ ğ¼ ğ‘›2, and ğ¿(ğ‘˜1) = ğ¿(ğ‘˜2).

For example, consider the expressions ğ‘˜1 and ğ‘˜2:
(i) ğ‘˜1 = ({(ğ‘1, ğ‘1)}, {(ğ‘1, ğ‘1), (ğ‘2, ğ‘2)}, (ğ‘1, ğ‘2)),
(ii) ğ‘˜2 = ({(ğ‘1, ğ‘1)}, {(ğ‘1, ğ‘1)}, (ğ‘1, ğ‘2)).

The related link sets are ğ¿(ğ‘˜1) = ğ¿(ğ‘˜2) = {(ğ‘3, ğ‘3)}. Then ğ‘˜1 and ğ‘˜2 are both link key expressions
but only ğ‘˜1 is a link key candidate as it is maximal on the link set {(ğ‘3, ğ‘3)} while ğ‘˜2 is not.

The set of link key expressions is denoted by lke, the set of link key candidates by lkc, and
we have that lkc âŠ† lke. The definition of link key candidates is based on the idea of maximality
which involves a certain form of closure. This gave rise to a number of papers studying the
potential relations existing between Formal Concept Analysis (FCA [12]) and the discovery of
link keys [9, 10]. Following the same line, we make precise in the next section two ways of
discovering link key candidates based on two extensions of FCA, pattern structures [13, 17] and
partition pattern structures [14].

3. From Link Keys to Non Redundant Link Keys

3.1. Discovering Link Keys with Pattern Structures

In this section we shortly recall how pattern structures can be used in the discovery of link
keys (details can be read in [11, 18]). For the sake of simplicity and readability, we rely on a
motivating example. Then we show how â€œPartition Pattern Structuresâ€ [14, 19] allow to discover
the so-called â€œnon-redundant link key candidatesâ€ denoted as nrlkc.

Example 2. Let us consider the pattern structure lkps = (ğº, (ğ¸, âŠ“), ğ›¿) displayed in Table 1. All
details for building lkps and the associated pattern concept lattice are given in [11]. In the
rows (â€œPS objectsâ€), ğº includes pairs of related instances, i.e., (ğ‘ğ‘–, ğ‘ğ‘—) with ğ‘ğ‘– âˆˆ ğ¼ (ğ‘1) and ğ‘ğ‘— âˆˆ ğ¼ (ğ‘2),
which correspond to the objects of lkps. The set of potential descriptions (ğ¸, âŠ“) includes all
possible pairs of properties preceded either by âˆ€ or âˆƒ. For the sake of simplicity, the âŠ“ operator
corresponds here to set intersection.

ğ‘ğ‘0
ğ¼ (ğ‘1) Ã— ğ¼ (ğ‘2)
âˆ…

ğ‘ğ‘1
{(ğ‘4, ğ‘5), (ğ‘5, ğ‘4)}
ğ‘˜1 = {âˆ€(ğ‘4, ğ‘4), âˆƒ(ğ‘4, ğ‘4)}

ğ‘ğ‘2
{(ğ‘4, ğ‘4), (ğ‘5, ğ‘5)}
ğ‘˜2 = {âˆ€(ğ‘3, ğ‘3), âˆƒ(ğ‘3, ğ‘3)}

ğ‘ğ‘4
{(ğ‘1, ğ‘1), (ğ‘2, ğ‘1),
(ğ‘2, ğ‘2), (ğ‘3, ğ‘3)}
ğ‘˜4 = {âˆƒ(ğ‘1, ğ‘1)}

ğ‘ğ‘3
{(ğ‘1, ğ‘1), (ğ‘1, ğ‘2),
(ğ‘2, ğ‘2), (ğ‘3, ğ‘3)}
ğ‘˜3 = {âˆƒ(ğ‘2, ğ‘2)}

ğ‘ğ‘5
{(ğ‘1, ğ‘1), (ğ‘2, ğ‘2), (ğ‘3, ğ‘3)}
ğ‘˜5 = {âˆƒ(ğ‘1, ğ‘1), âˆƒ(ğ‘2, ğ‘2)}

ğ‘ğ‘6
{(ğ‘3, ğ‘3)}
ğ‘˜6 = {âˆ€(ğ‘1, ğ‘1), âˆƒ(ğ‘1, ğ‘1),
âˆƒ(ğ‘2, ğ‘2)}

ğ‘ğ‘7
âˆ…
ğ‘ƒ(ğ·1) Ã— ğ‘ƒ(ğ·2)

Figure 2: The pattern concept lattice related to Table 1. Every intent in a pattern concept corresponds
to a link key candidate.

The mapping ğ›¿ relates a pair of instances (ğ‘, ğ‘) âˆˆ ğ¼ (ğ‘1) Ã— ğ¼ (ğ‘2) to a description as follows: (i)
ğ›¿(ğ‘, ğ‘) includes âˆ€(ğ‘, ğ‘) whenever ğ‘(ğ‘) = ğ‘(ğ‘) and ğ‘(ğ‘) â‰  âˆ…, (ii) ğ›¿(ğ‘, ğ‘) includes âˆƒ(ğ‘, ğ‘) whenever
ğ‘(ğ‘) âˆ© ğ‘(ğ‘) â‰  âˆ…. Actually, such descriptions correspond to link key expressions w.r.t. the pairs
of classes (ğ‘1, ğ‘2). In this work, we only consider the pair of classes ğ‘1 and ğ‘2, while dealing with
several pairs of classes is explained in [11].

Based on Fig. 1, the description of ğ›¿(ğ‘1, ğ‘1) is given by {âˆƒ(ğ‘1, ğ‘1), âˆƒ(ğ‘2, ğ‘2)} because ğ‘1(ğ‘1) âˆ©
ğ‘1(ğ‘1) â‰  âˆ… and ğ‘2(ğ‘1) âˆ© ğ‘2(ğ‘1) â‰  âˆ…, while ğ›¿(ğ‘2, ğ‘1) = {âˆƒ(ğ‘1, ğ‘1)} because ğ‘1(ğ‘2) âˆ© ğ‘1(ğ‘1) â‰  âˆ….
Then, ğ›¿(ğ‘1, ğ‘1) âŠ“ ğ›¿(ğ‘2, ğ‘1) = {âˆƒ(ğ‘1, ğ‘1)} and thus ğ›¿(ğ‘2, ğ‘1) âŠ‘ ğ›¿(ğ‘1, ğ‘1). This can be read in the
pattern concept lattice displayed in Fig.2 where the pattern concept ğ‘ğ‘5 is subsumed by the
pattern concept ğ‘ğ‘4, i.e., the intent {âˆƒ(ğ‘1, ğ‘1)} of ğ‘ğ‘4 is included in the intent {âˆƒ(ğ‘1, ğ‘1), âˆƒ(ğ‘2, ğ‘2)}
of ğ‘ğ‘5, while the extent {(ğ‘1, ğ‘1), (ğ‘2, ğ‘2), (ğ‘3, ğ‘3)} of ğ‘ğ‘5 is included in the extent of ğ‘ğ‘4 which is
{(ğ‘1, ğ‘1), (ğ‘2, ğ‘1), (ğ‘2, ğ‘2), (ğ‘3, ğ‘3)}.

In this way, the set of all pattern concepts is organized within the pattern concept lattice in

Fig. 2. Moreover, all link key candidates are lying in the intents of the pattern concepts.

3.2. Discovering Non Redundant Link Keys with Partition Pattern Structures

3.2.1. Motivation: sameAs is an Equivalence Relation.

Having a careful look at Fig. 2, one can verify that more compact link keys could be designed.
For example, in the extent of ğ‘ğ‘3, {(ğ‘1, ğ‘1), (ğ‘1, ğ‘2), (ğ‘2, ğ‘2), (ğ‘3, ğ‘3)}, the three first pairs have a non
empty intersection when considered in a particular order, i.e., ğ‘1 is shared by {(ğ‘1, ğ‘1), (ğ‘1, ğ‘2)} and
ğ‘2 is shared by {(ğ‘1, ğ‘2), (ğ‘2, ğ‘2)}. Actually there exists a potential owl:sameAs â€“or simply sameAsâ€“
relation between the elements in such pairs. Being an equivalence relation, sameAs generates an

equivalence class. Hence, we can â€œmergeâ€ some of these pairs in such an equivalence class. For
example (ğ‘1, ğ‘1) and (ğ‘1, ğ‘2) can be merged, i.e., a1 sameAs b1 and a1 sameAs b2 yield b1 sameAs b2
(symmetry and transitivity of sameAs). Moreover (ğ‘1, ğ‘2) and (ğ‘2, ğ‘2) can be merged because
a1 sameAs b2 and a2 sameAs b2 yield a1 sameAs a2. Finally, from a1 sameAs a2 and a1 sameAs b1 it
comes a2 sameAs b1. Then a1, a2, b1, b2, are in the same equivalence class w.r.t. sameAs.

Two important facts should be noticed: (i) the link a2 sameAs b1, absent in ğ‘ğ‘3 but present
in ğ‘ğ‘4, is inferred from the extent of ğ‘ğ‘3 thanks to the properties of sameAs while in the same
way a1 sameAs b2 could be inferred in ğ‘ğ‘4, (ii) the equivalence class {(ğ‘1, ğ‘1, ğ‘2, ğ‘2)} which can
be built in ğ‘ğ‘3 and as well in ğ‘ğ‘4, allows us to merge the link keys in ğ‘ğ‘3 and ğ‘ğ‘4 because they
have now the â€œsame extentâ€. Relying on this observation, we define an equivalence relation
over the extents of pattern concepts as follows.

Let us consider two RDF datasets ğ·1 and ğ·2, a link key ğ‘˜, two classes ğ‘1 and ğ‘2, and the
set of instances ğ¼ = ğ¼ (ğ‘1) âˆª ğ¼ (ğ‘2). Given ğ‘¥0 and ğ‘¥ğ‘› âˆˆ ğ¼, there exists a chain of sameAs re-
lations between ğ‘¥0 and ğ‘¥ğ‘› iff there exists a sequence of elements ğ‘¥1, ğ‘¥2, â€¦ , ğ‘¥ğ‘›âˆ’1 such that
x0 sameAs x1, x1 sameAs x2, â€¦ , xnâˆ’1 sameAs xn holds, where the symmetry of sameAs may be
used. Then, we define a relation between ğ‘¥0 and ğ‘¥ğ‘› in ğ¼ w.r.t. the link key ğ‘˜, denoted as
ğ‘¥0 â‰ƒğ‘˜ ğ‘¥ğ‘›, iff there exists a chain of sameAs relations between ğ‘¥0 and ğ‘¥ğ‘›. It can be checked
that â‰ƒğ‘˜ is an equivalence relation as sameAs itself is an equivalence relation. For example,
ğ¸ğ‘¥ğ‘¡(ğ‘ğ‘3)/â‰ƒâˆƒ(ğ‘2,ğ‘2) = {(ğ‘1, ğ‘1, ğ‘2, ğ‘2), (ğ‘3, ğ‘3)} where ğ¸ğ‘¥ğ‘¡(ğ‘ğ‘3) denotes the extent of ğ‘ğ‘3. In the
same way, ğ¸ğ‘¥ğ‘¡(ğ‘ğ‘4)/â‰ƒâˆƒ(ğ‘1,ğ‘1) = {(ğ‘1, ğ‘1, ğ‘2, ğ‘2), (ğ‘3, ğ‘3)}. Then the two link keys âˆƒ(ğ‘1, ğ‘1) and
âˆƒ(ğ‘2, ğ‘2) can be â€œidentifiedâ€ or â€œmergedâ€ because they have the same equivalence classes.

As a consequence, one may obtain more comparable sets of linked elements and thus minimize
the number of possible link key candidates. Moreover, it can be noticed that an equivalence class
determines a partition within the set of instances under study (singletons if any are omitted
here).

3.2.2. The design of a PPS for â€œNon Redundant Link Keysâ€.

Hereafter, one main objective is to build a specific pattern structure where concepts are
related to unique equivalence classes and yield â€œnon redundant link key candidatesâ€ denoted as
nrlkc. Here â€œnon redundantâ€ means any two elements in nrlkc are associated with different
equivalence classes. In addition, an equivalence class corresponds to a partition of the set of
instances. Accordingly, we define a â€œpartition pattern structureâ€ (pps) based on descriptions
which are partitions and used to discover non redundant link key candidates. Indeed, in such
a pps, objects in the rows correspond to pairs of properties and descriptions correspond to
partitions. An example of pps is proposed in [14] where pps are introduced for mining functional
dependencies.

Accordingly, we define a partition pattern structure over classes ğ‘1 and ğ‘2 as a triple

(lkc, (ğ‘ƒğ‘ğ‘Ÿğ‘¡(ğ¼ ), âŠ“ğ‘ğ‘ğ‘Ÿğ‘¡), ğ›¿) such as:

â€¢ lkc is the set of all link key candidates w.r.t. classes ğ‘1 and ğ‘2 which are given by a pattern

concept lattice (as displayed in Fig. 2).

pps objects (ğ‘˜ğ‘–)
ğ‘˜1 = {âˆƒ(ğ‘4, ğ‘4), âˆ€(ğ‘4, ğ‘4)}
ğ‘˜2 = {âˆƒ(ğ‘3, ğ‘3), âˆ€(ğ‘3, ğ‘3)}
ğ‘˜3 = {âˆƒ(ğ‘2, ğ‘2)}
ğ‘˜4 = {âˆƒ(ğ‘1, ğ‘1)}
ğ‘˜5 = {âˆƒ(ğ‘1, ğ‘1), âˆƒ(ğ‘2, ğ‘2)}
ğ‘˜6 = {âˆ€(ğ‘1, ğ‘1), âˆƒ(ğ‘1, ğ‘1), âˆƒ(ğ‘2, ğ‘2)}

Descriptions (partitions, ğ›¿(ğ‘˜ğ‘–))

{(ğ‘4, ğ‘5), (ğ‘5, ğ‘4)}
{(ğ‘4, ğ‘4), (ğ‘5, ğ‘5)}
{(ğ‘1, ğ‘1, ğ‘2, ğ‘2), (ğ‘3, ğ‘3)}
{(ğ‘1, ğ‘1, ğ‘2, ğ‘2), (ğ‘3, ğ‘3)}
{(ğ‘1, ğ‘1), (ğ‘2, ğ‘2), (ğ‘3, ğ‘3)}
{(ğ‘3, ğ‘3)}

Table 2
The partition pattern structure related to the pattern structure in Table 1 over the classes ğ‘1 and ğ‘2 in
datasets ğ·1 and ğ·2.

â€¢ (ğ‘ƒğ‘ğ‘Ÿğ‘¡(ğ¼ ), âŠ“ğ‘ğ‘ğ‘Ÿğ‘¡) is the set of potential descriptions or partitions and âŠ“ğ‘ğ‘ğ‘Ÿğ‘¡ is the â€œmeetâ€ of

two partitions.

â€¢ ğ›¿ maps a link key candidate ğ‘˜ to the partition ğ¼ / â‰ƒğ‘˜, which is the quotient set of ğ¼ w.r.t. â‰ƒğ‘˜.

As it can be seen in Table 2, pps objects are the link key candidates already computed and lying
in the intents of the pattern concept lattice. This means that link key candidates will compose
pps-concept extents, while partitions involving elements are declared in the descriptions and
thus will compose pps-concept intents. Moreover, partitions reduced to a singleton are omitted
in the descriptions of the pps objects.

Let us examine a concrete example of pps based on the pattern structure given in Ta-
ble 1. For ğ‘ğ‘3, we have ğ¸ğ‘¥ğ‘¡(ğ‘ğ‘3) = {(ğ‘1, ğ‘1), (ğ‘1, ğ‘2), (ğ‘2, ğ‘2), (ğ‘3, ğ‘3)} and ğ¼ ğ‘›ğ‘¡(ğ‘ğ‘3) = {âˆƒ(ğ‘2, ğ‘2)}.
The related partition, ğ¸ğ‘¥ğ‘¡(ğ‘ğ‘3)/â‰ƒâˆƒ(ğ‘2,ğ‘2) = {(ğ‘1, ğ‘1, ğ‘2, ğ‘2), (ğ‘3, ğ‘3)}, where singletons are omit-
ted, is associated with row ğ‘˜3 ({âˆƒ(ğ‘2, ğ‘2)}) in Table 2 .
In the same way, considering ğ‘ğ‘4
and {âˆƒ(ğ‘1, ğ‘1)}, ğ¸ğ‘¥ğ‘¡(ğ‘ğ‘4)/â‰ƒâˆƒ(ğ‘1,ğ‘1) is associated with row ğ‘˜4 ({âˆƒ(ğ‘1, ğ‘1)}) in Table 2. Moreover,
ğ¸ğ‘¥ğ‘¡(ğ‘ğ‘4)/â‰ƒâˆƒ(ğ‘1,ğ‘1) = {(ğ‘1, ğ‘1, ğ‘2, ğ‘2), (ğ‘3, ğ‘3)} and is equal to ğ¸ğ‘¥ğ‘¡(ğ‘ğ‘3)/â‰ƒâˆƒ(ğ‘2,ğ‘2). As already ob-
served, ğ‘˜3 and ğ‘˜4 are inducing the same partition and can be â€œmergedâ€. The other pps objects,
namely ğ‘˜1, ğ‘˜2, ğ‘˜5, and ğ‘˜6, are obtained from the corresponding pattern concepts in Fig. 2 in the
same way. Finally, the pps over classes ğ‘1 and ğ‘2 related to the datasets ğ·1 and ğ·2 is displayed
in Table 2.

The meet â€“or similarityâ€“ operation used to compare the rows in the pps corresponds to the
meet of two partitions ğ‘ğ‘ğ‘Ÿğ‘¡1 and ğ‘ğ‘ğ‘Ÿğ‘¡2 over ğ¼ and is denoted by ğ‘ğ‘ğ‘Ÿğ‘¡1 âŠ“ğ‘ğ‘ğ‘Ÿğ‘¡ ğ‘ğ‘ğ‘Ÿğ‘¡2. This meet
operation is classically defined as the intersection of the respective equivalence classes, also
known as the â€œcoarsest common refinement of the two partitionsâ€ (see [14]). For example the
meet ğ›¿(ğ‘˜4) âŠ“ğ‘ğ‘ğ‘Ÿğ‘¡ ğ›¿(ğ‘˜5) is given by {(ğ‘1, ğ‘1, ğ‘2, ğ‘2), (ğ‘3, ğ‘3)} âŠ“ğ‘ğ‘ğ‘Ÿğ‘¡ {(ğ‘1, ğ‘1), (ğ‘2, ğ‘2), (ğ‘3, ğ‘3)} which
yields the partition {(ğ‘1, ğ‘1), (ğ‘2, ğ‘2), (ğ‘3, ğ‘3)}. In particular, this means that ğ›¿(ğ‘˜4) âŠ“ ğ›¿(ğ‘˜5) = ğ›¿(ğ‘˜5)
and thus that ğ›¿(ğ‘˜5) âŠ‘ ğ›¿(ğ‘˜4).

Based on this meet operation, the pps concept lattice is constructed and shown in Fig. 3. The ex-
tent of a pps concept includes the ğ¸ğ‘ and the ğ¼ ğ‘› parts of a link key candidate (ğ¸ğ‘, ğ¼ ğ‘›, (ğ‘1, ğ‘2)) in lkc.
For example, the intent of ğ‘ğ‘ğ‘ ğ‘6 is {(ğ‘3, ğ‘3)} and its extent is ğ‘˜6, i.e., {âˆ€(ğ‘1, ğ‘1), âˆƒ(ğ‘1, ğ‘1), âˆƒ(ğ‘2, ğ‘2)}.
As all elements in the extents of the pps concept lattice, ğ‘˜6 is an element of nrlkc, i.e., a non
redundant link key candidate. Moreover, ğ‘˜6 corresponds to a closed set and thus verifies maxi-
mality, and it is non redundant w.r.t. the partition in the associated intent, i.e., no other link key
candidate induces the same partition.

3.2.3. Discussion: From LKC to NRLKC.

We now discuss what is gained in relying on pattern structures and then on partition pattern
structures. Actually, the discovery of link key candidates (lkc) is based on the construction of
the pattern concept lattice. Then the construction of the pps concept lattice yielding the non
redundant link key candidates should be considered as a â€œrefinementâ€ where equivalent link key
candidates, i.e., link key candidates inducing the same partition, are merged. For example, both
concepts ğ‘ğ‘3 and ğ‘ğ‘4 in Fig. 2 are merged into a single concept ğ‘ğ‘ğ‘ ğ‘34 in Fig. 3. The resulting
pps concept lattice is of smaller size and more concise as link key candidates in the concept
extents are non redundant.

The relations existing between lkc and nrlkc can be characterized as follows. By construction,
nrlkc âŠ† lkc as the discovery of non redundant link keys is based on lkc, i.e., the link key
candidates lying in the intents of concepts in the pattern concept lattice. Then, the candidates
which have the same equivalence classes w.r.t. the sameAs relation are merged to produce the
non redundant link key candidates in nrlkc. Thus, it comes that nrlkc âŠ† lkc and that |nrlkc |
â‰¤ |lkc | (where |X| denotes the cardinality of set X). In other words, a non redundant link key
candidate is always a link key candidate while the converse is not true.

The definition of nrlkc allows us to introduce a new quality measure for evaluating and
validating non redundant link key candidates. In the next section we make precise this new
quality measure and we discuss the benefits related to the discovery of non redundant link key
candidates.

4. Quality Measures for Non Redundant Link Key Candidates

Not all link key candidates are eligible to be final link keys. Some candidates can be too general or
related to noise in the data and thus they may generate owl:sameAs links which are not correct or
have a bad quality. For example the link key candidate ({}, {(country,country)}, (Person,Human))
states that two individuals (subjects) sharing the same country represent the same person, and
this is obviously not true. The candidate ({}, {(name,title)}, (Person,Book)) may be discovered
by chance and will generate non correct links as well.

An ideal link key candidate should be â€œcorrectâ€ and â€œcompleteâ€, and specific â€œquality measuresâ€
are defined for assessing these properties. In a supervised setting, when a set of reference links
is available, the correctness of a link key candidate is measured thanks to â€œprecisionâ€ and the
completeness thanks to â€œrecallâ€. In an unsupervised setting as this is the case here, the measures
of â€œcoverageâ€ and â€œdiscriminabilityâ€ are defined over the set of links directly generated by a link
key candidate [9]. The global quality of a link key candidate is then estimated thanks to the
harmonic mean of these two measures.

The coverage of a set ğ¿ of links over ğ‘1 and ğ‘2 is ğ‘ğ‘œğ‘£(ğ¿, ğ‘1, ğ‘2) =

{ğ‘|(ğ‘, ğ‘) âˆˆ ğ¿} and ğœ‹2(ğ¿) = {ğ‘|(ğ‘, ğ‘) âˆˆ ğ¿}.
The discriminability of ğ¿ is ğ‘‘ğ‘–ğ‘ (ğ¿) =

ğ‘šğ‘–ğ‘›(|ğœ‹1(ğ¿)|, |ğœ‹2(ğ¿)|)
|ğ¿|

.

|ğœ‹1(ğ¿) âˆª ğœ‹2(ğ¿)|
|ğ¼ (ğ‘1) âˆª ğ¼ (ğ‘2)|

where ğœ‹1(ğ¿) =

ğ‘ğ‘ğ‘ ğ‘0
Link Key Candidates

Singleton Partition

ğ‘ğ‘ğ‘ ğ‘1
ğ‘˜1{âˆ€(ğ‘4, ğ‘4), âˆƒ(ğ‘4, ğ‘4)}
{(ğ‘4, ğ‘5), (ğ‘5, ğ‘4)}

ğ‘ğ‘ğ‘ ğ‘2
ğ‘˜2{âˆ€(ğ‘3, ğ‘3), âˆƒ(ğ‘3, ğ‘3)}
{(ğ‘4, ğ‘4), (ğ‘5, ğ‘5)}

ğ‘ğ‘ğ‘ ğ‘6
ğ‘˜6{âˆ€(ğ‘1, ğ‘1), âˆƒ(ğ‘1, ğ‘1), âˆƒ(ğ‘2, ğ‘2)}
{(ğ‘3, ğ‘3)}

ğ‘ğ‘ğ‘ ğ‘5
ğ‘˜5{âˆƒ(ğ‘1, ğ‘1), âˆƒ(ğ‘2, ğ‘2)}
{(ğ‘1, ğ‘1), (ğ‘2, ğ‘2), (ğ‘3, ğ‘3)}

ğ‘ğ‘ğ‘ ğ‘34
ğ‘˜3, ğ‘˜4{âˆƒ(ğ‘1, ğ‘1)}, {âˆƒ(ğ‘2, ğ‘2)}
{(ğ‘1, ğ‘1, ğ‘2, ğ‘2), (ğ‘3, ğ‘3)}

ğ‘ğ‘7
âˆ…
ğ¼

Figure 3: The pps concept lattice over the partition pattern structure and the pattern concept lattice
given in Fig. 2.

Coverage and discriminability evaluate how close a set of links is to a total, respectively
bijective, mapping. Coverage is maximum when all instances of the considered classes are
linked to at least another instance, while discriminability is maximum when instances are linked
to at most one instance.

In the present setting, we are interested in the â€œredundancyâ€ of link key candidates, and we
would like to evaluate the quality of â€œnon redundantâ€ candidates. A link key candidate ğ‘˜ is
said to be â€œredundantâ€ in ğ» âŠ† lkc if there exists another link key candidate â„ âˆˆ ğ» such that
ğ¼ /â‰ƒğ‘˜ = ğ¼ /â‰ƒâ„, i.e., ğ‘˜ generates the same partition as â„. This is the case in the running example
for the link key candidates ğ‘˜3 and ğ‘˜4. One main consequence of detecting redundancy is to
reduce the number of candidates by merging candidates inducing the same partition. Then,
since â‰ƒğ‘˜3 and â‰ƒğ‘˜4 induce the same partition, ğ‘˜3 and ğ‘˜4 are merged into a non redundant link
key candidate ğ‘˜34 = {ğ‘˜3, ğ‘˜4} interpreted as â€œğ‘˜3 or ğ‘˜4â€.

Accordingly, we introduce the new quality measure ğ‘ğ‘†ğ‘–ğ‘§ğ‘’(ğ‘˜) that is compliant with the
semantics of sameAs and defined w.r.t. the partition associated with the equivalence relation â‰ƒğ‘˜:
ğ‘ğ‘†ğ‘–ğ‘§ğ‘’(ğ‘˜) = | {ğ‘¥ âˆˆ ğ¼ /â‰ƒğ‘˜ | |ğ‘¥| > 1} | where ğ¼ = ğ¼ (ğ‘1) âˆª ğ¼ (ğ‘2) and ğ¼ /â‰ƒğ‘˜ is the quotient set of ğ¼ w.r.t.

â‰ƒğ‘˜.
For example, ğ‘ğ‘†ğ‘–ğ‘§ğ‘’(ğ‘˜3) = ğ‘ğ‘†ğ‘–ğ‘§ğ‘’(ğ‘˜4) = |{(ğ‘1, ğ‘1, ğ‘2, ğ‘2), (ğ‘3, ğ‘3)}| = 2. The lower bound of ğ‘ğ‘†ğ‘–ğ‘§ğ‘’(ğ‘˜)
is 1 since ğ‘˜ generates at least one link. The upper bound is ğ‘šğ‘–ğ‘›(|ğ¼ (ğ‘1)|, |ğ¼ (ğ‘2)|) and this is
achieved when ğ‘˜ determines a 1-1 mapping. Moreover, pSize can be normalized into ğ‘›ğ‘ğ‘†ğ‘–ğ‘§ğ‘’(ğ‘˜) =
ğ‘ğ‘†ğ‘–ğ‘§ğ‘’(ğ‘˜)/|ğ¼ / â‰ƒğ‘˜|. Then ğ‘›ğ‘ğ‘†ğ‘–ğ‘§ğ‘’(ğ‘˜3) = 2/6 as ğ¼ / â‰ƒğ‘˜3 = {(ğ‘1, ğ‘1, ğ‘2, ğ‘2), (ğ‘3, ğ‘3), ğ‘4, ğ‘4, ğ‘5, ğ‘5}, where
this time singletons are counted.

The normalized measure ğ‘›ğ‘ğ‘†ğ‘–ğ‘§ğ‘’(ğ‘˜) evaluates how close are ğ‘1 and ğ‘2 w.r.t. â‰ƒğ‘˜, and is maximal
when all instances are linked. However, this is not always satisfactory, especially when the
cardinalities of the two classes significantly differ (i.e., classes are not balanced). Then, it is
more accurate to maximize the measure as soon as all instances of one class are linked as fol-
lows: ğ‘ ğ‘ ğ‘ğ‘(ğ‘˜) = ğ‘ğ‘†ğ‘–ğ‘§ğ‘’(ğ‘˜)/ğ‘šğ‘–ğ‘›(|ğ¼ (ğ‘1)/â‰ƒğ‘˜|, |ğ¼ (ğ‘2)/â‰ƒğ‘˜ |) (also known as the â€œSzymkiewiczâ€“Simpson
partition coefficientâ€). For example, ğ‘ ğ‘ ğ‘ğ‘(ğ‘˜3) = 2/4 with:
ğ‘ ğ‘ ğ‘ğ‘(ğ‘˜3) = |{(ğ‘1, ğ‘1, ğ‘2, ğ‘2), (ğ‘3, ğ‘3)}|/ğ‘šğ‘–ğ‘›(|{(ğ‘1, ğ‘2), ğ‘3, ğ‘4, ğ‘5}|, |{(ğ‘1, ğ‘2), ğ‘3, ğ‘4, ğ‘5}|).

5. Experiments

5.1. Datasets and experimental settings

We run experiments on DB-Yago datasets provided in [20]. These datasets are used by the
approaches to which we compare our results in the last series of experiments. They have been
rewritten into Terse RDF Triple Language (Turtle) which is a syntax for expressing RDF data
[21]. They are derived from DBpedia and Yago and organized into nine tasks. One particular
task consists in finding links between instances of a class in DBpedia and instances of a class in
Yago, e.g., db:Actor and yago:Actor. A set of reference links (i.e., owl:sameAs links) denoted
by ğ¿ğ‘Ÿğ‘’ğ‘“ is provided for each task. The statistics of DB-Yago datasets are given in Table 3.

Experiments were run on a MacBook Pro 2018 with Intel Core i7-8850H@2,6 GHz, 16GB
of RAM. The link key candidates are provided by a tool called Linkex2 in which we have
implemented the lkps algorithm i.e. the link key discovery algorithm based on pattern structures
proposed in [11]. A basic text normalization consisting in removing diacritics, tokenizing and
sorting the resulting bag of tokens is performed.

5.2. Redundancy of Link Key Candidates is not so Significant

In Table 3, column |lkc| represents the number of link key candidates discovered by lkps
algorithm while column |nrlkc| represents the number of non redundant link key candidates.
In most of the tasks, we can observe that |nrlkc| is equal to |lkc|, except for the tasks Actor
and Film where |nrlkc| is lower than |lkc| by 1% and by 5% respectively. This means that,
in general, link key candidates produce different partitions and only a few are redundant. By
contrast, if redundancy does not significantly reduce the number of link key candidates, it gives
a good idea of the compactness of partitions related to link key candidates.

Nevertheless, even if redundancy is not so significant, we decided to compare the quality
of the resulting sets of candidates measured with ğ‘ğ‘†ğ‘–ğ‘§ğ‘’ and the results of competitors, namely
keys and conditional keys as they are studied in [20].

5.3. Non Redundant Candidates, Classical Keys and Conditional Keys

The ğ‘ğ‘†ğ‘–ğ‘§ğ‘’ measure is used to evaluate and select the best link key candidates, â€“in this experiment
the link key candidate ranked firstâ€“ in every task listed in Table 3. Then, we compare recall,
precision, and F-measure of the links generated by the best link key candidates selected by

2Linkex is available online at https://gitlab.inria.fr/moex/linkex.

Interlinking task

Actor

Album

Book

Film

Mountain

Museum

Organization

Scientist

University

datasets
db:Actor
yago:Actor
db:Album
yago:Album
db:Book
yago:Book
db:Film
yago:Film
db:Mountain
yago:Mountain
db:Museum
yago:Museum
db:Organization
yago:Organization
db:Scientist
yago:Scientist
db:University
yago:University

|triples|
94 606
1 029 580
594 144
762 238
247 372
185 032
1 369 600
1 067 084
135 442
233 562
15 940
163 342
4 487 205
4 410 854
128 360
671 266
241 838
263 624

|subjects|
5 807
108 415
85 002
136 848
29 846
41 849
82 099
123 822
16 397
32 874
1 826
21 050
183 665
430 071
18 409
92 828
10 352
23 334

|properties|
16
16
5
5
7
7
9
9
5
5
7
7
17
17
10
18
9
9

|lkc|

|nrlkc|

time

2 198

2 177

56s

44

82

44

82

28s

39s

18 718

17 643

34m

39

48

39

48

5m

9s

1 425

1 425

57m

862

213

862

213

2m

56s

Table 3
DB-Yago datasets statistics, where |triples| denotes the number of triples in each dataset, |subjects| the
number of instances, and |properties| the number of properties.

ğ‘ğ‘†ğ‘–ğ‘§ğ‘’ against interlinking approaches providing classical keys and conditional keys as reported
in [20].

In Figure 4 we can observe that: (i) recall of link keys is significantly better than recall of
classical and conditional keys, (ii) precision of classical and conditional keys is slightly better
than precision of link keys in most of the tasks, (iii) F-measure is much higher for selected link
key candidates than for classical and conditional keys.

Link keys have a better recall because they are more flexible than classical keys, i.e., a link
key is not necessarily a pair of keys and an instance of class ğ‘1 may be linked to many instances
of class ğ‘2.

For summarizing, it can be concluded that considering the best link key candidates selected
by ğ‘ğ‘†ğ‘–ğ‘§ğ‘’ will ensure a higher interlinking quality compared to classical and conditional keys. We
also observe that the best link key according to discriminability and coverage is the same that
the best non redundant link key selected thanks to ğ‘ğ‘†ğ‘–ğ‘§ğ‘’. Actually, the Actor dataset makes an
exception: the link key candidate selected with ğ‘ğ‘†ğ‘–ğ‘§ğ‘’ obtains an F-measure of 0.95 contrasting
the score of 0.34 obtained with coverage and discriminability. In addition, contrasting key-based
approaches, link key discovery does not require any prior knowledge such as property or class
alignments.

(a)recall

(b)precision

(c)F-measure

0.57

0.56

0.22
9â‹…10âˆ’2
0.16
5â‹…10âˆ’2
0.14
1â‹…10âˆ’2

0.25

0.12

0

0

4â‹…10âˆ’2
0.11
3â‹…10âˆ’2
0.15

University

Scientist

Organization

Museum

Mountain

Film

Book

Album

Actor

0.28

0.38

0.27

0.61

0.67

0.59

0.57

0.84

0.79

0.79

0.91

0.69

0.82

0.93
0.99
0.99
0.99
0.98
0.98
1
0.94
1
1
0.94
0.99
1
0.91
0.96
0.99
0.95
0.99
1
0.99
1
0.98
0.99
0.99

0.83

0.26

0.28

0.16

0.11

2â‹…10âˆ’2

0.24

0.21

0

0

8â‹…10âˆ’2
6â‹…10âˆ’2

0.23

0.26

University

Scientist

Organization

Museum

Mountain

Film

Book

Album

Actor

0.71

0.76

0.67

classicalkeys
conditionalkeys
link keys

0.86

0.86

0.74

0.79

0.69

0.73

0.95

0.4

0.44

0.54

0.43

Figure 4: Interlinking performances of classical keys, conditional keys as given in [20] and link keys.
Actually a recall of 0 stands for a very small recall close to 0.

6. Synthesis and Conclusion

This paper introduces a formalization of link key discovery based on partition pattern structures
(pps). This approach allows to discover the set nrlkc of link key candidates which are not
redundant w.r.t. the owl:sameAs equivalence relation, while still being correct and complete. In
addition, new appropriate quality measures are proposed.

Practically, we observe in experiments that the redundancy of link key candidates in public
datasets is rather rare. Nevertheless, the experiments and the associated results show that
link key based on pps obtain better F-measure values than two other key-based approaches to
data-interlinking.

Among the perspectives, a first one is to consolidate the theory and practice of link key
discovery based on pps introduced and detailed in this paper. A second and very important
direction of investigation is related to the discovery of â€œfuzzy link keysâ€. We make the hypothesis
that the redundancy of link key candidates is rather rare because we are using the crisp equality
operator when we are building the link key candidates. Instead, in considering the discovery of
link key candidates as depending on a similarity relation, i.e., reflexive and symmetric â€“also
called a tolerance relationâ€“ rather than on an equality, then we could propose a formalization
of fuzzy link key candidates in the spirit of approximate-matching dependencies as they are
studied in [19]. We could also expect much more differences between crisp and fuzzy link key
candidates. In addition, a reduction of the size of the concept lattice related to nrlkc could also
be investigated thanks to similarities between partitions.

References

[1] A. Ferrara, A. Nikolov, F. Scharffe, Data Linking for the Semantic Web, International

Journal of Semantic Web and Information Systems 7 (2011) 46â€“76.

[2] P. Christen, Data Matching â€“ Concepts and Techniques for Record Linkage, Entity Resolu-

tion, and Duplicate Detection, Springer, 2012.

[3] M. Nentwig, M. Hartung, A.-C. Ngonga Ngomo, E. Rahm, A survey of current Link

Discovery frameworks, Semantic Web Journal 8 (2017) 419â€“436.

[4] A. N. Ngomo, S. Auer, LIMES â€“ A Time-Efficient Approach for Large-Scale Link Discovery
in: T. Walsh (Ed.), Proceedings of the 22nd International Joint

on the Web of Data,
Conference on Artificial Intelligence (IJCAI), IJCAI/AAAI, 2011, pp. 2312â€“2317.

[5] J. Volz, C. Bizer, M. Gaedke, G. Kobilarov, Silk â€“ A Link Discovery Framework for the
Web of Data, in: C. Bizer, T. Heath, T. Berners-Lee, K. Idehen (Eds.), Proceedings of the
WWW2009 Workshop on Linked Data on the Web (LDOW), CEUR Workshop Proceedings
538, 2009.

[6] R. Isele, C. Bizer, Active learning of expressive linkage rules using genetic programming,

Journal of web semantics 23 (2013) 2â€“15.

[7] A. N. Ngomo, K. Lyko, EAGLE: Efficient Active Learning of Link Specifications Using
in: E. Simperl, P. Cimiano, A. Polleres, Ã“. Corcho, V. Presutti
Genetic Programming,
(Eds.), Proceedings of the 9th Extended Semantic Web Conference (ESWC, Lecture Notes
in Computer Science 7295, Springer, 2012, pp. 149â€“163.

[8] A. N. Ngomo, K. Lyko, Unsupervised learning of link specifications: deterministic vs.
non-deterministic, in: P. Shvaiko, J. Euzenat, K. Srinivas, M. Mao, E. JimÃ©nez-Ruiz (Eds.),
Proceedings of the 8th International Workshop on Ontology Matching (at ISWC), CEUR
Workshop Proceedings 1111, 2013, pp. 25â€“36.

[9] M. Atencia, J. David, J. Euzenat, Data interlinking through robust linkkey extraction, in:

Proceedings of ECAI, 2014, pp. 15â€“20.

[10] M. Atencia, J. David, J. Euzenat, A. Napoli, J. Vizzini, Link key candidate extraction with

relational concept analysis, Discrete applied mathematics 273 (2020) 2â€“20.

[11] N. Abbas, J. David, A. Napoli, Discovery of Link Keys in RDF Data Based on Pattern
Structures: Preliminary Steps, in: F. J. Valverde-Albacete, M. Trnecka (Eds.), Proceedings
of the International Conference on Concept Lattices and Their Applications (CLA), CEUR
Workshop Proceedings 2668, 2020, pp. 235â€“246.

[12] B. Ganter, R. Wille, Formal Concept Analysis: Mathematical Foundations, Springer, 1999.
[13] B. Ganter, S. O. Kuznetsov, Pattern Structures and Their Projections, in: H. S. Delugach,
G. Stumme (Eds.), Proceedings of the International Conference on Conceptual Structures
(ICCS), Lecture Notes in Computer Science 2120, Springer, 2001, pp. 129â€“142.

[14] J. Baixeries, M. Kaytoue, A. Napoli, Characterizing functional dependencies in formal
concept analysis with pattern structures, Annals of Mathematics and Artificial Intelligence
72 (2014) 129â€“149.

[15] N. Abbas, A. Bazin, J. David, A. Napoli, Non-Redundant Link Keys in RDF Data: Preliminary
Steps, in: Proceedings of the FCA4AI Workshop at IJCAI, CEUR Workshop Proceedings
2972, 2021, pp. 125â€“130.

[16] M. Atencia, J. David, J. Euzenat, On the relation between keys and link keys for data

interlinking, Semantic Web Journal 12 (2021) 547â€“567.

[17] M. Kaytoue, S. O. Kuznetsov, A. Napoli, S. Duplessis, Mining Gene Expression Data with
Pattern Structures in Formal Concept Analysis, Information Sciences 181 (2011) 1989â€“2001.
[18] N. Abbas, A. Bazin, J. David, A. Napoli, Sandwich: An Algorithm for Discovering Relevant

Link Keys in an LKPS Concept Lattice, in: A. Braud, A. Buzmakov, T. Hanika, F. L. Ber
(Eds.), Proceedings of the 16th International Conference on Formal Concept Analysis
(ICFCA), Lecture Notes in Computer Science 12733, Springer, 2021, pp. 243â€“251.

[19] J. Baixeries, V. Codocedo, M. Kaytoue, A. Napoli, Characterizing Approximate-Matching
Dependencies in Formal Concept Analysis with Pattern Structures, Discrete Applied
Mathematics 249 (2018) 18â€“27.

[20] D. Symeonidou, L. GalÃ¡rraga, N. Pernelle, F. SaÃ¯s, F. M. Suchanek, VICKEY: Mining
Conditional Keys on Knowledge Bases, in: Proceedings of 16th International Semantic
Web Conference (ISWC), LNCS 10587, Springer, 2017, pp. 661â€“677.

[21] D. Beckett, T. Berners-Lee, E. Prudâ€™hommeaux, G. Carothers, RDF 1.1 Turtle, W3C Recom-

mendation, W3C, 2014. https://www.w3.org/TR/turtle/.

