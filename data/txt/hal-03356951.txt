The Complexity of Counting Problems Over Incomplete
Databases
Marcelo Arenas, Pablo BarcelÃ³, MikaÃ«l Monet

To cite this version:

Marcelo Arenas, Pablo BarcelÃ³, MikaÃ«l Monet. The Complexity of Counting Problems Over
ACM Transactions on Computational Logic, 2021, 22 (4), pp.1-52.
Incomplete Databases.
ï¿¿10.1145/3461642ï¿¿. ï¿¿hal-03356951ï¿¿

HAL Id: hal-03356951

https://hal.science/hal-03356951

Submitted on 28 Sep 2021

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

Lâ€™archive ouverte pluridisciplinaire HAL, est
destinÃ©e au dÃ©pÃ´t et Ã  la diffusion de documents
scientifiques de niveau recherche, publiÃ©s ou non,
Ã©manant des Ã©tablissements dâ€™enseignement et de
recherche franÃ§ais ou Ã©trangers, des laboratoires
publics ou privÃ©s.

1

The Complexity of Counting Problems
over Incomplete Databases

1
2
0
2

r
p
A
8
2

]

B
D
.
s
c
[

2
v
0
3
3
6
0
.
1
1
0
2
:
v
i
X
r
a

MARCELO ARENASâˆ—, Universidad CatÃ³lica & IMFD Chile
PABLO BARCELÃ“â€ , Universidad CatÃ³lica & IMFD Chile
MIKAÃ‹L MONET, Univ. Lille, Inria, CNRS, Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

We study the complexity of various fundamental counting problems that arise in the context of incomplete
databases, i.e., relational databases that can contain unknown values in the form of labeled nulls. Specifically,
we assume that the domains of these unknown values are finite and, for a Boolean query ğ‘, we consider the
following two problems: given as input an incomplete database ğ·, (a) return the number of completions of ğ·
that satisfy ğ‘; or (b) return the number of valuations of the nulls of ğ· yielding a completion that satisfies ğ‘.
We obtain dichotomies between #P-hardness and polynomial-time computability for these problems when ğ‘ is
a self-joinâ€“free conjunctive query, and study the impact on the complexity of the following two restrictions:
(1) every null occurs at most once in ğ· (what is called Codd tables); and (2) the domain of each null is the same.
Roughly speaking, we show that counting completions is much harder than counting valuations: for instance,
while the latter is always in #P, we prove that the former is not in #P under some widely believed theoretical
complexity assumption. Moreover, we find that both (1) and (2) can reduce the complexity of our problems.
We also study the approximability of these problems and show that, while counting valuations always has a
fully polynomial-time randomized approximation scheme (FPRAS), in most cases counting completions does
not. Finally, we consider more expressive query languages and situate our problems with respect to known
complexity classes.

CCS Concepts: â€¢ Theory of computation â†’ Complexity theory and logic; Incomplete, inconsistent,
and uncertain databases; â€¢ Mathematics of computing â†’ Approximation algorithms.

Additional Key Words and Phrases: Incomplete databases, closed-world assumption, counting complexity,
Fully Polynomial-time Randomized Approximation Scheme (FPRAS).

1 INTRODUCTION

Context. In the database literature, incomplete databases are often used to represent missing
information in the data; see, e.g., [1, 37, 52]. These are traditional relational databases whose active
domain can contain both constants and nulls, the latter representing unknown values [30]. There
are many ways in which one can define the semantics of such a database, each being equally
meaningful depending on the intended application. Under the so called closed-world assumption [1,
45], a standard, complete database ğœˆ (ğ·) is obtained from an incomplete database ğ· by applying a
valuation ğœˆ which replaces each null âŠ¥ in ğ· with a constant ğœˆ (âŠ¥). The goal is then to reason about
the space formed by all valuations ğœˆ and completions ğœˆ (ğ·) of ğ·.

Decision problems related to querying incomplete databases have been well studied already.
Consider for instance the problem Certainty(ğ‘( Â¯ğ‘¥)) which, for a fixed query ğ‘( Â¯ğ‘¥), takes as input
an incomplete database ğ· and a tuple Â¯ğ‘ and asks whether Â¯ğ‘ is an answer to ğ‘ for every possible
completion of ğ·. By now, we have a deep understanding of the complexity of these kind of decision

âˆ—Also with Department of Computer Science & Institute for Mathematical and Computational Engineering, School of
Engineering, Pontificia Universidad CatÃ³lica de Chile.
â€ Also with Institute for Mathematical and Computational Engineering, School of Engineering and Faculty of Mathematics,
Pontificia Universidad CatÃ³lica de Chile.

Authorsâ€™ addresses: Marcelo Arenas, Universidad CatÃ³lica & IMFD Chile, marenas@ing.puc.cl; Pablo BarcelÃ³, Universidad
CatÃ³lica & IMFD Chile, pbarcelo@uc.cl; MikaÃ«l Monet, Univ. Lille, Inria, CNRS, Centrale Lille, UMR 9189 CRIStAL, F-59000
Lille, France, mikael.monet@inria.fr.

 
 
 
 
 
 
1:2

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

problems for different choices of query languages, including conjunctive queries (CQs) and FO
queries [2, 30]. However, having the answer to this question is sometimes of little help: what if it is
not the case that ğ‘ is certain on ğ·? Can we still infer some useful information? This calls for new
notions that could be used to measure the certainty with which ğ‘ holds, notions which should be
finer than those previously considered. This is for instance what the recent work in [38] does by
introducing a notion of best answer, which are those tuples Â¯ğ‘ for which the set of completions of ğ·
over which ğ‘( Â¯ğ‘) holds is maximal with respect to set inclusion.

A fundamental complementary approach to address this issue can be obtained by considering
some counting problems related to incomplete databases; more specifically, determining the number
of completions/valuations of an incomplete database that satisfy a query ğ‘. These problems are
relevant as they tell us, intuitively, how close is ğ‘ from being certain over ğ·, i.e., what is the level of
support that ğ‘ has over the set of completions/valuations of ğ·. Surprisingly, such counting problems
do not seem to have been studied for incomplete databases. A reason for this omission in the
literature might be that, in general, it is assumed that the domain over which nulls can be interpreted
is infinite, and thus incomplete databases might have an infinite number of completions/valuations.
However, in many scenarios it is natural to assume that the domain over which nulls are interpreted
is finite, in particular when dealing with uncertainty in practice [4, 6, 7, 11, 23, 46]. By assuming
this we can ensure that the number of completions and valuations are always finite, and thus that
they can be counted. This is the setting that we study.

Problems studied. We focus on the problems #Comp(ğ‘) and #Val(ğ‘) for a Boolean query ğ‘,
which take as input an incomplete database ğ· together with a finite set dom(âŠ¥) of constants for
every null âŠ¥ occurring in ğ·, and ask the following: How many completions, resp., valuations, of ğ·
satisfy ğ‘? More formally, a valuation of ğ· is a mapping ğœˆ that associates to every null âŠ¥ of ğ· a
constant ğœˆ (âŠ¥) in dom(âŠ¥). Then, given a valuation ğœˆ of ğ·, we denote by ğœˆ (ğ·) the database that is
obtained from ğ· after replacing each null âŠ¥ with ğœˆ (âŠ¥), and we call such a database a completion.
Besides, in this article we consider set semantics, that is, we remove repeated tuples from ğœˆ (ğ·).
For #Comp(ğ‘) we count all databases of the form ğœˆ (ğ·) such that ğ‘ holds in ğœˆ (ğ·). Instead, for
#Val(ğ‘) we count the number of valuations ğœˆ such that ğ‘ holds in ğœˆ (ğ·). It is easy to see that these
two values can differ, as a completion might be obtained from two different valuations, i.e., there
might exist two distinct valuations ğœˆ, ğœˆ â€² such that ğœˆ (ğ·) = ğœˆ â€²(ğ·). We think that both problems are
meaningful: while #Comp(ğ‘) determines the support for ğ‘ over the databases represented by ğ·,
we have that #Val(ğ‘) further refines this by incorporating the support for a particular completion
that satisfies ğ‘ over the set of valuations for ğ·.

We deal with the data complexity of the problems #Comp(ğ‘) and #Val(ğ‘), focusing on obtaining
dichotomy results for them in terms of counting complexity classes, as well as studying the
existence of randomized algorithms that approximate their results under probabilistic guarantees.
For the dichotomies, we concentrate on self-join-free Boolean conjunctive queries (sjfBCQs). This
assumption simplifies the mathematical analysis, while at the same time defines a setting which is
rich enough for many of the theoretical concepts behind these problems to appear in full force.
Notice that a similar assumption is used in several works that study counting problems over
probabilistic and inconsistent databases; see, e.g., [18, 40]. To simplify further the presentation,
in the bulk of the article we mainly consider self-joinâ€“free Boolean conjunctive queries that do
not contain constants; however, we explain later (in Section 7) how our results can be extended to
queries that can contain constants and free variables.

To refine our analysis, we study two restrictions of the problems #Comp(ğ‘) and #Val(ğ‘) based
on natural modifications of the semantics, and analyze to what extent these restrictions simplify
our problems. For the first restriction we consider incomplete databases in which each null occurs

The complexity of counting problems over incomplete databases

1:3

Counting valuations

Counting completions

Non-uniform Uniform

Non-uniform Uniform

NaÃ¯ve

ğ‘…(ğ‘¥, ğ‘¥)
ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥)

Codd

ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥)

ğ‘…(ğ‘¥, ğ‘¥)
ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥, ğ‘¦) âˆ§ ğ‘‡ (ğ‘¦)
ğ‘…(ğ‘¥, ğ‘¦) âˆ§ ğ‘† (ğ‘¥, ğ‘¦)

ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥, ğ‘¦) âˆ§ ğ‘‡ (ğ‘¦)
ğ‘…(ğ‘¥, ğ‘¦) âˆ§ ğ‘† (ğ‘¥, ğ‘¦)

ğ‘…(ğ‘¥)

ğ‘…(ğ‘¥)

ğ‘…(ğ‘¥, ğ‘¥)
ğ‘…(ğ‘¥, ğ‘¦)

ğ‘…(ğ‘¥, ğ‘¥)
ğ‘…(ğ‘¥, ğ‘¦)

Table 1. Our dichotomies for counting valuations and completions of sjfBCQs. For each of the eight cases, if
an sjfBCQ ğ‘ contains a pattern mentioned in that case, then the problem is #P-hard (and #P-complete for
counting valuations, as well as for counting completions over Codd tables). In turn, for each case if an sjfBCQ
ğ‘ does not have any of the patterns mentioned in that case, then the problem is in FP.

NaÃ¯ve

Codd

FPRAS for counting valuations

Non-uniform Uniform
Always
Always

FPRAS for counting completions
Non-uniform Uniform
Never

Only when ğ‘ has
only unary atoms
?

Always

Always

Never

Table 2. Our results on the existence of FPRAS for solving the problems studied in the article (assuming
NP â‰  RP).

exactly once, which corresponds to the well-studied setting of Codd tables â€“ as opposed to naive
tables where nulls are allowed to have multiple occurrences. We denote the corresponding prob-
lems by #ValCd (ğ‘) and #CompCd (ğ‘). For the second restriction, we consider uniform incomplete
databases in which all the nulls share the same domain â€“ as opposed to the basic non-uniform
setting in which all nulls come equipped with their own domain. We denote the corresponding
problems by #Valu (ğ‘) and #Compu(ğ‘). When both restrictions are in place, we denote the problems
by #Valu
Cd

(ğ‘) and #Compu
Cd

(ğ‘).

Our dichotomies for exact counting. We provide complete characterizations of the complex-
ity of counting valuations and completions satisfying a given sjfBCQ ğ‘, when the input is a Codd
table or a naive table, and is a non-uniform or a uniform incomplete database (hence we have eight
cases in total). Our eight dichotomies express that these problems are either tractable or #P-hard,
and that the tractable cases can be fully characterized by the absence of certain forbidden patterns
in ğ‘. In essence, a pattern is simply an sjfBCQ which can be obtained from ğ‘ by deleting atoms and
occurrences of variables (the exact definition of this notion is given in Section 3). Our characteriza-
tions are presented in Table 1. By analyzing this table we can draw some important conclusions as
explained next.

#Comp(ğ‘) and #Val(ğ‘) are computationally difficult: For very few sjfBCQs ğ‘ the aforementioned
problems can be solved in polynomial time. Take as an example the uniform setting over naive
tables. Then #Valu(ğ‘) is #P-hard as long as ğ‘ contains the pattern ğ‘…(ğ‘¥, ğ‘¥), or ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥, ğ‘¦) âˆ§ ğ‘‡ (ğ‘¦),
or ğ‘…(ğ‘¥, ğ‘¦) âˆ§ ğ‘† (ğ‘¥, ğ‘¦). That is, as long as there is an atom in ğ‘ that contains a repeated variable ğ‘¥, or
a pair (ğ‘¥, ğ‘¦) of variables that appear in an atom and both ğ‘¥ and ğ‘¦ appear in some other atoms in ğ‘.
By contrast, for this same setting, #Compu(ğ‘) is #P-hard as long as ğ‘ contains the pattern ğ‘…(ğ‘¥, ğ‘¦)
or ğ‘…(ğ‘¥, ğ‘¥), that is, as long as there is an atom in ğ‘ that is not of arity one.

1:4

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

#Val(ğ‘) is always easier than #Comp(ğ‘): In all of the possible versions of our problem, the tractable
cases for #Val(ğ‘) are a strict superset of the ones for #Comp(ğ‘). For instance, #Compu
(âˆƒğ‘¥âˆƒğ‘¦ ğ‘…(ğ‘¥, ğ‘¦))
Cd
is hard, while #Valu
Cd

(âˆƒğ‘¥âˆƒğ‘¦ ğ‘…(ğ‘¥, ğ‘¦)) is tractable.

Even counting completions is hard: While counting the total number of valuations for an incom-
plete database can always be done in polynomial time, observe from Table 1 that the problem
#Compu
(âˆƒğ‘¥âˆƒğ‘¦ ğ‘…(ğ‘¥, ğ‘¦)) is #P-hard, and thus that simply counting the completions of a uniform
Cd
Codd table with a single binary relation ğ‘… is #P-hard. Moreover, we show that in the non-uniform
case a single unary relation suffices to obtain #P-hardness.

Codd tables help but not much: We show that counting valuations is easier for Codd tables than
for naive tables. In particular, there is always an sjfBCQ ğ‘ such that counting the valuations that
satisfy ğ‘ is #P-hard, yet it becomes tractable when restricted to the case of Codd tables. However,
for counting completions, both in the uniform and non-uniform setting, the sole restriction to
Codd tables presents no benefits: for every sjfBCQ ğ‘, we have that #Comp(ğ‘) (resp., #Compu(ğ‘))
is #P-hard if and only if #CompCd (ğ‘) (resp., #Compu
Cd
Non-uniformity complicates things: All versions of our problems become harder in the non-uniform
setting. This means that in all cases there is an sjfBCQ ğ‘ for which counting valuations is tractable
on uniform incomplete databases, but becomes #P-hard assuming non-uniformity, and the same
holds for counting completions.

(ğ‘)) is #P-hard.

Our dichotomies for approximate counting. Although #Val(ğ‘) can be #P-hard, we prove
that good randomized approximation algorithms can be designed for this problem. More precisely,
we give a general condition under which #Val(ğ‘) admits a fully polynomial-time randomized
approximation scheme [33] (FPRAS). This condition applies in particular to all unions of Boolean
conjunctive queries. Remarkably, we show that this no longer holds for #Comp(ğ‘); more precisely,
there exists an sjfBCQ ğ‘ such that #Comp(ğ‘) does not admit an FPRAS under a widely believed
complexity theoretical assumption. More surprisingly, even counting the completions of a uniform
incomplete database containing a single binary relation does not admit an FPRAS under such an
assumption (and in the non-uniform case, a single unary relation suffices). Generally, for sjfBCQs,
we obtain seven dichotomies for our problems between polynomial-time computability of exact
counting and non admissibility of an FPRAS. The only case that we did not completely solve is that
of #Compu
(ğ‘). Our dichotomies for approximate counting are illustrated in Table 2.
Cd

Beyond #P. It is easy to see that the problem of counting valuations is always in #P, provided
that the model checking problem for ğ‘ is in P. This is no longer the case for counting completions,
and in fact we show that, under a complexity theoretical assumption, there is an sjfBCQ ğ‘ for which
#Compu(ğ‘) is not in #P. This does not hold if restricted to Codd tables, however, as we prove that
#CompCd (ğ‘) is always in #P when the model checking problem for ğ‘ is in P.

For reasons that we explain in the article, a suitable complexity class for the problem #Comp(ğ‘)
is SpanP, which is defined as the class of counting problems that can be expressed as the number
of different accepting outputs of a nondeterministic Turing machine running in polynomial time.
While we have not managed to prove that there is an sjfBCQ ğ‘ for which #Comp(ğ‘) is SpanP-
complete, we show that this is the case for the problem of counting completions for the negation
of an sjfBCQ, even in the uniform setting; that is, we show that #Compu (Â¬ğ‘) is SpanP-complete
for some sjfBCQ ğ‘. Finally, we also show that SpanP is the right complexity class for counting
valuations of queries for which model checking is in NP.

Extension to queries with constants and free variables. As we said already, for pedagogical
reasons we mostly present our results by considering queries that are Boolean and that do not have

The complexity of counting problems over incomplete databases

1:5

constants. In Section 7 however, we explain how to extend these results to the case of queries that
have free variables and that can contain constants. For the case of a query ğ‘( Â¯ğ‘¥) with free variables Â¯ğ‘¥,
our counting problems are defined in the expected way; for instance the problem #Val(ğ‘( Â¯ğ‘¥)) takes as
input an incomplete database ğ·, a tuple of constants Â¯ğ‘ of same arity as Â¯ğ‘¥, and it outputs the number
of valuations ğœˆ of ğ· such that Â¯ğ‘ in an answer to ğ‘( Â¯ğ‘¥) on ğœˆ (ğ·). We then extend our dichotomies
and approximation results in this setting.

The current article extends the conference article [8] in the following ways:
â€¢ In [8] we left open the dichotomy for #Valu
Cd

(ğ‘), i.e., for counting valuations of sjfBCQs for
Codd tables under the uniform setting. We close this case here, by finding one more hard
pattern (namely, the pattern âˆƒğ‘¥, ğ‘¦ ğ‘…(ğ‘¥, ğ‘¦) âˆ§ ğ‘† (ğ‘¥, ğ‘¦)) and showing that the problem can be
solved in polynomial time for all other queries.

â€¢ We added Section 7 which explains how our framework can be extended to handle queries

with constants and free variables;

â€¢ Proposition 6.3, which establishes the NP-completeness of checking if a set of facts is a

possible completion of an incomplete database, is new;

â€¢ Finally, full proofs of most results are included in the body of the article.

Organization of the article. We start with the main terminology used in the article in Section 2,
and then present in Section 3 our four dichotomies on #Val(ğ‘) when ğ‘ is an sjfBCQ, and the input
incomplete database can be Codd or not, and the domain can be uniform or not. We then establish the
four dichotomies on #Comp(ğ‘) in Section 4. In Section 5, we study the approximability complexity
of our problems. We then give in Section 6 some general considerations about the exact complexity
of the problem #Comp(ğ‘) going beyond #P. We explain in Section 7 how to extend our results to
queries with constants and free variables. In Section 8, we discuss related work and explain the
differences with the problems considered in this article. Last, we provide some conclusions and
mention possible directions for future work in Section 9.

2 PRELIMINARIES

Relational databases and conjunctive queries. A relational schema ğœ is a finite non-empty
set of relation symbols written ğ‘…, ğ‘†, ğ‘‡ , . . . , each with its associated arity, which is denoted by
arity(ğ‘…). Let Consts be a countably infinite set of constants. A database ğ· over ğœ is a set of facts of
the form ğ‘…(ğ‘1, . . . , ğ‘arity(ğ‘…) ) with ğ‘… âˆˆ ğœ, and where each element ğ‘ğ‘– âˆˆ Consts. For ğ‘… âˆˆ ğœ, we denote
by ğ· (ğ‘…) the subset of ğ· consisting of facts over ğ‘…. Such a set is usually called a relation of ğ·.

A Boolean query ğ‘ is a query that a database ğ· can satisfy (written ğ· |= ğ‘) or not (written ğ· Ì¸|= ğ‘).
If ğ‘ is a Boolean query, then Â¬ğ‘ is the Boolean query such that ğ· |= Â¬ğ‘ if and only if ğ· Ì¸|= ğ‘. A
Boolean conjunctive query (BCQ) over ğœ is an FO formula of the form

âˆƒ Â¯ğ‘¥ (cid:0)ğ‘…1( Â¯ğ‘¥1) âˆ§ . . . âˆ§ ğ‘…ğ‘š ( Â¯ğ‘¥ğ‘š)(cid:1),

(1)

where all variables are existentially quantified, and where for each ğ‘– âˆˆ [1, ğ‘š], we have that ğ‘…ğ‘– is a
relation symbol in ğœ and Â¯ğ‘¥ğ‘– is a tuple of variables with | Â¯ğ‘¥ğ‘– | = arity(ğ‘…ğ‘– ). To avoid trivialities, we will
always assume that ğ‘š â©¾ 1, i.e., the query has at least one atom, and also that arity(ğ‘…ğ‘– ) â©¾ 1 for all
atoms. Observe that we do not allow constants to appear in the query (but we will come back to
this issue in Section 7). For simplicity, we typically write a BCQ ğ‘ of the form (1) as

and it will be implicitly understood that all variables in ğ‘ are existentially quantified. As usual, we de-
fine the semantics of a BCQ in terms of homomorphisms. A homomorphism from ğ‘ to a database ğ· is a

ğ‘…1( Â¯ğ‘¥1) âˆ§ . . . âˆ§ ğ‘…ğ‘š ( Â¯ğ‘¥ğ‘š),

1:6

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

(ğœˆ (âŠ¥1), ğœˆ (âŠ¥2))
ğœˆ (ğ·)

(ğ‘, ğ‘)

(ğ‘, ğ‘)

(ğ‘, ğ‘)

(ğ‘, ğ‘)

(ğ‘, ğ‘)

(ğ‘, ğ‘)

ğ‘†

ğ‘
ğ‘

ğ‘
ğ‘

ğ‘†

ğ‘
ğ‘

ğ‘
ğ‘

ğ‘†

ğ‘
ğ‘
ğ‘

ğ‘
ğ‘
ğ‘

ğ‘†

ğ‘
ğ‘

ğ‘
ğ‘

ğ‘†

ğ‘
ğ‘
ğ‘

ğ‘
ğ‘
ğ‘

ğ‘†

ğ‘
ğ‘

ğ‘
ğ‘

ğœˆ (ğ·) |= ğ‘?

Yes

Yes

Yes

No

Yes

No

Fig. 1. The six valuations of the (non-uniform) incomplete database ğ· = (ğ‘‡ , dom) with ğ‘‡ =
{ğ‘† (ğ‘, ğ‘), ğ‘† (âŠ¥1, ğ‘), ğ‘† (ğ‘, âŠ¥2)} from Example 2.2, and their corresponding completions. The Boolean conjunctive
query ğ‘ is âˆƒğ‘¥ ğ‘† (ğ‘¥, ğ‘¥).

mapping from the variables in ğ‘ to the constants used in ğ· such that {ğ‘…1(â„( Â¯ğ‘¥1)), . . . , ğ‘…ğ‘š (â„( Â¯ğ‘¥ğ‘š))} âŠ†
ğ·. Then, we have ğ· |= ğ‘ if there exists a homomorphism from ğ‘ to ğ·. A self-joinâ€“free BCQ (sjfBCQ)
is a BCQ such that no two atoms use the same relation symbol.

Incomplete databases. Let Nulls be a countably infinite set of nulls (also called labeled or
marked nulls in the literature), which is disjoint with Consts. An incomplete database over schema ğœ
is a pair ğ· = (ğ‘‡ , dom), where ğ‘‡ is a database over ğœ whose facts contain elements in Consts âˆª Nulls,
and where dom is a function that associates to every null âŠ¥ occurring in ğ· a subset dom(âŠ¥)
of Consts. Intuitively, ğ‘‡ is a database that can mention both constants and nulls, while dom tells us
where nulls are to be interpreted. Following the literature, we call ğ‘‡ a naive table [30].

An incomplete database ğ· = (ğ‘‡ , dom) can represent potentially many complete databases,
via what are called valuations. A valuation of ğ· is simply a function ğœˆ that maps each null âŠ¥
occurring in ğ‘‡ to a constant ğœˆ (âŠ¥) âˆˆ dom(âŠ¥). Such a valuation naturally defines a completion
of ğ·, denoted by ğœˆ (ğ‘‡ ), which is the complete database obtained from ğ‘‡ by substituting each
null âŠ¥ appearing in ğ‘‡ by ğœˆ (âŠ¥). It is understood, since a database is a set of facts, that ğœˆ (ğ‘‡ ) does
not contain duplicate facts. By paying attention to completions of incomplete databases that are
generated exclusively by applying valuations to them, we are sticking to the so called closed-world
semantics of incompleteness [1, 45]. This means that the databases represented by an incomplete
database ğ· = (ğ‘‡ , dom) are not open to adding facts that are not â€œjustifiedâ€ by the facts in ğ‘‡ .

Example 2.1. Let ğ· = (ğ‘‡ , dom) be the incomplete database consisting of the naive table ğ‘‡ =
{ğ‘† (âŠ¥1, âŠ¥1), ğ‘† (ğ‘, âŠ¥2)}, and where dom(âŠ¥1) = {ğ‘, ğ‘} and dom(âŠ¥2) = {ğ‘, ğ‘}. Let ğœˆ1 be the valuation
mapping âŠ¥1 to ğ‘ and âŠ¥2 to ğ‘. Then ğœˆ1(ğ‘‡ ) is {ğ‘† (ğ‘, ğ‘), ğ‘† (ğ‘, ğ‘)}. Let ğœˆ2 be the valuation mapping
both âŠ¥1 and âŠ¥2 to ğ‘. Then ğœˆ2(ğ‘‡ ) is {ğ‘† (ğ‘, ğ‘)}. On the other hand, the function ğœˆ mapping âŠ¥1 and âŠ¥2
â–¡
to ğ‘ is not a valuation of ğ·, because ğ‘ âˆ‰ dom(âŠ¥2).

When every null occurs at most once in ğ‘‡ , then ğ· is what is called a Codd table [16]; for instance,
the incomplete database in Example 2.1 is not a Codd table because âŠ¥1 occurs twice. We also
consider uniform incomplete databases in which the domain of every null is the same. Formally, a
uniform incomplete database is a pair ğ· = (ğ‘‡ , dom), where ğ‘‡ is a database over ğœ and dom is a
subset of Consts. The difference now is that a valuation ğœˆ of ğ· must simply satisfy ğœˆ (âŠ¥) âˆˆ dom for
every null of ğ·.

We will often abuse notation and use ğ· instead of ğ‘‡ ; for instance, we write ğœˆ (ğ·) instead of ğœˆ (ğ‘‡ ),

or ğ‘…(ğ‘, ğ‘) âˆˆ ğ· instead of ğ‘…(ğ‘, ğ‘) âˆˆ ğ‘‡ , or again ğ· (ğ‘…) instead of ğ‘‡ (ğ‘…).

The complexity of counting problems over incomplete databases

1:7

Counting problems on incomplete databases. We will study two kinds of counting problems
for incomplete databases: problems of the form #Val(ğ‘), that count the number of valuations ğœˆ that
yield a completion ğœˆ (ğ·) satisfying a given BCQ ğ‘, and problems of the form #Comp(ğ‘), that count
the number of completions that satisfy ğ‘. The query ğ‘ is assumed to be fixed, so that each query
gives rise to different counting problems, and we are considering the data complexity [53] of these
problems.

Before formally introducing our problems, let us observe that they are well defined if we assume
that the set of constants to which a null can be mapped to is finite. Hence, for the (default) case of
an incomplete database ğ· = (ğ‘‡ , dom), we assume that dom(âŠ¥) is always a finite subset of Consts.
Similarly, for the case of a uniform incomplete database ğ· = (ğ‘‡ , dom), we assume that dom is
a finite subset of Consts. Finally, given a Boolean query ğ‘, we use notation sig(ğ‘) for the set of
relation symbols occurring in ğ‘. With these ingredients, we can define our problems for the (default)
case of incomplete naive tables and a Boolean query ğ‘.

PROBLEM :
INPUT :
OUTPUT : Number of valuations ğœˆ of ğ· with ğœˆ (ğ·) |= ğ‘

#Val(ğ‘)
An incomplete database ğ· over sig(ğ‘)

PROBLEM :
INPUT :
OUTPUT : Number of completions ğœˆ (ğ·) of ğ· with

#Comp(ğ‘)
An incomplete database ğ· over sig(ğ‘)

ğœˆ (ğ·) |= ğ‘

We also consider the uniform variants of these problems, in which the input ğ· is a uniform
incomplete database over sig(ğ‘), and the restriction of these problems where the input is a Codd
table instead of a naive table. We then use the terms #Valu (ğ‘), #Compu(ğ‘) when restricted to the
uniform case, #ValCd (ğ‘), #CompCd (ğ‘) when restricted to Codd tables, and #Valu
(ğ‘)
Cd
when both restrictions are applied.

(ğ‘), #Compu
Cd

As we will see, even though the problems #Val(ğ‘) and #Comp(ğ‘) look similar, they are of
a different computational nature; this is because two distinct valuations can produce the same
completion of an incomplete database. We illustrate this phenomenon in the following example.

Example 2.2. Let ğ‘ be the Boolean conjunctive query âˆƒğ‘¥ ğ‘† (ğ‘¥, ğ‘¥), and ğ· be the (non-uniform)
incomplete database ğ· = (ğ‘‡ , dom), with ğ‘‡ = {ğ‘† (ğ‘, ğ‘), ğ‘† (âŠ¥1, ğ‘), ğ‘† (ğ‘, âŠ¥2)}, dom(âŠ¥1) = {ğ‘, ğ‘, ğ‘}
and dom(âŠ¥2) = {ğ‘, ğ‘}. We have depicted in Figure 1 the six valuations of ğ· together with the
completions that they define. Out of these six valuations ğœˆ, only four are such that ğœˆ (ğ·) |= ğ‘, so we
have #Val(ğ‘)(ğ·) = 4. Moreover, there are only 3 distinct completions of ğ· that satisfy ğ‘ â€“ because
â–¡
the first two are the same â€“ so #Comp(ğ‘)(ğ·) = 3.

Counting complexity classes. Given two problems ğ´, ğµ, we write ğ´ â©½p

T ğµ when ğ´ reduces
to ğµ under polynomial-time Turing reductions. When both ğ´ and ğµ are counting problems, we
write ğ´ â©½p
par ğµ when ğ´ can be reduced to ğµ under polynomial-time parsimonious reductions, i.e.,
when there exists a polynomial-time computable function ğ‘“ that transforms an input ğ‘¥ of ğ´ to an
input ğ‘“ (ğ‘¥) of ğµ such that ğ´(ğ‘¥) = ğµ(ğ‘“ (ğ‘¥)). We say that a counting problem is in FP when it can be
solved in polynomial time. We will consider the counting complexity class #P [50] of problems that
can be expressed as the number of accepting paths of a nondeterministic Turing machine running
in polynomial time. Following [50, 51], we define #P-hardness using Turing reductions. It is clear
that FP âŠ† #P. Moreover, this inclusion is widely believed to be strict. Therefore, proving that a

1:8

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

counting problem is #P-hard implies that it cannot be solved in polynomial time under such an
assumption.

3 DICHOTOMIES FOR COUNTING VALUATIONS
In this section, for a fixed sjfBCQ q, we study the complexity of the problem of computing, given as
input an incomplete database ğ·, the number of valuations ğœˆ of ğ· such that ğœˆ (ğ·) satisfies ğ‘. Recall
that we have four cases to consider for this problem depending on whether we focus on naive
or on Codd tables, where nulls are restricted to appear at most once, and whether we focus on
non-uniform or uniform incomplete databases, where nulls are restricted to have the same domain.
Our specific goal then is to understand whether the problem is tractable (in FP) or #P-hard in these
scenarios, depending on the shape of ğ‘.

To this end, the shape of an sjfBCQ ğ‘ will be characterized by the presence or absence of certain
specific patterns. In the following definition, we introduce the necessary terminology to formally
talk about the presence of a pattern in a query.

Definition 3.1. Let ğ‘, ğ‘â€² be sjfBCQs. We say that ğ‘â€² is a pattern of ğ‘ if ğ‘â€² can be obtained from ğ‘
by using an arbitrary number of times and in any order the following operations: deleting an atom,
deleting an occurrence of a variable, renaming a relation to a fresh one, renaming a variable to a
fresh one, and reordering the variables in an atom.1
â–¡

Example 3.2. Recall that we always omit existential quantifiers in Boolean queries. Then we
have that ğ‘â€² = ğ‘… â€²(ğ‘¢, ğ‘¢, ğ‘¦) âˆ§ ğ‘† â€²(ğ‘§) is a pattern of ğ‘ = ğ‘…(ğ‘¢, ğ‘¥, ğ‘¢) âˆ§ ğ‘† â€²(ğ‘¦, ğ‘¦) âˆ§ ğ‘‡ (ğ‘¥, ğ‘ , ğ‘§, ğ‘ ). Indeed,
ğ‘â€² can be obtained from ğ‘ by deleting atom ğ‘‡ (ğ‘¥, ğ‘ , ğ‘§, ğ‘ ), renaming ğ‘…(ğ‘¢, ğ‘¥, ğ‘¢) as ğ‘… â€²(ğ‘¢, ğ‘¥, ğ‘¢) to ob-
tain ğ‘… â€²(ğ‘¢, ğ‘¥, ğ‘¢) âˆ§ ğ‘† â€²(ğ‘¦, ğ‘¦), reordering the variables in ğ‘… â€²(ğ‘¢, ğ‘¥, ğ‘¢) to obtain ğ‘… â€²(ğ‘¢, ğ‘¢, ğ‘¥) âˆ§ ğ‘† â€²(ğ‘¦, ğ‘¦),
renaming variable ğ‘¦ into ğ‘§ to obtain ğ‘… â€²(ğ‘¢, ğ‘¢, ğ‘¥) âˆ§ ğ‘† â€²(ğ‘§, ğ‘§), deleting the second variable occurrence
â–¡
in ğ‘† â€²(ğ‘§, ğ‘§) to obtain ğ‘… â€²(ğ‘¢, ğ‘¢, ğ‘¥) âˆ§ ğ‘† â€²(ğ‘§), and finally renaming variable ğ‘¥ into ğ‘¦ to obtain ğ‘â€².

We point out that in Definition 3.1, the important parts are those about deleting atoms and
variable occurrences. The parts about reordering variable occurences inside an atom and about
renaming relations and variables to fresh ones have obviously no effect on the complexity of the
problem2; these are only here to allow us to formally say, for instance, that â€œğ‘…(ğ‘¥) is a pattern
of ğ‘…(ğ‘¦)â€, or that â€œğ‘† (ğ‘¥, ğ‘¢, ğ‘¥) is a pattern of ğ‘‡ (ğ‘¤, ğ‘§, ğ‘§)â€ (as these are, in essence, the same queries).

In the following general lemma, we show that if ğ‘â€² is a pattern of ğ‘, then each of the problems
considered in this section is as hard for ğ‘ as it is for ğ‘â€². Recall in this result that unless stated
otherwise, our problems are defined for naive tables under the non-uniform setting.

Lemma 3.3. Let ğ‘, ğ‘â€² be sjfBCQs such that ğ‘â€² is a pattern of ğ‘. Then we have #Val(ğ‘â€²) â©½p
Moreover, the same results hold if we restrict to Codd tables, and/or to the uniform setting.

par #Val(ğ‘).

Proof. We first present the proof for #Val(ğ‘â€²) â©½p

par #Val(ğ‘), that is, for naive tables in the non-
uniform setting. First of all, observe that we can assume without loss of generality that we did not
reorder the variables in the atoms nor renamed relation names or variables by fresh ones, because,
as mentioned above, this does not change the complexity of the problem.3 We can then write ğ‘ as

1We remind the reader that we assume all sjfBCQs to contain at least one atom and that all atoms must contain at least one
variable.
2This is in particular because the conjunctive queries we consider have no self-joins (otherwise, reordering variables inside
an atom could change the complexity).
3Formally, one can first check that we can assume without loss of generality that ğ‘â€² was obtained from ğ‘ by first deleting
some atoms and variable occurences to obtain a query ğ‘â€²â€², and then performing some renamings and variable reorderings
to obtain ğ‘â€² (that is, we can always push the renaming and reordering parts at the end of the transformation). But then,
since #Val(ğ‘â€²â€²) and #Val(ğ‘â€²) are obviously the same problem, we can assume ğ‘â€² = ğ‘â€²â€².

The complexity of counting problems over incomplete databases

1:9

), where 1 â©½ ğ‘—1 < . . . < ğ‘—ğ‘ â©½ ğ‘š and ğ‘¥ â€²
ğ‘—ğ‘˜

ğ‘…1 (ğ‘¥1) âˆ§ . . . âˆ§ ğ‘…ğ‘š (ğ‘¥ğ‘š) and ğ‘â€² as ğ‘… ğ‘—1 (ğ‘¥ â€²
is
) âˆ§ . . . âˆ§ ğ‘… ğ‘—ğ‘ (ğ‘¥ â€²
ğ‘—ğ‘
ğ‘—1
obtained from ğ‘¥ ğ‘—ğ‘˜ by deleting some variable occurrences but not all4, and the other atoms have
been deleted. Let ğ· â€² be an incomplete database input of #Val(ğ‘â€²). Let ğ´ be the set of constants that
are appearing in ğ· â€² or are in a domain of some null occurring in ğ· â€². For 1 â©½ ğ‘˜ â©½ ğ‘, we construct
the relation ğ· (ğ‘… ğ‘—ğ‘˜ ) from the relation ğ· â€²(ğ‘… ğ‘—ğ‘˜ ). Let us assume that ğ‘¥ ğ‘—ğ‘˜ is the tuple (ğ‘¥1, . . . , ğ‘¥ğ‘Ÿ ) (with
some variables possibly being equal). We initialize ğ· (ğ‘… ğ‘—ğ‘˜ ) to be empty, and then for every tuple ğ‘¡ â€²
in ğ· â€²(ğ‘… ğ‘—ğ‘˜ ) we add to ğ· (ğ‘… ğ‘—ğ‘˜ ) all the tuples ğ‘¡ that can be obtained from ğ‘¡ â€² in the following way for
1 â©½ ğ‘– â©½ ğ‘Ÿ :

a) If ğ‘¥ğ‘– is a variable occurrence that has not been deleted from ğ‘¥ ğ‘—ğ‘˜ , then copy the element
(constant or null) of ğ‘¡ â€² corresponding to that variable occurrence to the ğ‘–-th position of ğ‘¡;
b) Otherwise, if ğ‘¥ğ‘– is a variable occurrence that has been deleted from ğ‘¥ ğ‘—ğ‘˜ , then fill the ğ‘–-th

position of ğ‘¡ with every possible constant from ğ´.

Then we construct the relations ğ· (ğ‘…ğ‘– ) where ğ‘…ğ‘– does not appear in ğ‘â€² (this can happen if we have
deleted the atom ğ‘…ğ‘– (ğ‘¥ğ‘– )) by filling it with every possible ğ‘…ğ‘– -fact over ğ´. We leave the domains of all
nulls unchanged. The whole construction can be performed in polynomial time (this uses the fact
that ğ‘ is assumed to be fixed, so that the arities of the relations mentioned in ğ‘ are fixed). Hence, it
only remains to be checked that #Val(ğ‘â€²)(ğ· â€²) = #Val(ğ‘)(ğ·), that is, that the reduction works and is
indeed parsimonious. It is clear that the valuations of ğ· â€² are exactly the same as the valuations of ğ·
(because they have the same sets of nulls). Hence it is enough to verify that for every valuation ğœˆ,
we have ğœˆ (ğ· â€²) |= ğ‘â€² if and only if ğœˆ (ğ·) |= ğ‘. Let â„â€² be a homomorphism from ğ‘â€² to ğœˆ (ğ· â€²) witnessing
that ğœˆ (ğ· â€²) |= ğ‘â€² (i.e., we have â„â€²(ğ‘) âŠ† ğœˆ (ğ· â€²)). Then â„â€² can clearly be extended in the expected
way into a homomorphism â„ from ğ‘ to ğœˆ (ğ·): this is in particular thanks to the fact that we filled
the missing columns with every possible constant. Conversely, let â„ be a homomorphism from ğ‘
to ğœˆ (ğ·) witnessing that ğœˆ (ğ·) |= ğ‘. Then the restriction â„â€² of â„ to the variables occurring in ğ‘â€² is
such that â„(ğ‘â€²) âŠ† ğœˆ (ğ· â€²), hence we have ğœˆ (ğ· â€²) |= ğ‘â€². This concludes the proof for the case of naive
tables in the non-uniform setting. For the cases of Codd tables and/or for the uniform setting, the
reduction is exactly the same. Indeed, the domains of the nulls are unchanged, and it is clear that
â–¡
the presented construction preserves the property of being a Codd table.

The idea is then to show the #P-hardness of our problems for some simple patterns, which then
we combine with Lemma 3.3 and with some tractability proofs to obtain the desired dichotomies.
Our findings are summarized in the first two columns of Table 1 in the introduction. We first focus
on the two dichotomies for the non-uniform setting in Section 3.1, and then we move to the case of
uniform incomplete databases in Section 3.2. We explicitly state when a #P-hardness result holds
even in the restricted setting in which there is a fixed domain over which nulls are interpreted.
In other words, when there is a fixed domain ğ´ such that the incomplete databases used in the
reductions are of the form ğ· = (ğ‘‡ , dom) and dom(âŠ¥) âŠ† ğ´, for each null âŠ¥ of ğ‘‡ .

3.1 The complexity on the non-uniform case
In this section, we study the complexity of the problems #Val(ğ‘) and #ValCd(ğ‘), providing dichotomy
results in both cases. We start by proving the #P-hardness results needed for these dichotomies.
We first show that #Val(ğ‘…(ğ‘¥, ğ‘¥)) is #P-hard by actually proving that hardness holds already in the
uniform case.

Proposition 3.4. #Valu (ğ‘…(ğ‘¥, ğ‘¥)) is #P-hard. This holds even in the restricted setting in which all

nulls are interpreted over the same fixed domain {1, 2, 3}.

4See Footnote 1.

1:10

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

Proof. We reduce from the problem of counting the number of 3-colorings of a graph ğº = (ğ‘‰ , ğ¸),
which is #P-hard [32]. For every node ğ‘£ âˆˆ ğ‘‰ we have a null âŠ¥ğ‘£, and for every edge {ğ‘¢, ğ‘£ } âˆˆ ğ¸ we
have the facts ğ‘…(âŠ¥ğ‘£, âŠ¥ğ‘¢) and ğ‘…(âŠ¥ğ‘¢, âŠ¥ğ‘£). The domain of the nulls is {1, 2, 3}. It is then clear that the
number of valuations of the constructed database that do not satisfy ğ‘…(ğ‘¥, ğ‘¥) is exactly the number
of 3-colorings of ğº. Since the total number of valuations can be computed in PTIME, this concludes
â–¡
the reduction.

The next pattern that we consider is ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥). This time, we can show #P-hardness of the

problem even for Codd databases.

Proposition 3.5. #ValCd(ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥)) is #P-hard.
Proof. We start by recalling the setting of consistent query answering under key constraints.
Intuitively, in this case we are given a set Î£ of keys and a database ğ· that does not necessarily
satisfy Î£. Then the task is to reason about the set of all repairs of ğ· with respect to Î£ [9]. In our
context, this means that one wants to count the number of repairs of ğ· with respect to Î£ that
satisfy a given CQ ğ‘. When ğ‘ and Î£ are fixed, we call this problem #Repairs(ğ‘, Î£); see, e.g., [40].
We formalize these notions below.

Here we focus on the case when Î£ is a set of primary keys. Recall that this means that each
relation name ğ‘… âˆˆ ğœ of arity ğ‘› comes equipped with its own key, i.e., key(ğ‘…) = ğ´, where ğ´ = âˆ… or
ğ´ = [1, . . . , ğ‘] for some ğ‘ âˆˆ {1, . . . , ğ‘›}. Henceforth, ğ· is inconsistent with respect to Î£ if there is a
relation name ğ‘… âˆˆ ğœ and facts ğ‘…( Â¯ğ‘), ğ‘…( Â¯ğ‘) âˆˆ ğ· with Â¯ğ‘ â‰  Â¯ğ‘ such that
ğœ‹ğ´ ( Â¯ğ‘) = ğœ‹ğ´ ( Â¯ğ‘).

key(ğ‘…) = ğ´ and

In this case we say that the pair (ğ‘…( Â¯ğ‘), ğ‘…( Â¯ğ‘)) is key-violating. Let us define a block in a database ğ·
with respect to a set Î£ of primary keys to be any maximal set ğµ of facts from ğ· such that the facts
in ğµ are pairwise key-violating. A repair of ğ· with respect to Î£ is a subset ğ· â€² of ğ· that is obtained
by choosing exactly one tuple from each block of ğ· with respect to Î£.

Let us consider a schema ğœ with two binary relations ğ‘… â€² and ğ‘† â€², such that key(ğ‘… â€²) = key(ğ‘† â€²) = {1}.
That is, the first attribute of both ğ‘… â€² and ğ‘† â€² defines a key over such relations. We define this set of
keys over ğœ to be Î£. Also, let ğ‘ = âˆƒğ‘¥, ğ‘¦, ğ‘§ (ğ‘… â€²(ğ‘¦, ğ‘¥) âˆ§ ğ‘† â€²(ğ‘§, ğ‘¥)). For simplicity, we write the pair (ğ‘, Î£)
as ğ‘… â€²(y, ğ‘¥) âˆ§ ğ‘† â€²(z, ğ‘¥). The problem #Repairs(ğ‘… â€²(y, ğ‘¥) âˆ§ ğ‘† â€²(z, ğ‘¥)), which given a database ğ· â€² over
schema ğœ aims at computing the number of repairs of ğ· â€² under Î£ that satisfy ğ‘, is known to be
#P-complete [40].5

Now, observe that the #P-hardness of #ValCd(ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥)) easily follows from the hardness of
the problem #Repairs(ğ‘… â€²(y, ğ‘¥) âˆ§ğ‘† â€²(z, ğ‘¥)). In fact, let ğ· â€² be a database with binary relation ğ‘… â€², ğ‘† â€². We
construct an incomplete Codd database ğ· with unary relations ğ‘…, ğ‘† as follows. For every constant ğ‘
that appears in the first attribute of ğ‘… â€², we have a tuple ğ‘…(âŠ¥) in ğ·, where âŠ¥ is a fresh null, and
we set dom(âŠ¥) = {ğ‘ | ğ‘… â€²(ğ‘, ğ‘) âˆˆ ğ· â€²}. For every constant ğ‘ that appears in the first attribute of ğ‘† â€²,
we have a tuple ğ‘† (âŠ¥) in ğ·, where âŠ¥ is a fresh null, and we set dom(âŠ¥) = {ğ‘ | ğ‘† â€²(ğ‘, ğ‘) âˆˆ ğ· â€²}. It is
then clear that the number of repairs of ğ· â€² that satisfy ğ‘… â€²(y, ğ‘¥) âˆ§ ğ‘† â€²(z, ğ‘¥) is equal to the number of
valuations of ğ· that satisfy ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥), thus concluding the proof. We point out here that another
proof of Proposition 3.5, that uses different techniques, can be found in the conference version of
â–¡
the article [8] (the proof that we presented here is shorter).

Already with Propositions 3.5 and 3.4, we have all the relevant hard patterns for the non-uniform

setting. We start by proving our dichotomy result for naive tables, which is our default case.

5To see that [40] establishes the hardness of ğ‘ = ğ‘…â€² (y, ğ‘¥) âˆ§ ğ‘†â€² (z, ğ‘¥), first apply their rewrite rule R7 (from Fig. 6) to
obtain ğ‘â€² = ğ‘…â€² (y, ğ‘¥) âˆ§ ğ‘†â€² (x, ğ‘¥), then apply rewrite rule R10 to obtain ğ‘â€²â€² = ğ‘…â€² (y, ğ‘¥) âˆ§ ğ‘†â€² (x, ğ‘). Then, ğ‘â€²â€² is #P-hard by
Lemma 19, and so is ğ‘ by Lemma 7.

The complexity of counting problems over incomplete databases

1:11

Theorem 3.6 (dichotomy). Let ğ‘ be an sjfBCQ. If ğ‘…(ğ‘¥, ğ‘¥) or ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥) is a pattern of ğ‘, then

#Val(ğ‘) is #P-complete. Otherwise, #Val(ğ‘) is in FP.

Proof. The #P-hardness part of the claim follows from the last two propositions and from
Lemma 3.3. We explain why the problems are in #P right after this proof. When ğ‘ does not have
any of these two patterns then all variables have exactly one occurrence in ğ‘. This implies that
every valuation ğœˆ of ğ· is such that ğœˆ (ğ·) satisfies ğ‘ (except when one relation is empty, in which
case the result is simply zero). We can then compute the total number of valuations in FP by simply
â–¡
multiplying the sizes of the domains of every null in ğ·.

Notice that in this theorem, the membership of #Val(ğ‘) in #P can be established by considering a
nondeterministic Turing Machine ğ‘€ that, with input a non-uniform incomplete database ğ·, guesses
a valuation ğœˆ of ğ· and verifies whether ğœˆ (ğ·) satisfies ğ‘. This machine works in polynomial time as
we can verify whether ğœˆ (ğ·) satisfies ğ‘ in polynomial time (since ğ‘ is a fixed FO query). Then given
that #Val(ğ‘)(ğ·) is equal to the number of accepting runs of ğ‘€ with input ğ·, we conclude that
#Val(ğ‘) is in #P. Obviously, the same idea works for codd tables, that is, #ValCd(ğ‘) is also in #P. But
with this restriction we obtain more tractable cases, as shown by the following dichotomy result.

Theorem 3.7 (dichotomy). Let ğ‘ be an sjfBCQ. If ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥) is a pattern of ğ‘, then #ValCd (ğ‘) is

#P-complete. Otherwise, #ValCd(ğ‘) is in FP.

Proof. We only need to prove the tractability claim, since hardness follows from Proposition 3.5
and Lemma 3.3. We will assume without loss of generality that ğ· contains no constants, as we can
introduce a fresh null with domain {ğ‘} for every constant ğ‘ appearing in ğ·, and the result is again
a Codd table, and this does not change the output of the problem. Let ğ‘ be ğ‘…1( Â¯ğ‘¥1) âˆ§ . . . âˆ§ ğ‘…ğ‘š ( Â¯ğ‘¥ğ‘š).
Observe that since ğ‘ does not have ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥) as a pattern then any two atoms cannot have a
variable in common. But then, since ğ· is a Codd table we have

#ValCd (ğ‘)(ğ·) =

ğ‘š
(cid:214)

ğ‘–=1

#ValCd (ğ‘…ğ‘– ( Â¯ğ‘¥ğ‘– ))(ğ· (ğ‘…ğ‘– )).

Hence it is enough to show how to compute #ValCd(ğ‘…ğ‘– ( Â¯ğ‘¥ğ‘– ))(ğ· (ğ‘…ğ‘– )) for every 1 â©½ ğ‘– â©½ ğ‘š. Let Â¯ğ‘¡1, . . . , Â¯ğ‘¡ğ‘›
be the tuples of ğ· (ğ‘…ğ‘– ). Let us write ğœŒ (Â¯ğ‘¡ ğ‘— ) for the number of valuations of the nulls appearing in Â¯ğ‘¡ ğ‘—
ğ‘—=1 ğœŒ (Â¯ğ‘¡ ğ‘— ), so
that do not match Â¯ğ‘¥ğ‘– . Clearly, #ValCd (ğ‘…ğ‘– ( Â¯ğ‘¥ğ‘– ))(ğ· (ğ‘…ğ‘– )) = (cid:206)
we only have to show how to compute ğœŒ (Â¯ğ‘¡ ğ‘— ) for 1 â©½ ğ‘— â©½ ğ‘›. Since we can easily compute the total
number of valuations of Â¯ğ‘¡ ğ‘— , it is enough to show how to compute the number of valuations of Â¯ğ‘¡ ğ‘—
that match Â¯ğ‘¥ğ‘– . For every variable ğ‘¥ that appears in Â¯ğ‘¥ğ‘– , compute the size of the intersection of the
domains of the corresponding nulls in Â¯ğ‘¡ ğ‘— , and denote it ğ‘ ğ‘¥ . Then the number of valuations of Â¯ğ‘¡ ğ‘— that
match Â¯ğ‘¥ğ‘– is simply (cid:206)ğ‘¥ appears in Â¯ğ‘¥ğ‘–
â–¡
ğ‘ ğ‘¥ . This concludes the proof.

âŠ¥ appears in ğ· (ğ‘…ğ‘– ) |dom(âŠ¥)| âˆ’ (cid:206)ğ‘›

At this stage, we have completed the first column of Table 1, and we also know that ğ‘…(ğ‘¥, ğ‘¥) is a
hard pattern in the uniform setting for naive tables (but not for Codd tables, by Theorem 3.7). In
the next section, we treat the uniform setting.

3.2 The complexity on the uniform case
In this section, we study the complexity of the problems #Valu(ğ‘) and #Valu
Cd
dichotomy results in both cases.

(ğ‘), again providing

3.2.1 NaÃ¯ve tables. We start our investigation with the case of naive tables. In Proposition 3.4, we
already showed that #Valu(ğ‘…(ğ‘¥, ğ‘¥)) is #P-hard. In the following proposition, we identify two other
simple queries for which this problem is still intractable.

1:12

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

Proposition 3.8. #Valu(ğ‘…(ğ‘¥) âˆ§ğ‘† (ğ‘¥, ğ‘¦) âˆ§ğ‘‡ (ğ‘¦)) and #Valu(ğ‘…(ğ‘¥, ğ‘¦) âˆ§ğ‘† (ğ‘¥, ğ‘¦)) are both #P-hard. This
holds even in the restricted setting in which all nulls are interpreted over the same fixed domain {0, 1}.
Proof. We reduce both problems from the problem of counting the number of independent sets
in a graph (denoted by #IS), which is #P-complete [44]. We start with #Valu(ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥, ğ‘¦) âˆ§ ğ‘‡ (ğ‘¦)).
Let ğ‘ = ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥, ğ‘¦) âˆ§ ğ‘‡ (ğ‘¦) and ğº = (ğ‘‰ , ğ¸) be a graph. Then we define an incomplete database ğ·
as follows. For every node ğ‘£ âˆˆ ğ‘‰ , we have a null âŠ¥ğ‘£, and the uniform domain is {0, 1}. For every
edge {ğ‘¢, ğ‘£ } âˆˆ ğ¸, we have facts ğ‘† (âŠ¥ğ‘¢, âŠ¥ğ‘£) and ğ‘† (âŠ¥ğ‘£, âŠ¥ğ‘¢) in ğ·. Finally, we have facts ğ‘…(1) and ğ‘‡ (1)
in ğ·. For a valuation ğœˆ of the nulls, consider the corresponding subset ğ‘†ğœˆ of nodes of ğº, given
by ğ‘†ğœˆ = {ğ‘¡ âˆˆ ğ‘‰ | ğœˆ (âŠ¥ğ‘¡ ) = 1}. This is a bijection between the valuations of the database and the
node subsets of ğº. Moreover, we have that ğœˆ (ğ·) Ì¸|= ğ‘ if and only if ğ‘†ğœˆ is an independent set of ğº.
Since the total number of valuations of ğ· is 2 |ğ‘‰ |, we have that the number of independent sets
of ğº is equal to 2|ğ‘‰ | âˆ’ #Valu (ğ‘)(ğ·). Hence, we conclude that #IS â©½p
T #Valu(ğ‘). The idea is similar
for #Valu (ğ‘…(ğ‘¥, ğ‘¦) âˆ§ ğ‘† (ğ‘¥, ğ‘¦)): we encode the graph with the relation ğ‘† in the same way, and this time
â–¡
we add the fact ğ‘…(1, 1).

As shown in the following result, it turns out that the three aforementioned patterns are enough
to fully characterize the complexity of counting valuations for naive tables in the uniform setting.

Theorem 3.9 (dichotomy). Let ğ‘ be an sjfBCQ. If ğ‘…(ğ‘¥, ğ‘¥) or ğ‘…(ğ‘¥)âˆ§ğ‘† (ğ‘¥, ğ‘¦)âˆ§ğ‘‡ (ğ‘¦) or ğ‘…(ğ‘¥, ğ‘¦)âˆ§ğ‘† (ğ‘¥, ğ‘¦)

is a pattern of ğ‘, then #Valu (ğ‘) is #P-complete. Otherwise, #Valu (ğ‘) is in FP.

The #P-completeness part of the claim follows directly from what we have proved already.
Here, the most challenging part of the proof is actually the tractability part. We only present a
simple example to give an idea of the proof technique, and defer the full proof to Appendix A.1.
We will use the following definition. Given ğ‘›, ğ‘š âˆˆ N, let us write surjğ‘›â†’ğ‘š for the number of
surjective functions from {1, . . . , ğ‘›} to {1, . . . , ğ‘š}. By an inclusionâ€“exclusion argument, one can
(cid:1) (ğ‘š âˆ’ ğ‘–)ğ‘› (for instance, see [3]). It is clear that this can be
show that surjğ‘›â†’ğ‘š = (cid:205)ğ‘šâˆ’1
computed in FP, when ğ‘› and ğ‘š are given in unary.

ğ‘–=0 (âˆ’1)ğ‘– (cid:0)ğ‘š

ğ‘–

Example 3.10. Let ğ‘ be the sjfBCQ ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥), and ğ· be an incomplete database over rela-
tions ğ‘…, ğ‘†. Notice that ğ‘ does not have any of the patterns mentioned in Theorem 3.9. We will show
that #Valu(ğ‘) is in FP. Since ğ‘ contains only two unary atoms we can also assume without loss of
generality that the input ğ· is a Codd table (otherwise all valuations are satisfying).

Since we can compute in FP the total number of valuations, it is enough to show how to compute
the number of valuations of ğ· that do not satisfy ğ‘. Let dom be the uniform domain, ğ‘‘ be its
size, ğ‘›ğ‘… (resp., ğ‘›ğ‘† ) be the number of nulls in ğ· (ğ‘…) (resp., in ğ· (ğ‘†)) and ğ¶ğ‘… (resp., ğ¶ğ‘† ) be the set of
constants occurring in ğ· (ğ‘…) (resp., in ğ· (ğ‘†)), with ğ‘ğ‘… (resp., ğ‘ğ‘† ) its size. We can assume without loss
of generality that ğ¶ğ‘… âˆ© ğ¶ğ‘† = âˆ…, as otherwise all the valuations are satisfying, and this is computable
in PTIME. Furthermore, we can also assume that ğ¶ğ‘… âˆªğ¶ğ‘† âŠ† dom, since we can remove the constants
that are not in dom, as these can never match.

Let ğ‘€ := dom \ (ğ¶ğ‘… âˆª ğ¶ğ‘† ), and ğ‘š its size (i.e., with our assumptions we have ğ‘š = ğ‘‘ âˆ’ ğ‘ğ‘… âˆ’ ğ‘ğ‘† ).
Fix some subsets ğ‘€ â€² âŠ† ğ‘€ and ğ‘… â€² âŠ† ğ¶ğ‘…. The quantity surjğ‘›ğ‘… â†’|ğ‘€â€² |+ |ğ‘…â€² | then counts the number of
valuations of the nulls of ğ· (ğ‘…) that span exactly ğ‘€ â€² âˆª ğ‘… â€². Moreover, letting ğœˆğ‘… be a valuation of the
nulls of ğ· (ğ‘…) that spans exactly ğ‘€ â€² âˆª ğ‘… â€², the quantity (ğ‘‘ âˆ’ ğ‘ğ‘… âˆ’ |ğ‘€ â€²|)ğ‘›ğ‘† is the number of ways to
extend ğœˆğ‘… into a valuation ğœˆ of all the nulls of ğ· so that ğœˆ (ğ·) Ì¸|= ğ‘: indeed, every null of ğ· (ğ‘†) can
take any value in dom \ (ğ¶ğ‘… âˆª ğ‘€ â€²). The number of valuations of ğ· that do not satisfy ğ‘ is then
(keeping in mind that a null in ğ· (ğ‘…) cannot take a value in ğ¶ğ‘† ):
âˆ‘ï¸

surjğ‘›ğ‘… â†’|ğ‘€â€² |+|ğ‘…â€² | Ã— (ğ‘‘ âˆ’ ğ‘ğ‘… âˆ’ |ğ‘€ â€²|)ğ‘›ğ‘†

ğ‘€â€² âŠ†ğ‘€
ğ‘…â€² âŠ†ğ¶ğ‘…

The complexity of counting problems over incomplete databases

and since the summands only depends on the sizes of ğ‘€ â€² and ğ‘… â€², this is equal to

(cid:19)

(cid:18) ğ‘š
ğ‘šâ€²

(cid:19) (cid:18)ğ‘ğ‘…
ğ‘Ÿ â€²

âˆ‘ï¸

0â©½ğ‘šâ€²â©½ğ‘š
0â©½ğ‘Ÿ â€²â©½ğ‘ğ‘…

surjğ‘›ğ‘… â†’ğ‘šâ€²+ğ‘Ÿ â€² Ã— (ğ‘‘ âˆ’ ğ‘ğ‘… âˆ’ ğ‘šâ€²)ğ‘›ğ‘†

This last expression can clearly be computed in PTIME.6

1:13

â–¡

3.2.2 Codd tables. We conclude this section by turning our attention to the case of Codd tables.
Notice that none of the results proved so far provides a hard pattern in this case. We identify in the
following proposition a simple query for which the problem is intractable.

Proposition 3.11. #Valu
Cd

(ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥, ğ‘¦) âˆ§ ğ‘‡ (ğ‘¦)) is #P-hard.

Proof. We reduce from the problem of counting the number of independent sets of a bipartite
(simple) graph, written #BIS, which is #P-hard [44]. Let ğº = (ğ‘‹ âŠ” ğ‘Œ, ğ¸) be a bipartite graph.
Without loss of generality, we can assume that |ğ‘‹ | = |ğ‘Œ | = ğ‘›; indeed, if |ğ‘‹ | < |ğ‘Œ | then we could
simply add |ğ‘Œ | âˆ’ |ğ‘‹ | isolated nodes to complete the graph, which simply multiplies the number of
independent sets by 2|ğ‘Œ |âˆ’|ğ‘‹ |. Also, observe that counting the number of independent sets of ğº is
the same as counting the number of pairs (ğ‘†1, ğ‘†2) with ğ‘†1 âŠ† ğ‘‹, ğ‘†2 âŠ† ğ‘Œ , such that (ğ‘†1 Ã— ğ‘†2) âˆ© ğ¸ = âˆ….
We will call such a pair an independent pair. For 0 â©½ ğ‘–, ğ‘— â©½ ğ‘›, let ğ‘ğ‘–,ğ‘— be the number of independent
pairs (ğ‘†1, ğ‘†2) such that |ğ‘†1| = ğ‘– and |ğ‘†2| = ğ‘—. It is clear that (â˜…) the number of independent sets of ğº
is then #BIS(ğº) = (cid:205)0â©½ğ‘–,ğ‘— â©½ğ‘› ğ‘ğ‘–,ğ‘— . The idea of the reduction is to construct in polynomial time (ğ‘› + 1)2
incomplete databases ğ·ğ‘,ğ‘ for 0 â©½ ğ‘, ğ‘ â©½ ğ‘› such that, letting ğ¶ğ‘,ğ‘ be the number of valuations ğœˆ
of ğ·ğ‘,ğ‘ with ğœˆ (ğ·ğ‘,ğ‘) Ì¸|= ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥, ğ‘¦) âˆ§ ğ‘‡ (ğ‘¦), the values of the variables ğ‘ğ‘–,ğ‘— and ğ¶ğ‘–,ğ‘— form a linear
system of equations AZ = C, with A an invertible matrix. This will allow us, using (ğ‘› + 1)2 calls to
an oracle for #Valu
(ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥, ğ‘¦) âˆ§ğ‘‡ (ğ‘¦)), to recover the ğ‘ğ‘–,ğ‘— values, and then to compute #BIS(ğº)
Cd
using (â˜…). We now explain how we construct ğ·ğ‘,ğ‘ from ğº for 0 â©½ ğ‘, ğ‘ â©½ ğ‘›, and define A. First, we
fix an arbitrary linear order ğ‘¥1, . . . , ğ‘¥ğ‘› of ğ‘‹ , and similarly ğ‘¦1, . . . , ğ‘¦ğ‘› for ğ‘Œ . The database ğ·ğ‘,ğ‘ has
constants ğ‘ğ‘– for 1 â©½ ğ‘– â©½ ğ‘›, and has a fact ğ‘† (ğ‘ğ‘–, ğ‘ ğ‘— ) whenever (ğ‘¥ğ‘–, ğ‘¦ ğ‘— ) âˆˆ ğ¸. It has nulls âŠ¥1, . . . , âŠ¥ğ‘
and facts ğ‘…(âŠ¥ğ‘– ) for 1 â©½ ğ‘– â©½ ğ‘ (if ğ‘ = 0 there are no such nulls and facts), and nulls âŠ¥â€²
1, . . . , âŠ¥â€²
ğ‘
ğ‘– ) for 1 â©½ ğ‘– â©½ ğ‘; in particular, this is a Codd table. The uniform domain of the nulls
and facts ğ‘‡ (âŠ¥â€²
is {ğ‘ğ‘– | 1 â©½ ğ‘– â©½ ğ‘›}. Given a valuation ğœˆ of ğ·ğ‘,ğ‘, let ğ‘ƒ (ğœˆ) be the pair of subsets of ğ‘‰ defined by

ğ‘ƒ (ğœˆ)

def
= ({ğ‘¥ğ‘– | âˆƒ1 â©½ ğ‘˜ â©½ ğ‘ s.t. ğœˆ (âŠ¥ğ‘˜ ) = ğ‘ğ‘– }, {ğ‘¦ğ‘– | âˆƒ1 â©½ ğ‘˜ â©½ ğ‘ s.t. ğœˆ (âŠ¥â€²

ğ‘˜ ) = ğ‘ğ‘– })

One can then easily check that the following two claims hold:

â€¢ For every valuation ğœˆ of ğ·ğ‘,ğ‘, we have that ğœˆ (ğ·ğ‘,ğ‘) Ì¸|= ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥, ğ‘¦) âˆ§ ğ‘‡ (ğ‘¦) iff ğ‘ƒ (ğœˆ) is an

independent pair of ğº;7

â€¢ For every independent pair (ğ‘†1, ğ‘†2) of ğº, there are exactly surjğ‘â†’|ğ‘†1 | Ã— surjğ‘â†’|ğ‘†2 | valuations ğœˆ

such that ğ‘ƒ (ğœˆ) = (ğ‘†1, ğ‘†2).

But then, we have ğ¶ğ‘,ğ‘ = (cid:205)0â©½ğ‘–,ğ‘— â©½ğ‘› (surjğ‘â†’ğ‘– Ã— surjğ‘â†’ğ‘— )ğ‘ğ‘–,ğ‘— . In other words, we have the linear
def
system of equations AZ = C, where A is the (ğ‘› + 1)2 Ã— (ğ‘› + 1)2 matrix defined by A(ğ‘,ğ‘),(ğ‘–,ğ‘—)
=
surjğ‘â†’ğ‘– Ã— surjğ‘â†’ğ‘— . This matrix is the Kronecker product Aâ€² âŠ— Aâ€² of the (ğ‘› + 1) Ã— (ğ‘› + 1) matrix with
def
= surjğ‘â†’ğ‘– . Since Aâ€² is a triangular matrix with non-zero coefficients on the diagonal,
entries Aâ€²
ğ‘,ğ‘–
â–¡
it is invertible, hence so is A, which concludes the proof.

6Note that in the sum we do not need to specify that ğ‘šâ€² + ğ‘Ÿ â€² â©½ ğ‘›ğ‘… , as when ğ‘ < ğ‘ we have surjğ‘â†’ğ‘ = 0.
7This observation, and in fact the idea of reducing from #BIS, is due to Antoine Amarilli.

1:14

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

Note that in Proposition 3.8, we proved that #Valu(ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥, ğ‘¦) âˆ§ ğ‘‡ (ğ‘¦)) is #P-hard in the
general case where naive tables are allowed. Hence, the hardness of that query for naive tables
was in fact a consequence of Proposition 3.11. However, we decided to provide a separate proof for
Proposition 3.8, because in this case intractability holds already when nulls are interpreted over
the fixed domain {0, 1}, whereas we do not know if this is true for Codd tables.

The second pattern that we show is hard for #Valu for Codd tables is ğ‘…(ğ‘¥, ğ‘¦) âˆ§ ğ‘† (ğ‘¥, ğ‘¦). Again,
notice that we already showed this query to be hard in the case of naive tables (as Proposition 3.8),
even for a fixed domain of {0, 1}. In the case of Codd tables, hardness still holds, but the proof is
more complicated and uses domains of unbounded size (which is why we provide separate proofs).
We show:

Proposition 3.12. #Valu
Cd

(ğ‘…(ğ‘¥, ğ‘¦) âˆ§ ğ‘† (ğ‘¥, ğ‘¦)) is #P-hard.

def
= |ğ´|, and ğ‘›ğµ

Proof. Let ğ‘ be the query ğ‘…(ğ‘¥, ğ‘¦) âˆ§ ğ‘† (ğ‘¥, ğ‘¦). We reduce from the problem of counting the number
of matchings of a 2-3â€“regular bipartite graph, which is #P-complete [14, 55]. Let ğº = (ğ´ âŠ” ğµ, ğ¸)
be a 2-3â€“regular bipartite graph, with the nodes in ğ´ having degree 3 and those in ğµ having
def
= |ğµ|. Notice that since ğº is 2-3â€“regular we have that ğ‘›ğµ = 3ğ‘›ğ´
degree 2, and let ğ‘›ğ´
2 .
We say that a set ğ‘† âŠ† ğ¸ of edges of ğº is an ğ´-semimatching if every node ğ‘ of ğ´ is adjacent
to at most 1 edge of ğ‘†; formally, for every ğ‘ âˆˆ ğ´ we have |{ğ‘’ âˆˆ ğ‘† | ğ‘ âˆˆ ğ‘’}| â©½ 1. The type of
an ğ´-semimatching ğ‘† is the number ğ‘ of nodes in ğµ that are adjacent to exactly 2 edges of ğ‘†;
formally, ğ‘ def
|{ğ‘’ âˆˆ ğ‘† | ğ‘ âˆˆ ğ‘’}| = 2}|. For 0 â©½ ğ‘ â©½ ğ‘›ğµ, we write ğ‘‡ğ‘ for the number
of ğ´-semimatchings of ğº of type ğ‘. Observe then that ğ‘‡0 is simply the number of matchings of ğº.
The idea of the reduction is then as follows. We will construct databases ğ·ğ‘˜ for 0 â©½ ğ‘˜ â©½ ğ‘›ğµ such that,
letting ğ¶ğ‘˜ be the number of valuations ğœˆ of ğ·ğ‘˜ such that ğœˆ (ğ·ğ‘˜ ) Ì¸|= ğ‘, the values of the variables ğ‘‡ğ‘˜
and ğ¶ğ‘˜ form a system of linear equations AT = C, with A and invertible matrix. This will allow
us, using ğ‘›ğµ + 1 calls to and oracle for #Valu
(ğ‘), to recover the values ğ‘‡ğ‘˜ , and thus to obtain ğ‘‡0
Cd
in polynomial time, that is, the number of matchings of ğº. We now explain how to construct the
database ğ·ğ‘˜ for 0 â©½ ğ‘˜ â©½ ğ‘›ğµ. In what follows we use the convention that {1, . . . , ğ‘˜ } = âˆ… when ğ‘˜ = 0.
The database ğ·ğ‘˜ contains the following facts:

= |{ğ‘ âˆˆ ğµ |

(1) One fact ğ‘…(ğ‘, âŠ¥ğ‘) for every ğ‘ âˆˆ ğ´;
(2) One fact ğ‘† (âŠ¥ğ‘, ğ‘) for every ğ‘ âˆˆ ğµ;
(3) One fact ğ‘† (âŠ¥ğ‘â€², ğ‘â€²) for every ğ‘ âˆˆ ğ´ where ğ‘â€² is a fresh constant. In particular, observe that

there are ğ‘›ğ´ such facts. In what follows we will write ğ´â€² def

= {ğ‘â€² | ğ‘ âˆˆ ğ´}.

2) for every (ğ‘1, ğ‘2) âˆˆ ğ´ Ã— ğ´ with ğ‘1 â‰  ğ‘2;

(4) One fact ğ‘† (ğ‘1, ğ‘â€²
(5) One fact ğ‘† (ğ‘, ğ‘–) for every (ğ‘, ğ‘–) âˆˆ ğ´ Ã— {1, . . . , ğ‘˜ };
(6) One fact ğ‘† (ğ‘¢, ğ‘£) for every (ğ‘¢, ğ‘£) âˆˆ (ğ´ âˆª ğµ)2 such that {ğ‘¢, ğ‘£ } is not in ğ¸.
(7) One fact ğ‘…(ğ‘¢, ğ‘£) for every (ğ‘¢, ğ‘£) âˆˆ (ğ´â€² âˆª ğµ)2.

And finally, the (uniform) domain for all the nulls is dom def

= ğ´ âˆª ğµ âˆª ğ´â€² âˆª {1, . . . , ğ‘˜ }. Note that
this is indeed a Codd database. Now, let us compute ğ¶ğ‘˜ , the number of valuations ğœˆ of ğ·ğ‘˜ such
that ğœˆ (ğ·ğ‘˜ ) Ì¸|= ğ‘. For such a valuation ğœˆ of ğ·ğ‘˜ such that ğœˆ (ğ·ğ‘˜ ) Ì¸|= ğ‘, observe that (â˜…) for every ğ‘ âˆˆ ğ´
it holds that ğœˆ (âŠ¥ğ‘) is either ğ‘â€² or is one of the nodes in ğµ that is a neighbor of ğ‘; this is because
otherwise, the facts from (4-6) would make the query be satisfied. Then, for a valuation ğœˆ of ğ·ğ‘˜
def
such that ğœˆ (ğ·ğ‘˜ ) Ì¸|= ğ‘, let us define SM(ğœˆ)
= {{ğ‘, ğ‘} | (ğ‘, ğ‘) âˆˆ (ğ´ Ã— ğµ) âˆ© ğ‘…(ğœˆ (ğ·ğ‘˜ ))}. Because of (â˜…),
observe that SM(ğœˆ) is a subset of ğ¸, and that it is in fact an ğ´-semimatching. We can then partition

The complexity of counting problems over incomplete databases

1:15

the valuations ğœˆ of ğ·ğ‘˜ with ğœˆ (ğ·ğ‘˜ ) Ì¸|= ğ‘ according to the type of SM(ğœˆ) as follows:

{ğœˆ | ğœˆ is a valuation of ğ·ğ‘˜ with ğœˆ (ğ·ğ‘˜ ) Ì¸|= ğ‘} =

(cid:196)

0â©½ğ‘ â©½ğ‘›ğµ

(cid:196)

(cid:196)

{ğœˆ }.

ğ‘†: ğ‘† is an ğ´-semimatching
of ğº of type ğ‘

ğœˆ: ğœˆ valuation of ğ·ğ‘˜
ğœˆ (ğ·ğ‘˜ )Ì¸|=ğ‘
SM(ğœˆ)=ğ‘†

(2)
Fix an ğ´-semimatching ğ‘† of ğº of type ğ‘ âˆˆ {0, . . . , ğ‘›ğµ }, and let us count how many valuations ğœˆ
of ğ·ğ‘˜ there are such that ğœˆ (ğ·ğ‘˜ ) Ì¸|= ğ‘ and SM(ğœˆ) = ğ‘†. First of all, observe that for such a valuation ğœˆ,
the value of ğœˆ (âŠ¥ğ‘) for every ğ‘ âˆˆ ğ´ is forced: it is ğ‘â€² if ğ‘ is adjacent to no edge of ğ‘†, and otherwise it
is ğ‘ for the unique {ğ‘, ğ‘} âˆˆ ğ‘†. Therefore we have to count how many possibilities there are for the
remaining nulls, those of the form âŠ¥ğ‘â€² and âŠ¥ğ‘ from facts (2-3). We have:

â€¢ For a null âŠ¥ğ‘ such that ğ‘ is adjacent to two edges of ğ‘†, there are ğ‘›ğ´ + ğ‘˜ âˆ’ 2 possible values in

order to not satisfy the query. Note that there are ğ‘ such nulls âŠ¥ğ‘.

â€¢ For a null âŠ¥ğ‘â€² such that ğ‘ is not adjacent to an edge in ğ‘† (so that we know that ğœˆ (âŠ¥ğ‘) = ğ‘â€²),
there are ğ‘›ğ´ + ğ‘˜ âˆ’ 1 possible values in order to not satisfy the query. For a null âŠ¥ğ‘ such that ğ‘
is adjacent to exactly one edge {ğ‘, ğ‘} of ğ‘† (i.e., we have ğœˆ (âŠ¥ğ‘) = ğ‘) there are again ğ‘›ğ´ + ğ‘˜ âˆ’ 1
possible values to not satisfy the query. Observe that in total there are ğ‘›ğ´ âˆ’ 2ğ‘ such nulls âŠ¥ğ‘â€²
or âŠ¥ğ‘, because ğ‘† is an ğ´-semimatching.

â€¢ For a null âŠ¥ğ‘â€² such that ğ‘ is adjacent to an edge in ğ‘† (so that we know that ğœˆ (âŠ¥ğ‘) â‰  ğ‘â€²)
there are ğ‘›ğ´ + ğ‘˜ possibilities, and similarly for a null âŠ¥ğ‘ such that ğ‘ is not adjacent to
an edge in ğ‘† there are ğ‘›ğ´ + ğ‘˜ possible values. By the previous two items, in total there
are ğ‘›ğ´ + ğ‘›ğµ âˆ’ ğ‘ âˆ’ (ğ‘›ğ´ âˆ’ 2ğ‘) = ğ‘›ğµ + ğ‘ such nulls âŠ¥ğ‘â€² or âŠ¥ğ‘.

Therefore, there are exactly (ğ‘›ğ´ + ğ‘˜ âˆ’ 2)ğ‘ (ğ‘›ğ´ + ğ‘˜ âˆ’ 1)ğ‘›ğ´âˆ’2ğ‘ (ğ‘›ğ´ + ğ‘˜)ğ‘›ğµ +ğ‘ valuations ğœˆ of ğ·ğ‘˜ such
that ğœˆ (ğ·ğ‘˜ ) Ì¸|= ğ‘ and SM(ğœˆ) = ğ‘†. Since this depends only on the type of the ğ´-semimatching ğ‘† (and
not on ğ‘† itself), we obtain from Equation 2 that

ğ¶ğ‘˜ = |{ğœˆ | ğœˆ is a valuation of ğ·ğ‘˜ with ğœˆ (ğ·ğ‘˜ ) Ì¸|= ğ‘}|

âˆ‘ï¸

=

0â©½ğ‘ â©½ğ‘›ğµ

ğ‘‡ğ‘ Ã— (ğ‘›ğ´ + ğ‘˜ âˆ’ 2)ğ‘ (ğ‘›ğ´ + ğ‘˜ âˆ’ 1)ğ‘›ğ´âˆ’2ğ‘ (ğ‘›ğ´ + ğ‘˜)ğ‘›ğµ +ğ‘ .

That is, we have the linear system of equations AT = C, with Ağ‘˜,ğ‘ = (ğ‘›ğ´ + ğ‘˜ âˆ’ 2)ğ‘ (ğ‘›ğ´ +
ğ‘˜ âˆ’ 1)ğ‘›ğ´âˆ’2ğ‘ (ğ‘›ğ´ + ğ‘˜)ğ‘›ğµ +ğ‘ for 0 â©½ ğ‘, ğ‘˜ â©½ ğ‘›ğµ. But observe that we have A = DV, with D being
the diagonal (ğ‘›ğµ + 1) Ã— (ğ‘›ğµ + 1) matrix with entries (ğ‘›ğ´ + ğ‘˜ âˆ’ 2)ğ‘›ğ´ (ğ‘›ğ´ + ğ‘˜)ğ‘›ğµ , and V being
the (ğ‘›ğµ + 1) Ã— (ğ‘›ğµ + 1) Vandermonde matrix with coefficients (ğ‘›ğ´+ğ‘˜âˆ’2) (ğ‘›ğ´+ğ‘˜)
for 0 â©½ ğ‘˜ â©½ ğ‘›ğµ. Hence
to show that A is invertible, we only need to argue that the coefficients of this Vandermonde matrix V
def
= (ğ‘›ğ´+ğ‘¥âˆ’2) (ğ‘›ğ´+ğ‘¥)
are all distinct. But for the function ğ‘“ğ‘›ğ´ (ğ‘¥)
(ğ‘›ğ´+ğ‘¥âˆ’1) 3 ,
(ğ‘›ğ´+ğ‘¥âˆ’1) 2
so that ğ‘“ğ‘›ğ´ is strictly increasing on [0, ğ‘›ğµ] (we assume ğ‘›ğ´ â©¾ 2 without loss of generality), so that
â–¡
all the coefficients are indeed distinct. This concludes the proof.

, one can check that ğ‘“ â€²

ğ‘›ğ´ (ğ‘¥) =

(ğ‘›ğ´+ğ‘˜âˆ’1) 2

2

As we show next, the patterns from Propositions 3.12 and 3.11 are the only hard patterns

for #Valu
Cd

. The following is then the last dichotomy of this section.

Theorem 3.13 (dichotomy). Let ğ‘ be an sjfBCQ. If ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥, ğ‘¦) âˆ§ ğ‘‡ (ğ‘¦) or ğ‘…(ğ‘¥, ğ‘¦) âˆ§ ğ‘† (ğ‘¥, ğ‘¦) is a

pattern of ğ‘, then #Valu
Cd

(ğ‘) is #P-complete. Otherwise, #Valu
Cd

(ğ‘) is in FP.

We only need to show the tractability part of that claim, as hardness follows from Propositions 3.12
and 3.11 and Lemma 3.3. First of all, observe that we can assume without loss of generality that
the sjfBCQ ğ‘ is connected. This is because ğ‘ has no self-join and the database ğ· is Codd, so,

1:16

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

letting ğ‘1, . . . , ğ‘ğ‘¡ be the connected components of ğ‘, and letting ğ·ğ‘– be the database ğ· restricted to
the relations appearing in ğ‘ğ‘– , we have that

#Valu

Cd (ğ‘)(ğ·) =

#Valu

Cd (ğ‘ğ‘– )(ğ·ğ‘– ).

ğ‘¡
(cid:214)

ğ‘–=1
Second, notice that, for a connected sjfBCQ ğ‘, not containing any of these two patterns is
equivalent to the following: there exists a variable ğ‘¥ such that all atoms of ğ‘ contain variable ğ‘¥,
and for any two atoms of ğ‘, the only variable that they have in common is ğ‘¥. In other words, ğ‘¥
is in every atom and every other variable occurs in only one atom. For instance ğ‘…1(ğ‘¥, ğ‘¦, ğ‘¦) âˆ§
ğ‘…2(ğ‘¥, ğ‘¥, ğ‘§, ğ‘§, ğ‘§, ğ‘¢, ğ‘¢) âˆ§ ğ‘…3(ğ‘¥, ğ‘¥, ğ‘£, ğ‘¡, ğ‘¡) is such a query. We now provide an example of a connected
query with only two atoms.

Example 3.14. We consider the query ğ‘ = ğ‘…(ğ‘¥, ğ‘¥, ğ‘¦, ğ‘¦) âˆ§ ğ‘† (ğ‘¥, ğ‘¥). Let ğ· be an incomplete Codd
database over relations ğ‘…, ğ‘†, with uniform domain dom of size ğ‘‘. In this proof we will use sym-
bols ğ‘, ğ‘1, ğ‘2, . . . to denote a constant or a null, and symbols ğ‘, ğ‘1, ğ‘2, . . . to denote constants. Moreover,
unless stated otherwise, these symbols can refer to the same constant (but not to the same null
because ğ· is a Codd database). A fact that contains only constants is called a ground fact. Further-
more, since that database is Codd we will always represent a null with âŠ¥, being understood that
they are all distinct.

We start with a few simplifications. First, we assume wlog that ğ· does not contain ground
facts that already satisfy the query. Second, we assume wlog that ğ· does not contain facts of the
form ğ‘…(ğ‘, ğ‘â€², ğ‘, ğ‘ â€²) or ğ‘…(ğ‘, ğ‘ â€², ğ‘, ğ‘â€²) or ğ‘† (ğ‘, ğ‘ â€²) where ğ‘ and ğ‘ â€² are distinct constants. Indeed, because ğ·
is Codd and such a fact ğ‘“ can never be part of a match, we could simply remove ğ‘“ from ğ· and
multiply the end result by the appropriate value (namely, ğ‘‘ğ‘¡ where ğ‘¡ is the number of nulls of ğ‘“ ).
Last, we assume wlog that for any fact of the form ğ‘…(ğ‘, ğ‘â€², ğ‘, âŠ¥) or ğ‘…(ğ‘, ğ‘â€², âŠ¥, ğ‘) or ğ‘…(âŠ¥, ğ‘, ğ‘, ğ‘â€²)
or ğ‘…(ğ‘, âŠ¥, ğ‘, ğ‘â€²) or ğ‘† (ğ‘, âŠ¥) or ğ‘† (âŠ¥, ğ‘), we have ğ‘ âˆˆ dom; indeed otherwise, those facts can never be
part of a match and we could again remove them and multiply the result by the appropriate value.
Next, we need to introduce some notation. For a fact ğ‘“ of ğ·, the type of ğ‘“ is the word in {0, 1}arity(ğ‘“ )
that has a 1 in position ğ‘– iff the ğ‘–-th element of ğ‘“ is a null. For instance the type of ğ‘…(âŠ¥, âŠ¥, ğ‘, âŠ¥)
is 1101 and that of ğ‘† (ğ‘, ğ‘) is 00. Observe that there are a fixed number of possible types, because
the query is fixed. For a constant ğ‘ and fact ğ‘“ of ğ·, we say that ğ‘“ is ğ‘-determined if ğ‘“ contains the
constant ğ‘ at a position for variable ğ‘¥. For instance ğ‘…(âŠ¥, ğ‘, ğ‘ â€², âŠ¥) is ğ‘-determined and so is ğ‘† (ğ‘, ğ‘).
A fact ğ‘“ that contains only nulls on the positions for ğ‘¥ is called free. With the simplifications of
the last paragraph, a fact of ğ· is either free or it is ğ‘-determined for a unique constant ğ‘. Let t be a
type of ğ· (for ğ‘… or for ğ‘†). We say that t is free if it has only 1s in the positions corresponding to
variable ğ‘¥; in other words, if it is the type of a free fact. Otherwise we say that t is determined.
For a constant ğ‘ and determined type t, we write ğ‘›ğ‘…,ğ‘,t (resp., ğ‘›ğ‘…,ğ‘,t) the number of ğ‘…-facts (resp.,
of ğ‘†-facts) of ğ· that are ğ‘-determined of type t. For a free type t of ğ‘… (resp., of ğ‘†) we write ğ¹ğ‘…,t (resp.,
ğ¹ğ‘†,t) for the set of free ğ‘…-facts (resp., of free ğ‘†-facts) and fğ‘…,t (resp.,ft) for its size. Let ğ‘“ be a fact that
is ğ‘-determined. We write ğ›¼ ğ‘“ for the number of valuations ğœˆ of the nulls in ğ‘“ such that ğ‘“ matches
the corresponding atom in ğ‘. For instance if ğ‘“ is ğ‘…(âŠ¥, ğ‘, ğ‘ â€², âŠ¥) or again ğ‘…(ğ‘, ğ‘, ğ‘ â€², ğ‘ â€²) then ğ›¼ ğ‘“ = 1,
while if ğ‘“ is ğ‘…(ğ‘, ğ‘, âŠ¥, âŠ¥) then ğ›¼ ğ‘“ = ğ‘‘.8 Similarly we let ğ›½ğ‘“ denote the number of valuations ğœˆ of the
nulls in ğ‘“ such that ğ‘“ does not match the corresponding atom in ğ‘; which is then equal to ğ‘‘ğ‘¡ âˆ’ ğ›¼ ğ‘“ ,
for ğ‘¡ the number of nulls in ğ‘“ . Observe that ğ›¼ ğ‘“ and ğ›½ğ‘“ depend only on the type t of ğ‘“ . Hence
we will write ğ›¼t and ğ›½t instead. Let ğ‘“ be a free fact. We let ğ›¼ ğ‘“ be the number of valuations of

8When ğ‘“ is a ground fact â€“ such as ğ‘… (ğ‘, ğ‘, ğ‘â€², ğ‘â€²) â€“ we recall the mathematical convention that there exists a unique function
with emtpy domain, hence a unique valuation of the nulls of ğ‘“ .

The complexity of counting problems over incomplete databases

1:17

the nulls in ğ‘“ that are not on a position for variable ğ‘¥ that match the corresponding part of the
atom in ğ‘. For instance if ğ‘“ is ğ‘…(âŠ¥, âŠ¥, ğ‘ â€², âŠ¥) then ğ›¼ ğ‘“ = 1 and if ğ‘“ is ğ‘…(âŠ¥, âŠ¥, âŠ¥, âŠ¥) then ğ›¼ ğ‘“ = ğ‘‘. We
def
= ğ‘‘ğ‘¡ âˆ’ ğ‘‘ğ›¼ ğ‘“ where ğ‘¡ is the number of nulls, which correspond to the number of
also define ğ›½ğ‘“
valuations of the nulls in ğ‘“ such that the ground fact obtained does not match its corresponding
atom. Again, since ğ›¼ ğ‘“ and ğ›½ğ‘“ depend only on the free type t of ğ‘“ , we will write ğ›¼t and ğ›½t instead. It
is clear that we can compute all values ğ›¼ ğ‘“ ,ğ‘ and ğ›½ğ‘“ ,ğ‘ , for every determined fact ğ‘“ and constant ğ‘
of ğ·, and values ğ›¼ ğ‘“ for every free fact in polynomial time. Last, we fix a linear order ğ‘1, . . . , ğ‘ğ‘› on
the constants ğ‘ğ‘– such that there exists a fact of ğ· that is ğ‘ğ‘– -determined.

Next, we explain how we can compute in FP the number of valuations of ğ· that do not satisfy ğ‘.
To do so, we will first define some quantities, and then show that we can compute these quantities
in polynomial time using a dynamic programming approach. One of these quantities will be the
number of valuations of ğ· that do not satisfy ğ‘, which is what we want to compute. The quantities
that we will define are of the form ğ‘‰ (params), where params consist of the following parameters
(â€ ):

(a) one parameter ğ‘£ whose range is 0 . . . ğ‘›;
(b) one parameter ğ‘ğ‘…,t for every free type t âˆˆ {0, 1}4 of ğ‘…, with range 0 . . . fğ‘…,t;
(c) one parameter ğ‘Ÿğ‘… with range 0, . . . , ğ‘›;
(d) one parameter ğ‘Ÿğ‘† with range 0, . . . , ğ‘Ÿğ‘…;
We now explain what the quantity ğ‘‰ (params) with these parameters represent. To that end, we

define the incomplete database ğ· (params) to be the database that contains only

â€¢ all of the facts that are ğ‘ğ‘– -determined for 1 â©½ ğ‘– â©½ ğ‘£ (if ğ‘£ = 0 then ğ·ğ‘£ contains no determined

facts);

â€¢ for every free type t of ğ‘…, ğ· (params) contains ğ‘ğ‘…,t free ğ‘…-facts of ğ· of type t (it doesnâ€™t matter

which ones, say the first ğ‘ğ‘…,t ones);

â€¢ ğ· (params) contains all the free ğ‘†-facts of ğ·.
(Note that parameters (c) and (d) are not used to define the database but we still write ğ· (params).)
The quantity ğ‘‰ (params) is then defined to be the number of valuations ğœˆ of database ğ· (params)
such that ğœˆ (ğ· (params)) Ì¸|= ğ‘ and such that the following holds: (1) for every 1 â©½ ğ‘– â©½ ğ‘Ÿğ‘† and free
fact ğ‘“ of ğ‘… or of ğ‘†, the ground fact ğœˆ (ğ‘“ ) does not match the corresponding atom in ğ‘ with variable ğ‘¥
mapped to ğ‘ğ‘– (this condition is empty if ğ‘Ÿğ‘† = 0); and (2) for every ğ‘Ÿğ‘† + 1 â©½ ğ‘– â©½ ğ‘Ÿğ‘… and every free
fact ğ‘“ of ğ‘…, the ground fact ğœˆ (ğ‘“ ) does not match ğ‘…(ğ‘¥, ğ‘¥, ğ‘¦, ğ‘¦) with variable ğ‘¥ mapped to ğ‘ğ‘– (this
condition is empty if ğ‘Ÿğ‘… = ğ‘Ÿğ‘† ). By definition we then have that, when ğ‘£ = ğ‘›, ğ‘ğ‘…,t = fğ‘…,t for every
free type t of ğ‘… â€“ so that ğ· (params) is equal to ğ· â€“, ğ‘Ÿğ‘… = 0 and ğ‘Ÿğ‘† = 0 then ğ‘‰ (params) is then
equal to #Valu
(ğ‘)(ğ·). Observe that there are a fixed number of parameters in params (because
Cd
the query is fixed), and that the possible values of these parameters are polynomial in the size of
the input. We explain how compute the values ğ‘‰ (params) by dynamic programming.

Base case. Our base case will be when ğ‘£ is equal to zero (and the other parameters are arbitrary
as in (â€ )); in other words, the database ğ· (params) does not contain any determined facts, it
contains only free facts. We have to compute the number of valuations of ğ· (params) that do
not satisfy the query and such that (1) and (2) hold. We do so as follows. We guess a subset ğ‘†ğ‘…
of dom \ {ğ‘1, . . . , ğ‘ğ‘Ÿğ‘… }; this will be the set of constants ğ‘ such that ğ‘…(ğ‘, ğ‘, ğ‘ â€², ğ‘ â€²) âˆˆ ğœˆ (ğ· (params)) for
some ğ‘ â€². We also guess a subset ğ‘†ğ‘† of dom \ (cid:0){ğ‘1, . . . , ğ‘ğ‘Ÿğ‘† } âˆª ğ‘†ğ‘… (cid:1); this will be the set of constants ğ‘
such that ğ‘† (ğ‘, ğ‘) âˆˆ ğœˆ (ğ· (params)) (observe that ğ‘†ğ‘… and ğ‘†ğ‘† are disjoint; this is in order to avoid
satisfying the query). To â€œachieveâ€ these subsets, we for each free type t of ğ‘… guess a subset ğ‘Šğ‘…,t of
the free facts of ğ‘… of type t; these will be the ğ‘…-facts ğ‘“ of type t such that ğœˆ (ğ‘“ ) matches ğ‘…(ğ‘¥, ğ‘¥, ğ‘¦, ğ‘¦)
with a constant in ğ‘†ğ‘… for variable ğ‘¥. Similarly we for each free type t of ğ‘† guess a subset ğ‘Šğ‘†,t of the

1:18

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

free facts of ğ‘† of type t; these will be the ğ‘†-facts ğ‘“ of type t such that ğœˆ (ğ‘“ ) matches ğ‘† (ğ‘¥, ğ‘¥) with a
constant in ğ‘†ğ‘† for variable ğ‘¥. To ensure that these subsets are indeed enough to cover ğ‘†ğ‘… and ğ‘†ğ‘† , we
surjectively assign each of the corresponding facts a constant in ğ‘†ğ‘… (for ğ‘…-facts) or ğ‘†ğ‘† (for ğ‘†-facts).
For such facts ğ‘“ , we then choose one of the ğ›¼t valuations of ğ‘“ that ensure that the ground fact
obtained satisfies the correspoinding atom of the query; crucially, this quantity depends only on
the type of ğ‘“ . For the remaining (free) facts ğ‘“ , we choose one of the ğ›½t valuations of ğ‘“ that ensure
that the ground facts obtained do not satisfy the corresponding atom of the query. In the end we
obtain that ğ‘‰ (params) is equal to the following expression:

âˆ‘ï¸

âˆ‘ï¸

âˆ‘ï¸

Â· Â· Â·

âˆ‘ï¸

âˆ‘ï¸

âˆ‘ï¸

Â· Â· Â·

ğ›¾

(3)

ğ‘†ğ‘… âŠ†dom\{ğ‘1,...,ğ‘ğ‘Ÿğ‘… }

ğ‘†ğ‘† âŠ†dom\(cid:0) {ğ‘1,...,ğ‘ğ‘Ÿğ‘† }âˆªğ‘†ğ‘…(cid:1)
where t1 . . . tJ are all the free types of ğ‘…, tâ€²
1

first ğ‘ğ‘…,ti

free ğ‘…-facts of type ti, and where, letting ğ‘§ def

ğ‘Šğ‘…,t1 âŠ†ğ‘„ğ‘…,t1

ğ‘Šğ‘…,tJ

âŠ†ğ‘„ğ‘…,tJ

ğ‘Šğ‘…,tâ€²
1

âŠ†ğ¹ğ‘†,tâ€²
1

ğ‘Šğ‘…,tâ€²
K

âŠ†ğ¹ğ‘†,tâ€²
K

. . . tâ€²
K

are all the free types of ğ‘†, ğ‘„ğ‘…,ti
ğ‘–=1 |ğ‘Šğ‘…,ti | and ğ‘§ â€² def
= (cid:205)ğ½
= (cid:205)ğ¾

is the set of the

ğ‘–=1 |ğ‘Šğ‘†,tâ€²

i

|, we have

ğ›¾ = surjğ‘§â†’|ğ‘†ğ‘… | Ã— surjğ‘§â€²â†’|ğ‘†ğ‘† | Ã— (cid:0)

ğ½
(cid:214)

ğ‘–=1

ğ›¼ |ğ‘Šğ‘…,ti
ti

|

ğ›½ |ğ‘„ğ‘…,ti
ti

|âˆ’|ğ‘Šğ‘…,ti

|

(cid:1) Ã— (cid:0)

ğ¾
(cid:214)

ğ‘–=1

ğ›¼

|ğ‘Šğ‘†,tâ€²
i
tâ€²
i

|

ğ›½

|ğ¹ğ‘†,tâ€²
i
tâ€²
i

|âˆ’|ğ‘Šğ‘†,tâ€²
i

|

(cid:1).

Obviously, we cannot compute the expression in 3 in polynomial time, since we are summing
over subsets of the input facts. However, because ğ›¾ depends only on the sizes of all these sets, we
can express ğ‘‰ (params) as

âˆ‘ï¸

âˆ‘ï¸

âˆ‘ï¸

Â· Â· Â·

âˆ‘ï¸

âˆ‘ï¸

Â· Â· Â·

âˆ‘ï¸

ğ›¿,

(4)

0â©½ğ‘ ğ‘… â©½ğ‘‘âˆ’ğ‘Ÿğ‘…

0â©½ğ‘ ğ‘† â©½ğ‘‘âˆ’ğ‘Ÿğ‘† âˆ’ğ‘ ğ‘…

0â©½ğ‘¤ğ‘…,t1

0â©½ğ‘¤ğ‘…,tJ

â©½ğ‘ğ‘…,tJ

0â©½ğ‘¤ğ‘…,tâ€²
1

â©½fğ‘…,tâ€²
1

0â©½ğ‘¤ğ‘…,tâ€²
K

â©½fğ‘…,tâ€²
K

where, letting again ğ‘§ def

= (cid:205)ğ½

ğ‘–=1 ğ‘¤ğ‘…,ti

= (cid:205)ğ¾

ğ‘–=1 ğ‘¤ğ‘†,tâ€²

i

, we have

â©½ğ‘ğ‘…,t1
and ğ‘§ â€² def

ğ›¿ =surjğ‘§â†’ğ‘ ğ‘… Ã— surjğ‘§â€²â†’ğ‘ ğ‘† Ã— (cid:0)

ğ½
(cid:214)

ğ‘–=1

ğ›¼ ğ‘¤ğ‘…,ti
ti

ğ›½ğ‘ğ‘…,ti
ti

âˆ’ğ‘¤ğ‘…,ti

(cid:1) Ã— (cid:0)

Ã—

(cid:18)ğ‘‘ âˆ’ ğ‘‘ğ‘…
ğ‘ ğ‘…

(cid:19) (cid:18)ğ‘‘ âˆ’ ğ‘Ÿğ‘† âˆ’ ğ‘ ğ‘…
ğ‘ ğ‘†

(cid:19)

Ã— (cid:0)

ğ½
(cid:214)

ğ‘–=1

(cid:19)

(cid:18)ğ‘ğ‘…,ti
ğ‘¤ğ‘…,ti

(cid:1) Ã— (cid:0)

ğ¾
(cid:214)

ğ‘–=1

ğ¾
(cid:214)

ğ›¼

ğ‘–=1
(cid:18) fğ‘†,tâ€²
ğ‘¤ğ‘†,tâ€²

i

i

(cid:19)

(cid:1).

ğ‘¤ğ‘†,tâ€²
i
tâ€²
i

âˆ’ğ‘¤ğ‘†,tâ€²
i

(cid:1)

ğ›½

fğ‘†,tâ€²
i
tâ€²
i

But then, because the expression 4 contains a fixed number of nested sums (this number depends
only on the query ğ‘), and because indices and summands are polynomial, this quantity can be
computed in polynomial time. This concludes the base case, that was when ğ‘£ = 0.

Inductive case. Next we explain how we can compute the quantities ğ‘‰ (params) (with the pa-
rameters params as in (â€ )) in polynomial time from quantities ğ‘‰ (paramsâ€²) with a strictly smaller
value for parameter (a). Hence we assume that parameter ğ‘£ is â©¾ 1. The idea is to get rid of the ğ‘ğ‘£-
determined facts of ğ· (params), by partitioning the valuations of ğ· (params) that do not satisfy ğ‘
and satisfy (1) and (2) into
(A) those valuations ğœˆ that do not satisfy the query and satisfy (1) and (2) and such that no ğ‘ğ‘£-
determined ğ‘…-fact or free ğ‘…-fact ğ‘“ of ğ· (params) is such that ğœˆ (ğ‘“ ) matches ğ‘…(ğ‘¥, ğ‘¥, ğ‘¦, ğ‘¦) with
variable ğ‘¥ mapped to ğ‘ğ‘£; and

(B) those valuations ğœˆ that do not satisfy the query and satisfy (1) and (2) and such that at least one
ğ‘ğ‘£-determined ğ‘…-fact or free ğ‘…-fact ğ‘“ of ğ· (params) is such that ğœˆ (ğ‘“ ) matches ğ‘…(ğ‘¥, ğ‘¥, ğ‘¦, ğ‘¦)

The complexity of counting problems over incomplete databases

1:19

with variable ğ‘¥ mapped to ğ‘ğ‘£ (and thus, no ğ‘ğ‘£-determined ğ‘†-fact or free ğ‘†-fact ğ‘“ of ğ· (params)
is such that ğœˆ (ğ‘“ ) matches ğ‘† (ğ‘¥, ğ‘¥) with variable ğ‘¥ mapped to ğ‘ğ‘£).

To compute valuations in (A), we choose for each ğ‘…-fact ğ‘“ that is ğ‘ğ‘£-determined one of the ğ›½ğ‘“ ,ğ‘ğ‘£
valuations of its nulls that is such that ğœˆ (ğ‘“ ) does not match ğ‘…(ğ‘¥, ğ‘¥, ğ‘¦, ğ‘¦), we disallow the free
facts of ğ‘… to have valuations that would match on ğ‘ğ‘£ by increasing ğ‘Ÿ ğ‘… by one, and we choose any
valuation for the ğ‘ğ‘£-determined facts of ğ‘† (since we know that they will not be part of a match).
Formally, letting ğ‘¡ğ‘“ be the number of nulls of a fact ğ‘“ , we have the expression

ğ´ = (cid:0) (cid:214)

ğ›½ğ‘“ (cid:1) Ã— (cid:0) (cid:214)

ğ‘‘ğ‘¡ğ‘“ (cid:1) Ã— ğ‘‰ (paramsâ€²)

ğ‘ğ‘£ -determined
ğ‘…-fact ğ‘“
where paramsâ€² is equal to params except that ğ‘£ â€² = ğ‘£ âˆ’ 1 and ğ‘Ÿ â€²

ğ‘ğ‘£ -determined
ğ‘†-fact ğ‘“

ğ‘… + 1. This can be computed
in polynomial time if we know the value ğ‘‰ (paramsâ€²). For valuations in (B), we do as follows.
We choose exactly which subset of the ğ‘ğ‘£-determined and free facts of ğ‘… will match ğ‘…(ğ‘¥, ğ‘¥, ğ‘¦, ğ‘¦)
with ğ‘¥ = ğ‘ğ‘£ by partioning according to the types, for the remaining ğ‘ğ‘£-determined ğ‘…-facts we
choose one of the ğ›½ valuations that do not match on ğ‘ğ‘£, for the remaining free facts of ğ‘… we disallow
to match on ğ‘ğ‘£ by increasing ğ‘Ÿ ğ‘… by one, for each ğ‘ğ‘£-determined fact ğ‘“ of ğ‘† we choose one of the ğ›½ğ‘“ ,ğ‘ğ‘£
valuations of ğ‘“ that are such that ğœˆ (ğ‘“ ) is not ğ‘† (ğ‘ğ‘£, ğ‘ğ‘£), and for the free facts of ğ‘† we disallow
matching on ğ‘ğ‘£ by increasing ğ‘Ÿğ‘† by one. Formally, letting t1, . . . , tJ be the types of the ğ‘ğ‘£-determined
be the free types of ğ‘… we obtain an expression of the form
ğ‘…-facts and tâ€²
1

ğ‘… = ğ‘Ÿ â€²

, . . . , tâ€²
J

ğµ =

âˆ‘ï¸

Â· Â· Â·

âˆ‘ï¸

âˆ‘ï¸

âˆ‘ï¸

Â· Â· Â·

ğ›¾ Ã— ğ›¿ Ã— ğ‘‰ (paramsâ€²)

(5)

â©½ğ‘›ğ‘…,ğ‘ğ‘£ ,t1
where ğ›¾ is equal to 1 if (cid:205)ğ½

0â©½â„t1

0â©½â„tJ
ğ‘–=1 â„ti + (cid:205)ğ¾

â©½ğ‘›ğ‘…,ğ‘ğ‘£ ,tJ
ğ‘–=1 â„tâ€²

i

0â©½â„â€²
tâ€²
1

â©½ğ‘ğ‘…,tâ€²
1

0â©½â„â€²
tâ€²
K

â©½ğ‘ğ‘…,tâ€²
K

â©¾ 1 and to 0 otherwise (in order to match on ğ‘ğ‘£ in ğ‘…), ğ›¿

is

ğ½
(cid:214)

(cid:0)

ğ‘–=1

(cid:19)

(cid:18)ğ‘›ğ‘…,ğ‘ğ‘£,ti
â„ti

ğ›¼â„ti
ti

ğ›½ğ‘›ğ‘…,ğ‘ğ‘£ ,ti
ti

âˆ’â„ti

(cid:1) Ã— (cid:0)

ğ½
(cid:214)

ğ‘–=1

i

(cid:18)ğ‘ğ‘…,tâ€²
â„â€²
tâ€²
i

(cid:19)

ğ›¼

â„â€²
tâ€²
i

tâ€²
i

(cid:1) Ã— (cid:0) (cid:214)

ğ›½ğ‘“ (cid:1),

ğ‘ğ‘£ -determined
ğ‘†-fact ğ‘“

t

;

ğ‘…,t âˆ’ â„â€²

ğ‘…,t = ğ‘â€²

ğ‘… = ğ‘Ÿğ‘… + 1;
ğ‘† = ğ‘Ÿğ‘† + 1.

and where paramsâ€² is equal to params except that:
â€¢ we have ğ‘£ â€² = ğ‘£ âˆ’ 1;
â€¢ for every free type t of ğ‘…, we have ğ‘â€²
â€¢ we have ğ‘Ÿ â€²
â€¢ we have ğ‘Ÿ â€²
The crucial point to see that expressions A and B indeed compute what we want is that we
do not need to remember exactly which susbsets of constants are disallowed to match for the
free facts, but we only need to remember their numbers (this is what allows us to use a dynamic
programming approach); and similarly for the free facts of ğ‘…, we only need to remember how many
we have left at each stage of each type, but not their precise subsets. Again, if we know the values
of ğ‘‰ (paramsâ€²) where in paramsâ€² parameter ğ‘£ â€² is equal to ğ‘£ âˆ’ 1 then we can compute in polynomial
time the value ğ‘‰ (params) = ğ´ + ğµ. Thus, we can compute all values ğ‘‰ (params) in polynomial
â–¡
time, and this concludes this example.

The proof in this example can be extended as-is to any connected sjfBCQ containing only two
atoms and having only one variable (ğ‘¥) that joins. We claim that the same idea works for an arbitrary
number of atoms, which concludes Theorem 3.13. Since a full proof is technically tedious and does
not provide new insights, we omit it here.

1:20

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

4 DICHOTOMIES FOR COUNTING COMPLETIONS
In this section, we study the complexity of the problems of counting completions satisfying
an sjfBCQ ğ‘, in the four cases that can be obtained by considering naive or Codd tables and non-
uniform or uniform domains. We will again use the notion of pattern as introduced in Definition 3.1.
Our first step is to observe that Lemma 3.3, which we used in the last section for the problems or
counting valuations, extends to the problems of counting completions.

Lemma 4.1. Let ğ‘, ğ‘â€² be sjfBCQs such that ğ‘â€² is a pattern of ğ‘. Then we have that #Comp(ğ‘â€²) â©½p
par
#Comp(ğ‘). Moreover, the same results hold if we restrict to the case of Codd tables, and/or to the
uniform setting.

Proof. The reduction is exactly the same as the one of Lemma 3.3. To show that this reduc-
tion works properly for counting completions, it is enough to observe that for every pair of
valuations ğœˆ1, ğœˆ2 of ğ· â€² (or of ğ·, since ğ· and ğ· â€² have exactly the same set of nulls), we have
â–¡
that ğœˆ1(ğ· â€²) = ğœˆ2(ğ· â€²) iff ğœˆ1(ğ·) = ğœˆ2(ğ·).

We will then follow the same general strategy as in the last section, i.e., prove hardness for some
simple patterns and combine these with Lemma 4.1 and tractability proofs to obtain dichotomies.
Our findings are summarized in the last two columns of Table 1 in the introduction. We start in
Section 4.1 with the non-uniform cases and continue in Section 4.2 with the uniform cases. Again,
we explicitly state when a #P-hardness result holds even in the restricted setting in which there is
a fixed domain over which nulls are interpreted.

4.1 The complexity on the non-uniform case
Here, we study the complexity of the problems #Comp(ğ‘) and #CompCd (ğ‘), providing dichotomy
results in both cases. In fact, it turns out that these problems are #P-hard for all sjfBCQs. To prove
this, it is enough to show that the problem #CompCd (ğ‘…(ğ‘¥)) is hard, that is, even counting the
completions of a single unary table is #P-hard in the non-uniform setting.

Proposition 4.2. #CompCd (ğ‘…(ğ‘¥)) is #P-hard.

Proof. We provide a polynomial-time parsimonious reduction from the problem of counting
the vertex covers of a graph, which we denote by #VC. Let ğº = (ğ‘‰ , ğ¸) be a graph. We construct
a Codd table ğ· using a single unary relation ğ‘… such that the number of completions of ğ· equals
the number of vertex covers of ğº. For every edge ğ‘’ = {ğ‘¢, ğ‘£ } of ğº, we have one null âŠ¥ğ‘’ with
dom(âŠ¥ğ‘’ ) = {ğ‘¢, ğ‘£ } and the fact ğ‘…(âŠ¥ğ‘’ ). Let ğ‘ be a fresh constant. For every node ğ‘¢ âˆˆ ğ‘‰ we have a
null âŠ¥ğ‘¢ with dom(âŠ¥ğ‘¢) = {ğ‘¢, ğ‘} and the fact ğ‘…(âŠ¥ğ‘¢). Last, we add the fact ğ‘…(ğ‘). We now show that
the number of completions of ğ· equals the number of vertex covers of ğº.

Let VC(ğº) be the set of vertex covers of ğº. For a valuation ğœˆ of ğ·, define the set ğ‘†ğœˆ := {ğ‘¢ âˆˆ ğ‘‰ |
ğ‘…(ğ‘¢) âˆˆ ğ· }. Since the fact ğ‘…(ğ‘) is in every completion of ğ·, it is clear that the number of completions
of ğ· is equal to |{ğ‘†ğœˆ | ğœˆ is a valuation of ğ· }|. We claim that VC(ğº) = {ğ‘†ğœˆ | ğœˆ is a valuation of ğ· },
which shows that the reduction works. (âŠ†) Let ğ¶ âˆˆ VC(ğº), and let us show that there exists a
valuation ğœˆ of ğ· such that ğ‘†ğœˆ = ğ¶. For a null of the form âŠ¥ğ‘’ with ğ‘’ = {ğ‘¢, ğ‘£ } âˆˆ ğ¸, assuming wlog
that ğ‘¢ âˆˆ ğ¶, we define ğœˆ (âŠ¥ğ‘’ ) to be ğ‘¢. For a null of the form âŠ¥ğ‘¢ with ğ‘¢ âˆˆ ğ‘‰ , we define ğœˆ (âŠ¥ğ‘¢) to
be ğ‘¢ if ğ‘¢ âˆˆ ğ¶ and ğ‘ otherwise. It is then clear that ğ‘†ğœˆ = ğ¶. (âŠ‡) Let ğœˆ be a valuation of ğ·, and let
us show that ğ‘†ğœˆ is a vertex cover. Assume by contradiction that there is an edge ğ‘’ = {ğ‘¢, ğ‘£ } such
that ğ‘’ âˆ© ğ‘†ğœˆ = âˆ…. By definition of ğ·, we must have ğœˆ (âŠ¥ğ‘’ ) âˆˆ {ğ‘¢, ğ‘£ }, so that one of ğ‘¢ or ğ‘£ must be in ğ‘†ğœˆ ,
hence a contradiction. Therefore, we conclude that #VC â©½p
â–¡

par #CompCd (ğ‘…(ğ‘¥)).

The complexity of counting problems over incomplete databases

1:21

Recall from Section 2 that, to avoid trivialities, we assume all sjfBCQs to contain at least one
atom and that all atoms have at least one variable. Using Lemma 4.1, this allows us to obtain the
following dichotomy result.

Theorem 4.3 (Dichotomy). For every sjfBCQ ğ‘, it holds that #Comp(ğ‘) and #CompCd (ğ‘) are #P-

hard.

Notice here that we do not claim membership in #P; in fact, we will come back to this issue in
Section 6 to show that this is unlikely to be true for naive tables. However, we can still show that
membership in #P holds for Codd tables. We then obtain:

Theorem 4.4 (Dichotomy). For every sjfBCQ ğ‘, the problem #CompCd (ğ‘) is #P-complete.
Proof. Hardness is from Theorem 4.3. To show membership in #P we will actually prove a more
general result in Section 6.1. There, we show that for every Boolean query ğ‘ such that ğ‘ has model
â–¡
checking in P the problem #CompCd (ğ‘) is in #P. This in particular applies to all sjfBCQs.

4.2 The complexity on the uniform case
We now investigate the complexity of #Compu(ğ‘) and #Compu
(ğ‘). Recall that in the non-uniform
Cd
case, even counting the completions of a single unary table is a #P-hard problem. This no longer
holds in the uniform case, as we will show that #Compu (ğ‘) is in FP for every sjfBCQ that is defined
over a schema consisting exclusively of unary relation symbols.

Such a positive result, however, cannot be extended much further. In fact, we show next
that ğ‘…(ğ‘¥, ğ‘¥) and ğ‘…(ğ‘¥, ğ‘¦) are hard patterns, both for naive and Codd tables (and, thus, we also
conclude that the problem of counting the completions of a single binary Codd table is a #P-hard
problem). We start with the case of naive tables, for which hardness even holds when nulls are
interpreted over the fixed domain {0, 1}.

Proposition 4.5. The problems #Compu (ğ‘…(ğ‘¥, ğ‘¥)) and #Compu (ğ‘…(ğ‘¥, ğ‘¦)) are both #P-hard, even

when nulls are interpreted over the same fixed domain {0, 1}.

Proof. We reduce from #IS, the problem of counting the number of independent sets of a graph.
Let ğº = (ğ‘‰ , ğ¸) be a graph. We will construct an incomplete database ğ· containing a single binary
predicate ğ‘… such that each completion of ğ· satisfies ğ‘…(ğ‘¥, ğ‘¥) and the number of completions of ğ·
is 2 |ğ‘‰ | + #IS(ğº), thus establishing hardness for the two queries. For every node ğ‘¢ âˆˆ ğ‘‰ , we have a
null âŠ¥ğ‘¢ with dom(âŠ¥ğ‘¢) = {0, 1}. We then construct the naive table ğ· as follows:

â€¢ for every node ğ‘¢ âˆˆ ğ‘‰ we add to ğ· the fact ğ‘…(ğ‘¢, âŠ¥ğ‘¢);
â€¢ then for every edge {ğ‘¢, ğ‘£ } âˆˆ ğ¸, we add the facts ğ‘…(âŠ¥ğ‘¢, âŠ¥ğ‘£) and ğ‘…(âŠ¥ğ‘£, âŠ¥ğ‘¢) to ğ·; and
â€¢ last, we add the facts ğ‘…(0, 0), ğ‘…(0, 1), ğ‘…(1, 0), and ğ‘…(âŠ¥, âŠ¥), where âŠ¥ is a fresh null.

It is clear that every completion of ğ· satisfies ğ‘…(ğ‘¥, ğ‘¥) (thanks to the fact ğ‘…(âŠ¥, âŠ¥)). Let us now count
the number of completions of ğ·. First, we observe that, thanks to the facts of the form ğ‘…(ğ‘¢, âŠ¥ğ‘¢), for
ğ‘¢ âˆˆ ğ‘‰ , for every two valuations ğœˆ, ğœˆ â€² that do not assign the same value to the nulls of the form âŠ¥ğ‘¢,
it is the case that ğœˆ (ğ·) â‰  ğœˆ (ğ· â€²). We then partition the completions of ğ· into those that contain
the fact ğ‘…(1, 1), and those that do not contain ğ‘…(1, 1). Because of the facts of the form ğ‘…(ğ‘¢, âŠ¥ğ‘¢),
for ğ‘¢ âˆˆ ğ‘‰ , and thanks to the fact ğ‘…(âŠ¥, âŠ¥) which becomes ğ‘…(1, 1) when we assign 1 to âŠ¥, there are
exactly 2 |ğ‘‰ | completions of ğ· that contain ğ‘…(1, 1). Moreover, it is easy to see that there are #IS(ğº)
valuations ğœˆ of ğ· that assign 0 to âŠ¥ and that yield a completion not containing ğ‘…(1, 1). Indeed, one
can check that a valuation of ğ· that assigns 0 to âŠ¥ yields a completion not containing ğ‘…(1, 1) if
and only if the set {ğ‘¢ âˆˆ ğ‘‰ | ğœˆ (âŠ¥ğ‘¢) = 1} is an independent set of ğº. Therefore, we conclude that the
number of completions of ğ· is indeed 2 |ğ‘‰ | + #IS(ğº), and therefore that #IS â©½p
T #Compu(ğ‘), where ğ‘
â–¡
can be ğ‘…(ğ‘¥, ğ‘¥) or ğ‘…(ğ‘¥, ğ‘¦).

1:22

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

Next, we prove hardness of the same queries for Codd tables (but in this case we do not know if
harness holds when nulls are interpreted over a fixed domain, as our proof will use domains of
unbounded size). We will reduce from the problem of counting the number of induced pseudoforests
of a graph, as defined next.

Definition 4.6. A graph ğº is a pseudoforest if every connected component of ğº contains at most
one cycle. Let ğº = (ğ‘‰ , ğ¸) be a graph. For ğ‘† âŠ† ğ¸, let us denote by ğº [ğ‘†] the graph (ğ‘‰ â€², ğ‘†), where ğ‘‰ â€²
is the set of nodes of ğº that appear in some edge of ğ‘†. The problem #PF is the problem that takes
as input a graph ğº = (ğ‘‰ , ğ¸) and outputs the number of edge sets ğ‘† âŠ† ğ¸ such that ğº [ğ‘†] is a
pseudoforest.

Using techniques from matroid theory, the authors of [26] have shown that #PF is #P-hard on
graphs. We explain in Appendix B.1 how their proof actually shows hardness of this problem for
bipartite graphs (which we need); formally, we have:

Proposition 4.7 (Implied by [26]). The problem #PF restricted to bipartite graphs is #P-hard.

To prove that the reduction that we will present is correct, we will also need the following
folklore lemma about pseudoforests. We recall that an orientation of an undirected graph ğº = (ğ‘‰ , ğ¸)
is a directed graph that can be obtained from ğº by orienting every edge of ğº. Equivalently, one can
see such an orientation as a function ğ‘“ : ğ¸ â†’ ğ‘‰ that assigns to every edge in ğº a node to which it
is incident. We then have:

Lemma 4.8. A graph ğº is a pseudoforest if and only if there exists an orientation of ğº such that

every node has outdegree at most 1.

Proof. Folklore, see, e.g., [22, 27, 36].

Using the hardness of #PF on bipartite graphs, we are able show hardness of #Compu
Cd

and #Compu
Cd

(ğ‘…(ğ‘¥, ğ‘¦)) as follows.

â–¡

(ğ‘…(ğ‘¥, ğ‘¥))

Proposition 4.9. The problems #Compu
Cd

(ğ‘…(ğ‘¥, ğ‘¥)) and #Compu
Cd

(ğ‘…(ğ‘¥, ğ‘¦)) are both #P-hard.

Proof. We reduce both problems from #PF on bipartite graphs. Let ğº = (ğ‘ˆ âŠ” ğ‘‰ , ğ¸) be a bipartite
graph. We will construct a uniform Codd table ğ· over binary relation ğ‘… such that (1) all the
completions of ğ· satisfy both queries; and (2) the number of completions of ğ· is equal to #PF(ğº),
thus establishing hardness. For every (ğ‘¡, ğ‘¡ â€²) âˆˆ (ğ‘ˆ âˆª ğ‘‰ )2 \ ğ¸, we add to ğ· the fact ğ‘…(ğ‘¡, ğ‘¡ â€²); we call
these the complementary facts. For every ğ‘¢ âˆˆ ğ‘ˆ we add to ğ· the fact ğ‘…(ğ‘¢, âŠ¥ğ‘¢) and for every ğ‘£ âˆˆ ğ‘‰
the fact ğ‘…(âŠ¥ğ‘£, ğ‘£). Finally, we add to ğ· a fact ğ‘…(ğ‘“ , ğ‘“ ) where ğ‘“ is a fresh constant. The uniform domain
of the nulls if dom = ğ‘ˆ âˆªğ‘‰ . It is clear that ğ· is a Codd table and that every completion of ğ· satisfies
both queries (thanks to the fact ğ‘…(ğ‘“ , ğ‘“ )), so (1) holds. We now prove that (2) holds. First of all, observe
that a completion ğœˆ (ğ·) of ğ· is uniquely determined by the set of edges {(ğ‘¢, ğ‘£) âˆˆ ğ¸ | ğ‘…(ğ‘¢, ğ‘£) âˆˆ ğœˆ (ğ·)}:
this is because ğœˆ (ğ·) already contains all the complementary facts. For a set ğ‘† âŠ† ğ¸ of edges, let
us define ğ·ğ‘† to be the complete database that contains all the complementary facts and all the
facts ğ‘…(ğ‘¢, ğ‘£) for (ğ‘¢, ğ‘£) âˆˆ ğ‘† (note that ğ·ğ‘† is not necessarily a completion of ğ·). We now argue that
for every set ğ‘† âŠ† ğ¸, we have that ğ·ğ‘† is a completion of ğ· if and only if ğº [ğ‘†] is a pseudoforest,
which would conclude the proof. By Lemma 4.8 we only need to show that ğ·ğ‘† is a completion
of ğ· if and only if ğº [ğ‘†] admits an orientation with maximum outdegee 1. We show each direction
in turn. (â‡’) Assume ğ·ğ‘† is a completion of ğ·, and let ğœˆ be a valuation witnessing this fact, i.e.,
such that ğœˆ (ğ·) = ğ·ğ‘† . First, observe that we can assume without loss of generality that (â˜…) for
every ğ‘’ = (ğ‘¢, ğ‘£) âˆˆ ğ‘†, we have either ğœˆ (âŠ¥ğ‘¢) = ğ‘£ or ğœˆ (âŠ¥ğ‘£) = ğ‘¢ but not both. Indeed, if we had
both then we could modify ğœˆ into ğœˆ â€² by redefining, say, ğœˆ â€²(âŠ¥ğ‘¢) to be ğ‘¢, and we would still have

The complexity of counting problems over incomplete databases

1:23

that ğœˆ â€²(ğ·) = ğ·ğ‘† (because ğ‘…(ğ‘¢, ğ‘¢) is already present in ğ·: it is a complementary fact). We now
define an orientation ğ‘“ğœˆ : ğ‘† â†’ ğ‘ˆ âˆª ğ‘‰ of ğº [ğ‘†] from ğœˆ as follows. Let ğ‘’ = (ğ‘¢, ğ‘£) âˆˆ ğ‘†. Then: if we
have ğœˆ (âŠ¥ğ‘¢) = ğ‘£ we define ğ‘“ğœˆ ((ğ‘¢, ğ‘£)) to be ğ‘£, i.e., we orient the (undirected) edge (ğ‘¢, ğ‘£) from ğ‘¢ to ğ‘£.
Else, if we have ğœˆ (âŠ¥ğ‘£) = ğ‘¢ we define ğ‘“ğœˆ ((ğ‘¢, ğ‘£)) to be ğ‘¢, i.e., we orient the (undirected) edge (ğ‘¢, ğ‘£)
from ğ‘£ to ğ‘¢. Observe that by (â˜…) ğ‘“ğœˆ is well defined. It is then easy to check that the maximal outdegree
of the directed graph defined by ğ‘“ğœˆ is 1: this is because for every ğ‘¢ âˆˆ ğ‘ˆ (resp., ğ‘£ âˆˆ ğ‘‰ ), there is only
one fact in ğ· of the form ğ‘…(ğ‘¢, null) (resp., ğ‘…(null, ğ‘£)), namely, the fact ğ‘…(ğ‘¢, âŠ¥ğ‘¢) (resp., ğ‘…(âŠ¥ğ‘£, ğ‘£)). (â‡)
Let ğ‘“ : ğ‘† â†’ ğ‘ˆ âˆª ğ‘‰ be an orientation of ğº [ğ‘†] with maximum outdegree 1. Let ğœˆ ğ‘“ be the valuation
of ğ· defined from ğ‘“ as follows: for every ğ‘¢ âˆˆ ğ‘ˆ (resp., ğ‘£ âˆˆ ğ‘‰ ), if there is an edge (ğ‘¢, ğ‘£) âˆˆ ğ‘† such
that ğ‘“ ((ğ‘¢, ğ‘£)) = ğ‘£ (resp., such that ğ‘“ ((ğ‘¢, ğ‘£)) = ğ‘¢), then define ğœˆ ğ‘“ (âŠ¥ğ‘¢) to be ğ‘£ (resp., define ğœˆ ğ‘“ (âŠ¥ğ‘£) to
be ğ‘¢). Observe that there can be at most one such edge because ğ‘“ has maximum outdegree 1, so this
is well defined. If there is no such edge, define ğœˆ ğ‘“ (âŠ¥ğ‘¢) to be ğ‘¢ (resp., define ğœˆ ğ‘“ (âŠ¥ğ‘£) to be ğ‘£). Since all
edges in ğ‘† are given an orientation by ğ‘“ , it is clear that for every (ğ‘¢, ğ‘£) âˆˆ ğ‘† we have ğ‘…(ğ‘¢, ğ‘£) âˆˆ ğœˆ ğ‘“ (ğ·).
Moreover, since ğœˆ ğ‘“ (ğ·) contains all the complementary facts, we have that ğœˆ ğ‘“ (ğ·) = ğ·ğ‘† , which
â–¡
shows that ğ·ğ‘† is a completion of ğ· and concludes this proof.

As we show next, these two patterns suffice to characterize the complexity of #Compu(ğ‘)

and #Compu
Cd

(ğ‘).

Theorem 4.10 (Dichotomy). Let ğ‘ be an sjfBCQ. If ğ‘…(ğ‘¥, ğ‘¥) or ğ‘…(ğ‘¥, ğ‘¦) is a pattern of ğ‘, then

#Compu(ğ‘) and #Compu
Cd

(ğ‘) are #P-hard. Otherwise, these problems are in FP.

From what precedes, we only have to prove the tractability part of that claim, and this for
naive tables. To this end, we define a conjunction of basic singletons sjfBCQ to be an sjfBCQ of the
form ğ¶1(ğ‘¥1) âˆ§ . . . âˆ§ ğ¶ğ‘š (ğ‘¥ğ‘š), where each ğ¶ğ‘– (ğ‘¥ğ‘– ) is a conjunction of unary atoms over the same
variable ğ‘¥ğ‘– (here the ğ‘¥ğ‘– are pairwise distinct). Since ğ‘ does not contain the pattern ğ‘…(ğ‘¥, ğ‘¥) nor the
pattern ğ‘…(ğ‘¥, ğ‘¦), observe that ğ‘ must in fact be a conjunction of basic singletons sjfBCQ. The main
difficulty is to decompose the computation in such a way that we do not count the same completion
twice. Moreover, the fact that the database is naive and not Codd, and the fact that constants can
appear everywhere, complicate a lot the description of the algorithm. For these reasons, we provide
in the next section an example that gives the intuition of the general proof, and defer the general
proof to Appendix B.2.

Note that, as in the last section, we do not claim membership in #P in the statement of Theo-
rem 4.10. However, and also as in the last section, we can show that these problems are in #P for
Codd tables, which allows us to obtain our last dichotomy for exact counting.

Theorem 4.11 (Dichotomy). Let ğ‘ be an sjfBCQ. If ğ‘…(ğ‘¥, ğ‘¥) or ğ‘…(ğ‘¥, ğ‘¦) is a pattern of ğ‘, then

#Compu
Cd

(ğ‘) is #P-complete. Otherwise, this problem is in FP.

Proof. Hardness follows from Theorem 4.10, while membership in #P follows from the result
â–¡

proven in Section 6.1.

4.3 Example of tractability for Theorem 4.10
In this section, we prove that for the query ğ‘ def
(ğ‘) is in FP.
Observe that ğ‘ is a conjunction of basic singletons query, and that it is always satisfied (as long as
the database is not empty). We will show that #Compu(ğ‘) is in FP. Let ğ¶ğ‘…ğ‘†, ğ¶ğ‘…, ğ¶ğ‘† (resp, ğ‘ğ‘…ğ‘†, ğ‘ğ‘…, ğ‘ğ‘† )
be the sets of constants (resp., nulls) that occur respectively: in ğ‘… and in ğ‘†, only in ğ‘…, only in ğ‘†,
and denote ğ‘ğ‘…ğ‘†, ğ‘ğ‘…, ğ‘ğ‘† (resp., ğ‘›ğ‘…ğ‘†, ğ‘›ğ‘…, ğ‘›ğ‘† ) their sizes. Let dom be the uniform domain of the nulls,
and let ğ‘‘ be its size. First of all, observe that we can assume without loss of generality that ğ¶ def
=
ğ¶ğ‘…ğ‘† âˆª ğ¶ğ‘… âˆª ğ¶ğ‘† âŠ† dom, as otherwise we could simply remove the facts of ğ· that are over constants

= ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¦), the problem #Compu
Cd

1:24

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

dom

ğ¶ğ‘…ğ‘†

ğ¼ğ‘…ğ‘†

ğ¶ğ‘…

ğ¶ğ‘†

ğ¼ğ‘…

ğ¼ğ‘†

Fig. 2. How the sets dom, ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘†, ğ¶ğ‘…ğ‘†, ğ¶ğ‘… and ğ¶ğ‘† from Claim 4.12 are allowed to intersect when they
satisfy (â˜…). The sets themselves and the intersections can be empty.

that are not in dom and this would not change the result. Let ğ‘ = ğ‘ğ‘…ğ‘† + ğ‘ğ‘… + ğ‘ğ‘† . The next two claims
explain how we can decompose the computation in a way that we do not count a same completion
twice (Claim 4.12), and that we count all the possible completions (Claim 4.13).

Claim 4.12. For a triplet (ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) of subsets of dom satisfying the conditions (â˜…) ğ¼ğ‘… âŠ† dom \ ğ¶,
ğ¼ğ‘† âŠ† dom \ (ğ¶ âˆª ğ¼ğ‘…), and ğ¼ğ‘…ğ‘† âŠ† dom \ (ğ¶ğ‘…ğ‘† âˆª ğ¼ğ‘… âˆª ğ¼ğ‘† ), let us define ğ‘ƒ (ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) to be the complete
database consisting of the following facts:
(1) ğ‘…(ğ‘) and ğ‘† (ğ‘) for ğ‘ âˆˆ ğ¶ğ‘…ğ‘† âˆª ğ¼ğ‘…ğ‘† ;
(2) ğ‘…(ğ‘) for ğ‘ âˆˆ ğ¼ğ‘… âˆª (ğ¶ğ‘… \ ğ¼ğ‘…ğ‘† );
(3) ğ‘† (ğ‘) for ğ‘ âˆˆ ğ¼ğ‘† âˆª (ğ¶ğ‘† \ ğ¼ğ‘…ğ‘† );

Then, for any two such triplets of sets (ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) and (ğ¼ â€²
databases ğ‘ƒ (ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) and ğ‘ƒ (ğ¼ â€²

ğ‘…ğ‘† ) are distinct.

ğ‘…, ğ¼ â€²

ğ‘†, ğ¼ â€²

ğ‘…, ğ¼ â€²

ğ‘†, ğ¼ â€²

ğ‘…ğ‘† ) that are different, the complete

Proof. To help the reader, we have drawn in Figure 2 how the sets can intersect. If we have ğ¼ğ‘…ğ‘† â‰ 
ğ‘†, ğ¼ â€²
ğ‘…, ğ¼ â€²
ğ‘…ğ‘† )
ğ‘… with ğ‘ âˆˆ ğ¼ğ‘… and ğ‘ âˆ‰ ğ¼ â€²
ğ‘… then one
ğ‘…ğ‘† ) does not. Hence let us assume
â–¡

ğ‘…ğ‘† with ğ‘ âˆˆ ğ¼ğ‘…ğ‘† and ğ‘ âˆ‰ ğ¼ â€²
ğ¼ â€²
does not. So let us assume now that ğ¼ğ‘…ğ‘† = ğ¼ â€²
can check that ğ‘ƒ (ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) contains the fact ğ‘…(ğ‘) while ğ‘ƒ (ğ¼ â€²
ğ‘…. Using the same reasoning we obtain that ğ¼ğ‘† = ğ¼ â€²
that ğ¼ğ‘… = ğ¼ â€²

ğ‘…ğ‘† , then ğ‘ƒ (ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) contains both facts ğ‘…(ğ‘) and ğ‘† (ğ‘), while ğ‘ƒ (ğ¼ â€²

ğ‘…, ğ¼ â€²
ğ‘† , thus completing the proof.

ğ‘…ğ‘† . If we have ğ¼ğ‘… â‰  ğ¼ â€²
ğ‘†, ğ¼ â€²

Our next step is to show that every completion of ğ· is of the form ğ‘ƒ (ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) for some

triplet (ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) satisfying (â˜…):

Claim 4.13. For every completion ğ· â€² of ğ·, there exist a triplet (ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) satisfying (â˜…) such

that ğ· â€² = ğ‘ƒ (ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ).
Proof. We define:
â€¢ ğ¼ğ‘…

def
= ğ· â€²(ğ‘…) \ (ğ¶ğ‘… âˆª ğ· â€²(ğ‘†)); where we see ğ· â€²(ğ‘…) as the set of constants occurring in relation ğ‘…

of ğ· â€².
def
= ğ· â€²(ğ‘†) \ (ğ¶ğ‘† âˆª ğ· â€²(ğ‘…));
def
= (ğ· â€²(ğ‘…) âˆ© ğ· â€²(ğ‘†)) \ ğ¶ğ‘…ğ‘† .

â€¢ ğ¼ğ‘†
â€¢ ğ¼ğ‘…ğ‘†

Then one can easily check that (ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) satisfies (â˜…) and that ğ· â€² = ğ‘ƒ (ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ).

â–¡

The complexity of counting problems over incomplete databases

1:25

By combining these two claims, we have that the result that we wish to compute (which, we
recall, is simply the total number of completions of ğ·, because any valuation satisfies the query) is
equal to

âˆ‘ï¸

âˆ‘ï¸

âˆ‘ï¸

check(ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† )

where check(ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† )

def
=

ğ¼ğ‘… âŠ†dom\ğ¶

ğ¼ğ‘† âŠ†dom\(ğ¶âˆªğ¼ğ‘… )
ğ¼ğ‘…ğ‘† âŠ†dom\(ğ¶ğ‘…ğ‘† âˆªğ¼ğ‘… âˆªğ¼ğ‘† )
(cid:40)1 if ğ‘ƒ (ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) is a possible completion of ğ·
0 otherwise

.

Next, we show that the value of check(ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) can be computed in polynomial time and
actually only depends on the sizes of these sets. In order to show this, we will use the following:

Claim 4.14. We have check(ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) = 1 if and only if the following conditions hold:
(1) if ğ‘›ğ‘… â©¾ 1 and |ğ¶ğ‘… âˆª ğ¶ğ‘…ğ‘† âˆª ğ¼ğ‘…ğ‘† | = 0, then we have |ğ¼ğ‘… | â‰  0. Intuitively, this means that the value

of a null in ğ‘ğ‘… cannot be â€œabsorbedâ€ by ğ¶ğ‘… âˆª ğ¶ğ‘…ğ‘† âˆª ğ¼ğ‘…ğ‘† .

(2) if ğ‘›ğ‘† â©¾ 1 and |ğ¶ğ‘† âˆª ğ¶ğ‘…ğ‘† âˆª ğ¼ğ‘…ğ‘† | = 0, then we have |ğ¼ğ‘† | â‰  0. (Same reasonning for nulls in ğ‘ğ‘† .)
(3) if ğ‘›ğ‘…ğ‘† â©¾ 1 and |ğ¶ğ‘…ğ‘† | = 0, then we have |ğ¼ğ‘…ğ‘† | â‰  0. (Same reasonning for nulls in ğ‘ğ‘…ğ‘† .)
(4) the following system of equations, whose variables are natural numbers between 0 and ğ‘‘, has a

solution:

ğ‘§ {ğ‘ğ‘… }
ğ‘ğ‘…
ğ‘§ {ğ‘ğ‘† }
ğ‘ğ‘†

+ ğ‘§ {ğ‘ğ‘…,ğ¶ğ‘† }
ğ‘ğ‘…
+ ğ‘§ {ğ‘ğ‘† ,ğ¶ğ‘… }
ğ‘ğ‘†

â©½ ğ‘›ğ‘…

â©½ ğ‘›ğ‘…

â©½ ğ‘ğ‘…

â©½ ğ‘ğ‘†

â©¾ |ğ¼ğ‘… |

â©¾ |ğ¼ğ‘† |

+ ğ‘§ {ğ‘ğ‘…,ğ‘ğ‘† }
ğ‘ğ‘…
+ ğ‘§ {ğ‘ğ‘† ,ğ‘ğ‘… }
ğ‘ğ‘†
ğ‘§ {ğ¶ğ‘…,ğ‘ğ‘† }
ğ¶ğ‘…
ğ‘§ {ğ¶ğ‘† ,ğ‘ğ‘… }
ğ¶ğ‘†
ğ‘§ {ğ‘ğ‘… }
ğ‘ğ‘…
ğ‘§ {ğ‘ğ‘† }
ğ‘ğ‘†
, ğ‘§ {ğ¶ğ‘…,ğ‘ğ‘† }
ğ¶ğ‘…

ğ‘›ğ‘…ğ‘† + min(ğ‘§ {ğ‘ğ‘…,ğ¶ğ‘† }

ğ‘ğ‘…

, ğ‘§ {ğ¶ğ‘† ,ğ‘ğ‘… }
ğ¶ğ‘†

) + min(ğ‘§ {ğ‘ğ‘…,ğ‘ğ‘† }

ğ‘ğ‘…

, ğ‘§ {ğ‘ğ‘† ,ğ‘ğ‘… }
ğ‘ğ‘†

) + min(ğ‘§ {ğ‘ğ‘† ,ğ¶ğ‘… }

ğ‘ğ‘†

) â©¾ |ğ¼ğ‘…ğ‘† |

Proof. We prove the claim informally by explaining the main ideas, because a formal proof
would be too long and not that interesting. Conditions (1-3) are easily checked to be necessary. We
now explain why condition (4) is also necessary. Suppose that ğ‘ƒ (ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) is a completion of ğ·.
Observe that (â€ ) to obtain the constants in ğ¼ğ‘…ğ‘† , we had to use some or all of the following:

â€¢ the nulls in ğ‘ğ‘…ğ‘† ; or
â€¢ the nulls in ğ‘ğ‘… together with those in ğ‘ğ‘† ; or
â€¢ the nulls in ğ‘ğ‘… together with the constants in ğ¶ğ‘† ; or
â€¢ the nulls in ğ‘ğ‘† together with the constants in ğ¶ğ‘….
But then, to obtain ğ‘ƒ (ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) as a completion, we must have used three disjoint (possibly
empty) sets ğ‘ {ğ‘ğ‘… }
â©½ ğ‘‘,
we have done the same for the nulls in ğ‘ğ‘† and we also used a subset of the constants of ğ¶ğ‘… (and ğ¶ğ‘† )
in such a way that, according to (â€ ):

of the nulls in ğ‘ğ‘… of sizes 0 â©½ ğ‘§ {ğ‘ğ‘… }

, ğ‘ {ğ‘ğ‘…,ğ‘ğ‘† }
ğ‘ğ‘…

, ğ‘ {ğ‘ğ‘…,ğ¶ğ‘† }
ğ‘ğ‘…

, ğ‘§ {ğ‘ğ‘…,ğ‘ğ‘† }
ğ‘ğ‘…

, ğ‘§ {ğ‘ğ‘…,ğ¶ğ‘† }
ğ‘ğ‘…

ğ‘ğ‘…

ğ‘ğ‘…

â€¢ the nulls in ğ‘ {ğ‘ğ‘… }

have been used to obtain the set ğ¼ğ‘… (which, we recall, is the set of constants
that occur only in ğ‘… and that are not in ğ¶ğ‘…). Note that only the nulls in ğ‘ğ‘… could have been
used to obtain constants in ğ¼ğ‘…. This is what the fifth equation expresses.

ğ‘ğ‘…

â€¢ the nulls in ğ‘ {ğ‘ğ‘…,ğ¶ğ‘† }

have values in ğ‘ {ğ¶ğ‘† ,ğ‘ğ‘… }

, which gives us constants in ğ¼ğ‘…ğ‘† . Observe that

ğ‘ğ‘…

at maximum we could obtain min(ğ‘§ {ğ‘ğ‘…,ğ¶ğ‘† }

, ğ‘§ {ğ¶ğ‘† ,ğ‘ğ‘… }
ğ¶ğ‘†

) constants in this manner.

ğ¶ğ‘†

ğ‘ğ‘…

1:26

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

ğ‘ğ‘…

ğ¶ğ‘…

ğ‘ğ‘†

â€¢ the nulls in ğ‘ {ğ‘ğ‘…,ğ‘ğ‘† }

and those in ğ‘ {ğ‘ğ‘…,ğ‘ğ‘† }

have common values, which gives us constants

in ğ¼ğ‘…ğ‘† . Again, observe that we can get at most min(ğ‘§ {ğ‘ğ‘…,ğ‘ğ‘† }

â€¢ the nulls in ğ‘ {ğ‘ğ‘† ,ğ¶ğ‘… }

have values in ğ‘ {ğ¶ğ‘…,ğ‘ğ‘† }

) constants using these.
, which gives us constants in ğ¼ğ‘…ğ‘† . Observe that

, ğ‘§ {ğ‘ğ‘† ,ğ‘ğ‘… }
ğ‘ğ‘†

ğ‘ğ‘…

ğ‘ğ‘…

ğ‘ğ‘†

at maximum we could obtain min(ğ‘§ {ğ‘ğ‘† ,ğ¶ğ‘… }

, ğ‘§ {ğ¶ğ‘…,ğ‘ğ‘† }
ğ¶ğ‘…

) constants in this manner.

The first 4 equations express the partitioning process, and the last equation then expresses that by
combining all these constants we indeed obtained the whole set ğ¼ğ‘…ğ‘† .

We now explain why conditions (2-4) are sufficient. If |ğ¼ğ‘… |, |ğ¼ğ‘† | and ğ¼ğ‘…ğ‘† are all â©¾ 1 then condition (4)
is sufficient, because we can use the nulls and constants as explained above, and we have enough
of them to obtain the sets ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† . We explain what happens when ğ¼ğ‘… = âˆ… for instance. In that
case, condition (1) ensures us that we have either ğ‘›ğ‘… = 0 or ğ¶ğ‘… âˆª ğ¶ğ‘…ğ‘† âˆª ğ¼ğ‘…ğ‘† â‰  âˆ…. If we have ğ‘›ğ‘… = 0
then it is fine, since the only nulls that could be used to fill ğ¼ğ‘… are those in ğ‘ğ‘…. If we have ğ‘›ğ‘… â©¾ 1
and ğ¶ğ‘… âˆª ğ¶ğ‘…ğ‘† âˆª ğ¼ğ‘…ğ‘† â‰  âˆ… then we can use these to absorb the values of the nulls in ğ‘ğ‘…, and we are
fine (i.e., we will be able to obtain ğ¼ğ‘… = âˆ…). We leave it to the reader to complete the small gaps in
â–¡
this proof.

Using this, we have that the value of check(ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) only depends on the sizes of ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† , and

moreover can be computed in polynomial time

Claim 4.15. The value of check(ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) only depends on |ğ¼ğ‘… |, |ğ¼ğ‘† |, |ğ¼ğ‘…ğ‘† |, ğ‘›ğ‘…, ğ‘›ğ‘†, ğ‘›ğ‘…ğ‘†, ğ‘ğ‘…, ğ‘ğ‘†, ğ‘ğ‘…ğ‘† ,

and can be computed in FP.

Proof. The fact that this value only depends on the sizes of these sets is simply by inspection of
the conditions in Claim 4.14. Conditions (1-3) can obviously be checked in PTIME. The fact that
condition (4) can be checked in PTIME is because we can test all possible assignments between 0
and ğ‘‘ for all these variables and see if there is one assignment that satisfies the equations; indeed,
â–¡
observe that the number of variables is fixed because the query is fixed.

But then, we can express the result as follows

âˆ‘ï¸

0â©½ğ‘–ğ‘…,ğ‘–ğ‘† ,ğ‘–ğ‘…ğ‘† â©½ğ‘‘

(cid:18)ğ‘‘ âˆ’ ğ‘
ğ‘–ğ‘…

(cid:19) (cid:18)ğ‘‘ âˆ’ ğ‘ âˆ’ ğ‘–ğ‘…
ğ‘–ğ‘†

(cid:19) (cid:18)ğ‘‘ âˆ’ ğ‘ğ‘…ğ‘† âˆ’ ğ‘–ğ‘… âˆ’ ğ‘–ğ‘†
ğ‘–ğ‘…ğ‘†

(cid:19)

Ã— check(ğ‘–ğ‘…, ğ‘–ğ‘†, ğ‘–ğ‘…ğ‘† )

and we can evaluate this expression as-is in FP because computing check(ğ¼ğ‘…, ğ¼ğ‘†, ğ¼ğ‘…ğ‘† ) âˆˆ {0, 1} is in
PTIME by the last claim. This concludes this (long) example.

5 APPROXIMATING THE NUMBERS OF VALUATIONS AND COMPLETIONS
As we saw in the previous sections, counting valuations and completions of an incomplete database
are usually intractable problems. However, this does not necessarily rule out the existence of efficient
approximation algorithms for such counting problems, in particular if some source of randomization
is allowed. In this section, we investigate this question by focusing on the well-known notion of
Fully Polynomial-time Randomized Approximation Scheme (FPRAS) for counting problems [33].
Formally, let Î£ be a finite alphabet and ğ‘“ : Î£âˆ— â†’ N be a counting problem. Then ğ‘“ is said to have
an FPRAS if there is a randomized algorithm A : Î£âˆ— Ã— (0, 1) â†’ N and a polynomial ğ‘ (ğ‘¢, ğ‘£) such
that, given ğ‘¥ âˆˆ Î£âˆ— and ğœ€ âˆˆ (0, 1), algorithm A runs in time ğ‘ (|ğ‘¥ |, 1/ğœ€) and satisfies the following
condition:

Pr(cid:0)|ğ‘“ (ğ‘¥) âˆ’ A (ğ‘¥, ğœ€)| â©½ ğœ€ ğ‘“ (ğ‘¥)(cid:1) â©¾

3
4

.

Observe that the property of having an FPRAS is closed under polynomial-time parsimonious
reductions, that is, if we have an FPRAS for a counting problem ğ´ and for counting problem ğµ we
have that ğµ â©½p

par ğ´, then we also have an FPRAS for ğµ.

The complexity of counting problems over incomplete databases

1:27

In the following sections, we investigate the existence of FPRAS for the problems of counting
valuations and completions of an incomplete database. The overall picture that we obtain is shown
in Table 2. We first deal with counting valuations in Section 5.1, where we show a general condition
under which this problem has an FPRAS (which will apply, in particular, to all Boolean conjunctive
queries). Then, in Section 5.2, we show that the situation is quite different for counting completions,
as in most cases this problem does not admit an FPRAS.

5.1 Approximating the number of valuations
To prove the main result of this section, we need to consider the counting complexity class SpanL [5].
Given a finite alphabet Î£, an NL-transducer ğ‘€ over Î£ is a nondeterministic Turing Machine with
input and output alphabet Î£, a read-only input tape, a write-only output tape (where the head
is always moved to the right once a symbol in Î£ is written on it, so that the output cannot be
read by ğ‘€), and a work-tape of which, on input ğ‘¥, only the first ğ‘ Â· log(|ğ‘¥ |) cells can be used for
a fixed constant ğ‘ > 0 (so that the space used by ğ‘€ is logarithmic). Moreover, ğ‘¦ âˆˆ Î£âˆ— is said to
be an output of ğ‘€ with input ğ‘¥, if there exists an accepting run of ğ‘€ with input ğ‘¥ such that ğ‘¦ is
the string in the output tape when ğ‘€ halts. Then a function ğ‘“ : Î£âˆ— â†’ N is said to be in SpanL if
there exists an NL-transducer ğ‘€ over Î£ such that for every ğ‘¥ âˆˆ Î£âˆ—, the value ğ‘“ (ğ‘¥) is equal to the
number of distinct outputs of ğ‘€ with input ğ‘¥. In [5], it was proved that SpanL âŠ† #P, and also that
this inclusion is strict unless NL = NP.

Very recently, the authors of [10] have shown that every problem in SpanL has an FPRAS.

Theorem 5.1 ([10, Corollary 3]). Every problem in SpanL has an FPRAS.

By using this result, we can give a general condition on a Boolean query ğ‘ under which #Val(ğ‘)
has an FPRAS, as this condition ensures that #Val(ğ‘) is in SpanL. More precisely, a Boolean query ğ‘
is said to be monotone if for every pair of (complete) databases ğ·, ğ· â€² such that ğ· âŠ† ğ· â€², if ğ· |= ğ‘,
then ğ· â€² |= ğ‘. Moreover, ğ‘ is said to have bounded minimal models if there exists a constant ğ¶ğ‘
(that depends only on ğ‘) satisfying that for every (complete) database ğ·, if ğ· |= ğ‘, then there
exists ğ· â€² âŠ† ğ· such that ğ· â€² |= ğ‘ and the number of facts in ğ· â€² is at most ğ¶ğ‘. Finally, the model
checking problem for ğ‘, denoted by MC(ğ‘), is the problem of deciding, given a (complete) database ğ·,
whether ğ· |= ğ‘. Then ğ‘ is said to have a model checking in a complexity class C if MC(ğ‘) âˆˆ C.
With this terminology, we can state the main result of this section.

Proposition 5.2. Assume that a Boolean query ğ‘ is monotone, has model checking in nondeter-

ministic linear space, and has bounded minimal models. Then #Val(ğ‘) is in SpanL.

Proof. Let ğ· be the input incomplete database, with the domains for each null. First, the machine
guesses a subset ğ· â€² âŠ† ğ· of size â©½ ğ¶ğ‘, such that each fact of ğ· â€² is over a relation symbol that appears
in ğ‘. Observe that ğ· â€² contains at most |ğ· â€²| Ã— arity(ğ‘) â©½ ğ¶ğ‘ Ã— arity(ğ‘) distinct nulls, and that this
is a constant. The machine then guesses and remembers a valuation ğœˆ of ğ· â€² and computes ğœˆ (ğ· â€²).
The encoding size ||ğœˆ (ğ· â€²)|| of ğœˆ (ğ· â€²) is ğ‘‚ (log |ğ· |), so the machine can check in nondeterministic
linear space whether ğœˆ (ğ· â€²) |= ğ‘, and stops and rejects in the branches that fail the test. Then, the
machine reads the input tape left to right and for every occurrence of a null âŠ¥ (appearing in ğ·)
that it finds, it does the following:

â€¢ It checks whether âŠ¥ appears before on the input tape and if so it simply continues;
â€¢ Else if âŠ¥ does not appear before on the input tape but appears in ğ· â€² then the machine

writes ğœˆ (âŠ¥) on its output tape;

â€¢ Else if âŠ¥ does not appear before on the input tape and does not appear in ğ· â€² then it guesses
a value for it and writes that value on the output tape (but it does not remember that value).

1:28

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

It is easy to see that this procedure can be carried out by a logspace nondeterministic transducer,
so we only need to show that the distinct outputs of the machine correspond exactly to the distinct
valuations ğœˆ of ğ· such that ğœˆ (ğ·) |= ğ‘. Since the machine writes values for nulls in order of first
appearance on the input tape, it is clear that every valuation is outputted exactly once. Let ğœˆ be a
valuation that is outputted, and let ğ· â€² be the subdatabase such that ğœˆ (ğ· â€²) |= ğ‘. Since ğœˆ (ğ· â€²) âŠ† ğœˆ (ğ·)
and ğ‘ is monotone, we have ğœˆ (ğ·) |= ğ‘. Inversely, let ğœˆ be a valuation of ğ· such that ğœˆ (ğ·) |= ğ‘, and
let us show that it must be outputted. Since ğœˆ (ğ·) |= ğ‘ and ğ‘ has bounded minimal models, there
exists ğ·ğœˆ âŠ† ğœˆ (ğ·) of size â©½ ğ¶ğ‘ such that ğ·ğœˆ |= ğ‘. But ğ·ğœˆ is ğœˆ (ğ· â€²) for some ğ· â€² âŠ† ğ· of size â©½ ğ¶ğ‘.
Then it is clear that one of the branches of the machine has guessed ğ· â€² and then ğœˆ |ğ·â€² and then has
â–¡
written ğœˆ on the output tape.

In particular, given that a union of Boolean of conjunctive queries satisfies the three proper-
ties of the previous proposition, we conclude from Theorem 5.1 that #Val(ğ‘) can be efficiently
approximated by using a randomized algorithm if ğ‘ is a union of BCQs.9

Corollary 5.3. If ğ‘ is a union of BCQs, then #Val(ğ‘) has an FPRAS (and the same holds if restricted

to the uniform setting and/or to Codd tables).

We prove in the next section that the good properties stated in Proposition 5.2 do not hold for

counting completions.

5.2 Approximating the number of completions
In this section, we prove that the problem of counting completions of an incomplete database is much
harder in terms of approximation than the problem of counting valuations. In this investigation,
two randomized complexity classes play a fundamental role. Recall that RP is the class of decision
problems ğ¿ for which there exists a polynomial-time probabilistic Turing Machine ğ‘€ such that:
(a) if ğ‘¥ âˆˆ ğ¿, then ğ‘€ accepts with probability at least 3/4; and (b) if ğ‘¥ âˆ‰ ğ¿, then ğ‘€ does not accept ğ‘¥.
Moreover, BPP is defined exactly as RP but with condition (b) replaced by: (bâ€™) if ğ‘¥ âˆ‰ ğ¿, then ğ‘€
accepts with probability at most 1/4. Thus, BPP is defined as RP but allowing errors for both the
elements that are and are not in ğ¿. It is easy to see that RP âŠ† BPP. Besides, it is known that RP âŠ† NP,
and this inclusion is widely believed to be strict. Finally, it is not known whether BPP âŠ† NP
or NP âŠ† BPP, but it is widely believed that NP is not included in BPP.

The non-uniform case. Recall that #IS is the problem of counting the number of independent
sets of a graph. This problem will play a fundamental role when showing non-approximability of
counting completions in the non-uniform case. More precisely, the following is known about the
approximability of #IS.

Theorem 5.4 ([20, Theorem 3.1]). The problem #IS does not admit an FPRAS unless NP = RP.

In the proof of Proposition 4.2, we considered the problem #VC of counting the number of
vertex covers of a graph ğº = (ğ‘‰ , ğ¸), and showed that #VC â©½p
par #CompCd (ğ‘…(ğ‘¥)). By observing
that ğ‘† âŠ† ğ‘‰ is an independent set of ğº if and only if ğ‘‰ \ ğ‘† is a vertex cover of ğº, we can conclude
that #IS(ğº) = #VC(ğº) and, thus, the same reduction from the proof of Proposition 4.2 establishes
that #IS â©½p
par #CompCd (ğ‘…(ğ‘¥)). Therefore, from the fact that the reduction in Lemma 4.1 is also
parsimonious and preserves the property of being a Codd table, and the fact that the existence of
an FPRAS is closed under polynomial-time parsimonious reductions, we obtain the following result
from Theorem 5.4.

9As a matter of fact, this holds even for the larger class of unions of BCQs with inequalities (that is, atoms of the form
ğ‘¥ â‰  ğ‘¦), as such queries also satisfy the aforementioned three properties.

The complexity of counting problems over incomplete databases

1:29

Theorem 5.5 (Dichotomy). For every sjfBCQ ğ‘, it holds that #CompCd (ğ‘) does not admit an

FPRAS unless NP = RP (and, hence, the same holds for #Comp(ğ‘)).10

The uniform case. Recall that from Theorem 4.10, we know that if an sjfBCQ ğ‘ contains neither
ğ‘…(ğ‘¥, ğ‘¥) nor ğ‘…(ğ‘¥, ğ‘¦) as a pattern, then #Compu(ğ‘) is in FP. Thus, the question to answer in this
section is whether #Compu (ğ‘) and #Compu
(ğ‘) can be efficiently approximated if ğ‘ contains any
Cd
of these two patterns. For the case of naive tables, we will give a negative answer to this question.
Notice that, this time, our reduction from #IS in Proposition 4.5 is not parsimonious, so we cannot
use Theorem 5.4 as we did for the non-uniform case. Instead, we will rely on the following well-
known fact: if there exists a BPP algorithm for a problem that is NP-complete, then NP âŠ† BPP,
which in turn implies that NP = RP [34].

Proposition 5.6. Neither #Compu (ğ‘…(ğ‘¥, ğ‘¥)) nor #Compu(ğ‘…(ğ‘¥, ğ‘¦)) admits an FPRAS unless NP =
RP. This holds even in the restricted setting in which all nulls are interpreted over the same fixed
domain {1, 2, 3}.

Proof. Let ğº = (ğ‘‰ , ğ¸) be a graph. First, we explain how to construct an incomplete database ğ·
containing a single binary relation ğ‘…, with uniform domain {1, 2, 3}, and such that (a) all completions
of ğ· satisfy both queries; (b) if ğº is 3-colorable then ğ· has 8 completions; and (c) if ğº is not 3-
colorable then ğ· has 7 completions. For every node ğ‘¢ âˆˆ ğ‘‰ we have a null âŠ¥ğ‘¢. The database ğ·
consists of the following three disjoint sets of facts:

â€¢ For every edge {ğ‘¢, ğ‘£ } âˆˆ ğ¸, we have the two facts ğ‘…(âŠ¥ğ‘¢, âŠ¥ğ‘£) and ğ‘…(âŠ¥ğ‘£, âŠ¥ğ‘¢); we call these the

coding facts.

facts;

â€¢ We have the facts ğ‘…(1, 2), ğ‘…(2, 1), ğ‘…(2, 3), ğ‘…(3, 2), ğ‘…(1, 3), and ğ‘…(3, 1); we call these the triangle

â€¢ We have six fresh nulls âŠ¥1, âŠ¥â€²

1, âŠ¥2, âŠ¥â€²
ğ‘– â©½ 3; we call these the auxiliary facts;

â€¢ Last, we have a fact ğ‘…(ğ‘, ğ‘), where ğ‘ is a fresh constant.

2, âŠ¥3, âŠ¥â€²

3 and the facts ğ‘…(âŠ¥ğ‘–, âŠ¥â€²

ğ‘– ) and ğ‘…(âŠ¥â€²

ğ‘–, âŠ¥ğ‘– ) for 1 â©½

It is clear that all the completions of ğ· satisfy both queries (thanks to the fact ğ‘…(ğ‘, ğ‘)), so we only
need to prove (b) and (c). Observe that a candidate completion of ğ· can be equivalently seen as an
undirected graph, possibly with self-loops, over the nodes {1, 2, 3} (we omit the fact ğ‘…(ğ‘, ğ‘) since it is
in every completion) and that contains the triangle. Thanks to the auxiliary facts, it is easy to show
that all such graphs with at least one self-loop can be obtained as a completion of ğ·. For instance,
the completion that is triangle with a self-loop only on 1 can be obtained by assigning 1 to all the
nulls in the coding facts, assigning 1 to âŠ¥1, âŠ¥â€²
3. There are 7
such completions in total. Then, the completion whose graph is the triangle with no self-loops is
obtainable if and only if ğº is 3-colorable (we assign a 3-coloring to the nulls in the coding facts, and
assign 1 to âŠ¥ğ‘– and 2 to âŠ¥â€²
ğ‘– for every ğ‘– âˆˆ {1, 2, 3}). This indeed proves (b) and (c). Next, we show that
any FRPAS with ğœ€ = 1/16 for counting the number of completions of ğ· would yield a BPP algorithm
to solve 3-colorability, thus implying NP = RP since 3-colorability is an NP-complete problem.

1, âŠ¥2 and âŠ¥3 and assigning 2 to âŠ¥â€²

2 and âŠ¥â€²

Let A be an FPRAS for #Compu (ğ‘), with ğ‘ being ğ‘…(ğ‘¥, ğ‘¥) or ğ‘…(ğ‘¥, ğ‘¦), and let us define a BPP
algorithm B for 3-colorability using A. On input graph ğº, algorithm B does the following. First,
it computes in polynomial time the naive table ğ· as described above. Then B calls A with in-
put (ğ·, 1/16), and if A (ğ·, 1/16) â©¾ 7.5, then B accepts, otherwise B rejects. We now prove that B is
indeed a BPP algorithm for 3-colorability. Assume first that ğº is 3-colorable. Then by (b) and by def-
inition of what is an FPRAS, we have that Pr(cid:0)|8 âˆ’ A (ğ·, 1/16)| â©½ 8/16(cid:1) â©¾ 3
4 . This implies in particular
that Pr(cid:0)A (ğ·, 1/16) â©¾ 8 âˆ’ 8/16(cid:1) â©¾ 3
4 . Since 8 âˆ’ 8/16 = 7.5 we conclude that if ğº is 3-colorable, then B
10Again, we remind the reader that, to avoid trivialities, we assume all sjfBCQs to contain at least one atom and all atoms to
have at least one variable.

1:30

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

accepts with probability at least 3/4. Next, assume that ğº is not 3-colorable. Then by (c) we have
4 . This implies in particular that Pr(cid:0)A (ğ·, 1/16) â©½ 7 + 7/16(cid:1) â©¾ 3
that Pr(cid:0)|7 âˆ’ A (ğ·, 1/16)| â©½ 7/16(cid:1) â©¾ 3
4 .
Since 7 + 7/16 < 7.5, this implies in particular that Pr(cid:0)A (ğ·, 1/16) < 7.5(cid:1) â©¾ 3
4 . From this, we conclude
that if ğº is not 3-colorable, then B rejects with probability at least 3/4. This concludes the proof of
â–¡
the proposition.

By observing again that the reduction in Lemma 4.1 is parsimonious, and that the existence of an
FPRAS is closed under parsimonious reductions, we obtain that #Compu (ğ‘) cannot be efficiently
approximated if ğ‘ contains ğ‘…(ğ‘¥, ğ‘¥) or ğ‘…(ğ‘¥, ğ‘¦) as a pattern.

Theorem 5.7 (Dichotomy). Let ğ‘ be an sjfBCQ. If ğ‘ has ğ‘…(ğ‘¥, ğ‘¥) or ğ‘…(ğ‘¥, ğ‘¦) as a pattern, then
#Compu(ğ‘) does not admit an FPRAS unless NP = RP. Otherwise, this problem is in FP (by Theo-
rem 4.10).

We do not know if this result still holds for Codd tables, or if it is possible to design an FPRAS in

this setting. We leave this question open for future research.

6 ON THE GENERAL LANDSCAPE: BEYOND #P
Recall that, when studying the complexity of counting completions for sjfBCQs in Section 4, we did
claim that these problems are in #P for Codd tables, but that we did not claim so for naive tables.
The goal of this section is then threefold. First, we want to prove that the problem of counting
completions in indeed in #P for Codd tables. Second, we want to give formal evidence that we
indeed could not show membership in #P for naive tables. Third, we want to identify a counting
complexity class that is more appropriate to describe the complexity of #Comp(ğ‘). We deal with
these three objectives in the next three sections.

6.1 Membership in #P of #CompCd (ğ‘)
In this section, and as promised in the proofs of Propositions 4.4 and 4.11, we show that for any
Boolean query ğ‘, if the model checking problem for ğ‘ (denoted MC(ğ‘), recall the definition from
Section 5.1) is in P then the problem of counting completions for ğ‘ under Codd tables is in #P.

Proposition 6.1. If a Boolean query ğ‘ has the property that model checking is in P, then we have

that #CompCd (ğ‘) is in #P.

We recall that a fact that contains only constants is a ground fact. To show Proposition 6.1,
we first prove that we can check in polynomial time if a given set of ground facts is a possible
completion of an incomplete database:

Lemma 6.2. Given as input an incomplete Codd table ğ· and a set ğ‘† of ground facts, we can decide

in polynomial time whether there exists a valuation ğœˆ of ğ· such that ğœˆ (ğ·) = ğ‘†.

Proof. For every fact ğ‘“ of ğ·, let us denote by ğ‘ƒ (ğ‘“ ) the set of ground facts that can be obtained
from ğ‘“ via a valuation (ğ‘ƒ (ğ‘“ ) can be {ğ‘“ } if ğ‘“ is already a ground fact). The first step is to check that
for every fact ğ‘“ of ğ·, it holds that (â˜…) ğ‘ƒ (ğ‘“ ) âˆ© ğ‘† â‰  âˆ…. If this is not the case, then we know for sure
that for every valuation ğœˆ of ğ· we will have ğœˆ (ğ·) âŠˆ ğ‘†, so that we can safely reject. Next, we build
the bipartite graph ğºğ·,ğ‘† defined as follows: the nodes in the left partition of ğºğ·,ğ‘† are the facts of ğ·,
the nodes in the right partition are the facts in ğ‘†, and we connect a fact ğ‘“ of ğ· with all the ground
facts in the right partition that are in ğ‘† âˆ© ğ‘ƒ (ğ‘“ ). It is clear that we can construct ğºğ·,ğ‘† in polynomial
time. We then compute in polynomial time the size ğ‘š of a maximum-cardinality matching of ğºğ·,ğ‘† ,
for instance using [21]. It is clear that we have ğ‘š â©½ |ğ‘† |. At this stage, we claim that there exists
a valuation ğœˆ of ğ· such that ğœˆ (ğ·) = ğ‘† if and only if ğ‘š = |ğ‘† |. We prove this by analysing the two
possible cases:

The complexity of counting problems over incomplete databases

1:31

â€¢ If ğ‘š < |ğ‘† |, then let us show that there is no such valuation. Indeed, assume by way of
contradiction that such a valuation ğœˆ exists. Let ğµ be a subset of ğ· of minimal size such
that ğœˆ (ğµ) = ğ‘†. It is clear that such a subset exists, and moreover that its size is exactly |ğ‘† |. But
then, consider the set ğ‘€ of edges of ğºğ·,ğ‘† defined by ğ‘€ def
= {(ğ‘“ , ğœˆ (ğ‘“ )) | ğ‘“ âˆˆ ğµ}. Then ğ‘€ is a
matching of ğºğ·,ğ‘† of size |ğ‘† |, contradicting the fact that ğ‘š is the size of a maximum-cardinality
matching.

â€¢ If ğ‘š = |ğ‘† |, let us show that such a valuation exists. Let ğ‘€ be a matching of ğºğ·,ğ‘† of size |ğ‘† |.
It is clear that every node corresponding to a ground fact ğ‘“ âˆˆ ğ‘† is incident to (exactly) one
edge of ğ‘€; let us denote that edge by ğ‘’ğ‘“ . Moreover, since ğ‘€ is a matching, the mapping that
at the other end of ğ‘’ğ‘“ is injective. Hence, we can
associates to a ground fact ğ‘“ âˆˆ ğ‘† the fact ğ‘“ â€²
ğ‘“
define ğœˆ (âŠ¥) of every null âŠ¥ occurring in such a fact ğ‘“ â€²
ğ‘“ âˆˆ ğ· to be the unique constant such
that ğœˆ (ğ‘“ â€²
ğ‘“ ) = ğ‘“ holds, and for every other fact ğ‘“ â€² in ğ· not incident to an edge in ğ‘€, we chose
a value for its nulls so that ğœˆ (ğ‘“ â€²) âˆˆ ğ‘†, which we can do thanks to (â˜…). It is then clear that we
have ğœˆ (ğ·) = ğ‘†.

But then, we can simply accept if ğ‘š = |ğ‘† | and reject otherwise.

â–¡

We can now prove Proposition 6.1:

Proof of Proposition 6.1. We define a non-deterministic turing machine ğ‘€ğ‘ such that, given as
input an incomplete Codd table ğ·, its number of accepting computation paths is exactly the number
of completions of ğ· that satisfy ğ‘. First, compute in polynomial time the set ğ´ def
= (cid:208)ğ‘“ âˆˆğ· ğ‘ƒ (ğ‘“ ),
where ğ‘ƒ (ğ‘“ ) is defined just as in Lemma 6.2. Then, the machine ğ‘€ğ‘ guesses a subset ğ‘† of ğ´. It then
checks in polynomial time if ğ‘†, when seen as a database, satisfies ğ‘, and rejects if it is not the case.
Then, using Lemma 6.2, it checks in polynomial time whether there exists a valuation ğœˆ of ğ· such
that ğœˆ (ğ·) = ğ‘†, and accepts iff this is the case. It is then clear that ğ‘€ğ‘ satisfies the conditions, which
â–¡
shows that #CompCd(ğ‘) is in #P.

In the next two sections, all upper bounds will be proved for the most general scenario of non-
uniform naive tables, while all lower bounds will be proved for the most restricted scenario of
uniform naive tables with a fixed domain.

6.2 Non-membership in #P of #Comp(ğ‘)
We now want to show that #P is not the right complexity class for problems of the form #Comp(ğ‘),
over naive tables. One could try to show membership in #P of #Comp(ğ‘) as we did in the proof of
Proposition 6.1; that is, guess a set of ground facts, then check in polynomial time that it satisfies
the query and that it is a possible completion of the incomplete database. However, this proof
strategy does not work, as we show next that checking if a set of ground fact is a completion of an
incomplete database is an NP-complete problem. Moreover, this holds already for a fixed schema
containing only a binary relation and for a fixed set of ground facts.

Proposition 6.3. The exist a set ğ‘† of ground facts over binary relation ğ‘… such that the following is

NP-complete: given as input an incomplete database ğ· over ğ‘…, decide if ğ‘† is a completion of ğ·.

Proof. We reduce from 3-colorability. Given a graph ğº, we build the same incomplete data-
base ğ· as in the proof of Proposition 5.6, and the (fixed) set of ground facts is the triangle, that
is, ğ‘† = {ğ‘…(1, 2), ğ‘…(2, 1), ğ‘…(2, 3), ğ‘…(3, 2), ğ‘…(1, 3), ğ‘…(3, 1)}. Then, as in that proof, we have that ğ‘† is a
â–¡
completion of ğ· if and only if ğº is 3-colorable.

This does not, however, constitute a proof that #Comp(ğ‘) is not in #P (but it is a good hint).
To prove that #Comp(ğ‘) is unlikely to be in #P, we need to define the complexity class SPP

1:32

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

introduced in [24, 28, 42]. Given a nondeterministic Turing Machine ğ‘€ and a string ğ‘¥, let acceptğ‘€ (ğ‘¥)
(resp., rejectğ‘€ (ğ‘¥)) be the number of accepting (resp., rejecting) runs of ğ‘€ with input ğ‘¥, and let
gapğ‘€ (ğ‘¥) = acceptğ‘€ (ğ‘¥) âˆ’ rejectğ‘€ (ğ‘¥). Then a language ğ¿ is said to be in SPP [24] if there exists a
polynomial-time nondeterministic Turing Machine ğ‘€ such that: (a) if ğ‘¥ âˆˆ ğ¿, then gapğ‘€ (ğ‘¥) = 1;
and (b) if ğ‘¥ âˆ‰ ğ¿, then gapğ‘€ (ğ‘¥) = 0. It is conjectured that NP âŠˆ SPP as, for example, for every
known polynomial-time nondeterministic Turing Machine ğ‘€ accepting an NP-complete problem,
the function gapğ‘€ is not bounded. In the following proposition, we show how this conjecture helps
us to reach our second goal.

Proposition 6.4. There exists an sjfBCQ ğ‘ such that #Compu(ğ‘) is not in #P unless NP âŠ† SPP.
The proof of this result relies on the proof of Theorem 6.6, in the next section (we presented the
results in this order for narrative purposes). We will then defer its presentation until the proof of
Theorem 6.6 is given.

6.3 An appropriate counting complexity class for #Comp(ğ‘): SpanP
To meet our third goal, we need to introduce one last counting complexity class. The class SpanP [35]
is defined exactly as the class SpanL introduced in Section 5.1, but considering polynomial-time
nondeterministic Turing machines with output, instead of logarithmic-space nondeterministic
Turing machines with output. It is straightforward to prove that #P âŠ† SpanP. Besides, it is known
that #P = SpanP if and only if NP = UP [35].11 Therefore, it is widely believed that #P is properly
included in SpanP. The following easy observation can be seen as a first hint that SpanP is a good
alternative to describe the complexity of counting completions.

Observation 6.5. If ğ‘ is a Boolean query such that MC(ğ‘) is in P, then #Comp(ğ‘) is in SpanP.
Notice that this result applies to all sjfBCQs and, more generally, to all FO Boolean queries.
In fact, this results applies to even more expressive query languages such as Datalog [1]. More
surprisingly, in the following theorem we show that #Compu(ğ‘) can be SpanP-complete for an FO
query ğ‘ and, in fact, already for the negation of an sjfBCQ.

Theorem 6.6. There exists an sjfBCQ ğ‘ such that #Compu (Â¬ğ‘) is SpanP-complete under

polynomial-time parsimonious reductions.

To prove this result, we will use the problem of counting the number of satisfying assignments
of a 3-CNF formula that are distinct in the first ğ‘˜ variables, that we denote by #k3SAT. Formally,
the problem #k3SAT takes as input a 3-CNF formula ğ¹ on variables {ğ‘¥1, . . . , ğ‘¥ğ‘› } and an integer
1 â©½ ğ‘˜ â©½ ğ‘›, and outputs the number of assignments of the first ğ‘˜ variables that can be extended to a
satisfying assignment of ğ¹ . This problem is shown to be SpanP-complete in [35]:

Proposition 6.7 ([35, Section 6]). #k3SAT is SpanP complete (under polynomial-time parsimo-

nious reductions).

We are ready to prove Theorem 6.6.

Proof of Theorem 6.6. Notice that we only need to show hardness for a fixed sjfBCQ ğ‘. We
reduce from #k3SAT to #Compu (Â¬ğ‘), for a fixed sjfBCQ ğ‘ to be defined. Let ğ¹ be a 3-CNF on
variables {ğ‘¥1, . . . , ğ‘¥ğ‘› }, and 1 â©½ ğ‘˜ â©½ ğ‘›. We first explain how we build the incomplete database ğ·,
and we will define the sjfBCQ ğ‘ after. For every variable ğ‘¥ğ‘– , 1 â©½ ğ‘– â©½ ğ‘›, we have a null âŠ¥ğ‘¥ğ‘– , and the
11Recall that UP is the class Unambiguous Polynomial-Time introduced in [49], and that ğ¿ âˆˆ UP if and only if there exists
a polynomial-time nondeterministic Turing Machine ğ‘€ such that if ğ‘¥ âˆˆ ğ¿, then acceptğ‘€ (ğ‘¥) = 1, and if ğ‘¥ âˆ‰ ğ¿, then
acceptğ‘€ (ğ‘¥) = 0.

The complexity of counting problems over incomplete databases

1:33

(uniform) domain is {0, 1}. For (ğ‘, ğ‘, ğ‘) âˆˆ {0, 1}3, we have a relation ğ¶ğ‘ğ‘ğ‘ of arity 3, and we fill it with
every tuple of the form ğ¶ğ‘ğ‘ğ‘ (ğ‘â€², ğ‘ â€², ğ‘ â€²) with (ğ‘â€², ğ‘ â€², ğ‘ â€²) âˆˆ {0, 1}3 such that ğ‘ = ğ‘â€²âˆ¨ğ‘ = ğ‘ â€²âˆ¨ğ‘ = ğ‘ â€² holds;
hence for every (ğ‘, ğ‘, ğ‘) âˆˆ {0, 1}3 there are exactly 7 facts of this form. For every clause ğ¾ = ğ‘™1 âˆ¨ğ‘™2 âˆ¨ğ‘™3
of ğ¹ with ğ‘™1, ğ‘™2, ğ‘™3 being literals over variables ğ‘¦1, ğ‘¦2, ğ‘¦3, letting (ğ‘1, ğ‘2, ğ‘3) âˆˆ {0, 1}3 be the unique
tuple such that ğ‘ğ‘– = 1 iff ğ‘™ğ‘– is a positive literal, we add to ğ¶ğ‘1ğ‘2ğ‘3 the fact ğ¶ğ‘1ğ‘2ğ‘3 (âŠ¥ğ‘¦1, âŠ¥ğ‘¦2, âŠ¥ğ‘¦3). Last,
we have a binary relation ğ‘† that we fill with the tuples ğ‘† (ğ‘–, âŠ¥ğ‘¥ğ‘– ) for 1 â©½ ğ‘– â©½ ğ‘˜. The sjfBCQ ğ‘ then
simply says that there exists a tuple that appears in all the relations ğ¶ğ‘ğ‘ğ‘ :

ğ‘ = âˆƒğ‘¥âˆƒğ‘¦ ğ‘† (ğ‘¥, ğ‘¦) âˆ§ âˆƒğ‘¥âˆƒğ‘¦âˆƒğ‘§

(cid:18) (cid:219)

(cid:19)

ğ¶ğ‘ğ‘ğ‘ (ğ‘¥, ğ‘¦, ğ‘§)

(ğ‘,ğ‘,ğ‘) âˆˆ {0,1}3

(6)

Note that we added the seemingly useless query âˆƒğ‘¥âˆƒğ‘¦ ğ‘† (ğ‘¥, ğ‘¦) to ğ‘ because the set of relations in ğ·
has to be a subset of the set of relations occurring in ğ‘ (indeed, this is how we defined our problems
in Section 2). We now show that the number of completions of ğ· that do not satisfy ğ‘ is equal to
the number of assignments of the first ğ‘˜ variables that can be extended to a satisfying assignment
of ğ¹ , thus establishing that #Compu (Â¬ğ‘) is SpanP-hard (under polynomial-time parsimonious
reductions). First, observe that the assignments of the variables are in bijection with the valuations
of the nulls of ğ·. One can then readily observe the following:

â€¢ If ğ‘ is falsified in a completion of ğ·, it can only be because there does not exist a tuple that
occurs in all the relations; this is because the query âˆƒğ‘¥âˆƒğ‘¦ ğ‘† (ğ‘¥, ğ‘¦) is always satisfied by any
completion of ğ·.

â€¢ For every assignment of the variables, letting ğœˆ be the corresponding valuation of the nulls,
there exists a tuple that is in all relations ğ¶ğ‘ğ‘ğ‘ of ğœˆ (ğ·) if and only if that assignment is
not satisfying for ğ¹ . Indeed, this happens if and only if there exists a relation ğ¶ğ‘ğ‘ğ‘ such
that ğœˆ (ğ·)(ğ¶ğ‘ğ‘ğ‘ ) contains exactly 8 facts.

â€¢ For every two valuations ğœˆ, ğœˆ â€² such that the corresponding assignments are not satisfying the
formula, we have that ğœˆ (ğ·) â‰  ğœˆ â€²(ğ·) if and only if ğœˆ and ğœˆ â€² differ on the first ğ‘˜ variables. This
is because, by the previous item, each relation ğ¶ğ‘ğ‘ğ‘ contains exactly the 7 ground tuples that
we initially put in ğ·.

By putting it all together, we obtain that the reduction works as expected.

â–¡

This theorem gives evidence that SpanP is the right class to describe the complexity of counting
completions for FO queries (and even for queries with model checking in polynomial time). It is
important to notice that SpanP-hardness is proved in Theorem 6.6 by considering parsimonious
reductions. This is a delicate issue, because from the main result in [48], it is possible to conclude that
every counting problem that is #P-hard (even under polynomial-time parsimonious reductions) is
also SpanP-hard under polynomial-time Turing reductions, so a more restrictive notion of reduction
has to be used when proving that a counting problem is SpanP-hard [35].

Before continuing, we prove Proposition 6.4.

|

Proof of Proposition 6.4. Let ğ‘ be the sjfBCQ defined in Equation (6) in the proof of The-
(ğ‘, ğ‘, ğ‘) âˆˆ {0, 1}3} consists of 10 relation symbols,
orem 6.6. Its schema ğœ = {ğ‘† } âˆª {ğ¶ğ‘ğ‘ğ‘
with ğ‘† being binary and each ğ¶ğ‘ğ‘ğ‘ being ternary. Let us denote by #Compu(ğœ) the problem
that takes as input an incomplete database over schema ğœ and outputs its number of comple-
tions. The first part of our proof is to reduce #Compu(ğœ) to #Compu(ğ‘); formally, we claim
that #Compu(ğœ) â©½p
par #Compu(ğ‘). Indeed, let ğ· be an incomplete database over schema ğœ, that is
an input of #Compu (ğœ). We construct in polynomial time an incomplete database ğ· â€² over the same
schema such that #Compu (ğœ)(ğ·) = #Compu(ğ‘)(ğ· â€²), thus establishing the parsimonious reduction.

1:34

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

Let ğ‘“ be a fresh constant that does occurs neither in ğ· nor in the domain of some null. Then the rela-
tion ğ· â€²(ğ‘†) is the same as the relation ğ· (ğ‘†), plus a fact ğ‘† (ğ‘“ , ğ‘“ ). Moreover, for every (ğ‘, ğ‘, ğ‘) âˆˆ {0, 1}3,
the relation ğ· â€²(ğ¶ğ‘ğ‘ğ‘ ) consists of all the facts in ğ· (ğ¶ğ‘ğ‘ğ‘ ), plus a fact ğ¶ğ‘ğ‘ğ‘ (ğ‘“ , ğ‘“ , ğ‘“ ). It is easy to
see that ğ· and ğ· â€² have the same number of completions. Moreover, thanks to the facts that
use the constant ğ‘“ , we have that every completion of ğ· â€² satisfies ğ‘. Therefore, we indeed have
that #Compu(ğœ)(ğ·) = #Compu (ğ‘)(ğ· â€²). This proves that #Compu (ğœ) â©½p

par #Compu (ğ‘).

For the second part of the proof, we need to introduce the complexity class GapP. This class
consists of function problems that can be expressed as the difference of two functions in #P [24, 29].
It is known that if the inclusion SpanP âŠ† GapP holds, then we have that NP âŠ† SPP [39].12 With
this, we are able to prove the proposition. Assume that #Compu(ğ‘) is in #P. Then, by the first part
of the proof we have that #Compu(ğœ) âˆˆ #P as well (because #P is closed under polynomial-time
parsimonious reductions). Now, observe that for every incomplete database ğ· over ğœ, the following
holds:

#Compu(Â¬ğ‘)(ğ·) = #Compu (ğœ)(ğ·) âˆ’ #Compu (ğ‘)(ğ·).
But then this means that #Compu (Â¬ğ‘) is in GapP (since both problems in the right hand side are
in #P). Since #Compu(Â¬ğ‘) is SpanP-complete by Theorem 6.6 under polynomial-time parsimonious
reductions, and since GapP is closed under polynomial-time parsimonious reductions, this would
â–¡
indeed imply that SpanP âŠ† GapP and, hence, that NP âŠ† SPP.

We conclude this section by considering an even more general scenario where queries have
model checking in NP. Interestingly, in this case SpanP is again the right class to describe the
complexity not only of counting completions, but also of counting valuations.

Theorem 6.8. If ğ‘ is a Boolean query with MC(ğ‘) âˆˆ NP, then both #Val(ğ‘) and #Comp(ğ‘) are in
SpanP. Moreover, there exists such a Boolean query ğ‘ for which #Valu(ğ‘) is SpanP-complete under
polynomial-time parsimonious reductions (and for #Compu(ğ‘), we can even take ğ‘ to be the negation
of an sjfBCQ, hence with model checking in P, as given by Theorem 6.6).

Proof. It is straightforward to prove that these problems are in SpanP. The part in between
parenthesis has been shown in theorem 6.6. Thus, we need to prove that #Valu(ğ‘) is SpanP-hard for
a fixed Boolean query ğ‘ such that MC(ğ‘) âˆˆ NP, under polynomial-time parsimonious reductions.
To do this, we will reduce from the SpanP-complete problem #HamSubgraphs, defined as follows.
Let ğº = (ğ‘‰ , ğ¸) be a undirected graph, and let ğ‘† âŠ† ğ‘‰ . The subgraph of ğº induced by ğ‘†, denoted
by ğº [ğ‘†], is the graph with set of nodes ğ‘† and set of edges {{ğ‘¢, ğ‘£ } âˆˆ ğ¸ | ğ‘¢, ğ‘£ âˆˆ ğ‘† }, We recall that a
graph ğº is Hamiltonian when there exists a cycle in ğº that visits every node of ğº exactly once. The
problem #HamSubgraphs takes as input a simple graph ğº = (ğ‘‰ , ğ¸) and an integer ğ‘˜, and outputs
the number of induced subgraphs ğº [ğ‘†] with |ğ‘† | = ğ‘˜ such that ğº [ğ‘†] is Hamiltonian.

Proposition 6.9 ([35, Section 6]). #HamSubgraphs is SpanP-complete (under polynomial-time

parsimonious reductions).

Next we show that #HamSubgraphs â©½p

par #Valu(ğ‘), for a fixed Boolean query ğ‘ (to be defined).
Let ğº = (ğ‘‰ , ğ¸) be an undirected graph. We first explain how we construct the incomplete database ğ·,
and we will then define the query ğ‘. The schema contains two binary relation symbols ğ‘…,ğ‘‡ and one
unary relation symbol ğ¾. Fix a linear order ğ‘1, . . . , ğ‘ğ‘› of the nodes of ğº. For every edge {ğ‘¢, ğ‘£ } âˆˆ ğ¸
we have the facts ğ‘…(ğ‘¢, ğ‘£) and ğ‘…(ğ‘£, ğ‘¢). For 1 â©½ ğ‘– â©½ ğ‘› we have a fact ğ‘‡ (ğ‘ğ‘–, âŠ¥ğ‘– ), and the domain of
12In fact, the class GapSpanP is defined in [39], where it is proved that a function ğ‘“ is in GapSpanP if and only if ğ‘“ = ğ‘” âˆ’ â„,
where â„, ğ‘” are functions in SpanP. Then it is shown in [39, Corollary 3.5] that the inclusion GapSpanP âŠ† GapP implies
that NP âŠ† SPP. But if we have that SpanP âŠ† GapP, then we also have that GapSpanP âŠ† GapP as GapP is closed under
subtraction and, therefore, we conclude that NP âŠ† SPP as desired.

The complexity of counting problems over incomplete databases

1:35

the nulls is {0, 1}. For 1 â©½ ğ‘— â©½ ğ‘˜ we have a fact ğ¾ ( ğ‘—). Observe that ğ· is a Codd table. We now
define the Boolean query ğ‘, which will be a sentence in existential second-order logic (âˆƒSO) over
relational signature ğ‘…,ğ‘‡ , ğ¾. Before doing so, we explain the main idea: intuitively, ğ‘ will check
that there are exactly ğ‘˜ facts of the form ğ‘‡ (ğ‘ğ‘–, 1) in the relation ğ‘‡ and that, letting ğ‘† be the set
of nodes ğ‘£ such that ğ‘‡ (ğ‘£, 1) is in relation ğ‘‡ , the induced subgraph ğº [ğ‘†] is Hamiltonian. This will
indeed ensure that we have #Valu(ğ‘)(ğ·) = #HamSubgraphs(ğº, ğ‘˜), thus completing this reduction,
which is parsimonious and can be performed in polynomial-time. The query is

ğ‘ = âˆƒğ‘† ğœ“1(ğ‘†) âˆ§ ğœ“2 (ğ‘†)
where ğ‘† is a unary second order variable and the formula ğœ“1(ğ‘†) states that (a) the elements ğ‘  of ğ‘† are
exactly all the elements such that ğ‘‡ (ğ‘ , 1) holds, and that (b) there are exactly the same number of
elements in ğ‘† as there are elements ğ‘— for which ğ¾ ( ğ‘—) holds. It is clear that (a) can be expressed in FO.
Moreover, (b) can be expressed in âˆƒSO by asserting the existence of a binary second-order relation ğ‘ˆ
that represents a bijective function from ğ‘† to the elements in ğ¾. Then ğœ“2 (ğ‘†) is a formula that asserts
that ğº [ğ‘†] is Hamiltonian. Since this is a property in NP, ğœ“2(ğ‘†) can be expressed in âˆƒSO by Faginâ€™s
theorem (see, e.g., [31]). This shows that the reduction is correct. Finally, the fact that MC(ğ‘) is in
â–¡
NP again follows from Faginâ€™s theorem. This concludes the proof.

7 EXTENSIONS TO QUERIES WITH CONSTANTS AND FREE VARIABLES
So far, we have only considered our counting problems for queries that are Boolean and that do not
contain constants. In this section we explain how our framework can be adapted to queries with
constants and with free variables. Specifically, we will explain how one can obtain dichotomies for
self-joinâ€“free conjunctive queries with constants and free variables.

Before that, we have to formally define our counting problems for a query with free variables.
Let ğ‘( Â¯ğ‘¥) be a query with free variables Â¯ğ‘¥. For a tuple of constants Â¯ğ‘¡ of appropriate arity, we
write ğ‘(Â¯ğ‘¡) the Boolean query obtained by substituting the variables Â¯ğ‘¥ with the constants Â¯ğ‘¡. The
problem #Val(ğ‘( Â¯ğ‘¥)) then takes as input an incomplete database ğ· over relations sig(ğ‘( Â¯ğ‘¥)), a tuple
of constants Â¯ğ‘¡, and returns the number of valuations ğœˆ of ğ· such that ğœˆ (ğ·) |= ğ‘(Â¯ğ‘¡). We write this
output #Val(ğ‘( Â¯ğ‘¥))(ğ·, Â¯ğ‘¡). The problem #Comp(ğ‘( Â¯ğ‘¥)) is defined similarly.

We first explain in Section 7.1 how to obtain dichotomies for self-join-free conjunctive query with
free variables and constants, assuming we have dichotomies for self-joinâ€“free Boolean conjunctive
queries with constants. In section 7.2, we then explain how to obtain dichotomies for the later case.

7.1 Dealing with free variables
Suppose in this section that we have a dichotomy between #P-hardness and FP of our counting
problems, for every sjfBCQ that is allowed to contain constants. We then show how to obtain
dichotomies, for every self-joinâ€“free CQ that is allowed to have constants and free variables. To
this end, we will need the following definition. Let ğ‘( Â¯ğ‘¥) be a self-join-free CQ with free variables Â¯ğ‘¥,
and let Â¯ğ‘¡ and Â¯ğ‘¡ â€² be two tuples of constants with appropriate arity. We say that Â¯ğ‘¡ and Â¯ğ‘¡ â€² are equivalent
with respect to ğ‘( Â¯ğ‘¥) if one can go from ğ‘(Â¯ğ‘¡) to ğ‘( Â¯ğ‘¡ â€²) by iteratively renaming constants into fresh
constants. For instance, if ğ‘(ğ‘¥1, ğ‘¥2) is âˆƒğ‘¦ ğ‘…(ğ‘¦, ğ‘, ğ‘¥1, ğ‘¥2) âˆ§ ğ‘† (ğ‘ â€², ğ‘¥), then (ğ‘, ğ‘ â€²â€²) is equivalent to (ğ‘, ğ‘ â€²â€²â€²),
and (ğ‘ â€²â€², ğ‘ â€²â€²â€²) and (ğ‘ â€²â€²â€², ğ‘ â€²â€²) are also equivalent. It is clear that, if ğ‘( Â¯ğ‘¥) is fixed, this defines an
equivalence relation that has only finitely many classes. Furthermore, it is also clear that if Â¯ğ‘¡ and Â¯ğ‘¡ â€² are
equivalent with respect to ğ‘( Â¯ğ‘¥) then the problems #Val(ğ‘(Â¯ğ‘¡)) and #Val(ğ‘( Â¯ğ‘¡ â€²)) (resp., #Comp(ğ‘(Â¯ğ‘¡))
and #Comp(ğ‘( Â¯ğ‘¡ â€²))) have the same complexity. We can now show what we wanted. In what follows,
hardness refers to #P-hardness (but it is not important for the proof).

Lemma 7.1. Assume that the following is true: for every sjfBCQ ğ‘ that is allowed to have constants,
the problem #Val(ğ‘) is either hard or is tractable. Then the following is also true: for every self-joinâ€“free

1:36

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

conjunctive query ğ‘( Â¯ğ‘¥), the problem #Val(ğ‘( Â¯ğ‘¥)) is either hard or is tractable. This holds also for
counting completions, and when restricted to Codd tables and/or to the uniform setting.

Proof. We only deal with counting valuations for the naive and non-uniform case, as the other
cases are similar. We prove the following for any self-joinâ€“free CQ ğ‘( Â¯ğ‘¥), which implies the claim:
if there exists a tuple of constants Â¯ğ‘¡ such that #Val(ğ‘(Â¯ğ‘¡)) is hard, then #Val(ğ‘( Â¯ğ‘¥)) is hard as well,
otherwise #Val(ğ‘( Â¯ğ‘¥)) is tractable. We start with the â€œifâ€ direction. Let Â¯ğ‘¡ be a tuple of constants
such that #Val(ğ‘(Â¯ğ‘¡)) is hard. By definition, it is clear that, for any incomplete database ğ·, we have
that #Val(ğ‘(Â¯ğ‘¡))(ğ·) = #Val(ğ‘( Â¯ğ‘¥))(ğ·, Â¯ğ‘¡); this shows hardness of #Val(ğ‘( Â¯ğ‘¥)). Now for the â€œotherwiseâ€
direction. Let Â¯ğ‘¡1, . . . , Â¯ğ‘¡ğ‘˜ be representatives of the finitely many equivalence classes of the equivalence
relation defined above. We have access to oracles for #Val(ğ‘( Â¯ğ‘¡1)), . . . , #Val(ğ‘( Â¯ğ‘¡ğ‘˜ )). Let ğ·, Â¯ğ‘¡ be an
input of #Val(ğ‘( Â¯ğ‘¥)). We then simply recognize (in constant time since the query if fixed) to which Â¯ğ‘¡ğ‘–
the tuple Â¯ğ‘¡ is equivalent with respect to ğ‘( Â¯ğ‘¥), and call the appropriate oracle.
â–¡

(Notice that this idea actually works for conjunctive queries (with self-joins), or even unions of
conjunctive queries.) Hence, the problem becomes that of obtaining dichotomies for self-joinâ€“free
Boolean conjunctive queries that can contain constants. We explain in the next section how this
can be done.

7.2 Dealing with constants
In this section, we simply write â€œan sjfBCQâ€ to mean an sjfBCQ that can contain some constants. To
the best of our knowledge, there is no general reduction that allows us to easily obtain dichotomies
for the case with constants from the case where queries do not have constants. Hence, the strategy to
obtain dichotomies will be the same as in Section 3; namely, we will again use the notion of pattern to
find a set of hard patterns, and then show that when a query does not have any of the hard patterns
then the problem is tractable. The notion of pattern for an sjfBCQ that can contain constants is
the same as the one we used in Definition 3.1, but we simply add the possibility of deleting an
occurrence of a constant. For instance the query ğ‘…(ğ‘¥, ğ‘) is a pattern of the query ğ‘…(ğ‘¥, ğ‘¥, ğ‘, ğ‘, ğ‘ â€²) (in
this section all variables are existentially quantified, since we consider only Boolean queries). The
main property of patterns that we used then extends in this setting, as shown next.

Lemma 7.2. Let ğ‘, ğ‘â€² be sjfBCQs such that ğ‘â€² is a pattern of ğ‘. Then we have #Val(ğ‘â€²) â©½p

par #Val(ğ‘).
Moreover, the same results hold if we restrict to Codd tables, and/or to the uniform setting, and/or to
counting completions.

Proof. The reduction is exactly the same as that of Lemma 3.3, the only difference being that,
when we delete an occurrence of a constant ğ‘, we simply fill the corresponding columns of every
â–¡
tuple with this constant.

Next, we prove dichotomies for counting valuations for the non-uniform setting, for naive and
Codd databases. For Codd databases, it turns out that there is no new hard pattern that involves
constants, so the dichotomy is the same as for sjfBCQs without constants. Formally:

Theorem 7.3 (dichotomy). Let ğ‘ be an sjfBCQ. If ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥) is a pattern of ğ‘, then #ValCd (ğ‘) is

#P-complete. Otherwise, #ValCd(ğ‘) is in FP.

Proof. The proof is exactly as the proof of Theorem 3.7, with the following modification: we
let ğœŒ (Â¯ğ‘¡ ğ‘— ) be the number of valuations of the nulls appearing in Â¯ğ‘¡ ğ‘— that do not match the corresponding
â–¡
atom of ğ‘; and clearly, this can again be computed in polynomial time.

For naive tables however, we find two new hard patterns that involve constants, as shown next.

The complexity of counting problems over incomplete databases

1:37

Proposition 7.4. Let ğ‘, ğ‘ â€² be two distinct constants. The problems #Val(ğ‘…(ğ‘, ğ‘)) and #Val(ğ‘…(ğ‘, ğ‘ â€²))

are both #P-hard.

Proof. We only explain for #Val(ğ‘…(ğ‘, ğ‘ â€²)), as the other case is analogous. The reduction is similar
to that used in Proposition 3.8, but we reduce from counting the number of independent sets in
bipartite graphs (in Proposition 3.8 we did not need the graphs to be bipartite). Let ğº = (ğ‘ˆ âŠ” ğ‘‰ , ğ¸)
be a bipartite graph. We have one null âŠ¥ğ‘¢ for every node ğ‘¢ âˆˆ ğ‘ˆ with domain dom(âŠ¥ğ‘¢) = {0, ğ‘},
and one null âŠ¥ğ‘£ for every node ğ‘¢ âˆˆ ğ‘‰ with domain dom(âŠ¥ğ‘£) = {0, ğ‘ â€²}. For every edge (ğ‘¢, ğ‘£) âˆˆ ğ¸
we have a fact ğ‘…(âŠ¥ğ‘¢, âŠ¥ğ‘£) in ğ·. Then it is clear that the number of valuations of ğ· that do not
contain ğ‘…(ğ‘, ğ‘ â€²) is equal to the number of independent sets of ğº, thus establishing hardness. (Note
â–¡
that for ğ‘…(ğ‘, ğ‘), we do not need the graph to be bipartite for the reduction to work.)

We then claim that these are the only additional patterns that are necessary to obtain a dichotomy

for #Val(ğ‘) for sjfBCQs with constants.

Theorem 7.5 (dichotomy). Let ğ‘ be an sjfBCQ. If ğ‘…(ğ‘¥, ğ‘¥) or ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥) or ğ‘…(ğ‘, ğ‘) or ğ‘…(ğ‘, ğ‘ â€²)

for ğ‘ â‰  ğ‘ â€² is a pattern of ğ‘, then #Val(ğ‘) is #P-complete. Otherwise, #Val(ğ‘) is in FP.

The #P-hardness part of the claim follows from Lemma 7.2 and Propositions 3.4 and 3.5 and 7.4.
We now show the tractability claim. First, observe that not having any of these patterns means the
following: every variable in ğ‘ has exactly one occurrence and every atom of ğ‘ contains at most
one constant (but notice that the same constant can appear in multiple atoms). But then, because
the database is Codd and because ğ‘ has no self-joins, by multiplying by the appropriate factor,
the problem #Val(ğ‘) reduces to the problem #Val(ğ‘â€²) where ğ‘â€² is an sjfBCQ of the form ğ‘…1(ğ‘1) âˆ§
ğ‘…2(ğ‘2) âˆ§ . . . âˆ§ ğ‘…ğ‘˜ (ğ‘ğ‘˜ ), where the constants ğ‘1, . . . ğ‘ğ‘˜ are not necessarily distinct. We give next an
example proof that the problem is tractable for such a simple query.

= {âŠ¥ğ‘…

= {âŠ¥ğ‘…ğ‘†

1 , . . . , âŠ¥ğ‘…ğ‘†

Example 7.6. Let ğ‘ be the query ğ‘…(ğ‘) âˆ§ ğ‘† (ğ‘ â€²) with ğ‘ â‰  ğ‘ â€², and ğ· be an incomplete naive database.
We explain how to compute #Val(Â¬ğ‘)(ğ·) (the number of valuations that do not satisfy the query)
in FP. This is enough, since the total number of valuations can clearly be computed in FP. First of all,
we can assume without loss of generality that ğ· does not contain ground atoms that already satisfy
the query. Then, let ğµğ‘…ğ‘† def
ğ‘›ğ‘…ğ‘† } be the set of nulls that occur in both ğ· (ğ‘…) and ğ· (ğ‘†),
ğµğ‘… def
1 , . . . , âŠ¥ğ‘…
ğ‘›ğ‘… } be the set of nulls that occur in ğ· (ğ‘…) but not in ğ· (ğ‘†), and ğµğ‘†
ğ‘›ğ‘† }
be the set of nulls that occur in ğ· (ğ‘†) but not in ğ· (ğ‘…). Let ğ· â€² be the database that contains only
the facts ğ‘…(âŠ¥) and ğ‘† (âŠ¥) for âŠ¥ âˆˆ ğµğ‘…ğ‘† . Notice that the number of valuations of the nulls in ğµğ‘… such
that no null has value ğ‘ is (cid:206)ğ‘›ğ‘…
ğ‘– ) \ {ğ‘}|, and that the number of valuations of the nulls
in ğµğ‘… such that some null has value ğ‘ is then (cid:206)ğ‘›ğ‘…
ğ‘–=1 |dom(âŠ¥ğ‘…
ğ‘– ) \ {ğ‘}|, and a similar
expression can be obtained for the valuations of the nulls in ğµğ‘† and constant ğ‘ â€². Then, by case
analysis of whether some null in ğµğ‘… has value ğ‘ or not, and whether some null in ğµğ‘† has value ğ‘ â€² or
not, we obtain that #Val(Â¬ğ‘)(ğ·) = ğ´ + ğµ + ğ¶, where

ğ‘–=1 |dom(âŠ¥ğ‘…

ğ‘–=1 |dom(âŠ¥ğ‘…

ğ‘– )| âˆ’ (cid:206)ğ‘›ğ‘…

1, . . . , âŠ¥ğ‘†

def
= {âŠ¥ğ‘†

ğ´ = (cid:0)

ğ‘›ğ‘…(cid:214)

ğ‘–=1

|dom(âŠ¥ğ‘…

ğ‘– )| âˆ’

ğ‘›ğ‘…(cid:214)

ğ‘–=1

|dom(âŠ¥ğ‘…

ğ‘– ) \ {ğ‘}|(cid:1) Ã—

ğ‘›ğ‘†(cid:214)

ğ‘–=1

|domâŠ¥ğ‘†

ğ‘– | \ {ğ‘ â€²}| Ã—

ğ‘›ğ‘…ğ‘†(cid:214)

ğ‘–=1

|domâŠ¥ğ‘…ğ‘†
ğ‘–

\ {ğ‘ â€²}|

is the number of valuations of ğ· that do not satisfy ğ‘ and such that some null in ğµğ‘… has value ğ‘,

ğµ =

ğ‘›ğ‘…(cid:214)

ğ‘–=1

|dom(âŠ¥ğ‘…

ğ‘– )| \ {ğ‘}| Ã— (cid:0)

ğ‘›ğ‘†(cid:214)

ğ‘–=1

|dom(âŠ¥ğ‘†

ğ‘– )| âˆ’

ğ‘›ğ‘†(cid:214)

ğ‘–=1

|dom(âŠ¥ğ‘†

ğ‘– ) \ {ğ‘ â€²}|(cid:1) Ã—

ğ‘›ğ‘…ğ‘†(cid:214)

ğ‘–=1

|domâŠ¥ğ‘…ğ‘†
ğ‘–

\ {ğ‘})

1:38

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

is the number of valuations of ğ· that do not satisfy ğ‘ and such that no null in ğµğ‘… has value ğ‘ and

some null in ğµğ‘† has value ğ‘ â€², and

ğ¶ =

ğ‘›ğ‘…(cid:214)

ğ‘–=1

|dom(âŠ¥ğ‘…

ğ‘– ) \ {ğ‘}| Ã—

ğ‘›ğ‘†(cid:214)

ğ‘–=1

|dom(âŠ¥ğ‘†

ğ‘– ) \ {ğ‘ â€²}| Ã— #Val(Â¬ğ‘)(ğ· â€²)

is the number of valuations of ğ· that do not satisfy ğ‘ and such that no null in ğµğ‘… has value ğ‘
and no null in ğµğ‘† has value ğ‘ â€². Hence, we only have to explain how to compute #Val(Â¬ğ‘)(ğ· â€²)
in polynomial time. For ğ‘˜ âˆˆ {0, . . . , ğ‘›ğ‘…ğ‘† }, let ğ· â€²
be the database containing only the facts of ğ· â€²
ğ‘˜
over the nulls âŠ¥ğ‘…ğ‘†
. We then define the quantities ğ‘‰ (ğ‘†, ğ‘˜), for ğ‘† âˆˆ {{ğ‘}, {ğ‘ â€²}, {ğ‘, ğ‘ â€²}, âˆ…}
and ğ‘˜ âˆˆ {0, . . . , ğ‘›ğ‘…ğ‘† } to be the number of valuations of ğ·ğ‘˜ that do not satisfy ğ‘ and such that no
null has a value that is in ğ‘†. Notice then that ğ‘‰ (âˆ…, ğ‘›ğ‘…ğ‘† ) = #Val(Â¬ğ‘)(ğ· â€²). For an element ğ‘ and
set ğ´, we write [ğ‘ âˆˆ ğ´] to mean 1 if ğ‘ âˆˆ ğ´ and 0 otherwise. But then we can easily compute the
quantities ğ‘‰ (ğ‘†, ğ‘˜) by dynamic programming using the following relations:

1 , . . . , âŠ¥ğ‘…ğ‘†
ğ‘˜

ğ‘‰ (âˆ…, ğ‘˜) =[ğ‘ âˆˆ dom(âŠ¥ğ‘…ğ‘†

ğ‘˜ )] Ã— ğ‘‰ ({ğ‘}, ğ‘˜ âˆ’ 1)

+ [ğ‘ â€² âˆˆ dom(âŠ¥ğ‘…ğ‘†
+ |dom(âŠ¥ğ‘…ğ‘†

ğ‘˜ )] Ã— ğ‘‰ ({ğ‘ â€²}, ğ‘˜ âˆ’ 1)
ğ‘˜ ) \ {ğ‘, ğ‘ â€²}| Ã— ğ‘‰ (âˆ…, ğ‘˜ âˆ’ 1)

ğ‘‰ ({ğ‘, ğ‘ â€²}, ğ‘˜) = |dom(âŠ¥ğ‘…ğ‘†

ğ‘˜ ) \ {ğ‘, ğ‘ â€²}| Ã— ğ‘‰ ({ğ‘, ğ‘ â€²}, ğ‘˜ âˆ’ 1)

and

and

ğ‘‰ ({ğ‘}, ğ‘˜) =[ğ‘ â€² âˆˆ dom(âŠ¥ğ‘…ğ‘†

ğ‘˜ )] Ã— ğ‘‰ ({ğ‘, ğ‘ â€²}, ğ‘˜ âˆ’ 1)
ğ‘˜ ) \ {ğ‘, ğ‘ â€²}| Ã— ğ‘‰ ({ğ‘, ğ‘ â€²}, ğ‘˜ âˆ’ 1)

+ |dom(âŠ¥ğ‘…ğ‘†

and a similar relation for ğ‘‰ ({ğ‘ â€²}, ğ‘˜).

â–¡

The proof for the general case is simply a tedious generalization of the proof for this example,

and is not very interesting, so we omit it.

Therefore, by combining Theorems 7.3 and 7.5 with Lemma 7.1, we obtain dichotomies for
counting valuations of self-joinâ€“free conjunctive queries that can contain constants and free
variable, for the non-uniform setting for both naive and Codd tables. It is likely that dichotomies
can be obtained for counting valuations in the uniform setting by using the same methodology, but
we do not pursue this further as our goal in this section is not to be exhaustive but rather to give
the main ideas to be able to handle free variables and constants.

For counting completions, the reader can check that the pattern ğ‘…(ğ‘) is hard for #CompCd (so
that in this case again all queries are hard), and that for #Compu
, any query that contains an atom
Cd
that is not unary is again hard (it is evident from the proof of Proposition 4.9). By combining these
observations with Lemma 7.1 and with the tractability proof for #Compu (which can be shown
to extend in this case), we obtain four dichotomies for counting completions for self-joinâ€“free
conjunctive queries that can contain constants and free variables.

Last, we point out that by using the same methodology, one also can extend our results on
approximations to the case of queries containing constants and free variables (since the relevant
reductions are parsimonious).

The complexity of counting problems over incomplete databases

1:39

8 RELATED WORK
There are two main lines of work that must be compared to what we do in this article. In both cases
the goal is to go beyond the traditional notion of certain answers that so far had been used almost
exclusively to deal with query answering over uncertain data. We discuss them here, explain how
they relate to our problems and what are the fundamental differences.

Best answers and 0-1 laws for incomplete databases. Libkin has recently introduced a frame-
work that can be used to measure the certainty with which a Boolean query holds on an incomplete
database, and also to compare query answers (for a non-Boolean query) [38]. For a Boolean query ğ‘,
incomplete database ğ·, and integer ğ‘˜, he defines the quantity ğœ‡ğ‘˜ (ğ‘, ğ·) as |Suppğ‘˜ (ğ‘,ğ·) |
, where ğ‘‰ ğ‘˜ (ğ·)
denotes the set of valuations of ğ· with domain {1, . . . , ğ‘˜ }, and Suppğ‘˜ (ğ‘, ğ·) denotes the set of
valuations ğœˆ âˆˆ ğ‘‰ ğ‘˜ (ğ·) such that ğœˆ (ğ·) |= ğ‘; hence, ğœ‡ğ‘˜ (ğ‘, ğ·) represents the relative frequency of
valuations ğœˆ in {1, . . . , ğ‘˜ } for which the query is satisfied. He then shows that, for a very large class
of queries (namely, generic queries), the value ğœ‡ğ‘˜ (ğ‘, ğ‘‘) always tends to 0 or 1 as ğ‘˜ tends to infinity
(and the same results holds when considering completions instead of valuations). This means that,
intuitively, over an infinite domain the query ğ‘ is either almost certainly true or almost certainly
false.

|ğ‘‰ ğ‘˜ (ğ·) |

He also studies the complexity of finding best answers for a non Boolean query ğ‘. As mentioned
in the introduction, a tuple ğ‘ is a better answer than another tuple ğ‘ when for every valuation ğœˆ
of ğ·, if we have ğ‘ âˆˆ ğ‘(ğœˆ (ğ‘‘)) then we also have ğ‘ âˆˆ ğ‘(ğœˆ (ğ‘‘)). A best answer is then an answer
such that there is no other answer strictly better than it (under inclusion of the sets of satisfying
valuations). He studies the complexity of comparing answers under this semantics, and that of
computing the set of best answers (see also [25]).

There are several crucial differences between this previous work and ours. First, Libkin does
not study the complexity of computing ğœ‡ğ‘˜ (ğ‘, ğ‘‘). We do this under the name #Valu(ğ‘); moreover,
we also study the setting in which the domains are not uniform. Second, knowing that a tuple
is the best answer might not tell us anything about the size of its â€œsupportâ€, i.e., the number of
valuations that support it. In particular, a best answer is not necessarily an answer which has the
biggest support. Finally, under the semantics of better answers it does not matter if we look at the
completions or at the valuations (i.e., a tuple is a best answer with respect to inclusion of valuations
iff it is the best answer with respect to completions); while we have shown that it does matter for
counting problems.

Counting problems for probabilistic databases and consistent query answering. Re-
markably, counting problems have received considerable attention in other database scenarios
where uncertainty issues appear. As mentioned in the introduction, this includes the settings of
probabilistic databases and inconsistent databases. In the former case, uncertainty is represented
as a probability distribution on the possible states of the data [19, 47]. There, query answering
amounts to computing a weighted sum of the probabilities of the possible states of the data that
satisfy a query ğ‘. We call this problem Prob(ğ‘). In the case of inconsistent databases, we are given
a set Î£ of constraints and a database ğ· that does not necessarily satisfy Î£; cf. [9, 12, 13]. Then the
task is to reason about the set of all repairs of ğ· with respect to Î£ [9]. In our context, this means
that one wants to count the number of repairs of ğ· with respect to Î£ that satisfy a given query ğ‘.
When ğ‘ and Î£ are fixed, we call this problem #Repairs(ğ‘, Î£).

Both Prob(ğ‘) and #Repairs(ğ‘, Î£) have been intensively studied already. To start with, counting
complexity dichotomies have been obtained for the problem #Repairs(ğ‘, Î£); e.g., [40] gives a
dichotomy for this problem when ğ‘ is an sjfBCQ and ğœ consists of primary keys, and [41] extends
this result to CQs with self-joins but only for unary keys constraints. We also mention [15], where

1:40

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

the problem of counting repairs such that a particular input tuple is in the result of the query
on the repair is studied. A seemingly close counting problem for probabilistic databases is the
problem Prob(ğ‘) over block independent disjoint (BIDs) databases. We do not define it formally here,
but counting repairs under primary keys can be seen as a special case of this problem, where the
tuples in a â€œblockâ€ all have the same probability, and where the sum of the probabilities sum to 1 (and
in BIDs this sum is allowed to be < 1, meaning that a block can be completely erased). Dichotomies
for this problem have been obtained in [18] for sjfBCQs. Counting complexity dichotomies for
other models of probabilistic databases also exist; e.g., for tuple-independent probabilistic databases
in which each fact is assigned an independent probability of being part of the actual dataset.
Interestingly, dichotomies in this case hold for arbitrary unions of BCQs, and thus not just for
sjfBCQs [19].

In some cases, one can use a problem of the form #Repairs(ğ‘, Î£) (or Prob(ğ‘)) to show the
hardness of a problem of the form #Val(ğ‘â€²). For instance, in Section 3.1 we used the #P-hardness
of #Repairs(ğ‘… â€²(y, ğ‘¥) âˆ§ ğ‘† â€²(z, ğ‘¥)) to prove that of #ValCd(ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥)). In general however, the
problems #Repairs(ğ‘, Î£) and Prob(ğ‘) seem to be unrelated to our problems, for the following
reasons. First, in our setting the nulls can appear anywhere, so there is no notion of primary keys
here; hence it seems unlikely that one can design a generic reduction from the problem of counting
valuations/completions to the problem of counting repairs. In fact, it would perfectly make sense
to study our counting problems where we add constraints such as functional dependencies. Second,
in the BID and counting repairs problems, each â€œvaluationâ€ (repair) gives a different complete
database, while in our case we have seen that this is not necessarily the case. In particular, problems
of the form #Comp(ğ‘) have no analogues in these settings, whereas we have seen that they behave
very differently in our setting.

Concerning approximation results, it is known that the problems #Repairs(ğ‘, Î£) and Prob(ğ‘)
admit an FPRAS in some important settings. In particular, when ğ‘ is a union of BCQs, this holds for
#Repairs(ğ‘, Î£) when Î£ is a set of primary keys [15], and for Prob(ğ‘) over BID and tuple-independent
probabilistic databases [18]. We observe here that this is reminescent of our Corollary 5.3, which
shows that problems of the form #Val(ğ‘) have an FPRAS for every union of BCQs.

9 FINAL REMARKS
Our work aims to be a first step in the study of counting problems over incomplete databases.
The main conclusion behind our results is that the counting problems studied in this article are
particularly hard from a computational point of view, especially when compared to more positive
results obtained in other uncertainty scenarios; e.g., over probabilistic and inconsistent databases.
As we have shown, a particularly difficult problem in our context is that of counting completions,
even in the uniform setting where all nulls have the same domain. In fact, Proposition 4.9 shows
that this problem is #P-hard even in very restricted scenarios, and Proposition 5.6 that it cannot be
approximated by an FPRAS. It seems then that the only way in which one could try to tackle this
problem is by developing suitable tractable heuristics, without provable quantitative guarantees,
but that work sufficiently well in practical scenarios. An example of this could be developing
algorithms that compute â€œunder-approximationsâ€ for the number of completions of a naive table
satisfying a certain sjfBCQ ğ‘. Notice that a related approach has been proposed by Console et al.
for constructing under-approximations of the set of certain answers by applying methods based on
many-valued logics [17].

We plan to continue working on several interesting problems that are left open in this article. First
of all, we would like to pinpoint the complexity of #Comp(ğ‘) when ğ‘ is an sjfBCQ; in particular,
whether this problem is SpanP-complete for at least one such a query. We also want to study
whether the non-existence of FPRAS for #Compu(ğ‘) established in Proposition 5.6 continues to

The complexity of counting problems over incomplete databases

1:41

hold over Codd tables. We would also like to develop a more thorough understanding of the role
of fixed domains in our dichotomies. In several cases, that we have explicitly stated, our lower
bounds hold even if nulls in tables are interpreted over a fixed domain. Still, in some cases we do not
know whether this holds. These include, e.g., Proposition 3.11, Proposition 4.2, and Proposition 4.9.
Finally, it would also be interesting to study these counting problems under bag semantics (instead
of the set semantics used in this article), or consider arbitrary conjunctive queries as opposed to
only self-joinâ€“free ones.

ACKNOWLEDGMENTS
We thank Antoine Amarilli for suggesting to use #BIS in the proof of Proposition 3.11, as well as
the anonymous reviewers for their careful proofreading. This work was partially funded by ANID
- Millennium Science Initiative Program - Code ICN17_002. Arenas is funded by Fondecyt grant
1191337 and BarcelÃ³ by Fondecyt grant 1200967.

REFERENCES
[1] Serge Abiteboul, Richard Hull, and Victor Vianu. 1995. Foundations of databases. Vol. 8. Addison-Wesley Reading.

http://webdam.inria.fr/Alice/

[2] Serge Abiteboul, Paris Kanellakis, and GÃ¶sta Grahne. 1991. On the representation and querying of sets of possible worlds.
Theoretical computer science 78, 1 (1991), 159â€“187. https://www.sciencedirect.com/science/article/pii/0304397551900072

[3] Adam. 2013. Number of surjective functions. https://math.stackexchange.com/a/615136/378365
[4] Parag Agrawal, Anish Das Sarma, Jeffrey Ullman, and Jennifer Widom. 2010. Foundations of uncertain-data integration.

Proceedings of the VLDB Endowment 3, 1-2 (2010), 1080â€“1090. http://ilpubs.stanford.edu:8090/846/2/main.pdf

[5] Carme Ãlvarez and Birgit Jenner. 1993. A very hard log-space counting class. Theoretical Computer Science 107, 1

(1993), 3â€“30. https://www.sciencedirect.com/science/article/pii/030439759390252O

[6] Periklis Andritsos, Ariel Fuxman, and Renee J Miller. 2006. Clean answers over dirty databases: A probabilistic approach.
In 22nd International Conference on Data Engineering (ICDEâ€™06). IEEE, 30â€“30. ftp://ftp.cs.toronto.edu/csrg-technical-
reports/513/tr513.pdf

[7] Lyublena Antova, Christoph Koch, and Dan Olteanu. 2009. 10(106) worlds and beyond: efficient representation and
processing of incomplete information. The VLDB Journal 18, 5 (2009), 1021â€“1040. https://arxiv.org/abs/cs/0606075
[8] Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet. 2020. Counting Problems over Incomplete Databases. In Proceedings
of the 39th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems. 165â€“177. https://arxiv.org/abs/
1912.11064

[9] Marcelo Arenas, Leopoldo Bertossi, and Jan Chomicki. 1999. Consistent query answers in inconsistent databases.
In Proceedings of the eighteenth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems. 68â€“79.
http://marenas.sitios.ing.uc.cl/publications/pods99.pdf

[10] Marcelo Arenas, Luis Alberto Croquevielle, Rajesh Jayaram, and Cristian Riveros. 2019. Efficient logspace classes for
enumeration, counting, and uniform generation. In Proceedings of the 38th ACM SIGMOD-SIGACT-SIGAI Symposium
on Principles of Database Systems. 59â€“73. https://arxiv.org/abs/1906.09226

[11] Omar Benjelloun, Anish Das Sarma, Alon Halevy, Martin Theobald, and Jennifer Widom. 2008. Databases with
uncertainty and lineage. The VLDB Journal 17, 2 (2008), 243â€“264. http://ilpubs.stanford.edu:8090/811/1/2007-26.pdf
[12] Leopoldo Bertossi. 2011. Database repairing and consistent query answering. Synthesis Lectures on Data Management

3, 5 (2011), 1â€“121. https://www.cs.ubc.ca/~laks/cpsc504/dc-leo.pdf

[13] Leopoldo Bertossi. 2019. Database repairs and consistent query answering: Origins and further developments. In
Proceedings of the 38th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems. 48â€“58. https:
//dl.acm.org/citation.cfm?id=3322190

[14] Jin-Yi Cai, Pinyan Lu, and Mingji Xia. 2012. Holographic reduction, interpolation and hardness. Computational
Complexity 21, 4 (2012), 573â€“604. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.145.8882&rep=rep1&
type=pdf

[15] Marco Calautti, Marco Console, and Andreas Pieris. 2019. Counting database repairs under primary keys revisited. In
Proceedings of the 38th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems. 104â€“118. https:
//core.ac.uk/download/pdf/224804156.pdf

[16] T Codd. 1975. Understanding relations (installment# 7). FDT Bull. of ACM Sigmod 7 (1975), 23â€“28.
[17] Marco Console, Paolo Guagliardo, and Leonid Libkin. 2016. Approximations and refinements of certain answers via

many-valued logics. In KR. 349â€“358. https://homepages.inf.ed.ac.uk/libkin/papers/kr16.pdf

1:42

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

[18] Nilesh Dalvi, Christopher Re, and Dan Suciu. 2011. Queries and materialized views on probabilistic databases. J.

Comput. System Sci. 77, 3 (2011), 473â€“490. https://www-cs.stanford.edu/~chrismre/papers/jcss-probdb.pdf

[19] Nilesh Dalvi and Dan Suciu. 2013. The dichotomy of probabilistic inference for unions of conjunctive queries. Journal

of the ACM (JACM) 59, 6 (2013), 1â€“87. https://homes.cs.washington.edu/~suciu/jacm-dichotomy.pdf

[20] Martin Dyer, Alan Frieze, and Mark Jerrum. 2002. On counting independent sets in sparse graphs. SIAM J. on Computing

31, 5 (2002), 1527â€“1541. http://yaroslavvb.com/papers/dyer-on.pdf

[21] Jack Edmonds. 1965. Paths, trees, and flowers. Can. J. of Math. 17 (1965), 449â€“467. https://math.nist.gov/~JBernal/p_t_

f.pdf

[22] Genghua Fan, Yan Li, Ning Song, and Daqing Yang. 2015. Decomposing a graph into pseudoforests with one having
bounded degree. Journal of Combinatorial Theory, Series B 115 (2015), 72â€“95. https://www.sciencedirect.com/science/
article/pii/S0095895615000581

[23] Wenfei Fan, Floris Geerts, Xibei Jia, and Anastasios Kementsietsidis. 2008. Conditional functional dependencies for
capturing data inconsistencies. ACM Transactions on Database Systems (TODS) 33, 2 (2008), 1â€“48. https://www.inf.ed.
ac.uk/publications/online/0949.pdf

[24] Stephen A Fenner, Lance J Fortnow, and Stuart A Kurtz. 1994. Gap-definable counting classes. J. Comput. System Sci.

48, 1 (1994), 116â€“148. https://www.sciencedirect.com/science/article/pii/S0022000005800248

[25] AmÃ©lie Gheerbrant and Cristina Sirangelo. 2019. Best answers over incomplete data: Complexity and first-order
rewritings. In the Twenty-Eighth International Joint Conference on Artificial Intelligence (IJCAI 2019). https://www.ijcai.
org/proceedings/2019/236

[26] Omer GimÃ©nez and Marc Noy. 2006. On the complexity of computing the Tutte polynomial of bicircular matroids. Com-
binatorics, Probability and Computing 15, 3 (2006), 385â€“395. https://www.cambridge.org/core/journals/combinatorics-
probability-and-computing/article/on-the-complexity-of-computing-the-tutte-polynomial-of-bicircular-
matroids/8B45505EDDDF91337E62D45B143EC5E5

[27] Logan Grout and Benjamin Moore. 2019. On decomposing graphs into forests and pseudoforests. arXiv preprint

arXiv:1904.12435 (2019). https://arxiv.org/abs/1904.12435

[28] Sanjay Gupta. 1991. The power of witness reduction. In 1991 Proceedings of the Sixth Annual Structure in Complexity

Theory Conference. IEEE, 43â€“59. https://ieeexplore.ieee.org/abstract/document/160242

[29] Sanjay Gupta. 1995. Closure properties and witness reduction. J. Comput. System Sci. 50, 3 (1995), 412â€“432. https:

//www.sciencedirect.com/science/article/pii/S002200008571032X

[30] Tomasz Imielinski and Witold Lipski Jr. 1984. Incomplete Information in Relational Databases. Journal of the ACM

(JACM) 31, 4 (1984), 761â€“791. https://cs.uwaterloo.ca/~david/cs848s14/il84.pdf

[31] Neil Immerman. 2012. Descriptive complexity. Springer Science & Business Media. https://people.cs.umass.edu/

~immerman/book/ch0_1_2.pdf

[32] FranÃ§ois Jaeger, Dirk L Vertigan, and Dominic JA Welsh. 1990. On the computational complexity of the Jones and Tutte
polynomials. In Mathematical Proc. of the Cambridge Phil. Soc., Vol. 108. Cambridge University Press, 35â€“53. https:
//www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/on-
the-computational-complexity-of-the-jones-and-tutte-polynomials/0EA052341269A2816C36B15380B8AA02
[33] Mark R Jerrum, Leslie G Valiant, and Vijay V Vazirani. 1986. Random generation of combinatorial structures from
a uniform distribution. Theoretical computer science 43 (1986), 169â€“188. http://www2.stat.duke.edu/~scs/Courses/
Stat376/Papers/ConvergeRates/RandomizedAlgs/JerrumValiantVaziraniTCS1986.pdf

[34] Ker-I Ko. 1982. Some observations on the probabilistic algorithms and NP-hard problems. Inform. Process. Lett. 14, 1

(1982), 39â€“43. https://www.sciencedirect.com/science/article/pii/0020019082901399

[35] Johannes KÃ¶bler, Uwe SchÃ¶ning, and Jacobo TorÃ¡n. 1989. On counting and approximation. Acta Informatica 26, 4

(1989), 363â€“379. https://www.researchgate.net/publication/226508658_On_counting_and_approximation

[36] Åukasz Kowalik. 2006. Approximation scheme for lowest outdegree orientation and graph density measures. In
International Symposium on Algorithms and Computation. Springer, 557â€“566. https://www.mimuw.edu.pl/~kowalik/
papers/orient.pdf

[37] Leonid Libkin. 2014. Incomplete data: what went wrong, and how to fix it. In Proceedings of the 33rd ACM SIGMOD-
SIGACT-SIGART symposium on Principles of database systems. 1â€“13. https://homepages.inf.ed.ac.uk/libkin/papers/
pods14.pdf

[38] Leonid Libkin. 2018. Certain answers meet zero-one laws. In Proceedings of the 37th ACM SIGMOD-SIGACT-SIGAI
Symposium on Principles of Database Systems. 195â€“207. https://homepages.inf.ed.ac.uk/libkin/papers/pods18.pdf
[39] Meena Mahajan, Thomas Thierauf, and N. V. Vinodchandran. 1994. A note on SpanP functions. Inf. Process. Lett. 51, 1

(1994), 7â€“10. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.24.9933&rep=rep1&type=pdf

[40] Dany Maslowski and Jef Wijsen. 2013. A dichotomy in the complexity of counting database repairs. J. Comput. System

Sci. 79, 6 (2013), 958â€“983. https://www.sciencedirect.com/science/article/pii/S0022000013000214

The complexity of counting problems over incomplete databases

1:43

[41] Dany Maslowski and Jef Wijsen. 2014. Counting database repairs that satisfy conjunctive queries with self-joins. In

ICDT. 155â€“164. http://www.openproceedings.org/ICDT/2014/paper_17.pdf

[42] Mitsunori Ogiwara and Lane A. Hemachandra. 1993. A complexity theory for feasible closure properties. J. Comput.

Syst. Sci. 46, 3 (1993), 295â€“325. https://www.sciencedirect.com/science/article/pii/002200009390006I

[43] James Oxley. 2003. What is a matroid. Cubo MatemÃ¡tica Educacional 5, 3 (2003), 179â€“218. https://www.math.lsu.edu/

~oxley/survey4.pdf

[44] J Scott Provan and Michael O Ball. 1983. The complexity of counting cuts and of computing the probability that a

graph is connected. SIAM J. Comput. 12, 4 (1983), 777â€“788. https://epubs.siam.org/doi/abs/10.1137/0212053

[45] Raymond Reiter. 1978. On closed world data bases. Springer US, 55â€“76. https://pdfs.semanticscholar.org/d82a/

786f460a5d5c2c6d97aa60f0ead0e70dc67e.pdf

[46] Anish Das Sarma, Omar Benjelloun, Alon Halevy, Shubha Nabar, and Jennifer Widom. 2009. Representing uncertain
data: models, properties, and algorithms. The VLDB Journal 18, 5 (2009), 989â€“1019. http://ilpubs.stanford.edu:
8090/924/1/uncertainData.pdf

[47] Dan Suciu, Dan Olteanu, Christopher RÃ©, and Christoph Koch. 2011. Probabilistic databases. Morgan & Claypool.

https://www.morganclaypool.com/doi/abs/10.2200/S00362ED1V01Y201105DTM016

[48] Seinosuke Toda and Osamu Watanabe. 1992. Polynomial-time 1-Turing reductions from# PH to# P. Theoretical
Computer Science 100, 1 (1992), 205â€“221. https://www.sciencedirect.com/science/article/pii/030439759290369Q
[49] Leslie G. Valiant. 1976. Relative complexity of checking and evaluating. Inf. Process. Lett. 5, 1 (1976), 20â€“23. https:

//www.sciencedirect.com/science/article/pii/0020019076900971

[50] Leslie G Valiant. 1979. The complexity of computing the permanent. Theoretical computer science 8, 2 (1979), 189â€“201.

https://core.ac.uk/download/pdf/82500417.pdf

[51] Leslie G. Valiant. 1979. The complexity of enumeration and reliability problems. SIAM J. Comput. 8, 3 (1979), 410â€“421.

https://www.math.cmu.edu/~af1p/Teaching/MCC17/Papers/enumerate.pdf

[52] Ron van der Meyden. 1998. Logical approaches to incomplete information: A survey. In Logics for databases and

information systems. Springer, 307â€“356. https://link.springer.com/chapter/10.1007/978-1-4615-5643-5_10

[53] Moshe Y Vardi. 1982. The complexity of relational query languages. In Proceedings of the fourteenth annual ACM
symposium on Theory of computing. 137â€“146. http://www.dis.uniroma1.it/~degiacom/didattica/semingsoft/SIS05-
06/materiale/1-query-congiuntive/riferimenti/vardi-1982.pdf

[54] Dominic Welsh. 1999. The Tutte polynomial. Random Structures & Algorithms 15, 3-4 (1999), 210â€“228. https:
//onlinelibrary.wiley.com/doi/pdf/10.1002/(SICI)1098-2418(199910/12)15:3/4%3C210::AID-RSA2%3E3.0.CO;2-R
[55] Mingji Xia, Peng Zhang, and Wenbo Zhao. 2007. Computational complexity of counting problems on 3-regular planar

graphs. Theoretical Computer Science 384, 1 (2007), 111â€“125. https://core.ac.uk/download/pdf/82063901.pdf

[56] Thomas Zaslavsky. 1982. Bicircular geometry and the lattice of forests of a graph. The Quarterly Journal of Mathematics
33, 4 (1982), 493â€“511. https://academic.oup.com/qjmath/article-abstract/33/4/493/1498307?redirectedFrom=PDF

1:44

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

Appendix

A PROOFS FOR SECTION 3 (DICHOTOMIES FOR COUNTING VALUATIONS)

A.1 Proof of Theorem 3.9
In this section we prove the tractability claim of the following dichotomy theorem.

Theorem 3.9 (dichotomy). Let ğ‘ be an sjfBCQ. If ğ‘…(ğ‘¥, ğ‘¥) or ğ‘…(ğ‘¥)âˆ§ğ‘† (ğ‘¥, ğ‘¦)âˆ§ğ‘‡ (ğ‘¦) or ğ‘…(ğ‘¥, ğ‘¦)âˆ§ğ‘† (ğ‘¥, ğ‘¦)

is a pattern of ğ‘, then #Valu (ğ‘) is #P-complete. Otherwise, #Valu (ğ‘) is in FP.

First, to characterize the queries that do not have these patterns, we will use the notion of

connectivity graph of an sjfBCQ ğ‘:

Definition A.1. Let ğ‘ be an sjfBCQ. The connectivity graph of ğ‘ is the graph ğºğ‘ = (ğ‘‰ , ğ¸) with
labeled edges, where ğ‘‰ is the set of atoms of ğ‘, and for every two atoms ğ‘…( Â¯ğ‘¥ğ‘– ), ğ‘† ( Â¯ğ‘¦ğ‘– ) of ğ‘, if they
share a variable then we have an edge between the corresponding nodes of ğºğ‘, that edge being
labeled with the variables in Â¯ğ‘¥ğ‘– âˆ© Â¯ğ‘¦ğ‘– .

Example A.2. Figure 3 shows the connectivity graph of the query

ğ‘…1(ğ‘¥1, ğ‘¥1, ğ‘¦1, ğ‘¡1), ğ‘…2(ğ‘¥1, ğ‘¦1, ğ‘¡2), ğ‘†1(ğ‘¥2, ğ‘¡3), ğ‘†2(ğ‘¥2, ğ‘¡4), ğ‘†3(ğ‘¥2),ğ‘‡1(ğ‘¥3),ğ‘‡2(ğ‘¥3),ğ‘‡3(ğ‘¥3),ğ‘‡4(ğ‘¥3, ğ‘¡5).

â–¡

ğ‘…1(ğ‘¥1, ğ‘¥1, ğ‘¦1, ğ‘¡1)

ğ‘†1(ğ‘¥2, ğ‘¡3)

ğ‘¥1, ğ‘¦1

ğ‘¥2

ğ‘…2(ğ‘¥1, ğ‘¦1, ğ‘¡2)

ğ‘†2(ğ‘¥2, ğ‘¡4)

ğ‘¥2

ğ‘¥2

ğ‘†3(ğ‘¥2)

ğ‘¥3

ğ‘‡1(ğ‘¥3)

ğ‘‡4(ğ‘¥3, ğ‘¡5)

ğ‘¥3

ğ‘¥3

ğ‘¥3

ğ‘¥3

ğ‘‡2(ğ‘¥3)

ğ‘‡3(ğ‘¥3)

ğ‘¥3

Fig. 3. The connectivity graph ğºğ‘ of the sjfBCQ ğ‘ from Example A.2.

The following is then readily observed:

Lemma A.3. Let ğ‘ be an sjfBCQ that does not contain any of the patterns mentioned in Theorem 3.9.
Then for every connected component ğ¶ of ğºğ‘, ğ¶ is a clique and there exists a variable such that all
edges of ğ¶ are labeled by exactly that variable.

Proof. First, observe that every edge of ğºğ‘ must be labeled by exactly one variable, as otherwise
the query ğ‘ would contain the pattern ğ‘…(ğ‘¥, ğ‘¦) âˆ§ ğ‘† (ğ‘¥, ğ‘¦). Let ğ¶ be a connected component of ğºğ‘.
Then we have:

â€¢ ğ¶ is a clique. Indeed, assume by contradiction that ğ¶ is not a clique. Then, since ğ¶ is connected
and is not a clique, we can find 3 nodes ğ´1(ğ‘¥), ğ´2 (ğ‘¥ â€²), ğ´3(ğ‘¥ â€²â€²) such that ğ´1(ğ‘¥) is adjacent
to ğ´2(ğ‘¥ â€²), ğ´2(ğ‘¥ â€²) is adjacent to ğ´3(ğ‘¥ â€²â€²), and ğ´1(ğ‘¥) is not adjacent to ğ´3(ğ‘¥ â€²â€²). Let ğ‘‹ be ğ‘¥ âˆ© ğ‘¥ â€²
and ğ‘Œ be ğ‘¥ â€² âˆ© ğ‘¥ â€²â€², i.e., the labels on the two corresponding edges of ğ¶. By definition of ğºğ‘
and since ğ´1(ğ‘¥) is not adjacent to ğ´3(ğ‘¥ â€²â€²), we must have ğ‘‹ âˆ© ğ‘Œ = âˆ…. But ğ‘‹ and ğ‘Œ are not
empty (again by definition of ğºğ‘), so by picking ğ‘¥ in ğ‘‹ and ğ‘¦ in ğ‘Œ we see that ğ‘ contains the
pattern ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥, ğ‘¦) âˆ§ ğ‘‡ (ğ‘¦), a contradiction.

The complexity of counting problems over incomplete databases

1:45

â€¢ There exists a variable that labels every edge of ğ¶. Indeed, since every edge of ğºğ‘ is labeled
by exactly one variable, and since ğ¶ is a clique, if it was not the case then again we could
find the pattern ğ‘…(ğ‘¥) âˆ§ ğ‘† (ğ‘¥, ğ‘¦) âˆ§ ğ‘‡ (ğ‘¦) in ğ‘.

This concludes the proof.

â–¡

For instance, the query from Example A.2 does not satisfy this criterion, since the edge in
the first connected component of ğºğ‘ is labeled by two variables. However if we consider the
query ğ‘†1(ğ‘¥2, ğ‘¡3), ğ‘†2(ğ‘¥2, ğ‘¡4), ğ‘†3 (ğ‘¥2),ğ‘‡1(ğ‘¥3),ğ‘‡2(ğ‘¥3),ğ‘‡3(ğ‘¥3),ğ‘‡4(ğ‘¥3, ğ‘¡5) (i.e., we remove the first connected
component), then it satisfies the criterion.

We will also use the general fact that for an sjfBCQ ğ‘, we can assume wlog that ğ‘ does not

contain variables that occur only once:

Lemma A.4. Let ğ‘ be an sjfBCQ, and let ğ‘â€² be the sjfBCQ obtained from ğ‘ by deleting all the

variables that have only one occurrence in ğ‘. Then #Valu(ğ‘) â©½p

T #Valu(ğ‘â€²).

Proof. Let ğ· be an incomplete database input of #Valu(ğ‘). Let ğ‘† be set of nulls âŠ¥ such that:
â€¢ âŠ¥ occurs in a column corresponding to a variable that has been deleted; and
â€¢ âŠ¥ does not occur in a column corresponding to a variable that has not been deleted.

Then, letting ğ· â€² be the database obtained from ğ· by projecting out the columns corresponding
to the deleted variables, it is clear that we have #Valu(ğ‘)(ğ·) = #Valu(ğ‘â€²)(ğ· â€²) Ã— (cid:206)
âŠ¥âˆˆğ‘† |dom(âŠ¥)|,
where dom is the uniform domain of the nulls. We note here that this lemma is also true in the
â–¡
non-uniform setting.

By Lemma A.3 and Lemma A.4, it is enough to show the tractability of #Valu (ğ‘) when ğ‘ is of
the form ğ¶1(ğ‘¥1) âˆ§ . . . âˆ§ ğ¶ğ‘š (ğ‘¥ğ‘š), where each ğ¶ğ‘– (ğ‘¥ğ‘– ) is what we call a basic singleton query, i.e., is
a conjunction of unary atoms over the same variable ğ‘¥ğ‘– . We call such an sjfBCQ a conjunction of
basic singletons. For instance,

ğ‘†1(ğ‘¥2), ğ‘†2(ğ‘¥2), ğ‘†3(ğ‘¥2),ğ‘‡1(ğ‘¥3),ğ‘‡2(ğ‘¥3),ğ‘‡3(ğ‘¥3),ğ‘‡4(ğ‘¥3)

is such a query, with ğ‘š = 2. We will use the following:

Lemma A.5. Let ğ‘ = ğ¶1(ğ‘¥1) âˆ§ . . . âˆ§ğ¶ğ‘š (ğ‘¥ğ‘š) be a conjunction of basic singletons sjfBCQ, and let ğ· be
def
= |{ğœˆ valuation of ğ· | ğœˆ (ğ·) Ì¸|= (cid:212)ğ‘– âˆˆğ‘† ğ¶ğ‘– (ğ‘¥ğ‘– )}|.

an incomplete database. For ğ‘† âŠ† [ğ‘š], we define ğ‘ğ‘† (ğ·)
Then we have #Valu(ğ‘)(ğ·) = (cid:205)ğ‘† âŠ† [ğ‘š] (âˆ’1) |ğ‘† |ğ‘ğ‘† (ğ·).

Proof. Direct, by inclusionâ€“exclusion.

â–¡

Hence, and remembering that we consider data complexity, it is enough to show how to com-
pute ğ‘ğ‘† (ğ·) for every ğ‘† âŠ† [ğ‘š]. The main difficulties in computing ğ‘ğ‘† (ğ·) is that the relations can
have nulls in common (since we consider naive tables), and that they may also have constants; this
makes it technically painful to express a closed-form expression for ğ‘ğ‘† (ğ·). We explain how to do
it next, thus finishing the proof of Theorem 3.9.

Proposition A.6. Let ğ‘ = ğ¶1(ğ‘¥1) âˆ§ . . . âˆ§ ğ¶ğ‘š (ğ‘¥ğ‘š) be a conjunction of basic singletons sjfBCQ
and ğ‘† âŠ† [ğ‘š]. Then, given an incomplete database ğ· as input, we can compute ğ‘ğ‘† (ğ·) in polynomial
time.

Proof. First, observe that to compute ğ‘ğ‘† (ğ·) we can assume without loss of generality that
the input database ğ· only contains facts over relation names that occur in some ğ¶ğ‘– (ğ‘¥ğ‘– ), for ğ‘– âˆˆ ğ‘†.
Indeed, ğ‘ğ‘† (ğ·) counts the valuations ğœˆ of ğ· that do not satisfy any of the ğ¶ğ‘– (ğ‘¥ğ‘– ) for ğ‘– âˆˆ ğ‘†, so that for
any ğ‘— âˆ‰ ğ‘† we do not care if ğœˆ satisfies ğ¶ ğ‘— (ğ‘¥ ğ‘— ) or not; hence, we could simply multiply the result by

1:46

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

the appropriate factor. Therefore, we can assume that ğ‘† is [ğ‘š]. We now need to fix some notation.
Let us write the conjunction of basic singleton sjfBCQ ğ‘ as

= (cid:205)ğ‘š

ğ‘…1(ğ‘¥1) âˆ§ . . . âˆ§ ğ‘…ğ‘š1 (ğ‘¥1) âˆ§ ğ‘…ğ‘š1+1(ğ‘¥2) âˆ§ . . . âˆ§ ğ‘…ğ‘š1+ğ‘š2 (ğ‘¥2) âˆ§ . . . âˆ§ ğ‘…(cid:205)ğ‘šâˆ’1

ğ‘–=1 ğ‘šğ‘– (ğ‘¥ğ‘š) âˆ§ . . . âˆ§ ğ‘…(cid:205)ğ‘š
and let ğ¾ be the number of atoms in ğ‘, that is, ğ¾ def
ğ‘–=1 ğ‘šğ‘– . Let dom be the uniform domain of
the nulls occurring in ğ· and ğ‘‘ its size. For s âŠ† [ğ¾], we write ğ¶s the set of constants that occur in
each of the relations ğ· (ğ‘…ğ‘– ) for ğ‘– âˆˆ s but in none of the others, and write ğ‘s the size of that set. We
call such a set a block of constants. Similarly for the nulls, we write ğ‘s the set of nulls that occur in
each of the relations ğ· (ğ‘…ğ‘– ) for ğ‘– âˆˆ s but in none of the others (and we call this a block of nulls),
and ğ‘›s for its size. We can assume wlog that:
(a) For every 1 â©½ ğ‘– â©½ ğ‘š, there is no constant that occurs in every ğ· (ğ‘…) for ğ‘… a relation name
in ğ¶ğ‘– (ğ‘¥ğ‘– ). Indeed otherwise any valuation would satisfy ğ¶ğ‘– (ğ‘¥ğ‘– ), thus ğ‘ [ğ‘š] (ğ·) would simply
be 0.

ğ‘–=1 ğ‘šğ‘– (ğ‘¥ğ‘š)

(b) Every constant ğ‘ appearing in ğ· is in dom. Indeed otherwise, with the last item, this constant
would have no chance to be part of a match, so we could simply remove it (i.e., remove all
tuples of the form ğ‘…(ğ‘) from ğ·).
For a subset ğ´ âŠ† dom, let us write ğ´âˆ def
of dom, we denote by I (ğ‘ ) the set

= dom \ ğ´. Finally, for a set ğ‘ = {ğ´1, . . . , ğ´ğ‘™ } of subsets

I (ğ‘ )

def
= {

ğ‘™
(cid:217)

ğ‘–=1

ğµğ‘– | (ğµ1, . . . , ğµğ‘™ ) âˆˆ {ğ´1, ğ´âˆ

1 } Ã— . . . Ã— {ğ´ğ‘™, ğ´âˆ

ğ‘™ }}

We now explain informally how we can compute ğ‘ [ğ‘š] (ğ·). Let ğ¿ = s1, . . . , s2ğ¾ be an arbitrary
linear order of the set of subsets of [ğ¾]. We will define by induction on ğ‘– âˆˆ [2ğ¾ ] an expression
computing ğ‘ [ğ‘š] (ğ·), which will be a nested sum of the form

âˆ‘ï¸

sums1

ğ‘“s1 Ã—

(cid:18) âˆ‘ï¸

sums2

ğ‘“s2 Ã— (cid:0) . . . (

âˆ‘ï¸

sums2ğ¾

(cid:19)

ğ‘“s2ğ¾ ) . . . (cid:1)

(7)

where each sumsğ‘– sums over the possible images ğ´sğ‘– of the nulls in ğ‘sğ‘– by a valuation, and ğ‘“sğ‘–
def
= |ğ´sğ‘– |, i.e., the number of valuations ğœˆ of ğ‘sğ‘– with image

, where ğ‘sğ‘–

will simply be surjğ‘›sğ‘– â†’ğ‘sğ‘–
exactly ğ´sğ‘– . But there are two technicalities:

â€¢ First, we need to ensure that each basic singleton query ğ¶ğ‘– (ğ‘¥ğ‘– ) of ğ‘ will not be satisfied. In
, . . . , ğµ |I (ğ‘ğ‘–âˆ’1 |)
)
si
is included in one of the sets in I (ğ‘ğ‘–âˆ’1), where ğ‘ğ‘–âˆ’1 contains all
for ğ‘— < ğ‘–. We iteratively build that sum from the

order to do that, sumsğ‘– will actually sum over all the possible partitions (ğµ1
si
of ğ´sğ‘– , where each of the ğµ ğ‘—
the blocks of constants and all the other ğµğ‘Ÿ
sj

sğ‘–

def
= {dom} âˆª {ğ¶s | s âŠ† [ğ¾]}. This will allow us to avoid

outside to the inside, starting with ğ‘0
summing over the ğµ ğ‘—
si

that would render a basic singleton query true.
â€¢ Second, as is, such a sum is obviously not going to be computable in PTIME, as we are
summing over subsets of dom. To fix this, observe that the value of the subsum for sğ‘– actually
only depends on the sizes of the sets in ğ‘ğ‘–âˆ’1. Hence, iterating from the outside to the inside,
whenever sumsğ‘– contains a sum of the form, say, ğµğ‘˜
for ğ‘— < ğ‘–, we can replace this with a
si
, and add to ğ‘“sğ‘– a factor of (cid:0)ğ‘ğ‘˜â€²
sum over 0 â©½ ğ‘ğ‘˜
si

(cid:1). Now, because of how ğ‘0 is defined, and

âŠ† ğµğ‘˜â€²
sj

â©½ ğ‘ğ‘˜â€²
sj

because of how I works, all the initial numbers in the first sum are either |dom \ (cid:208)ğ¾
or one of the numbers ğ‘s for s âŠ† [ğ¾]. These can all be computed in polynomial time.

ğ‘–=1 ğ¶ {ğ‘– } |

sj
ğ‘ğ‘˜
si

The complexity of counting problems over incomplete databases

1:47

The resulting expression then indeed evaluates to ğ‘ [ğ‘š] (ğ·), and is in a form that allows us to
directly compute it in polynomial time (but non-elementary in the query). This concludes the proof
â–¡
of Proposition A.6.

B PROOFS FOR SECTION 4 (DICHOTOMIES FOR COUNTING COMPLETIONS)

B.1 Proof for Proposition 4.7
In this section we explain how to obtain the following hardness result.

Proposition 4.7 (Implied by [26]). The problem #PF restricted to bipartite graphs is #P-hard.

This result is proven for (non-necessarily bipartite) graphs in [26] using techniques from matroid
theory, in particular using the notions of bicircular matroid of a graph and of Tutte polynomial of a
matroid. We did not find a way to show that the result holds on bipartite graphs without explaining
their proof for general graphs, and we did not find a way to explain the proof for general graphs
without introducing these concepts. Therefore, we need to define these concepts here. We have
tried to keep this exposition as brief as possible, but more detailed introductions to matroid theory
and to the Tutte polynomial can be found in [43, 54]. First, we define what is a matroid.

Definition B.1. A matroid ğ‘€ = (ğ¸, I) is a pair where ğ¸ is a finite set (called the ground set) and I
is a set of subsets of ğ¸ whose elements are called independent sets and that satisfies the following
properties:
Non emptiness. I â‰  âˆ…;
Heritage. For every ğ´â€² âŠ† ğ´ âŠ† ğ¸, if ğ´ âˆˆ I then ğ´â€² âˆˆ I;
Independent set exchange. For every ğ´, ğµ âˆˆ I, if |ğ´| > |ğµ| then there exists ğ‘¥ âˆˆ ğ´ \ ğµ such

that ğµ âˆª {ğ‘¥ } âˆˆ I.

In a matroid ğ‘€ = (ğ¸, I), an independent set ğ´ âˆˆ I is called a basis if every strict superset ğ´ âŠŠ
ğ´â€² âŠ† ğ¸ is not in I. Notice that, thanks to the independent set exchange property, all bases of ğ‘€
have the same number of elements. The rank of ğ‘€ is defined as the number of elements in any
basis of ğ‘€. Given a matroid ğ‘€ = (ğ¸, I) and ğ´ âŠ† ğ¸, we can define the submatroid of ğ‘€ generated
by ğ´ to be ğ‘€ğ´ = (ğ´, I â€²), where for ğ´â€² âŠ† ğ´ we have ğ´â€² âˆˆ I â€² iff ğ´â€² âˆˆ I (one should check that this
is indeed a matroid). The rank function rkğ‘€ : {ğ´ | ğ´ âŠ† ğ¸} â†’ N of ğ‘€ is then defined with rkğ‘€ (ğ´)
being the rank of the matroid ğ‘€ğ´. We will now omit the subscript in rkğ‘€ as this will not cause
confusion. We are ready to define the Tutte polynomial of a matroid.

Definition B.2. Let ğ‘€ = (ğ¸, I) be a matroid. The Tutte polynomial of ğ‘€, denoted T(ğ‘€; ğ‘¥, ğ‘¦), is

the two-variables polynomial defined by

T(ğ‘€; ğ‘¥, ğ‘¦) =

âˆ‘ï¸

(ğ‘¥ âˆ’ 1)rk(ğ‘€)âˆ’rk(ğ´) (ğ‘¦ âˆ’ 1) |ğ´ |âˆ’rk(ğ´)

ğ´ âŠ†ğ¸
We will use the following observation:

Observation B.3. Let ğ‘€ = (ğ¸, I) be a matroid. Then T(ğ‘€; 2, 1) = |I|, i.e., evaluating the Tutte

polynomial of a matroid at point (2, 1) simply counts its number of independent sets.

Proof. We have T(ğ‘€; 2, 1) = (cid:205)ğ´ âŠ†ğ¸ 0 |ğ´ |âˆ’rk(ğ´) . We recall the convention that 00 = 1, and the fact
that 0ğ‘˜ = 0 for ğ‘˜ > 0. Observe then that we always have rk(ğ´) â©½ |ğ´|, and that we have rk(ğ´) = |ğ´|
â–¡
if and only if ğ´ âˆˆ I, which proves the claim.

Next, we define what is called the bicircular matroid of a graph ğº = (ğ‘‰ , ğ¸). Recall from Defini-

tion 4.6 the definition of the induced subgraph ğº [ğ‘†] for ğ‘† âŠ† ğ¸.

1:48

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

Definition B.4. Let ğº = (ğ‘‰ , ğ¸) be a graph and I = {ğ‘† âŠ† ğ¸ | ğº [ğ‘†] is a pseudoforest}. Then one
can check that (ğ¸, I) is a matroid [56]. This matroid is called the bicircular matroid of ğº, and is
denoted by ğµ(ğº).

Notice then that the problem #PF is exactly the same as the problem of computing, given
as input a graph ğº, the quantity T(ğµ(ğº); 2, 1). We now explain the steps used in [26] to prove
that computing T(ğµ(ğº); 2, 1) is #P-hard for graphs. The starting point of our explanation is that
computing T(ğµ(ğº); 1, 1) is #P-hard.

Proposition B.5 ([26, Corollary 4.3]). The problem of computing, given a graph ğº, the quan-

tity T(ğµ(ğº); 1, 1) is #P-hard.

Second, let us define the following univariate polynomial: for a graph ğº, let ğ‘ƒğº (ğ‘¥) be

ğ‘ƒğº (ğ‘¥) = T(ğµ(ğº); ğ‘¥, 1).

Notice that this is indeed a polynomial and that its degree is at most |ğ¸| (the degree is exactly |ğ¸|
iff ğº is itself a pseudoforest). If we could compute efficiently the coefficients of ğ‘ƒğº , then we could in
particular compute the value ğ‘ƒğº (1) = T(ğµ(ğº); 1, 1), which is #P-hard by the previous proposition.
We recall that to compute the coefficients of a polynomial of degree ğ‘›, it is enough to know its
value on ğ‘› + 1 distinct points; in fact, given these values in ğ‘› + 1 distinct points, it is possible to
efficiently compute the coefficients of the polynomial by using standard interpolation techniques
(for example, by using Lagrange polynomials).

We need one last definition.

Definition B.6. Let ğº be a graph. For ğ‘˜ âˆˆ N, let sğ‘˜ (ğº) be the graph obtained from ğº by replacing

each edge of ğº by a path of lenght ğ‘˜; this graph is called the ğ‘˜-stretch of ğº.

Then, using a result attributed to Brylawski (see [32]), the authors of [26] obtain that, â€œup to a

trivial factorâ€, we have

A careful inspection of [32] reveals13 that, in fact, we have

T(ğµ(sğ‘˜ (ğº)); 2, 1) â‰ƒ T(ğµ(ğº); 2ğ‘˜, 1).

T(ğµ(sğ‘˜ (ğº)); 2, 1) = (2ğ‘˜ âˆ’ 1) |ğ¸ |âˆ’rkğµ (ğº ) (ğ¸) Ã— T(ğµ(ğº); 2ğ‘˜, 1).

Notice that rkğµ (ğº) (ğ¸) is the size (number of edges) of a pseudoforest of ğº that is maximal by
inclusion of edges, which we can compute in polynomial time.14

With this, the authors of [26] can conclude the proof that computing T(ğµ(ğº); 2, 1) is hard for
(non-necessarily bipartite) graphs, i.e., that #PF is #P-hard. Indeed, given as input ğº = (ğ‘‰ , ğ¸), we
can construct in polynomial time the graphs sğ‘˜ (ğº) for |ğ¸| + 1 distinct values of ğ‘˜, then use oracle
calls to obtain the numbers T(ğµ(sğ‘˜ (ğº)); 2, 1), which gives us the value of ğ‘ƒğº on |ğ¸| + 1 distinct
points. With that we can recover the coefficients of ğ‘ƒğº and compute ğ‘ƒğº (1) = T(ğµ(ğº); 1, 1) as
argued above, thus proving hardness for general graphs. To obtain hardness for bipartite graphs,
it is enough to observe that when ğ‘˜ is even then the ğ‘˜-stretch of ğº is bipartite (even if ğº is not
bipartite). Hence, to obtain a proof of Proposition 4.7 for bipartite graphs, we can simply change
that proof and specify that we make |ğ¸| + 1 calls to the oracle T(ğµ(sğ‘˜ (ğº)); 2, 1) for |ğ¸| + 1 disctinct
even values of ğ‘˜.

13To be precise, we use Equations (7.1) and (7.2) of [32] with ğ‘¥ = 1, ğ‘¦ = 0, and Equation (2.2) with ğ‘¥ = 2, ğ‘¦ = 1.
14This is because, since ğµ (ğº) is a matroid, any two such pseudoforests have the same number of edges. We can then simply
start from the empty subgraph and iteratively add edges until it is not possible to add an edge such that the resulting graph
is a pseudoforest. This also relies on the fact that we can check in polynomial time whether a graph is a pseudoforest.

The complexity of counting problems over incomplete databases

1:49

B.2 Proof of Theorem 4.10
In this section we prove the tractability part of the following:

Theorem 4.10 (Dichotomy). Let ğ‘ be an sjfBCQ. If ğ‘…(ğ‘¥, ğ‘¥) or ğ‘…(ğ‘¥, ğ‘¦) is a pattern of ğ‘, then

#Compu(ğ‘) and #Compu
Cd

(ğ‘) are #P-hard. Otherwise, these problems are in FP.

Let ğ‘ be an sjfBCQ not containing any of these two patterns. Then, as observed in Section 4.2, ğ‘
is a conjunction of basic singletons query. Let ğœ = {ğ‘…1, . . . , ğ‘…ğ‘™ } be the set of relation symbols of ğ‘,
and ğ· be an incomplete database over these relations, with dom the uniform domain of the nulls
and ğ‘‘ its size. For every s âŠ† ğœ, s â‰  âˆ…, let:

â€¢ ğ¶s be the set of constants that occur in all relations of s and in none of the others; ğ‘s be its

size;

â€¢ ğ‘s be the set of nulls that occur in all relations of s and in none of the others; ğ‘›s be its size.
We also define ğ‘ as (cid:205)
âˆ…â‰ sâŠ†ğœ ğ‘s. We can assume wlog that ğ¶s âŠ† dom for all âˆ… â‰  s âŠ† ğœ, otherwise we
can simply remove from ğ· the corresponding facts. Let ğ¿ def
= 2ğ‘™ âˆ’ 1, and let s1, . . . , sğ¿ be an arbitrary
linear order of {s âŠ† ğœ | s â‰  âˆ…} (for instance, by non-decreasing size). We will follow the same
steps as in the example of Section 4.3. The following lemma is the generalization of Claim 4.12, and
explains how we can guide the computation so that we do not count the same completion twice:

Lemma B.7. For a tuple (ğ¼s1, . . . , ğ¼sğ¿ ) of subsets of dom satisfying (â˜…)
ğ¶sâ€²

ğ¼s âŠ† (dom \ (ğ¶ âˆª

ğ¼sâ€²)) âˆª

(cid:216)

(cid:216)

âˆ…â‰ sâ€² âŠ†ğœ
sâ€²â‰ s
for every s âˆˆ (s1, . . . , sğ¿) (in other words, all the sets ğ¼s are mutually disjoint subsets of dom, and a
set ğ¼s can only contain a constant ğ‘ âˆˆ ğ¶ if ğ‘ is in one of the sets ğ¶sâ€² for which sâ€² is striclty included
in s), let us define ğ‘ƒ (ğ¼s1, . . . , ğ¼sğ¿ ) to be the complete database consisting of the following facts, for
every âˆ… â‰  s âŠ† ğœ:

âˆ…â‰ sâ€²âŠŠs

sğ¿ ).

, . . . , ğ¼ â€²

, . . . , ğ¼ â€²

, . . . , ğ¼ â€²

sâŠ‹sâ€² ğ¼sâ€²
, . . . , ğ¼ â€²

. Then (wlog) there exists ğ‘ âˆˆ ğ¼s \ ğ¼ â€²
s

sğ¿ ) satisfying (â˜…) and that are distinct, we

â€¢ ğ‘…(ğ‘) for every ğ‘… âˆˆ s and ğ‘ âˆˆ ğ¼s or ğ‘ âˆˆ ğ¶s \ (cid:208)
Then, for every two such tuples (ğ¼s1, . . . , ğ¼sğ¿ ) and (ğ¼ â€²
s1
have that ğ‘ƒ (ğ¼s1, . . . , ğ¼sğ¿ ) â‰  ğ‘ƒ (ğ¼ â€²
s1
sğ¿ ). Assume that ğ‘ƒ = ğ‘ƒ â€², and let us
Proof. Let us write ğ‘ƒ = ğ‘ƒ (ğ¼s1, . . . , ğ¼sğ¿ ) and ğ‘ƒ â€² = ğ‘ƒ (ğ¼ â€²
s1
sğ¿ ). Assume by way of contradiction that for some âˆ… â‰  s âŠ† ğœ we
show that (ğ¼s1, . . . , ğ¼sğ¿ ) = (ğ¼ â€²
s1
have ğ¼s â‰  ğ¼ â€²
. By the definition of ğ‘ƒ, we have that ğ‘ƒ contains all
s
the facts ğ‘…(ğ‘) for ğ‘… âˆˆ s. Let us show that ğ‘ƒ does not contain any fact ğ‘…(ğ‘) for ğ‘… âˆ‰ s. Otherwise,
assume that ğ‘ƒ contains ğ‘…(ğ‘) with ğ‘… âˆ‰ s. Then there exists sâ€² âŠ† ğœ such that ğ‘… âˆˆ sâ€² and such
that ğ‘ âˆˆ ğ¼sâ€² âˆª (ğ¶sâ€² \ (cid:208)
sâ€²âŠ‹sâ€²â€² ğ¼sâ€²â€²). Since s does not contain ğ‘… while sâ€² does, we have sâ€² âŠˆ s. But then
by (â˜…) we have that ğ¼s and ğ¼sâ€² âˆª ğ¶sâ€² are disjoint, which is a contradiction because ğ‘ is supposed to
be in both ğ¼s and ğ¼sâ€² âˆª (ğ¶sâ€² \ (cid:208)
sâ€²âŠ‹sâ€²â€² ğ¼sâ€²â€²). Therefore, it is indeed the case that ğ‘ƒ does not contain
any fact ğ‘…(ğ‘) for ğ‘… âˆ‰ s. Now, if ğ‘ƒ â€² contains a fact ğ‘…(ğ‘) for some ğ‘… âˆ‰ ğœ then we are done since
this would imply ğ‘ƒ â‰  ğ‘ƒ â€², a contradiction. Hence we can assume that ğ‘ƒ â€² does not contain any
fact ğ‘…(ğ‘) for ğ‘… âˆ‰ ğœ. We will now prove that ğ‘ƒ â€² does not contain all the facts ğ‘…(ğ‘) for ğ‘… âˆˆ ğœ, thus
establishing a contradiction (because ğ‘ƒ does, so we would have ğ‘ƒ â‰  ğ‘ƒ â€²) and concluding this proof.
Assume by contradiction that ğ‘ƒ â€² contains all the facts ğ‘…(ğ‘) for ğ‘… âˆˆ s. First of all, observe that we
have ğ‘ âˆ‰ ğ¶s because by (â˜…) we have that ğ¼s and ğ¶s are disjoint, and we know that ğ‘ âˆˆ ğ¼s. Hence,
the only way in which ğ‘ƒ â€² could contain all the facts ğ‘…(ğ‘) for ğ‘… âˆˆ s is if there exist sâ€²
1, . . . , sâ€²
ğ‘˜
ğ‘— = s and such that for every 1 â©½ ğ‘— â©½ ğ‘˜ we
with ğ‘˜ â©¾ 1 and sâ€²
have that (i) ğ‘ âˆˆ ğ¼sâ€² ğ‘— âˆª (ğ¶sâ€² ğ‘— \ (cid:208)
sâ€² ğ‘— âŠ‹sâ€²â€² ğ¼sâ€²â€²). Observe that there must exist 1 â©½ ğ‘—1, ğ‘—2 â©½ ğ‘˜ such that sâ€²
ğ‘—1

ğ‘— âŠŠ s for 1 â©½ ğ‘— â©½ ğ‘˜ such that (cid:208)1â©½ ğ‘— â©½ğ‘˜ sâ€²

1:50

Marcelo Arenas, Pablo BarcelÃ³, and MikaÃ«l Monet

ğ‘—2 are incomparable by inclusion (otherwise, since all sğ‘— are strictly included in s, their union
and sâ€²
and ğ¼sâ€² ğ‘—2 âˆª ğ¶sâ€² ğ‘—2
could not be equal to s). Also observe that by (â˜…) we have that the sets ğ¼sâ€² ğ‘—1 âˆª ğ¶sâ€² ğ‘—1
must be disjoint. But then (i) applied to ğ‘—1 and ğ‘—2 gives a contradiction (namely, these two sets are
â–¡
not disjoint since they both contain ğ‘). This finishes the proof.

This next Lemma generalizes Claim 4.13 and tells us that by summing over all such tuples (ğ¼s1, . . . , ğ¼sğ¿ )

we cannot miss a completion of ğ·:

Lemma B.8. Let ğ· â€² be a completion of ğ·. Then there exists a tuple (ğ¼s1, . . . , ğ¼sğ¿ ) of subsets of dom

satisfying (â˜…) such that ğ· â€² = ğ‘ƒ (ğ¼s1, . . . , ğ¼sğ¿ ).

Proof. For âˆ… â‰  s âŠ† ğœ, let us define ğ·s to be the set of constants that occur in all relation of s
def
= ğ·s \ ğ¶s. It is then routine
â–¡

and in none of the others. Define the set ğ¼s for âˆ… â‰  s âŠ† ğœ as follows: ğ¼s
to check that (ğ¼s1, . . . , ğ¼sğ¿ ) satisfies (â˜…) and is such that ğ· â€² = ğ‘ƒ (ğ¼s1, . . . , ğ¼sğ¿ ).

Lemma B.7 and B.8 allows us to express the result as

âˆ‘ï¸

. . .

âˆ‘ï¸

. . .

âˆ‘ï¸

check(ğ¼s1, . . . , ğ¼sğ¿ )

(8)

ğ¼s1 âŠ†dom\ğ¶

ğ¼sğ‘— âŠ† (dom\(ğ¶âˆª(cid:208)1â©½ğ‘˜ < ğ‘— ğ¼sğ‘˜ ))âˆª(cid:208)

ğ¶sâ€²
where check(ğ¼s1, . . . , ğ¼sğ¿ ) âˆˆ {0, 1} is defined by

âˆ…â‰ sâ€²âŠŠs

ğ¼sğ¿ âŠ†dom\(ğ¶sğ¿ âˆª(cid:208)1â©½ğ‘˜ <ğ¿ ğ¼sğ‘˜ )

check(ğ¼s1, . . . , ğ¼sğ¿ )

def
=

(cid:40)1 if ğ‘ƒ (ğ¼s1, . . . , ğ¼sğ¿ ) is a completion of ğ· that satisfies ğ‘
0 otherwise

.

As such we cannot evaluate this expression in P. The next step is to show that the value
of check(ğ¼s1, . . . , ğ¼sğ¿ ) only depends on (|ğ¼s1 |, . . . , |ğ¼sğ¿ |), which would allow us to rewrite the result as

âˆ‘ï¸

(cid:214)

(cid:18)ğ‘‘ âˆ’ ğ‘ âˆ’ (cid:205)1â©½ğ‘˜< ğ‘— ğ‘–sğ‘˜ + (cid:205)

0â©½ğ‘–s1 ,...,ğ‘–sğ¿

â©½ğ‘‘

1â©½ ğ‘— â©½ğ¿

ğ‘–sğ‘—

âˆ…â‰ sâ€²âŠŠs

(cid:19)

ğ¶sâ€²

Ã— check(ğ‘–s1, . . . , ğ‘–sğ¿ )

(9)

We give here the necessary and sufficient conditions for ğ‘ƒ (ğ¼s1, . . . , ğ¼sğ¿ ) to be a completion of ğ·

that satisfies ğ‘.

Lemma B.9. We have check(ğ¼s1, . . . , ğ¼sğ¿ ) = 1 if and only if the following conditions hold:
(1) for every basic singleton query ğ¶ğ‘– (ğ‘¥) of ğ‘, letting s be its sets of relation symbols, there exists s âŠ†

sâ€² âŠ† ğœ such that we have |ğ¼sâ€² | â©¾ 1 or ğ‘sâ€² â©¾ 1.

(2) for every âˆ… â‰  s âŠ† ğœ, if ğ‘›s â©¾ 1 and | (cid:208)
sâ€² âŠ‡s
(3) consider the following system of equations, with integer variables between 0 and ğ‘‘:

ğ¼sâ€² | = 0 then |ğ¼s| â‰  0.

ğ¶sâ€² âˆª (cid:208)

sâ€²âŠ‹s

â€¢ for every two sets ğ´, ğ´â€² of subsets of {âˆ… â‰  s âŠ† ğœ }, we have a variable ğ‘§ğ´,ğ´â€²
ğ‘s

for every s âˆˆ ğ´ and
for every s âˆˆ ğ´â€². For instance if ğœ = {ğ‘…, ğ‘†,ğ‘‡ , ğ‘ˆ } and if ğ´ = {{ğ‘…, ğ‘† }, {ğ‘†,ğ‘‡ }}

a variable ğ‘§ğ´,ğ´â€²
ğ¶s
and ğ´â€² = {{ğ‘ˆ }} we have the variables
ğ‘§ { {ğ‘…,ğ‘† },{ğ‘†,ğ‘‡ } },{ {ğ‘ˆ } }
ğ‘{ğ‘…,ğ‘† }

ğ‘{ğ‘†,ğ‘‡ }

and ğ‘§ { {ğ‘…,ğ‘† },{ğ‘†,ğ‘‡ } },{ {ğ‘ˆ } }

and ğ‘§ { {ğ‘…,ğ‘† },{ğ‘†,ğ‘‡ } },{ {ğ‘ˆ } }

ğ¶{ğ‘ˆ }

.

ğ‘{ğ‘†,ğ‘‡ }

The intuition is that we will use ğ‘§ { {ğ‘…,ğ‘† },{ğ‘†,ğ‘‡ } },{ {ğ‘ˆ } }
with ğ‘§ { {ğ‘…,ğ‘† },{ğ‘†,ğ‘‡ } },{ {ğ‘ˆ } }
of the constants
in ğ¶ {ğ‘ˆ } in order to obtain constants in ğ¼ {ğ‘…,ğ‘†,ğ‘‡ ,ğ‘ˆ }. Let us write ğ‘‰ this set of variables. (we note
here that we are using sligthly different notation than for the example in Section 4.3; this is for
readability reasons only.)

of the nulls in ğ‘ {ğ‘†,ğ‘‡ } and with ğ‘§ { {ğ‘…,ğ‘† },{ğ‘†,ğ‘‡ } },{ {ğ‘ˆ } }

of the nulls in ğ‘ {ğ‘…,ğ‘† } and combine them

ğ‘{ğ‘…,ğ‘† }

ğ¶{ğ‘ˆ }

The complexity of counting problems over incomplete databases

1:51

â€¢ Now, for every âˆ… â‰  s âŠ† ğœ we have the constraint

as well as the constraint

ğ‘§ğ´,ğ´â€²
ğ‘s

â©½ ğ‘›s

ğ‘§ğ´,ğ´â€²
ğ‘s

â©½ ğ‘s

âˆ‘ï¸

ğ‘§ğ´,ğ´â€²
ğ‘s

âˆˆğ‘‰

âˆ‘ï¸

ğ‘§ğ´,ğ´â€²
ğ¶s

âˆˆğ‘‰

intuitively expressing that we do not use more nulls and constants than there are available.

â€¢ for every âˆ… â‰  s âŠ† ğœ we have a constraint

âˆ‘ï¸

ğ´,ğ´â€² âŠ† { âˆ…â‰ sâŠ†ğœ }
ğ´âˆªğ´â€²=s

ğ‘§ğ´,ğ´â€²
âˆ—

â©¾ ğ¼s

min
âˆˆğ‘‰

ğ‘§ğ´,ğ´â€²
âˆ—

intuitively meaning that we have allocated the groups of nulls and constants in a way that
allows us to fill the set ğ¼s.

Then this system of equations must have a solution.

Proof. The idea is the same as in Claim 4.14. The only difference is that we added condition (1),
â–¡

which ensures that the guessed completion indeed satisfies the query.

As in the example of Section 4.3, this implies that the value of check(ğ¼s1, . . . , ğ¼sğ¿ ) only depends
on (|ğ¼s1 |, . . . , |ğ¼sğ¿ |) and can be computed in FP (by testing all assignments of the ğ‘§âˆ—
âˆ— variables; because
the schema is fixed so there are only a fixed number of such variables). But then we can compute
the result in FP by evaluating the expression 9, which finishes the proof.

