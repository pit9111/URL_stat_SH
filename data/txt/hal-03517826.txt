The Mu-RA System for Recursive Path Queries over
Graphs
Amela Fejza, Pierre GenevÃ¨s, Nabil LayaÃ¯da, Sarah Chlyah

To cite this version:

Amela Fejza, Pierre GenevÃ¨s, Nabil LayaÃ¯da, Sarah Chlyah. The Mu-RA System for Recursive Path
Queries over Graphs. 32nd ACM International Conference on Information and Knowledge Man-
agement (CIKM 2023), Oct 2023, Birmingham, United Kingdom.
ï¿¿hal-
03517826v4ï¿¿

ï¿¿10.1145/3583780.3614756ï¿¿.

HAL Id: hal-03517826

https://inria.hal.science/hal-03517826v4

Submitted on 9 Nov 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

Lâ€™archive ouverte pluridisciplinaire HAL, est
destinÃ©e au dÃ©pÃ´t et Ã  la diffusion de documents
scientifiques de niveau recherche, publiÃ©s ou non,
Ã©manant des Ã©tablissements dâ€™enseignement et de
recherche franÃ§ais ou Ã©trangers, des laboratoires
publics ou privÃ©s.

Distributed under a Creative Commons Attribution 4.0 International License

The ğœ‡-RA System for Recursive Path Queries over Graphs

Amela Fejza
Tyrex team, Univ. Grenoble Alpes, CNRS, Inria, Grenoble
INP, LIG
Grenoble, France
amela.fejza@inria.fr

Pierre GenevÃ¨s
Tyrex team, Univ. Grenoble Alpes, CNRS, Inria, Grenoble
INP, LIG
Grenoble, France
pierre.geneves@inria.fr

Nabil LayaÃ¯da
Tyrex team, Univ. Grenoble Alpes, CNRS, Inria, Grenoble
INP, LIG
Grenoble, France
nabil.layaida@inria.fr

Sarah Chlyah
Tyrex team, Univ. Grenoble Alpes, CNRS, Inria, Grenoble
INP, LIG
Grenoble, France
sarah.chlyah@inria.fr

ABSTRACT
We demonstrate a system for recursive query answering over graphs.
The system is based on a complete implementation of the recur-
sive relational algebra ğœ‡-RA, extended with parsers and compilers
adapted for queries over knowledge and property graphs. Each
component of the system comes with novelty for processing recur-
sion. As a result, one can formulate, optimize and efficiently answer
expressive queries that navigate recursively along paths in different
types of graphs. We demonstrate the system on real datasets and
show how it performs considering other state-of-the-art systems.

CCS CONCEPTS
â€¢ Information systems â†’ Network data models; Graph-based
database models; Relational database query languages.

KEYWORDS
query languages; query optimization; path queries; recursive rela-
tional algebra; property graphs; graphs

ACM Reference Format:
Amela Fejza, Pierre GenevÃ¨s, Nabil LayaÃ¯da, and Sarah Chlyah. 2023. The
ğœ‡-RA System for Recursive Path Queries over Graphs. In Proceedings of the
32nd ACM International Conference on Information and Knowledge Manage-
ment (CIKM â€™23), October 21â€“25, 2023, Birmingham, United Kingdom. ACM,
New York, NY, USA, 5 pages. https://doi.org/10.1145/3583780.3614756

1 INTRODUCTION
Graph data structures have become increasingly popular in var-
ious applications such as social networks, knowledge extraction,
transportation networks, etc.

Recent developments have shown a significant interest in equip-
ping query languages with recursive query constructs such as regu-
lar path queries (RPQs) and their combinations. They enable queries

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
CIKM â€™23, October 21â€“25, 2023, Birmingham, United Kingdom.
Â© 2023 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0124-5/23/10. . . $15.00
https://doi.org/10.1145/3583780.3614756

to exploit the linked nature of graph data by allowing for naviga-
tions along deep paths in the graph. The optimization of recursive
queries is notoriously known as a difficult problem. Recently, ğœ‡-RA
[12] introduced a clean generalization of Coddâ€™s relational algebra
for the optimization of recursive queries, enabling in particular
richer query evaluation plan spaces than with earlier approaches.
We demonstrate a system for recursive query answering over
graph datasets. The system includes a complete implementation of
the theory of the recursive relational algebra and concepts intro-
duced in [4, 5, 7, 8, 12, 14]. The system also includes parsers and
compilers so that one can formulate, optimize and answer queries
that navigate recursively in knowledge and property graphs. We
explain the main components of the ğœ‡-RA system (parser, optimizer
and translator) and then the backend evaluator to evaluate the best
estimated plan in a centralized or distributed way [4, 5].

One major novelty and advantage of this system resides in being
a layer on top of an unmodified backend like PostgreSQL. In other
terms, the optimization layer can be easily plugged or unplugged
on top of existing relational backends, not requiring any modifi-
cation of PostgreSQL for example. Yet, the overall system offers
comparable or even superior performance with respect to recent
graph-specific engines (such as MilleniumDB [20]) for recursive
query answering over practical graphs such as Yago [10, 18].

The purpose of this demonstration is to present the system in
an interactive manner, showing: (i) a discovery and practical tour
of the different components and functionalities of the system using
concrete queries over real practical graphs; (ii) demonstrating that
the system also supports expressive path patterns (regular and not
regular) not supported by other systems, yet useful in formulating
meaningul queries on real datasets. In particular, one purpose of this
demonstration is to disprove a wrong statement made in a recent
paper [15] about the expressivity of the approach; and (iii) showing
that the system provides comparable or superior performance when
compared to some state-of-the-art systems for answering queries
with recursive path patterns on real datasets.

2 PRELIMINARY BACKGROUND
The recursive relational algebra (ğœ‡-RA) [12] is an extension of
Coddâ€™s relational algebra with a fixpoint operator so as to cap-
ture and to optimize recursive queries. A term ğœ‘ in ğœ‡-RA can be a
relation ğ‘‹ denoting a classical relational table, a constant |ğ‘ â†’ ğ‘£ |

CIKM â€™23, October 21â€“25, 2023, Birmingham, United Kingdom.

Amela Fejza, Pierre GenevÃ¨s, Nabil LayaÃ¯da, and Sarah Chlyah

that assigns a value to a column name, a filter ğœğ‘“ (ğœ‘) that keeps only
the tuples in ğœ‘ that satisfy a condition ğ‘“ , an antiprojection (cid:101)
ğœ‹ğ‘ (ğœ‘)
which removes the column named ğ‘ from the term ğœ‘, a renaming
operator ğœŒğ‘
ğ‘ (ğœ‘) that renames column ğ‘ into ğ‘ in the term ğœ‘, a binary
operator such as natural join (ğœ‘1 âŠ²âŠ³ ğœ‘2), antijoin, and union (ğœ‘1 âˆªğœ‘2).
Besides those rather classical operators, one of the main features
of ğœ‡-RA is that a term can also be a fixpoint operator of the form
ğœ‡ğ‘‹ . ğœ‘. This notation binds a relation ğ‘‹ to the term ğœ‘ in which ğ‘‹
appears, hence it is an explicit way to write a recursive term in an
algebraic manner.

For example, the term ğœ‡ğ‘‹ .ğ‘… âˆª (ğ· âŠ²âŠ³ ğ‘‹ ) denotes a relation ob-
tained by repeatedly joining the initial relation ğ‘… with a relation ğ·
until no new tuples are retrieved. The transitive closure relation ğ‘…+
is the particular case where ğ· = ğ‘…. The general fixpoint notation
makes it possible to express not only transitive closures but also
a variety of more expressive forms of recursion. The theory also
comes with a set of algebraic rewrite rules specifically designed to
transform fixpoint terms into semantically equivalent (yet more
efficient) variants, generalizing the initial idea of Codd to recursive
queries. In particular, transformations include algebraic rewritings
where filters, antiprojections and joins are â€œpushed throughâ€ fix-
point terms (modulo some conditions are satisfied), yielding other
fixpoint terms whose evaluation can be way more efficient than the
initial ones. Some fixpoint terms can also be merged into a single
fixpoint term, replacing two recursions by a single one.

Such transformation rules, together with the necessary mech-
anisms to check the conditions under which they are valid, are
detailed in [12]. This basically opens the way to much more ef-
ficient query evaluation plans for recursive queries, that are out
of reach of earlier approaches, especially those based on Datalog
[3, 16, 17, 19]. This is because in a Datalog optimizer there is no
equivalent to merging fixpoints, therefore currently in a Datalog
program corresponding to the optimized translation of ğ‘+/ğ‘+ at
least one of the two transitive closures ğ‘+ or ğ‘+ will be fully mate-
rialized (even if there is no solution to ğ‘+/ğ‘+).

In ğœ‡-RA, this query can be evaluated by a single recursion that
starts from ğ‘/ğ‘ and recursively appends ğ‘ on the left or ğ‘ on the
right. Since the size of such transitive closures may be an order of
magnitude larger than the graph size, performance gains can be
significant on real datasets.

3 SYSTEM ARCHITECTURE
The system is coded in Scala (39K lines of code). The overall system
architecture is illustrated in Figure 1. It is composed of several
components:

An interface. which is an interactive notebook that uses Al-
mond [2], a modern Scala shell that provides features in Jupyter
notebooks. The interface exposes an API to interact with the dif-
ferent ğœ‡-RA system components and displays information about
the different stages of the query optimization process. The user
provides a graph query with recursive path patterns. The inter-
face also displays query answers and information and statistics on
the evaluation process (query evaluation time, number of results,
selected evaluation plan etc.)

Figure 1: Architecture of the system.

A parser of high-level query languages. that parses the input
query and translates it into a ğœ‡-RA term that operates on a relational
representation of the queried graph. Specifically, ğœ‡-RA adopts a
relational representation of graphs where each edge is represented
as a relation. Property graph representations have extra relations
for representing node properties. The parser is the only component
that is dependent on the chosen graph relational representation.
ğœ‡-RA supports the relational data model on which RA is based.

An optimizer. that has two sub-components. The first one is a
plan enumerator that applies all the algebraic rewrite rules of clas-
sical relational algebra together with the rewrite rules concerning
fixpoint terms presented in [12], in a fully compositional way. By
composition, all these rules enable new query evaluation plans (in
particular merged fixpoints, and their further transformations) that
were not possible with earlier approaches. Overall, this results in
a richer query evaluation plan space. For enumerating the plan
space, there are two possibilities: (i) a bottom-up enumerator where
the application of rewrite rules is applied to one term at a time;
(ii) a top-down plan enumerator [7, 8] where the plan space is
explored by transforming sets of terms at once. The second sub-
component is a cost estimator that picks an estimated most efficient
term, based on cost estimations for the algebraic operators and
cardinality statistics of the datasets. This cost estimation technique
is inspired from [13, 14]. The optimizer component can be plugged
or unplugged. It makes it easy to measure the performance gains
brought by the logical optimizations.

A translator. that translates the estimated best term into SQL
using Recursive Common Table Expression (CTE) or PL/pgSQL with
WHILE loops for more general forms of recursion not expressible
with CTEs. This is for instance the case of merged fixpoint terms
for the PostgreSQL backend. The distributed evaluator component
uses in one of its distributed evaluation plans the SQL translator to
compute the fixpoint on PostgreSQL evaluators present on parallel
workers [4].

The ğœ‡-RA System for Recursive Path Queries over Graphs

CIKM â€™23, October 21â€“25, 2023, Birmingham, United Kingdom.

A backend evaluator. which provides two possibilities: (i) a re-
lational database managment system in charge of evaluating the
translation of the best estimated plan. For this demonstration, the
relational backend used is PostgreSQL. (ii) a distributed evaluator
that distributes the evaluation of ğœ‡-RA terms on Spark [4, 5]. After
evaluation, query answers and information about the evaluation
are presented in the user interface.
The fact that the optimizer is a separate component that sits on
top of unmodified backends offers several advantages. In particular,
performance gains do not rely on low level system optimizations
of platforms that are subject to change, but rather on logical op-
timizations (of recursive path queries) that can be applied on any
platform capable of evaluating ğœ‡-RA terms.

4 DEMONSTRATION
In this demonstration we give a complete overview and practical
tour of the centralized part of the system that uses PostgreSQL as a
backend 1. This demonstration is performed with the ğœ‡-RA inter-
active interface. We propose three scenarios focusing respectively
on the process that a user query goes through in the ğœ‡-RA system
before being executed; expressivity; and performance comparisons.

4.1 Regular Path Query scenario
We start by showing an example of an UCRPQ (Unions of Con-
junctions of Regular Path Queries) query of the form (ğ‘+/ğ‘+) over
the Yago dataset. We use a preprocessed version of the real world
Yago2s [10, 18] dataset. This dataset version contains 83 predicates
and 62,643,951 rows (graph edges). They correspond to general
knowledge about people, cities, countries, etc. This example is
shown in Figure 2. The user writes the query, sets a time budget for
the plan space enumeration, and then calls the optimizer with these
inputs. The call to the optimize procedure successively invokes
the following components: the parser, the plan enumerator, and the
cost estimator (see Sec. 3). The user can then retrieve information
such as the total number of explored plans and the chosen plan.
The interface provides the user with a feature that automatically
generates visual representations of plans. In this representation,
squares represent the equivalence nodes and circles represent oper-
ation nodes. The purpose of equivalence nodes is to regroup plans
that are semantically equivalent. Each operator node is an algebraic
operator that can be unary (e.g. filter) or binary (e.g. join).

Once a plan is chosen, it is translated to SQL before execution on
PostgreSQL. Figure 4 and Figure 5 show two possible translations
for the initial query considered in Figure 2. Plan 2 translation in Fig-
ure 5 corresponds to the translation of the chosen plan graphically
displayed in Figure 3. In this plan, ğ‘/ğ‘ is computed first and each
iteration in the PL/pgSQL WHILE loop adds to the result set all
paths obtained by appending ğ‘ to the left of the previously known
paths as well as all paths obtained by appending ğ‘ to the the right of
those previous paths. In Figure 4, Plan 1 translation shows the SQL
translation of a different plan for the same query which has two fix-
point terms (not merged). In this case, each recursion is translated
into a Recursive Common Table Expression (CTE) individually and
a+ and b+ are respectively first calculated fully and then joined

1We provide an accompanying video [6].

Figure 2: An example in the interactive notebook.

Figure 3: A plan graphically displayed in the notebook.

together. During the live demonstration, this translation in particu-
lar will be explained in more details. The user can also display the
different evaluation times of the chosen plans in the interface. An
excerpt of the retrieved query answers is shown in Figure 2.

4.2 Expressivity scenario
In the second scenario, we focus on the expressive power of queries
supported by the system. This scenario focuses on two key aspects:
(i) An erroneous statement of [15] states that ğœ‡-RA cannot ex-
press (ğ‘ğ‘ğ‘ (ğ‘‘ğ‘ğ‘)âˆ—)+. This statement is wrong because the query
corresponds to a regular path query, hence trivially supported in
ğœ‡-RA. For example, ğ‘ğ‘âˆ— stands for ğ‘|ğ‘ğ‘+. Hence, (ğ‘ğ‘ğ‘ (ğ‘‘ğ‘ğ‘)âˆ—)+ can
be simply expressed as (ğ‘ğ‘ğ‘ |ğ‘ğ‘ğ‘ (ğ‘‘ğ‘ğ‘)+)+. We further explain using
a concrete example why the statement is not true by writing and
evaluating a query of this form over the Yago dataset. We use the
query :

CIKM â€™23, October 21â€“25, 2023, Birmingham, United Kingdom.

Amela Fejza, Pierre GenevÃ¨s, Nabil LayaÃ¯da, and Sarah Chlyah

Figure 4: SQL translation of the first plan for query Q.

Figure 5: SQL translation of the second plan for query Q.

Q=((haschild/islocatedin/dealswith/(ismarriedto/islocatedin/dealswith)+)

|

(haschild/islocatedin/dealswith))+.

We also describe how this query is optimized in the ğœ‡-RA system.
The optimized term is sent to PostgreSQL and evaluted in 0.6 sec-
onds on a commodity laptop. Note that the query given in [15] and
query Q cannot be expressed in Cypher 9 language [11].

(ii) ğœ‡-RA supports some queries with particular non-regular

forms of recursion2, currently not supported in [15].

An example of a supported non-regular query pattern is ğ‘ğ‘›ğ‘ğ‘›,
that returns the pairs of nodes connected by a path composed of a
number of edges labeled ğ‘ followed by the same number of edges
labeled ğ‘. We can express a query of this form on wikitree [9], a
well-known genealogy dataset. We propose a query that retrieves
pairs of people that are of the same generation (which is a special
case of ğ‘ğ‘›ğ‘ğ‘›).

This query can be written in ğœ‡-RA [12] syntax as follows:
(cid:0)ğœŒm
src (ğ‘…) âŠ²âŠ³ ğœŒ m
ğœğ‘ğ‘Ÿğ‘’ğ‘‘=parent (ğœ‡ (ğ‘‹ .
(cid:0)ğœŒm

src (ğ‘‹ ) âŠ²âŠ³ ğœŒn
Figure 6 shows the plan space explored when this query is pro-

ğœ‹ğ‘š ( (cid:101)
src (ğ‘…)(cid:1) ) ) ) )

ğœ‹ğ‘š (ğœŒm
(cid:101)
âŠ²âŠ³ ğœŒn
trg

src (ğ‘…) ) âˆª (cid:101)

src (ğ‘…)(cid:1)

ğœ‹ğ‘› (ğœŒ src
trg

cessed by the plan enumerator of the ğœ‡-RA system.

4.3 Performance comparison scenario
In this scenario, we focus on the performance gains brought in
practice. For this purpose, we consider a recent state-of-the-art
system: MilleniumDB [20]. We assess the two systems on a common
set of third-party queries over the public Yago dataset. Furthermore,

2going beyond the expressive power of regular patterns and UCRPQs in particular.

Figure 6: Some explored plans for the non-regular subquery

Figure 7: Comparison with state-of-the-art systems.

to evaluate the impact of the ğœ‡-RA optimizer, we also disable it and
compare with the evaluation times obtained with a plain-vanilla
PostgreSQL that receives a (non-optimized) translation of the initial
query (see the black and red arrows in Figure 1).

We evaluate 7 queries (Q1-Q7) taken from [1] and 2 queries (Q8-
Q9) taken from [21], on ğœ‡-RA, MilleniumDB (MDB) and PostgreSQL.
Results are shown in Figure 7. ğœ‡-RA outperforms clearly the other
two systems. On Q9, PostgreSQL does not even respond. During
the demo, attendees will also be able to propose their own queries
to experiment with.

Q1Q2Q3Q4Q5Q6Q7Q8Q9Queries0500010000150002000025000300003500040000Evaluation time (ms)MDBÂµâˆ’RAPostgreSQLThe ğœ‡-RA System for Recursive Path Queries over Graphs

CIKM â€™23, October 21â€“25, 2023, Birmingham, United Kingdom.

REFERENCES
[1] Zahid Abul-Basher, Nikolay Yakovets, Parke Godfrey, Shadi Ghajar-Khosravi, and
Mark H Chignell. 2017. Tasweet: optimizing disjunctive regular path queries in
graph databases. In EDBT/ICDT 2017 joint conference 20th international conference
on extending database technology. https://doi. org/10.5441/002/edbt.
[2] Almond. 2023. Almond : A Scala kernel for Jupyter. https://almond.sh/.
[3] Molham Aref, Balder ten Cate, Todd J. Green, Benny Kimelfeld, Dan Olteanu,
Emir Pasalic, Todd L. Veldhuizen, and Geoffrey Washburn. 2015. Design and
Implementation of the LogicBlox System. In Proceedings of the 2015 ACM SIGMOD
International Conference on Management of Data (Melbourne, Victoria, Australia)
(SIGMOD â€™15). ACM, New York, NY, USA, 1371â€“1382. https://doi.org/10.1145/
2723372.2742796

[4] Sarah Chlyah. 2022. On Algebraic Foundations for the Optimization of Itera-
tive Programming with Distributed Data Collections. (Fondements algÃ©briques
pour lâ€™optimisation de la programmation itÃ©rative avec des collections de donnÃ©es
distribuÃ©es). Ph. D. Dissertation. Grenoble Alpes University, France.
https:
//tel.archives-ouvertes.fr/tel-03783672

[5] Sarah Chlyah, Pierre GenevÃ¨s, and Nabil LayaÃ¯da. 2021. Distributed Evaluation
of Graph Queries using Recursive Relational Algebra. arXiv:2111.12487 [cs.DB]
[6] Amela Fejza. 2023. Accompanying video for the paper â€œThe ğœ‡-RA System for

Recursive Path Queries Over Graphsâ€. https://shorturl.at/AXZ23

[7] Amela Fejza. 2023. On the Optimization of Recursive Plan Enumeration with
an Application to Property Graph Queries. (Sur lâ€™optimisation de lâ€™Ã©numÃ©ration
de plans rÃ©cursifs avec une application aux requÃªtes de graphes de propriÃ©tÃ©s).
Ph. D. Dissertation. Grenoble Alpes University, France. https://tel.archives-
ouvertes.fr/tel-04128256

[8] Amela Fejza, Pierre GenevÃ¨s, and Nabil LayaÃ¯da. 2023. Efficient Enumeration of
Recursive Plans in Transformation-based Query Optimizers. (Jan. 2023). https:
//hal.inria.fr/hal-03692274 preprint.

[9] Michael Fire and Yuval Elovici. 2015. Data mining of online genealogy datasets for
revealing lifespan patterns in human population. ACM Transactions on Intelligent
Systems and Technology (TIST) 6, 2 (2015), 28.

[10] Max Planck Institute for Informatics and Telecom ParisTech University. 2019.
YAGO: A high-quality knowledge base. https://www.mpi-inf.mpg.de/yago-naga/
yago/.

[11] Nadime Francis, Alastair Green, Paolo Guagliardo, Leonid Libkin, Tobias Lin-
daaker, Victor Marsault, Stefan Plantikow, Mats Rydberg, Petra Selmer, and
AndrÃ©s Taylor. 2018. Cypher: An Evolving Query Language for Property

Graphs. In Proceedings of the 2018 International Conference on Management
of Data (Houston, TX, USA) (SIGMOD â€™18). New York, NY, USA, 1433â€“1445.
https://doi.org/10.1145/3183713.3190657

[12] Louis Jachiet, Pierre GenevÃ¨s, Nils Gesbert, and Nabil LayaÃ¯da. 2020. On the
Optimization of Recursive Relational Queries: Application to Graph Queries. In
Proceedings of the ACM SIGMOD International Conference on Management of Data.
681â€“697. https://doi.org/10.1145/3318464.3380567

[13] Muideen Lawal. 2021. On Cost Estimation for the Recursive Relational Algebra. (Sur
lâ€™estimation des coÃ»ts pour lâ€™algÃ¨bre relationnelle rÃ©cursive). Ph. D. Dissertation.
Grenoble Alpes University, France. https://tel.archives-ouvertes.fr/tel-03322720
[14] Muideen Lawal, Pierre GenevÃ¨s, and Nabil LayaÃ¯da. 2020. A Cost Estimation
Technique for Recursive Relational Algebra. In CIKM 2020 - 29th ACM Inter-
national Conference on Information and Knowledge Management. Virtual Event,
France, 1â€“4. https://doi.org/10.1145/3340531.3417460

[15] Wilco v. Leeuwen, Thomas Mulder, Bram van de Wall, George Fletcher, and
Nikolay Yakovets. 2022. AvantGraph Query Processing Engine. Proc. VLDB
Endow. 15, 12 (aug 2022), 3698â€“3701. https://doi.org/10.14778/3554821.3554878
[16] Nicola Leone, Gerald Pfeifer, Wolfgang Faber, Thomas Eiter, Georg Gottlob,
Simona Perri, and Francesco Scarcello. 2006. The DLV System for Knowledge
Representation and Reasoning. ACM Trans. Comput. Logic 7, 3 (July 2006), 499â€“
562. https://doi.org/10.1145/1149114.1149117

[17] John D. Ramsdell. 2004. Datalog version 2.2, a lightweight deductive database
http://www.ccs.neu.edu/home/ramsdell/tools/datalog/datalog.html

system.
(retrieved in october 2019).

[18] Fabian M. Suchanek, Gjergji Kasneci, and Gerhard Weikum. 2007. Yago: A Core
of Semantic Knowledge. In Proceedings of the 16th International Conference on
World Wide Web (Banff, Alberta, Canada) (WWW â€™07). ACM, New York, NY, USA,
697â€“706. https://doi.org/10.1145/1242572.1242667

[19] Jacopo Urbani, Ceriel J. H. Jacobs, and Markus KrÃ¶tzsch. 2016. VLog: A Column-
Oriented Datalog System for Large Knowledge Graphs. In Proceedings of the
ISWC 2016 Posters & Demonstrations Track co-located with 15th International
Semantic Web Conference (ISWC 2016), Kobe, Japan, October 19, 2016. http://ceur-
ws.org/Vol-1690/paper113.pdf

[20] Domagoj Vrgoc, Carlos Rojas, Renzo Angles, Marcelo Arenas, Diego Arroyuelo,
Carlos Buil Aranda, Aidan Hogan, Gonzalo Navarro, Cristian Riveros, and Juan
Romero. 2021. MillenniumDB: a persistent, open-source, graph database. arXiv
preprint arXiv:2111.01540 (2021).

[21] Nikolay Yakovets, Parke Godfrey, and Jarek Gryz. 2015. WAVEGUIDE: Evaluating

SPARQL Property Path Queries.. In EDBT, Vol. 2015. 525â€“528.

