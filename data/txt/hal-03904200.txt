Private Sampling with Identifiable Cheaters
CÃ©sar Sabater, Florian Hahn, Andreas Peter, Jan Ramon

To cite this version:

CÃ©sar Sabater, Florian Hahn, Andreas Peter, Jan Ramon. Private Sampling with Identifiable Cheaters.
Proceedings on Privacy Enhancing Technologies, In press, 2023 (2). ï¿¿hal-03904200ï¿¿

HAL Id: hal-03904200

https://inria.hal.science/hal-03904200

Submitted on 16 Dec 2022

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

Lâ€™archive ouverte pluridisciplinaire HAL, est
destinÃ©e au dÃ©pÃ´t et Ã  la diffusion de documents
scientifiques de niveau recherche, publiÃ©s ou non,
Ã©manant des Ã©tablissements dâ€™enseignement et de
recherche franÃ§ais ou Ã©trangers, des laboratoires
publics ou privÃ©s.

Private Sampling with Identifiable Cheaters

CÃ©sar Sabater
INRIA Lille
Villeneuve dâ€™Ascq, France
cesar.sabater@inria.fr

Andreas Peter
University of Oldenburg
Oldenburg, Germany
andreas.peter@uni-oldenburg.de

Florian Hahn
University of Twente
Enschede, Netherlands
f.w.hahn@utwente.nl

Jan Ramon
INRIA Lille
Villeneuve dâ€™Ascq, France
jan.ramon@inria.fr

ABSTRACT
In this paper we study verifiable sampling from probability distri-
butions in the context of multi-party computation. This has various
applications in randomized algorithms performed collaboratively
by parties not trusting each other. One example is differentially
private machine learning where noise should be drawn, typically
from a Laplace or Gaussian distribution, and it is desirable that no
party can bias this process. In particular, we propose algorithms to
draw random numbers from uniform, Laplace, Gaussian and arbi-
trary probability distributions, and to verify honest execution of the
protocols through zero-knowledge proofs. We propose protocols
that result in one party knowing the drawn number and protocols
that deliver the drawn random number as a shared secret.

KEYWORDS
differential privacy, sampling, zero knowledge proofs, multiparty
computation

1 INTRODUCTION
Nowadays, randomization is an important algorithmic technique.
Its numerous applications include randomized algorithms, e.g., for
many problems the simplest or most efficient known solution strat-
egy is a randomized algorithm, and hiding information, e.g., in
cryptography or in differential privacy. While true randomness is
hard to achieve in most cases it is sufficient to be able to gener-
ate pseudo-random numbers. A wide range of approaches exist to
generate pseudo-random numbers of good quality.

The situation becomes more complicated when we consider gen-
erating random numbers in the context of multi-party computation
between parties which do not trust each other. We are particularly
interested in algorithms which allow multiple parties to draw a
random number from a specified probability distribution in such
a way that all parties can be convinced that the number drawn is
truly random and that either all parties, only one party, or none of
the parties learn the drawn random number. This implies that no
party should be able to influence the probability distribution or be
able to predict or guess the random number.

This work is licensed under the Creative Commons Attribu-
tion 4.0 International License. To view a copy of this license
visit https://creativecommons.org/licenses/by/4.0/ or send a
letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
Proceedings on Privacy Enhancing Technologies YYYY(X), 1â€“23
Â© YYYY Copyright held by the owner/author(s).
https://doi.org/XXXXXXX.XXXXXXX

1

Such algorithms are particularly useful for differentially private
federated machine learning using sensitive data from multiple data
owners. In this setting, one would like to learn a statistical model
M with parameters ğœƒ on the sensitive data of multiple data owners.
Such model could reveal sensitive information and therefore one
possible technique is to perturb the model before publication suf-
ficiently such that it becomes differentially private [27], i.e., such
Ë†M with parameters Ë†ğœƒ one cannot
that from the perturbed model
distinguish a change in a single individual. This can be achieved by
drawing some noise ğœ‚ from an appropriate probability distribution,
e.g., ğœ‚ often is a vector of Laplace or Gaussian random variables,
and setting Ë†ğœƒ = ğœƒ +ğœ‚. In such scenario it is important nobody knows
ğœ‚ as else that party could subtract ğœ‚ from the published Ë†ğœƒ to obtain
the sensitive model parameters ğœƒ . At the same time, all data owners
want to be sure that ğœ‚ is drawn correctly: if anyone can bias the
distribution of this noise, privacy may not be guaranteed anymore
or the model parameters may be biased in a way similar as what
one can achieve with data poisoning [49, 53].

In this paper we develop algorithms to verifiably draw random
numbers. We consider uniform distributions, Laplace distributions,
Gaussian distributions and arbitrary distributions. We develop
strategies with three different privacy levels for the random num-
ber: strategies which verifiably draw a publicly known random
number, strategies which verifiably draw a random number which
is revealed to only one party and strategies which verifiably draw
a random number and output it as a shared secret so that none of
the parties knows the random number.

An important tool to prove correct behavior can be found in
zero knowledge proofs (ZKP). These are cryptographic techniques
that allow a party to prove statements without revealing anything
else. Typically, one considers statements involving logical and arith-
metic relations over private values which can be expressed using
additions, multiplications and other elementary operations such as
comparisons. For drawing from Laplace or Gaussian distributions,
transcendental functions are needed. We work towards bridging
this gap based on Cordic [52], a classic technique for computing
such functions.

The main contributions of this paper can be summarized as
follows: (1) we propose strategies to prove relationships involving
logarithms or trigonometric functions in zero knowledge, (2) we
propose and compare several strategies to let a party verifiably
draw Gaussian random numbers, (3) we propose algorithms to let
one party verifiably sample from the Laplace distribution and from
an arbitrary distribution, (4) we propose algorithms to draw from

Proceedings on Privacy Enhancing Technologies YYYY(X)

CÃ©sar Sabater, Florian Hahn, Andreas Peter, and Jan Ramon

the Gaussian or Laplace distribution a random number represented
as a shared secret.

The remainder of this paper is structured as follows:
After reviewing some common notations and concepts in Sec-
tion 2, we formalize our problem statement in Section 3. Next, in
Section 4 we discuss related work and in Section 5 we provide a
high-level overview of our method. After that, in Section 6 we re-
view the Cordic algorithm and adapt it for zero-knowledge proofs.
In Sections 7 and 8 we apply these techniques for sampling from
the Laplace and Gaussian distributions. To show how our methods
work in practice, in Section 9 we provide an experimental compari-
son of the several possible strategies to sample from the Gaussian
distribution. In Section 10 we discuss the application of our tech-
niques to the problem of differentially private machine learning.
Finally, in Section 11 we conclude and outline directions of future
work.

2 PRELIMINARIES
We will denote the set of the first ğ‘˜ positive integers by [ğ‘˜] = {ğ‘– âˆˆ
N | 1 â‰¤ ğ‘– â‰¤ ğ‘˜ }. We denote the security parameter by ğœ†. We say that
a function is negligible in ğœ† if, for each positive polynomial ğ‘“ , it is
smaller than 1
for sufficiently big ğœ†. We omit ğœ† sometimes in
ğ‘“ (ğœ†)
negligible functions when it is clear it refers to ğœ†. ğ‘ â†ğ‘… ğ‘† means
that ğ‘ is sampled uniformly at random from elements of ğ‘†. For
vectors a = (ğ‘1, . . . , ğ‘ğ‘˜ ) and b = (ğ‘1, . . . , ğ‘ğ‘˜ ), a + b and a âˆ— b are the
element wise addition and product. ab is the multi-exponentiation
(cid:206)ğ‘˜
. For a scalar ğ‘ , ğ‘  + a = (ğ‘ , . . . , ğ‘ ) + a, ğ‘  âˆ— a = (ğ‘ , . . . , ğ‘ ) âˆ— a
and ağ‘  = a(ğ‘ ,...,ğ‘ ) . The function sign(ğ‘¥) is equal to 1 if ğ‘¥ â‰¥ 0 and to
âˆ’1 otherwise.

ğ‘–=1 ğ‘ğ‘ğ‘–

ğ‘–

2.1 Setting and Threat Model
We consider a set of ğ‘› parties P = {ğ‘ƒ1, . . . , ğ‘ƒğ‘› }. We assume parties
have access to a public-key infrastructure which they can use to
prove their identity when sending messages. Parties communicate
through secure channels and have access to a public bulletin board
that they can use to post messages. When a party sends a message
to the bulletin board, it is forwarded to all other agents as when
using a broadcast channel. In addition, all broadcasted messages
remain publicly visible in the bulletin board, which allows to have
publicly verifiable protocols.

We assume that a subset of parties Pğ‘ğ‘œğ‘Ÿ âŠ‚ P is corrupted and
controlled by an adversary A. A can make corrupted parties to
deviate arbitrarily from the protocol and perform coordinated at-
tacks. Our protocols are secure if at least one party is honest. The
set Pğ‘ğ‘œğ‘Ÿ of corrupted parties is assumed to be static, meaning that
it does not change after the beginning of the execution.

We prove security in the simulation paradigm, using the model
of security with identifiable abort [33] for the stand-alone setting
[29]. This setting allows to obtain sequentially composable proto-
cols in which parties are able to detect malicious actions and can
in such cases abort the protocol. Deterrence measures may be in
place to discourage parties from being detected as malicious. In
fact, unless parties stop participating our protocols either complete
successfully or abort with a proof that a specific party is a cheater,
i.e., in case our protocols abort the message trace (which is kept on
the bulletin board) allows for proving that a specific party did not

follow the protocol. Assuming that adversaries will be deterred if
they risk getting caught is a standard assumption that applies in
many scenarios [3].

In parts of our protocols, we make use of specific Zero Knowledge
Proofs that are non-interactive versions of compressed Î£-protocols
whose security relies on the Random Oracle Model [6]. We provide
a detailed description of our security framework and prove the
security of our protocols in Appendix B.

2.2 Commitment Schemes
A commitment scheme allows for committing to values while keep-
ing them hidden. We use the vector variant of the Pedersen commit-
ment scheme [47]. Let G be a cyclic multiplicative group of prime
order ğ‘ exponential in ğœ† in which the Discrete Logarithm Assump-
tion (DLA) holds. The setup of the commitment scheme takes as
input a string of length ğ‘‚ (1ğœ†) and outputs a vector g = (ğ‘”1, . . . , ğ‘”ğ‘˜ )
of elements sampled at random from G \ {1}. It is required that no
pairwise discrete logarithm on the elements ğ‘”1, . . . , ğ‘”ğ‘˜ is known,
which can be guaranteed without a trusted party as the setup only
requires public randomness. A commitment ğ‘ƒ âˆˆ G of a vector
x = (ğ‘¥1, . . . , ğ‘¥ğ‘˜ ) âˆˆ Zğ‘˜
ğ‘ satisfies ğ‘ƒ = gx. We say that x is an open-
ing of ğ‘ƒ. The scheme is binding as no computationally bounded
adversary can find two openings x and xâ€² of ğ‘ƒ such that x â‰  xâ€²
except with probability negligible in ğœ†. If x = ( Ë†x, ğ‘Ÿ ), where Ë†x is the
data and ğ‘Ÿ is sampled uniformly at random from Zğ‘ , ğ‘ƒ is uniformly
distributed in G and therefore does not reveal any information
about Ë†x. This is known as the hiding property. In our protocols, one
coordinate of g is always reserved for randomness. The scheme
is also homomorphic as, given commitments ğ‘ƒ and ğ‘„ of x and y
respectively, ğ‘ƒğ‘„ is a commitment of x + y.

2.3 Arithmetic Circuits
An arithmetic circuit (or just circuit) ğ¶ : Zğ‘˜
ğ‘ is a function
that only contains additions and multiplications modulo ğ‘. In the
following sections we will define circuits using the notation

ğ‘ â†’ Zğ‘ 

ğ¶ (ğ‘; ğ‘–1, . . . , ğ‘–ğ‘˜ ) (cid:66)

,

ğ‘œ1
ï£®
ï£¯
...
ï£¯
ï£¯
ï£¯
ğ‘œğ‘ 
ï£¯
ï£°

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£º
ï£»

where (ğ‘–1, . . . , ğ‘–ğ‘˜ ) is the input, (ğ‘œ1, . . . , ğ‘œğ‘  ) is the output, and ğ‘ are
constants that may change the circuit structure, for example, in the
case we are defining a family of similar circuits.

2.4 Compressed Î£-Protocols
We will prove statements about private committed values using
Zero Knowledge Proofs [31]. In such proofs, for a NP relation R, a
prover P interacts with a verifier V to prove, for a public statement
ğ‘, the knowledge of a private witness ğ‘¤ such that (ğ‘; ğ‘¤) âˆˆ R. At the
end of the interaction, V either accepts or rejects the proof. ZKPs
are (1) complete, as V always accepts a proof of an honest P, (2)
sound, as a proof of a dishonest P is rejected except with negligible
probability and (3) zero knowledge, as no information other than
(ğ‘; ğ‘¤) âˆˆ R is revealed by the protocol. The ZKPs that we use are
also called zero knowledge arguments, as they are sound if P is
computationally bounded. Additionally, they rely on the DLA.

2

Private Sampling with Identifiable Cheaters

Proceedings on Privacy Enhancing Technologies YYYY(X)

The ZKPs we use are called compressed Î£-protocols [2]. Partic-
ularly, we use Protocol Î ğ‘ğ‘  of [2], that proves the nullity of the
output of arithmetic circuits in Zğ‘ applied to private inputs. Let
G, Zğ‘ , and g be as defined for commitments, then for any circuit
ğ¶ : Zğ‘˜
ğ‘ , by applying Î ğ‘ğ‘  to ğ¶ we obtain a complete, sound
and zero knowledge proof for the relation

ğ‘ â†’ Zğ‘ 

{(ğ‘ƒ âˆˆ G; x âˆˆ Zğ‘˜

ğ‘ ) : ğ‘ƒ is a commitment of x âˆ§ ğ¶ (x) = 0)}.

While Î ğ‘ğ‘  is an interactive protocol between P and V, it can be
turned into a non-interactive proof using the Strong Fiat-Shamir
heuristic [8]. By this transformation, ZKPs can be generated offline
by P and later be verified by any party.

Let ğ‘š be the number of multiplication gates of ğ¶, then the proof
generated by the execution of Î ğ‘ğ‘  has a size of 2âŒˆlog(ğ‘˜ +2ğ‘š +4)âŒ‰ âˆ’1
elements of G and 6 elements of Zğ‘ . To generate such proof, the
dominant computations are modular exponentiations in G (GEX). P
performs 5ğ‘˜ + 8ğ‘š + 2âŒˆlog2 (ğ‘˜ + 2ğ‘š + 4)âŒ‰ + 6 GEX, and the verification
cost is of ğ‘˜ + 2ğ‘š + 2âŒˆlog2 (ğ‘˜ + 2ğ‘š + 4)âŒ‰ âˆ’ 1 GEX.

We provide a detailed explanation of compressed Î£-protocols,

their cost and some optimizations in Appendix A.

2.5 Secret Sharing
Consider again ğ‘› parties {ğ‘ƒğ‘– }ğ‘›
ğ‘–=1. For a positive prime ğ‘, group Zğ‘ ,
and a number ğ‘ âˆˆ Zğ‘ , one can generate an additive secret share
for ğ‘ by drawing a random vector (ğ‘1, . . . , ğ‘ğ‘›) âˆˆ Zğ‘›
ğ‘ subject to the
constraint that (cid:205)ğ‘›
ğ‘–=1 ğ‘ğ‘– = ğ‘ mod ğ‘. We then denote this sharing of ğ‘
as âŸ¦ğ‘âŸ§ = (ğ‘1 . . . ğ‘ğ‘›). The process of computing and revealing ğ‘ from
the sharing âŸ¦ğ‘âŸ§ is called opening the sharing âŸ¦ğ‘âŸ§. If every party
ğ‘ƒğ‘– only receives ğ‘ğ‘– (for ğ‘– âˆˆ [ğ‘›]), then if not all parties collude each
party can only see at most ğ‘› âˆ’ 1 uniformly randomly distributed
numbers, and hence has no information about the value of ğ‘.

If for one or more values a sharing is available, it is possible to
perform various operations on them without revealing any new in-
formation, see [24] for an overview. If âŸ¦ğ‘âŸ§ = (ğ‘1 . . . ğ‘ğ‘›) is a sharing
of ğ‘ and âŸ¦ğ‘âŸ§ is a sharing of ğ‘, then âŸ¦ğ‘ + ğ‘âŸ§ = (ğ‘1 + ğ‘1 . . . ğ‘ğ‘› + ğ‘ğ‘›)
is a sharing of ğ‘ + ğ‘. Given a sharing âŸ¦ğ‘âŸ§ of ğ‘ and a public con-
stant ğ‘, then âŸ¦ğ‘ğ‘âŸ§ = (ğ‘ğ‘1 . . . ğ‘ğ‘ğ‘›) is a sharing of ğ‘ğ‘. For multiply-
ing two sharings, one can use pre-computed triples of sharings
(âŸ¦ğ‘¥âŸ§, âŸ¦ğ‘¦âŸ§, âŸ¦ğ‘§âŸ§) with ğ‘¥ and ğ‘¦ random and ğ‘¥ğ‘¦ = ğ‘§. Given such
triple, and two sharings âŸ¦ğ‘âŸ§ and âŸ¦ğ‘âŸ§ which one wants to mul-
tiply, one can compute âŸ¦ğ‘‘âŸ§ = âŸ¦ğ‘âŸ§ âˆ’ âŸ¦ğ‘¥âŸ§ and âŸ¦ğ‘’âŸ§ = âŸ¦ğ‘âŸ§ âˆ’ âŸ¦ğ‘¦âŸ§
and open both âŸ¦ğ‘‘âŸ§ and âŸ¦ğ‘’âŸ§. Then, a sharing of ğ‘ = ğ‘ğ‘ is obtained
by âŸ¦ğ‘âŸ§ = âŸ¦ğ‘§âŸ§ + ğ‘‘âŸ¦ğ‘¦âŸ§ + ğ‘’âŸ¦ğ‘¥âŸ§ + ğ‘‘ğ‘’. Several approaches have been
proposed to generate such triples of sharings (âŸ¦ğ‘âŸ§, âŸ¦ğ‘âŸ§, âŸ¦ğ‘âŸ§) effi-
ciently, typically involving a somewhat homomorphic encryption
(SHE) scheme with distributed decryption, where the parties can
generate random sharings âŸ¦ğ‘âŸ§ and âŸ¦ğ‘âŸ§ uniformly at random, en-
crypt them, multiply them and decrypt the product in a distributed
way to obtain âŸ¦ğ‘âŸ§ [24].

Weâ€™ll adopt a number of ideas from [23]. In particular, we will
represent sharings in binary form, denoting by ğµğ¼ğ‘‡ ğ‘† (ğ‘¥, (ğ‘¥ (ğ‘–) )ğ‘™âˆ’1
ğ‘–=0 )
the relation âŸ¦ğ‘¥âŸ§ = (cid:205)ğ‘™âˆ’1
ğ‘–=0âŸ¦ğ‘¥ (ğ‘–) âŸ§2ğ‘– with ğ‘¥ (ğ‘–) âˆˆ {0, 1}. The protocol
ğ‘–=0 ) returns (âŸ¦ğ‘§ (ğ‘–) âŸ§)ğ‘™âˆ’1
Bit-add((âŸ¦ğ‘¥ (ğ‘–) âŸ§)ğ‘™âˆ’1
ğ‘–=0 such that
there holds ğ‘§ = ğ‘¥ +ğ‘¦ for ğµğ¼ğ‘‡ ğ‘† (ğ‘¥, (âŸ¦ğ‘¥ (ğ‘–) âŸ§)ğ‘™âˆ’1
ğ‘–=0 ), ğµğ¼ğ‘‡ ğ‘† (ğ‘¦, (âŸ¦ğ‘¦ (ğ‘–) âŸ§)ğ‘™âˆ’1
ğ‘–=0 )
ğ‘–=0 ). To implement it, let ğ‘ (âˆ’1) = 0. For ğ‘– =
and ğµğ¼ğ‘‡ ğ‘† (ğ‘§, (âŸ¦ğ‘§ (ğ‘–) âŸ§)ğ‘™âˆ’1

ğ‘–=0 ; (âŸ¦ğ‘¦ (ğ‘–) âŸ§)ğ‘™âˆ’1

3

0 . . . ğ‘™ âˆ’ 1:

âŸ¦ğ‘§ (ğ‘–) âŸ§ = Bit-xor(âŸ¦ğ‘¥ (ğ‘–) âŸ§, Bit-xor(âŸ¦ğ‘¦ (ğ‘–) âŸ§, âŸ¦ğ‘ (ğ‘–âˆ’1) âŸ§))
where Bit-xor(ğ‘, ğ‘) = (ğ‘ âˆ’ ğ‘)2; and âŸ¦ğ‘ (ğ‘–) âŸ§ = âŸ¦ğ‘¥ (ğ‘–) âŸ§âŸ¦ğ‘¦ (ğ‘–) âŸ§ +
âŸ¦ğ‘ (ğ‘–âˆ’1) âŸ§((1 âˆ’ âŸ¦ğ‘¥ (ğ‘–) âŸ§)âŸ¦ğ‘¦ (ğ‘–) âŸ§ + âŸ¦ğ‘¥ (ğ‘–) âŸ§(1 âˆ’ âŸ¦ğ‘¦ (ğ‘–) âŸ§)). After this loop,
return (âŸ¦ğ‘§ (ğ‘–) âŸ§)ğ‘™

ğ‘–=1.

2.6 Random Numbers
A (secure) pseudo-random number generator (PRG) is a function ğº :
{0, 1}ğ‘˜ â†’ {0, 1}ğ‘ (ğ‘˜) for some polynomial ğ‘ with ğ‘ (ğ‘˜) > ğ‘˜ such that
for any randomized polynomial time algorithm ğ´ : {0, 1}ğ‘ (ğ‘˜) â†’
{0, 1} there holds |ğ‘ƒğ‘¥â†ğ‘… {0,1}ğ‘˜ (ğ´(ğº (ğ‘¥)) = 1)âˆ’ğ‘ƒğ‘¥â†ğ‘… {0,1}ğ‘ (ğ‘˜ ) (ğ´(ğ‘¥) =
1)| â‰¤ ğœ‡ (ğ‘˜) for some function ğœ‡ negligible in ğ‘˜. In other words, a
PRG is a function which takes a string ğ‘¥ as input and outputs a
longer string ğº (ğ‘¥) which cannot be distinguished from a random
sequence by a polynomial time algorithm.

3 PROBLEM STATEMENT
We call ğœ‹ a sampling protocol over a domain X if ğœ‹ is a randomized
multi-party protocol which outputs sequences of elements of X.
We consider sampling protocols which take only one input per
party at the beginning of the protocol. In particular, let P = {ğ‘ƒğ‘– }ğ‘›
ğ‘–=1
be the set of ğ‘› parties which participate to a sampling protocol
ğœ‹, and let ğ‘ ğ‘– be the input (also called seed) of party ğ‘ƒğ‘– (for ğ‘– âˆˆ
[ğ‘›]). We denote the output of ğœ‹ by ğœ‹ (s) where s = (ğ‘ ğ‘– )ğ‘›
ğ‘–=1 is the
vector of seeds. We assume that there is some increasing polynomial
ğ‘ : N â†’ N such that if s âˆˆ {0, 1}ğ‘˜Ã—ğ‘› then ğœ‹ (s) âˆˆ Xğ‘ (ğ‘˜) . Let
sâˆ’ğ‘– = (ğ‘ 1, . . . , ğ‘ ğ‘–âˆ’1, ğ‘ ğ‘–+1, . . . , ğ‘  |ğ‘  |) denote the vector s without the
ğ‘–-th component.

Definition 1 (Correct Sampling). For a multi-party protocol ğœ‹, we
say a party is honest if it follows the steps of protocol ğœ‹ correctly and
does not collude with other parties. We say that a sampling protocol
ğœ‹ correctly samples from a probability distribution D if there is a
function ğœ‡ with ğœ‡ (ğ‘˜) negligible in ğ‘˜ such that for every run of ğœ‹
by parties P = {ğ‘ƒğ‘– }ğ‘›
ğ‘–=1 among which there is at least one ğ‘– âˆˆ [ğ‘›]
such that party ğ‘ƒğ‘– is honest, for every sâˆ’ğ‘– âˆˆ {0, 1}ğ‘˜Ã—(ğ‘›âˆ’1) , for any
probabilistic polynomial time algorithm ğ´ : {0, 1}ğ‘˜ (ğ‘›âˆ’1) Ã—Xğ‘ (ğ‘˜) â†’
{0, 1}, there holds that either ğœ‹ finishes correctly and

|ğ‘ƒğ‘ ğ‘– â†ğ‘… {0,1}ğ‘˜ (ğ´(sâˆ’ğ‘–, ğœ‹ (s)) = 1)
âˆ’ ğ‘ƒğ‘¡â†ğ‘… {0,1}ğ‘˜ (ğ‘›âˆ’1) ,ğ‘¥â†ğ‘… Dğ‘ (ğ‘˜ ) (ğ´(ğ‘¡, ğ‘¥) = 1)| â‰¤ ğœ‡ (ğ‘˜),
or ğœ‹ aborts and detects a party that attempted to cheat, where Dğ‘ (ğ‘˜)
draws vectors from Xğ‘ (ğ‘˜) whose components are independently
distributed according to D.

In other words, if there is at least one honest party, then ğœ‹ acts
as a (generalized) PRG even if all parties except that honest party
would disclose their seeds. As a result, as soon as a single party is
honest it can trust that any output of ğœ‹ used by any party is pseudo-
random and no party could predict it in advance. We denote the
fact that ğ‘¥ is correctly drawn from D by ğ‘¥ â†âˆ—

We say a protocol ğœ‹ verifiably samples from D if ğœ‹ correctly
samples from D and after every execution of ğœ‹ the value of ğ‘¥ is
uniquely defined given the union of the information obtained by all
parties and the information published by ğœ‹ is sufficient to convince

ğ‘… D.

Proceedings on Privacy Enhancing Technologies YYYY(X)

CÃ©sar Sabater, Florian Hahn, Andreas Peter, and Jan Ramon

ğ‘… D.

any party that ğ‘¥ has been correctly drawn. We denote the fact that
ğ‘¥ is verifiably drawn from D by ğ‘¥ â†ğ‘‰

In this paper, we will often informally consider both discrete
and continuous probability distributions, and ğ‘ƒ D then either rep-
resents a probability mass or probability density according to the
context. As computers work with finite precision, we will eventu-
ally discretize up to some parameter-defined precision. While in
the end all distributions will be discrete, we will use the continuous
representations whenever this simplifies the explanation.

In the sequel, unless made explicit otherwise, weâ€™ll assume there
are ğ‘› parties among whom at least one is honest, and that D is
a publicly agreed probability distribution. Also, to simplify the
explanation we will often describe protocols generating just one
random number, the extension to streams of random numbers is
then straightforward.

We can distinguish several types of verifiable sampling proto-
cols, depending on how they output the sampled number ğ‘¥. For a
verifiable sampling protocol ğœ‹, we say it is a

â€¢ public draw if after running ğœ‹ the value of ğ‘¥ is published.
â€¢ private draw if after running ğœ‹ exactly one party knows ğ‘¥,
but the other parties have no information on ğ‘¥ next to the
prior distribution D.

â€¢ hidden draw if after running ğœ‹ the parties have received
an additive secret share (ğ‘¥1, . . . , ğ‘¥ğ‘›) for ğ‘¥, but still no party
has any information about ğ‘¥ next to the prior distribution
D.

In this paper, we study the problem of finding efficient verifiable
sampling protocols of each of the three above types given the prob-
ability distribution D.

This problem is reasonably straightforward if D is the uniform
distribution over the integers in the interval [0, ğ¿) for some ğ¿ > 0:

Protocol 1 (Public uniform sampling). For each ğ‘– âˆˆ [ğ‘›] let
party ğ‘ƒğ‘– generate its own random number ğ‘Ÿğ‘– uniformly distributed
over [0, ğ¿) from its own secret seed ğ‘ ğ‘– and publish a commitment ğ¶ğ‘–
to it. Then, all parties open their commitment, i.e., they publish ğ‘Ÿğ‘– and
the randomness associated to the commitment to prove that ğ¶ğ‘– was a
commitment to ğ‘Ÿğ‘– . Finally, all parties compute publicly (cid:205)ğ‘›
ğ‘–=1 ğ‘Ÿğ‘– mod ğ¿.

It is easy to see Protocol 1 draws ğ‘Ÿ verifiably: if at least one
party ğ‘ƒğ‘– is honest, it has generated a uniformly distributed number
ğ‘Ÿğ‘– and ğ‘Ÿ is also uniformly distributed because non-honest parties
ğ‘ƒ ğ‘— cannot change their ğ‘Ÿ ğ‘— as a function of other parties because
they start with a commitment on their ğ‘Ÿ ğ‘— . Note that Protocol 1 is a
generalization for multiple parties of [10]. We present the protocol
in more detail and prove its security in Appendix B.3.

Protocol 2 (Private uniform sampling). One can sample a
vector of ğ‘˜ numbers private to ğ‘ƒ1 as follows: ğ‘ƒ1 draws uniformly at
random a vector a = (ğ‘1, . . . , ğ‘ğ‘˜ ) âˆˆ [0, ğ¿)ğ‘˜ and publishes a vector
commitment ğ¶ to it. Then, all parties generate jointly a public random
number ğ‘Ÿ âˆˆ [0, ğ¿) with Protocol 1. ğ‘ƒ1 expands ğ‘Ÿ to random numbers
(ğ‘Ÿ1, . . . , ğ‘Ÿğ‘˜ ) âˆˆ [0, ğ¿)ğ‘˜ using a PRG. Finally, for ğ‘– âˆˆ [ğ‘˜], ğ‘ƒ1 computes
ğ‘¢ğ‘– = ğ‘ğ‘– +ğ‘Ÿğ‘– mod ğ¿ and performs a zero knowledge proof of the modular
sum for each ğ‘¢ğ‘– . (ğ‘¢1, . . . , ğ‘¢ğ‘˜ ) is a vector of private uniform random
numbers.

4

Again, it is easy to see that (ğ‘¢1, . . . , ğ‘¢ğ‘˜ ) is drawn verifiably. This
protocol has many aspects in common with the Augmented Coin-
Tossing protocol defined in [29, Section 7.4.3.5]. We provide a proof
of the security of Protocol 2 in Appendix B.4.

Protocol 3 (Hidden uniform sampling). For each ğ‘– âˆˆ [ğ‘›] let
party ğ‘ƒğ‘– generate its own random number ğ‘Ÿğ‘– uniformly distributed
over [0, ğ¿) and publish a commitment ğ¶ğ‘– to it. Then, they consider
(ğ‘Ÿ1, . . . , ğ‘Ÿğ‘›) as a secret share of the random number ğ‘Ÿ = (cid:205)ğ‘›
ğ‘–=1 ğ‘Ÿğ‘– mod ğ¿.
After running Protocol 3, if there is a honest party, ğ‘Ÿ is fixed and
follows the right probability distribution, and as not all parties col-
lude no party knows more about ğ‘Ÿ than that it follows the uniform
distribution over [0, ğ¿).

The problem of finding efficient verifiable sampling protocols
becomes more challenging when D is not the uniform distribution,
but a more general distribution such as a normal distribution or a
Laplace distribution. Even for single party computation there some-
times exist multiple approaches with varying cost and precision.

4 RELATED WORK
Below we describe lines of work that are related to ours.

Multiparty Computation between unreliable participants. The
seminal work of [10] proposed the first protocol to sample a public
random bit (i.e. tossing a coin) between two parties that do not trust
each other. Subsequent works such as [13] proposed protocols to
perform coin tossing between an arbitrary number of parties.

The work of [20] proved that in the malicious model without
aborts it is impossible that a multiparty protocol is guaranteed to
finish correctly and perform an unbiased coin toss if the number of
malicious users is half or more of the total of participants. For such
cases, there is no other possibility than providing weaker security
guarantees. In the framework of malicious security with abort[29],
protocols either end correctly or are aborted by malicious parties.
This could lead to bias in the computations if a protocol is restarted
after an abort and the adversary speculatively chooses when allow
the protocol to finish correctly. To prevent this, a possible solution
is to identify and punish malicious parties that cause aborts. The
work of [3] proposes covert security, where cheating adversaries can
get caught with certain probability. This is weaker than malicious
security with abort, but allows cheaters to be detected. A stronger
notion is malicious security with identifiable abort[33], where a
party that cheats causes the protocol to abort with overwhelming
probability and, in addition, the cheater is identified. Our work fits
in that framework.

If deterrence measures are strong enough, this could be sufficient
to discourage malicious behavior. Otherwise, if corrupted peers are
willing to sacrifice themselves at any cost, other measures can be
taken to attenuate the bias as much as possible [5, 43].

The work [30] proposes a method to securely perform a wide
family of randomized computations (related to interactive games)
over private data and private random numbers, using zero knowl-
edge proofs to verify correctness. They prove that this is secure
in the ideal paradigm without abort if the majority of parties is
honest.

Sampling from Gaussians and other popular non-uniform distribu-
tions. Distributions such as the Gaussian distribution, the Laplace

Private Sampling with Identifiable Cheaters

Proceedings on Privacy Enhancing Technologies YYYY(X)

distribution, the Poisson distribution or the exponential distribution
are important in the field of statistics. Algorithms to securely draw
from such distributions have applications in federated machine
learning. Several contributions concern the problem of verifiable
noise for differential privacy [35, 50] and hence can benefit from
secure drawing.

Even in the semi-honest model where parties follow the specified
protocol, drawing hidden random numbers is sometimes non-trivial.
For example, in [19] one needs to make a sum of statistics and
a Laplacian-distributed noise term, hence the authors propose a
protocol where parties generate random numbers summing to a
Laplacian distributed value which can then be included in a secure
aggregation without being revealed.

In [26], protocols are proposed to generate secret-shared sam-
ples for Gaussian, Exponential and Poisson distributions. For the
Gaussian distribution, their approach generates samples by aver-
aging uniform seeds, a method which we call the Central Limit
Theorem (CLT) approach. We compare the CLT approach with our
approaches in Section 9. Even if more than a decade has passed
since [26], recent contributions still resort to these techniques to
generate Gaussian samples among unreliable participants. For ex-
ample, recent protocols use the technique of [26] by adapting it
to generate private draws from the Exponential distribution [45]
and to sample hidden draws from the Binomial distribution [9].
The work of [41] proposes techniques to securely sample from the
geometrical and Gaussian distributions, both building on [26], and
studies them in the light of differentially private memory access
patterns. In addition, [41] defines an extension of the malicious
security model which includes information leakage, as measured
in differential privacy, and proves the security of their protocols
within this model.

In our work, we propose new techniques for privately drawing
from the Gaussian distribution and show that all our techniques for
all but the lowest precision requirements outperform the technique
of [26], which is the most efficient method known so far. The same
dynamics are at play for exponential, Poisson and Laplace distri-
butions. Compared to the techniques in [26], our methods have a
better complexity as a function of the precision parameter. We ex-
tend our methodology to hidden draws of Gaussian, Laplacian and
Arbitrary distributions. Achieving sufficient precision when sam-
pling is important for both the statistical quality and the security
of the algorithms [42].

Implementation of math functions using cryptographic primitives.
Using secret sharing techniques, there is a large body of work on
how to compute math functions such as square roots, logarithms
and trigonometric [1, 4, 25, 32, 32, 37]. However they usually rely on
splines or other approximation techniques that approximate func-
tions by splitting the domain and using low-degree polynomials
for each part. Alternatively, they rely on rational approximations.
Piecewise approximations require the use of conditionals which
are expensive when computing with secret shares, and rational
approximations only allow for a fixed precision. Our work uses
iterative approximations which allow to customize the precision
of the approximation and are easy to compute given that we avoid
the use of comparison gates in our circuits. Furthermore, for the

5

Gaussian distribution, piecewise approximations require an exter-
nal method to sample from the tails of the distribution. We also
show protocols for private sampling from Gaussian and Laplace
distributions where we avoid the high cost of secret shared compu-
tation by letting one party perform the calculation and then prove
correct behavior using compressed Î£-protocols.

Zero Knowledge Proofs for such functions, as we apply in our
work, is a less explored technique. [54] proposes techniques to prove
a limited set of relations involving common activation functions in
machine learning.

5 METHOD
We start with discussing two generic approaches: a strategy based
on the inverse cumulative probability distribution and a strategy
based on table lookup.

5.1 Inverse Cumulative Probability

Distribution

Assume D is a probability distribution on X âŠ† R. The cumulative
probability distribution is defined as

âˆ«

ğ¹ D (ğ‘¥) =

ğ‘ƒ D (ğ‘¡) dğ‘¡

ğ‘¡ â‰¤ğ‘¥
To the extent D is discrete, we can see ğ‘ƒ D as a sum of scaled Dirac
delta functions over which integration is possible and results in a
sum. Then, the inverse ğ¹ âˆ’1
D

is a function on the interval (0, 1).

An approach to sampling from arbitrary distributions D on do-
mains X âŠ† R, known as the inversion method, consists of sampling
uniformly from the (0, 1) interval and applying the inverse of the
cumulative distribution function ğ¹ âˆ’1
. Indeed, if ğ‘¡ â†ğ‘… (0, 1), then
D
ğ‘ƒ (ğ¹ âˆ’1

D (ğ‘¡) = ğ‘¥) = ğ‘ƒ D (ğ‘¥).
Public Sampling from an Arbitrary Distribution. This approach

can easily be applied to draw random numbers publicly:

Protocol 4 (Public draw from arbitrary distribution). Run
protocol 1 to generate a public uniformly distributed random number
ğ‘Ÿ â€², and then publicly compute ğ‘Ÿ = ğ¹ âˆ’1

D (ğ‘Ÿ â€²).

Using the inversion method for private or hidden draws is more
involved since one needs a multi-party algorithm to compute ğ¹ âˆ’1
D
or a ZKP algorithm to prove to other parties that ğ¹ âˆ’1
was applied
D
correctly. In many practical cases, ğ¹ âˆ’1
does not have a simple closed
D
form. This especially holds for the Gaussian distribution which we
will discuss in more detail in Section 8.

We can extend this method to multi-variate distributions. For
example, consider a distribution D over R2. To sample a pair (ğ‘¥, ğ‘¦)
according to D, we first define ğ‘ƒğ‘¥ (ğ‘¥) = âˆ« ğ‘ƒ D (ğ‘¥, ğ‘¦) dğ‘¦, apply the
inversion method to draw a random number ğ‘¥ according to ğ‘ƒğ‘¥ , and
then define ğ‘ƒğ‘¦ |ğ‘¥ (ğ‘¦) = ğ‘ƒ D (ğ‘¦|ğ‘¥) = ğ‘ƒ D (ğ‘¥, ğ‘¦)/ğ‘ƒğ‘¥ (ğ‘¥) and apply again
the inversion method to draw a random ğ‘¦.

5.2 Table Lookup
As pointed out above, practical inverse cumulative probability func-
tions are often expensive to compute, especially in a secure multi-
party setting. In such scenarios approaches such as the ones dis-
cussed in Sections 5.1 and 8 incur a high cost for each drawn random

Proceedings on Privacy Enhancing Technologies YYYY(X)

CÃ©sar Sabater, Florian Hahn, Andreas Peter, and Jan Ramon

number. In this section we consider an approach based on table
lookup. While the involved techniques are well-known, this ap-
proach is interesting as a baseline, especially as it has a number of
properties which are different from the other methods considered
in this paper. In particular, the method studied here has a high
pre-processing cost but then allows for drawing random numbers
at a low constant cost per drawn random number.

Protocol 5 (Table-lookup private sampling).

â€¢ Preprocessing. Let ğ‘€ âˆˆ N. The parties publicly pre-compute
(cid:17)(cid:17) for all ğ‘– âˆˆ [ğ‘€] and store them into a

(cid:16) 2ğ‘–âˆ’1
2ğ‘€

the pairs (cid:16)
database DB.

ğ‘–, ğ¹ âˆ’1
D

â€¢ Sampling. Party ğ‘ƒ1 privately draws using Protocol 2 a random
number ğ‘Ÿ â€² distributed uniformly in [ğ‘€]. Then, ğ‘ƒ1 sets ğ‘Ÿ =
(cid:17), publishes commitments to ğ‘Ÿ â€² and ğ‘Ÿ , and publishes
ğ¹ âˆ’1
D
a ZKP that (ğ‘Ÿ â€², ğ‘Ÿ ) âˆˆ DB.

(cid:16) 2ğ‘Ÿ â€²âˆ’1
2ğ‘€

In Protocol 5 a zero knowledge set membership proof is needed.
There is a large body of work on this topic since in [15] the first
method was shown that has a large preprocessing cost (linear in
ğ‘€) but only a unit communication cost for proving membership.
Several improvements have been proposed which vary in their
assumptions and efficiency, [7] discusses some lines of recent work.
Only already storing the database DB may take a prohibitive
amount of space if a high precision is needed, as ğ‘€ is exponential
in the number of desired correct digits. As a result, this technique
can only be used when the needed precision is not too high. If it is
feasible, it is expensive for drawing only a few random numbers but
it can become more efficient than other methods if a huge number
of random numbers need to be drawn, as asymptotically the cost
per sample will dominate.

5.3 Laplace Distribution
The Laplace distribution, denoted ğ¿ğ‘ğ‘ (ğ‘) is defined by

ğ‘ƒğ¿ğ‘ğ‘ (ğ‘) (ğ‘¥) = exp(âˆ’|ğ‘¥ |/ğ‘)/2ğ‘.

The cumulative distribution is

ğ¹ğ¿ğ‘ğ‘ (ğ‘¥) = 1/2 + sign(ğ‘¥)/2 âˆ’ sign(ğ‘¥) exp(âˆ’|ğ‘¥ |/2).

To sample a number ğ‘Ÿ from ğ¿ğ‘ğ‘ (ğ‘) it is convenient to separately
draw the sign ğ‘  and absolute value ğ‘ of ğ‘Ÿ . Then, ğ‘ƒ (ğ‘  = âˆ’1) = ğ‘ƒ (ğ‘  =
(cid:17). In
1) = 1/2 and ğ‘ƒ (ğ‘) = 1
ğ‘
Section 7 we will describe protocols for both private and hidden
Laplace-distributed draws.

(cid:17) and ğ‘ƒ (ğ‘ â‰¤ ğ‘¡) = 1 âˆ’ exp (cid:16)

exp (cid:16)

âˆ’ ğ‘
ğ‘

âˆ’ ğ‘¡
ğ‘

5.4 Gaussian Distribution
The Gaussian distribution, denoted by N (ğœ‡, ğœ2), is defined by
ğ‘ƒN (ğœ‡,ğœ 2) (ğ‘¥) = exp(âˆ’(ğ‘¥ âˆ’ ğœ‡)2/2ğœ2)/

2ğœ‹ğœ.

âˆš

We will sometimes use the shorthand ğ‘ƒN = ğ‘ƒN (0,1) . The cumulative
distribution is

ğ¹ N (ğ‘¥) = (1 + erf(ğ‘¥/

(1)
where erf is the error function. There is no closed form for ğ‘ƒN, ğ¹ N
nor its inverse. In the single party setting multiple strategies have
been investigated to sample from this important distribution:

2))/2

âˆš

â€¢ the Central Limit Theorem (CLT) approach, which consists
of sampling repeatedly from a uniform distribution and com-
puting the average, which is simple but requires ğ‘‚ (1/Î”2)
time for a root mean squared error Î”,

â€¢ the Box-MÃ¼ller method [12], that can obtain two Gaussian
numbers from two uniform samples by the application of
a closed form formula, but involves the computation of a
square root, trigonometric functions and a logarithm,

â€¢ rejection sampling methods, such as the polar version of
Box-MÃ¼ller [36] or the Ziggurat Method [40] are efficient
and highly accurate. While the former avoids the compu-
tation of trigonometric functions and leads to an efficient
verifiable implementation, the latter uses several conditional
branches which are expensive to prove in zero knowledge
and requires an external method for sampling in the tails of
the distribution,

â€¢ the inversion method for Gaussians that involves the approx-
imation of the inverse error function erf âˆ’1, which can be
done with rational functions or Taylor polynomials, and
â€¢ the recursive method of Wallace [51], which is very popular
for its efficiency, but requires as input a vector of already
generated Gaussian samples to generate an output vector
of the same size; furthermore, samples from input and out-
put vectors are correlated, which deteriorates the statistical
quality.

Before studying some of these in the multi-party setting, we will
first provide Î£-protocols of relations involving approximations of
certain elementary functions.

6 PROOFS OF ELEMENTARY FUNCTIONS
In this section, we construct zero knowledge proofs of statements
that involve the approximation of elementary functions, i.e. sine,
cosine, natural logarithm and square root. These functions can
be numerically approximated using basic operations such as addi-
tion and multiplication. While classic cryptographic tools are used
to prove statements over integers, we operate with real numbers
which we approximate with fixed precision. Therefore, we use rep-
resentations of integer multiples of 2âˆ’ğœ“ by multiplying our values
with 2ğœ“ and rounding them deterministically to obtain elements of
Zğ‘ . Negative numbers are represented in the upper half of Zğ‘ . For
example, the number ğ‘ < 0 is represented with ğ‘ + 2ğœ“ ğ‘. The set of
representable numbers is denoted by

QâŸ¨ğ‘,ğœ“ âŸ© = {ğ‘£ âˆˆ Q : 2ğœ“ ğ‘£ âˆˆ Z âˆ§ âˆ’ğ‘/2 â‰¤ 2ğœ“ ğ‘£ < ğ‘/2}

which is closed under addition and multiplication modulo ğ‘ (rounded
up to 2âˆ’ğœ“ ). The encoding of ğ‘£ âˆˆ QâŸ¨ğ‘,ğœ“ âŸ© is denoted by âŸ¨ğ‘£âŸ© =
2ğœ“ ğ‘£ mod ğ‘.

We show circuits such that the nullity of their output is equiv-
alent to the statements we want to prove. We will first construct
circuits to describe low level statements and then use these as
building blocks for higher level statements. In the end, we apply
compressed Î£-protocols (see Section 2.4) to produce zero knowl-
edge proofs of these circuits. For parameters (ğ‘; ğ‘) of all circuits
defined below, ğ‘ always contains public constants and ğ‘ private
values.

6

Private Sampling with Identifiable Cheaters

Proceedings on Privacy Enhancing Technologies YYYY(X)

We present in Section 6.1 circuits for proving various types of
simple statements. In Section 6.2, we introduce Cordic, the core
approximation algorithm. We implement circuits to prove its correct
execution in Section 6.3, and details on how to expand its domain
of application, particularly for our sampling techniques, in Section
6.4.

6.1 Building Blocks
We introduce below proofs of basic statements that we will use to
prove approximations, including the handling of some statements
of numbers in QâŸ¨ğ‘,ğœ“ âŸ©. Note that additions, multiplication by an
integer and range proofs port directly to Zğ‘ by our encoding âŸ¨Â·âŸ©.
In Appendix A.5, we show that to prove that an integer ğ‘¥ âˆˆ Zğ‘
belongs to [0, 2ğ‘˜ ) we can use the circuit

ğ¶ğ‘…ğ‘ (ğ‘˜; ğ‘¥, x) (cid:66)

(cid:20) x âˆ— (1 âˆ’ x)
ğ‘¥ âˆ’ (cid:205)ğ‘˜

ğ‘–=1 ğ‘¥ğ‘– 2ğ‘–âˆ’1

(cid:21)

where x = (ğ‘¥1, . . . , ğ‘¥ğ‘˜ ) is the bit map of ğ‘¥. Here, x âˆ— (1 âˆ’ x) is a
vector with at position ğ‘– the value ğ‘¥ğ‘– (1âˆ’ğ‘¥ğ‘– ), which is 0 if ğ‘¥ğ‘– âˆˆ {0, 1}.
The second expression evaluates to 0 if x is indeed the correct bit
map of ğ‘¥. Hence, the nullity of the circuit, i.e., its righthandside
evaluating to the zero vector, proves ğ‘¥ âˆˆ [0, 2ğ‘˜ ).

Generalized range proof. ğ¶ğ‘…ğ‘ can be used twice to prove mem-
bership in any range [ğ‘, ğ‘] âŠ‚ Zğ‘ . To prove ğ‘¥ âˆˆ [ğ‘, ğ‘] we use the
circuit

ğ¶ğºğ‘…ğ‘ (ğ‘, ğ‘; ğ‘¥, s1, s2) (cid:66)

(cid:20) ğ¶ğ‘…ğ‘ (âŒŠlog(ğ‘ âˆ’ ğ‘)âŒ‹ + 1; ğ‘¥ âˆ’ ğ‘, s1)
ğ¶ğ‘…ğ‘ (âŒŠlog(ğ‘ âˆ’ ğ‘)âŒ‹ + 1; ğ‘ âˆ’ ğ‘¥ + ğ‘, s2)

(cid:21)

where s1, s2 âˆˆ {0, 1} âŒŠlog(ğ‘âˆ’ğ‘) âŒ‹+1 the auxiliary bit vectors required
for ğ¶ğ‘…ğ‘.

(Right) Bit-shift. For ğ‘ âˆˆ QâŸ¨ğ‘,ğœ“ âŸ© and an integer ğ‘˜ > 0, a bit shift
ğ‘ >> ğ‘˜ is equal to the biggest value in QâŸ¨ğ‘,ğœ“ âŸ© smaller than ğ‘/2ğ‘˜ .
We have that ğ‘ = ğ‘ >> ğ‘˜ if âŸ¨ğ‘âŸ© âˆ’ 2ğ‘˜ âŸ¨ğ‘âŸ© âˆˆ [0, 2ğ‘˜ ). For the vector s
of the bit decomposition of âŸ¨ğ‘âŸ© âˆ’ 2ğ‘˜ âŸ¨ğ‘âŸ©, the circuit is

ğ¶>> (ğ‘˜; âŸ¨ğ‘âŸ©, âŸ¨ğ‘âŸ©, s) (cid:66) ğ¶ğ‘…ğ‘ (ğ‘˜; âŸ¨ğ‘âŸ© âˆ’ 2ğ‘˜ âŸ¨ğ‘âŸ©, s).

Note that in the definition of ğ¶>>, as in all subsequent circuits, the
evaluation of inputs to sub-circuits such as ğ¶ğ‘…ğ‘ are computations
performed within the circuit.

Approximate product. For private ğ‘, ğ‘, ğ‘ âˆˆ QâŸ¨ğ‘,ğœ“ âŸ©, it can be proven
that ğ‘ is the rounding of ğ‘ğ‘, that is by proving that âŸ¨ğ‘âŸ© âˆ’ âŸ¨ğ‘âŸ©âŸ¨ğ‘âŸ© +
âŸ¨1/2âŸ© âˆˆ [0, 2ğœ“ ). For s âˆˆ {0, 1}ğœ“ the bitmap of âŸ¨ğ‘âŸ© âˆ’ âŸ¨ğ‘âŸ©âŸ¨ğ‘âŸ© + âŸ¨1/2âŸ©
our circuit is

ğ¶ğ‘ƒğ‘Ÿğ‘œğ‘‘ (ğœ“ ; âŸ¨ğ‘âŸ©, âŸ¨ğ‘âŸ©, âŸ¨ğ‘âŸ©, s) (cid:66) ğ¶ğ‘…ğ‘ (ğœ“ ; âŸ¨ğ‘âŸ© âˆ’ âŸ¨ğ‘âŸ©âŸ¨ğ‘âŸ© + âŸ¨1/2âŸ©, s).

Approximate division. For private ğ‘, ğ‘, ğ‘ âˆˆ QâŸ¨ğ‘,ğœ“ âŸ©, we prove that ğ‘
is approximately ğ‘/ğ‘ with error 2âˆ’ğœ“ . We also require that ğ‘ âˆˆ [ğ´, ğµ]
for public ğ´, ğµ âˆˆ QâŸ¨ğ‘,ğœ“ âŸ©. We prove that âŸ¨ğ‘âŸ©âŸ¨ğ‘âŸ© âˆ’ 2ğœ“ âŸ¨ğ‘âŸ© + âŸ¨ğ‘âŸ© âˆˆ
[0, 2âŸ¨ğ‘âŸ©). Our range proofs require that the bounds are public, so
we prove that âŸ¨ğ‘âŸ©âŸ¨ğ‘âŸ© âˆ’ 2ğœ“ âŸ¨ğ‘âŸ© + âŸ¨ğ‘âŸ© âˆˆ [0, 2ğ‘ ğ‘ +1) and 2ğœ“ âŸ¨ğ‘âŸ© âˆ’ âŸ¨ğ‘âŸ©âŸ¨ğ‘âŸ© âˆˆ
[0, 2ğ‘ ğ‘ +1) where ğ‘ ğ‘ = âŒŠlog2 (âŸ¨ğµâŸ© âˆ’ âŸ¨ğ´âŸ©)âŒ‹ + 1. For s1, s2 âˆˆ Zğ‘ ğ‘ +1

ğ‘

auxiliary bit vectors, the circuit is

ğ¶ğ·ğ‘–ğ‘£ (ğœ“, ğ‘ ğ‘ ; âŸ¨ğ‘âŸ©, âŸ¨ğ‘âŸ©, âŸ¨ğ‘âŸ©, s1, s2)

(cid:66)

(cid:20)ğ¶ğ‘…ğ‘ (ğ‘ ğ‘ ; âŸ¨ğ‘âŸ©âŸ¨ğ‘âŸ© âˆ’ 2ğœ“ âŸ¨ğ‘âŸ© + âŸ¨ğ‘âŸ©, s1)
ğ¶ğ‘…ğ‘ (ğ‘ ğ‘ ; 2ğœ“ âŸ¨ğ‘âŸ© âˆ’ âŸ¨ğ‘âŸ©âŸ¨ğ‘âŸ©, s2)

(cid:21)

.

Exponentiation in Zğ‘ . Let ğ‘¦, ğ‘¥ âˆˆ Zğ‘ be private values with ğ‘¥ âˆˆ
[0, 2ğ‘˜ ) and ğ¸ âˆˆ Zğ‘ a public integer such that ğ¸ğ‘¥ < ğ‘/2. We prove
that ğ‘¦ = ğ¸ğ‘¥ . Let x âˆˆ {0, 1}ğ‘˜ the vector of bits of ğ‘¥, we prove that
ğ‘¦=1 ğ‘¦ğ‘– where for ğ‘– âˆˆ {1, . . . , ğ‘˜ }, ğ‘¦ğ‘– is equal to ğ¸2ğ‘–âˆ’1 if xğ‘– = 1,
ğ‘¦ = (cid:206)ğ‘˜
or to 1 if xğ‘– = 0. The circuit is

ğ¶ğ¼ ğ¸ğ‘¥ (ğ‘˜, ğ¸; ğ‘¥, ğ‘¦, x) (cid:66)

(cid:20)
ğ‘¦ âˆ’ (cid:206)ğ‘˜

ğ¶ğ‘…ğ‘ (ğ‘˜; ğ‘¥, x)
ğ‘–=1 1 + xğ‘– (ğ¸2ğ‘–âˆ’1

(cid:21)

.

âˆ’ 1)

Modular sum. We prove, for private ğ‘¥, ğ‘§ âˆˆ Zğ‘ and public ğ‘¦ âˆˆ Zğ‘
such that all belong to [0, ğ‘€), that ğ‘§ = ğ‘¥ + ğ‘¦ mod ğ‘€. Let x1, x2, z1
and z2 vectors of intermediate values for ğ¶ğºğ‘…ğ‘, and let ğ‘ âˆˆ {0, 1},
our circuit is

ğ¶ğ‘€ğ‘œğ‘‘ (ğ‘€, ğ‘¦; ğ‘¥, ğ‘§, x1, x2, z1, z2, ğ‘) (cid:66)

ğ¶ğºğ‘…ğ‘ (0, ğ‘€ âˆ’ 1; ğ‘¥, x1, x2)
ï£®
ï£¯
ğ¶ğºğ‘…ğ‘ (0, ğ‘€ âˆ’ 1; ğ‘§, z1, z2)
ï£¯
ï£¯
ğ‘ (1 âˆ’ ğ‘)
ï£¯
ï£¯
ğ‘§ âˆ’ (ğ‘¥ + ğ‘¦ âˆ’ ğ‘ğ‘€)
ï£¯
ï£°

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£»

.

Ideas for ğ¶ğ¼ ğ¸ğ‘¥ and ğ¶ğ‘€ğ‘œğ‘‘ are taken from pages 112-115 of [16].

Private magnitude shift. Here, we prove that ğ‘¦ = ğ‘¥ >> ğ‘˜ for
public ğ¾ and private ğ‘˜ â‰¤ ğ¾. Let k, kâ€², kâ€²â€² âˆˆ {0, 1}ğ¾ and â„ âˆˆ Zğ‘ be
intermediate values for range proofs and integer exponentiations
and I>> = (â„, k, kâ€², kâ€²â€²), our circuit is

ğ¶ğ‘ƒ >> (ğ¾; ğ‘¥, ğ‘˜, ğ‘¦, I>>) (cid:66)

ğ¶ğ¼ ğ¸ğ‘¥ (ğ¾, 2; ğ‘˜, â„, k)
ï£®
ï£¯
ğ¶ğ‘…ğ‘ (ğ¾; ğ‘¥ âˆ’ â„ğ‘¦, kâ€²)
ï£¯
ï£¯
ğ¶ğ‘…ğ‘ (ğ¾; â„ âˆ’ ğ‘¥ + â„ğ‘¦ âˆ’ 1, kâ€²â€²)
ï£¯
ï£°

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£»

.

6.2 Cordic Algorithm
We use the Cordic algorithm [52] for approximations, which has
long been state of the art for computations of elementary functions
from simple operations [44]. Essentially, it uses the same core it-
eration algorithm, which only uses additions and bit-shifts, for all
elementary function approximations. We will use Cordic parame-
terized for two settings described below, the first is used for sine
and cosine and the second for square root and logarithm. In what
follows, we only provide an algorithmic description of the Cordic
algorithm as is needed in order to understand our extension to the
zero knowledge setting in Section 6.3.

Setting 1 (Sine and Cosine). Let ğœƒ0 = 0. From input values ğ‘‹0, ğ‘Œ0, ğœƒ âˆˆ

QâŸ¨ğ‘,ğœ“ âŸ©, the following iterations are performed:

ğ‘‹ğ‘– = ğ‘‹ğ‘–âˆ’1 âˆ’ ğœ‰ğ‘– (ğ‘Œğ‘–âˆ’1 >> ğ‘–)
ğ‘Œğ‘– = ğ‘Œğ‘–âˆ’1 + ğœ‰ğ‘– (ğ‘‹ğ‘–âˆ’1 >> ğ‘–)
ğœƒğ‘– = ğœ‰ğ‘– tanâˆ’1 (1 >> ğ‘–) + ğœƒğ‘–âˆ’1

where ğœ‰ğ‘– âˆˆ {âˆ’1, 1} is equal to sign(ğœƒ âˆ’ ğœƒğ‘–âˆ’1) and tanâˆ’1 (1 >> ğ‘–)
is taken from a precomputed table. Let ğœˆ be the total number of
(cid:112)1 + (1 >> 2ğ‘—) and ğ¾1 =
iterations, and let constants ğ¾1,ğœˆ = (cid:206)ğœˆ

ğ‘—=0

7

Proceedings on Privacy Enhancing Technologies YYYY(X)

CÃ©sar Sabater, Florian Hahn, Andreas Peter, and Jan Ramon

limğœˆâ†’âˆ ğ¾1,ğœˆ â‰ˆ 1.6. We have that

.

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£»

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£»

= ğ¾1

lim
ğœˆâ†’âˆ

ğ‘‹ğœˆ
ï£®
ï£¯
ğ‘Œğœˆ
ï£¯
ï£¯
ğœƒğœˆ âˆ’ ğœƒ
ï£¯
ï£°

ğ‘‹0 cos ğœƒ âˆ’ ğ‘Œ0 sin ğœƒ
ï£®
ï£¯
ğ‘‹0 sin ğœƒ + ğ‘Œ0 cos ğœƒ
ï£¯
ï£¯
0
ï£¯
ï£°
Recall the representation parameter ğœ“ of QâŸ¨ğ‘,ğœ“ âŸ© defined at the
beginning of the section. By the convergence rate of Cordic, if
ğœ“ â‰¥ ğœˆ + âŒˆlog2 (ğœˆ)âŒ‰ + 1, with input ğ‘‹0 = 1/ğ¾1,ğœˆ , ğ‘Œ0 = 0, and
ğœƒ âˆˆ [âˆ’ğœ‹/2, ğœ‹/2], then ğ‘‹ğœˆ and ğ‘Œğœˆ are approximations of sin(ğœƒ )
and cos(ğœƒ ) respectively with error at most 21âˆ’ğœˆ .
âˆš

ğ‘¥). In this setting Cordic only takes two
inputs ğ‘‹0, ğ‘Œ0 âˆˆ QâŸ¨ğ‘,ğœ“ âŸ© and, with ğœƒ0 = 0, it performs the iterations

Setting 2 (ln(ğ‘¥) and

ğ‘‹ğ‘– = ğ‘‹ğ‘–âˆ’1 + ğœ‰ğ‘– (ğ‘Œğ‘–âˆ’1 >> ğ¹ğ‘– )
ğ‘Œğ‘– = ğ‘Œğ‘–âˆ’1 + ğœ‰ğ‘– (ğ‘‹ğ‘–âˆ’1 >> ğ¹ğ‘– )
ğœƒğ‘– = ğœ‰ğ‘– tanhâˆ’1 (1 >> ğ¹ğ‘– ) + ğœƒğ‘–âˆ’1
with ğœ‰ğ‘– = sign(âˆ’ğ‘Œğ‘–âˆ’1) and shift magnitude ğ¹ğ‘– = ğ‘– + 1 âˆ’ ğ‘˜ where
the small value ğ‘˜ is equal to the biggest integer such that 3ğ‘˜+1 +
(cid:112)1 + (1 >> 2ğ¹ ğ‘—âˆ’1) and
2ğ‘˜ âˆ’ 1 â‰¤ 2(ğ‘– + 1). Now let ğ¾2,ğœˆ = (cid:206)ğœˆ
ğ¾2 = limğœˆâ†’âˆ ğ¾2,ğœˆ â‰ˆ 0.8. In Setting 2, we have that

ğ‘—=1

(cid:113)

.

=

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£»

lim
ğœˆâ†’âˆ

ğ‘‹ğœˆ
ï£®
ï£¯
ğ‘Œğœˆ
ï£¯
ï£¯
ğœƒğœˆ
ï£¯
ï£°

0 âˆ’ ğ‘Œ 2
ğ‘‹ 2
0
0
tanhâˆ’1 (cid:16) ğ‘Œ0
ğ‘‹0

ï£®
ğ¾2
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£°
With ğœ“ as in Setting 1, ğ‘¥ âˆˆ [ 1
4 , 1) and fixing ğ‘‹0 = ğ‘¥ + 1, ğ‘Œ0 =
ğ‘¥ âˆ’ 1 we get by the identity ln(ğ‘¥) = 2 tanhâˆ’1 ( ğ‘¥âˆ’1
ğ‘¥+1 ) that ğœƒğœˆ is
an approximation of 1
2 ln(ğ‘¥) with error at most 21âˆ’ğ¹ğœˆ . Similarly,
for the same ğœ“ and domain of ğ‘¥,
ğ‘¥ can be obtained by setting
(cid:19)

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£»

âˆš

(cid:17)

with error at most 21âˆ’ğ¹ğœˆ .

(ğ‘‹0, ğ‘Œ0) =

(cid:18)
ğ‘¥ +

1
ğ¾ 2

2,ğ‘›+1

, ğ‘¥ âˆ’ 1
ğ¾ 2

2,ğ‘›+1

6.3 Cordic in Zero Knowledge
We first specify a set of statements that together are equivalent to
a correctly performed Cordic computation. Note that the iterations
in Settings 1 and 2 are very similar. Except for the correctness of
the ğœ‰ğ‘– values, they can be described by equations

ğœ‰ğ‘– = âˆ’1 âˆ¨ ğœ‰ğ‘– = 1 âˆ€ğ‘– âˆˆ {1, . . . , ğœˆ },
ğ‘Œğ‘– = ğ‘Œğ‘–âˆ’1 + ğœ‰ğ‘– (ğ‘‹ğ‘–âˆ’1 >> ğ¹ğ‘– ) âˆ€ğ‘– âˆˆ {1, . . . , ğœˆ },
ğ‘‹ğ‘– = ğ‘‹ğ‘–âˆ’1 âˆ’ ğ‘šğœ‰ğ‘– (ğ‘Œğ‘–âˆ’1 >> ğ¹ğ‘– ) âˆ€ğ‘– âˆˆ {1, . . . , ğœˆ },

ğœƒğœˆ =

ğœˆ
(cid:213)

ğ‘–=1

ğœ‰ğ‘–ğ›¼ğ‘–,

(2)

(3)

(4)

(5)

where the constants in Setting 1 are ğ‘š = 1, ğ¹ğ‘– = ğ‘– and ğ›¼ğ‘– =
tanâˆ’1 (1 >> ğ‘–) and in Setting 2, ğ¹ğ‘– is already defined, ğ‘š = âˆ’1
and ğ›¼ğ‘– = tanhâˆ’1 (1 >> ğ¹ğ‘– ). To prove the correct value of the ğœ‰ğ‘– â€™s,
we avoid wide range checks at each iteration (on ğœƒ âˆ’ ğœƒğ‘– or ğ‘Œğ‘–âˆ’1),
but instead we use properties of the convergence of Cordic: all of
ğœ‰1, . . . , ğœ‰ğœˆ âˆˆ {âˆ’1, 1} have been chosen correctly if

ğœƒğœˆ âˆ’ ğœƒ âˆˆ [âˆ’ğ›¼ğœˆ, ğ›¼ğœˆ ]

ğ‘Œğœˆ âˆˆ [âˆ’2âˆ’ğ¹ğœˆâˆ’1, 2âˆ’ğ¹ğœˆâˆ’1 ]

in Setting 1, and

in Setting 2.

(6)

(7)

8

We outline below the circuits that imply the above statements.
Let ğ‘† âˆˆ {1, 2} be the Cordic setting that defines the involved con-
stants. Let ğœ‰ âˆ— = (ğœ‰1, . . . , ğœ‰ğœˆ ) and let
ğ‘–=1 , (sğ‘–, sâ€²
be the vector of all intermediate values. The nullity of circuit

I = (âŸ¨ğ‘‹ğ‘– âŸ©, âŸ¨ğ‘Œğ‘– âŸ©)ğœˆâˆ’1

ğ‘–=0 , ğœ‰ âˆ—)

ğ‘– âŸ©)ğœˆâˆ’1

ğ‘– âŸ©, âŸ¨ğ‘Œ â€²

ğ‘–, âŸ¨ğ‘‹ â€²

ğ¶ğ¶ğ‘Ÿğ‘‘ (ğœˆ, ğ‘†; âŸ¨ğ‘‹0âŸ©, âŸ¨ğ‘Œ0âŸ©, âŸ¨ğ‘‹ğœˆ âŸ©, âŸ¨ğ‘Œğœˆ âŸ©, âŸ¨ğœƒğœˆ âŸ©, I)
ğ¶>> (ğ¹ğ‘– ; âŸ¨ğ‘‹ğ‘–âˆ’1âŸ©, âŸ¨ğ‘‹ â€²
ï£®
ï£¯
ğ¶>> (ğ¹ğ‘– ; âŸ¨ğ‘Œğ‘–âˆ’1âŸ©, âŸ¨ğ‘Œ â€²
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£°

âŸ¨ğ‘Œğ‘– âŸ© âˆ’ âŸ¨ğ‘Œğ‘–âˆ’1âŸ© âˆ’ ğœ‰ğ‘– âŸ¨ğ‘‹ â€²
âŸ¨ğ‘‹ğ‘– âŸ© âˆ’ âŸ¨ğ‘‹ğ‘–âˆ’1âŸ© + ğ‘šğœ‰ğ‘– âŸ¨ğ‘Œ â€²

(1 + ğœ‰ âˆ—) âˆ— (1 âˆ’ ğœ‰ âˆ—)

âŸ¨ğœƒğœˆ âŸ© âˆ’ (cid:205)ğœˆ

ğ‘–=1 ğœ‰ğ‘– âŸ¨ğ›¼ğ‘– âŸ©

(cid:66)

ğ‘–âˆ’1âŸ©, sğ‘–âˆ’1) âˆ€ğ‘– âˆˆ [ğœˆ]
ğ‘–âˆ’1âŸ©, sâ€²
ğ‘–âˆ’1) âˆ€ğ‘– âˆˆ [ğœˆ]

ğ‘–âˆ’1âŸ© âˆ€ğ‘– âˆˆ [ğœˆ]
ğ‘–âˆ’1âŸ© âˆ€ğ‘– âˆˆ [ğœˆ]

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£»

is a proof of the core of the execution in eqs. (2) to (5). Here, for
ğ‘– âˆˆ {0, 1}ğ¹ğ‘– are auxiliary bit vectors to prove bit
ğ‘– âˆˆ {1, . . . , ğœˆ }, sğ‘–, sâ€²
shifts of ğ‘‹ğ‘– and ğ‘Œğ‘– with result ğ‘‹ â€²

ğ‘–âˆ’1 respectively.
We complete the above core circuit for Setting 1. Let

ğ‘–âˆ’1 and ğ‘Œ â€²

ğ›¾ = âŒŠlog2 (2âŸ¨ğ›¼ğœˆ âŸ©)âŒ‹ + 1,
and let sğ›¼ âˆˆ {0, 1}ğ›¾ be the bit decomposition of âŸ¨ğœƒ âŸ© âˆ’ âŸ¨ğœƒğœˆ âŸ©. The
circuit

ğ¶ğ¶ğ‘Ÿğ‘‘1 (ğœˆ; âŸ¨ğœƒ âŸ©, âŸ¨ğ‘‹0âŸ©, âŸ¨ğ‘Œ0âŸ©, âŸ¨ğ‘‹ğœˆ âŸ©, âŸ¨ğ‘Œğœˆ âŸ©, âŸ¨ğœƒğœˆ âŸ©, I, sğ›¼ )

(cid:66)

(cid:20)ğ¶ğ¶ğ‘Ÿğ‘‘ (ğœˆ, 1; âŸ¨ğ‘‹0âŸ©, âŸ¨ğ‘Œ0âŸ©, âŸ¨ğ‘‹ğœˆ âŸ©, âŸ¨ğ‘Œğœˆ âŸ©, âŸ¨ğœƒğœˆ âŸ©, I)
ğ¶ğ‘…ğ‘ (ğ›¾; âŸ¨ğœƒ âŸ© âˆ’ âŸ¨ğœƒğœˆ âŸ© + âŸ¨ğ›¼ğœˆ âŸ©, sğ›¼ )

(cid:21)

.

proves eqs. (2) to (6). Similarly, we extend the core circuit to a
complete one for setting 2: for sğ‘Œ equal to the bit decomposition of
ğ‘Œğœˆ ,

ğ¶ğ¶ğ‘Ÿğ‘‘2 (ğœ“, ğœˆ; âŸ¨ğ‘‹0âŸ©, âŸ¨ğ‘Œ0âŸ©, âŸ¨ğ‘‹ğœˆ âŸ©, âŸ¨ğ‘Œğœˆ âŸ©, âŸ¨ğœƒğœˆ âŸ©, I, sğ‘Œ )

(cid:66)

(cid:20)ğ¶ğ¶ğ‘Ÿğ‘‘ (ğœˆ, 2; âŸ¨ğ‘‹0âŸ©, âŸ¨ğ‘Œ0âŸ©, âŸ¨ğ‘‹ğœˆ âŸ©, âŸ¨ğ‘Œğœˆ âŸ©, âŸ¨ğœƒğœˆ âŸ©, I)
ğ¶ğ‘…ğ‘ (ğœ“ âˆ’ ğ¹ğœˆ ; âŸ¨ğ‘Œğœˆ âŸ©, sğ‘Œ )

(cid:21)

.

proves eqs. (2) to (5) and (7).

The instantiation of ğ¶ğ¶ğ‘Ÿğ‘‘1 and ğ¶ğ¶ğ‘Ÿğ‘‘2 for elementary functions
is straightforward. Inputs that are intermediate values are defined
as above. For trigonometric functions, we set Iğ‘‡ = (âŸ¨ğœƒğœˆ âŸ©, I, sğ›¼ ) and
use

ğ¶ğ‘‡ ğ‘Ÿ (ğœˆ; âŸ¨ğœƒ âŸ©, âŸ¨ğ‘âŸ©, âŸ¨ğ‘ âŸ©, Iğ‘‡ ) (cid:66) ğ¶ğ¶ğ‘Ÿğ‘‘1 (ğœˆ; âŸ¨ğœƒ âŸ©, âŸ¨1/ğ¾1,ğœˆ âŸ©, 0, âŸ¨ğ‘ âŸ©, âŸ¨ğ‘âŸ©, Iğ‘‡ )

to compute ğ‘  = sin(ğœƒ ) and ğ‘ = cos(ğœƒ ). For the logarithm, let Iğ¿ =
(âŸ¨ğ‘‹ğœˆ âŸ©, âŸ¨ğ‘Œğœˆ âŸ©, âŸ¨ğœƒğœˆ âŸ©, I, sğ‘Œ ). Then,

ğ¶ğ¿ğ‘œğ‘” (ğœ“, ğœˆ; âŸ¨ğ‘¥âŸ©, âŸ¨ğ‘™âŸ©, Iğ¿) (cid:66)

(cid:20)ğ¶ğ¶ğ‘Ÿğ‘‘2 (ğœ“, ğœˆ; âŸ¨ğ‘¥âŸ© + âŸ¨1âŸ©, âŸ¨ğ‘¥âŸ© âˆ’ âŸ¨1âŸ©, Iğ¿)
âŸ¨ğ‘™âŸ© âˆ’ 2âŸ¨ğœƒğœˆ âŸ©

(cid:21)

proves ğ‘™ = ln(ğ‘¥). For the square root let Iğ‘† = (âŸ¨ğ‘Œğœˆ âŸ©, âŸ¨ğœƒğœˆ âŸ©, I, sğ‘Œ ), then

ğ¶ğ‘†ğ‘ğ‘Ÿğ‘¡ (ğœ“, ğœˆ; âŸ¨ğ‘¥âŸ©, âŸ¨ğ‘ âŸ©, Iğ‘† ) (cid:66)
ğ¶ğ¶ğ‘Ÿğ‘‘2 (ğœ“, ğœˆ; âŸ¨ğ‘¥âŸ© + âŸ¨1/4ğ¾ 2

2,ğœˆ+1âŸ©, âŸ¨ğ‘¥âŸ© âˆ’ âŸ¨1/4ğ¾ 2

2,ğœˆ+1âŸ©, âŸ¨ğ‘ âŸ©, Iğ‘† )

proves ğ‘  =

âˆš

ğ‘¥.

Finally, we point out that, with minor adjustments to the above
approximations, proofs of hyperbolic trigonometric functions and
ğ‘’ğ‘¥ can be obtained.

Private Sampling with Identifiable Cheaters

Proceedings on Privacy Enhancing Technologies YYYY(X)

6.4 Extending the Domain
Here we extend the domain of approximations, which is necessary
for our sampling applications. We sometimes do not define inputs
such as bit vectors for range proofs and other intermediate values
that are clear from the context or that are already defined in previous
circuits.

Sine and cosine. As shown, sine and cosine can be approximated

in (cid:2)âˆ’ ğœ‹

2 , ğœ‹
2

(cid:3). For ğ‘„ âˆˆ {1, 2, 3, 4} we use the identity

sin (cid:16)
ğ‘„

ğœ‹
2

+ ğœƒ â€²(cid:17)

=

cos(ğœƒ â€²)
âˆ’ sin(ğœƒ â€²)
âˆ’ cos(ğœƒ â€²)
sin(ğœƒ â€²)

ï£±ï£´ï£´ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£´ï£´

ï£³

if ğ‘„ = 1
if ğ‘„ = 2
if ğ‘„ = 3
if ğ‘„ = 4

extend the domain to [0, 2ğœ‹]. Let sğœ‹ , sâ€²
ğ¶ğºğ‘…ğ‘, and Iğ‘‡ğ‘” = (âŸ¨ğœƒ â€²âŸ©, âŸ¨ğ‘  â€²âŸ©, âŸ¨ğ‘ â€²âŸ©, ğ‘„, sğœ‹ , sâ€²

ğœ‹ , Iğ‘‡ ). Let

ğœ‹ be bit vectors as needed for

([ ğ‘—1], [ ğ‘—2], [ ğ‘—3], [ ğ‘—4]) = (âŸ¨ğ‘ â€²âŸ©, âˆ’âŸ¨ğ‘  â€²âŸ©, âˆ’âŸ¨ğ‘ â€²âŸ©, âŸ¨ğ‘  â€²âŸ©)

and

([ğ‘˜1], [ğ‘˜2], [ğ‘˜3], [ğ‘˜4]) = ([ ğ‘—2], [ ğ‘—3], [ ğ‘—4], [ ğ‘—1])

for ğ‘– âˆˆ {1, 2, 3, 4} be literal variable replacements. Circuit

ğ¶ğ‘‡ ğ‘Ÿğº (ğœˆ; âŸ¨ğœƒ âŸ©, âŸ¨ğ‘ âŸ©, âŸ¨ğ‘âŸ©, Iğ‘‡ğ‘”)

(cid:66)

ï£®
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£°

ğ¶ğºğ‘…ğ‘ (âŸ¨âˆ’ ğœ‹

ğ¶ğ‘‡ ğ‘Ÿ (ğœˆ; âŸ¨ğœƒ â€²âŸ©, âŸ¨ğ‘  â€²âŸ©, âŸ¨ğ‘ â€²âŸ©, Iğ‘‡ )
2 âŸ©; âŸ¨ğœƒ â€²âŸ©, sğœ‹ , sâ€²
ğœ‹ )
2 âŸ© âˆ’ âŸ¨ğœƒ â€²âŸ©

2 âŸ©, âŸ¨ ğœ‹
âŸ¨ğœƒ âŸ© âˆ’ ğ‘„ âŸ¨ ğœ‹

(cid:206)4

ğ‘–=1 (ğ‘„ âˆ’ ğ‘–)2 + ([ ğ‘—ğ‘– ] âˆ’ âŸ¨ğ‘ âŸ©)2 + ([ğ‘˜ğ‘– ] âˆ’ âŸ¨ğ‘âŸ©)2

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£»

proves ğ‘  = ğ‘ ğ‘–ğ‘›(ğœƒ ) and ğ‘ = cos(ğœƒ ) in the extended domain.

Natural logarithm. We extend the domain of ln(ğ‘¥) to (0, 1). For
ğ‘¥ â€² âˆˆ [ 1
2 , 1) and non-negative integer ğ‘’ such that ğ‘¥ = 2âˆ’ğ‘’ğ‘¥ â€² âˆˆ
(0, 1). We prove that ğ‘™ = ln(ğ‘¥ â€²) âˆ’ ğ‘’ ln(2) = ln(ğ‘¥). Let Iğ¿ğ‘” =
(ğ‘’, â„, e, sğ‘¥ â€², âŸ¨ğ‘¥ â€²âŸ©, âŸ¨ğ‘™ â€²âŸ©, Iğ¿), then

ğ¶ğ¿ğ‘œğ‘”ğº (ğœ“, ğœˆ; âŸ¨ğ‘¥âŸ©, âŸ¨ğ‘™âŸ©, Iğ¿ğ‘”) (cid:66)

proves our approximation.

ğ¶ğ¿ğ‘œğ‘” (ğœ“, ğœˆ; âŸ¨ğ‘¥ â€²âŸ©, âŸ¨ğ‘™ â€²âŸ©, Iğ¿)
ï£®
ï£¯
ğ¶ğ‘…ğ‘ (ğœ“ âˆ’ 1; âŸ¨ğ‘¥ â€²âŸ© âˆ’ âŸ¨0.5âŸ©, sğ‘¥ â€²)
ï£¯
ï£¯
ğ¶ğ¼ ğ¸ğ‘¥ (ğœ“ âˆ’ 1, 2; ğ‘’, â„, e)
ï£¯
ï£¯
â„âŸ¨ğ‘¥âŸ© âˆ’ âŸ¨ğ‘¥ â€²âŸ©
ï£¯
ï£¯
âŸ¨ğ‘™âŸ© âˆ’ âŸ¨ğ‘™ â€²âŸ© + ğ‘’ âŸ¨ln(2)âŸ©
ï£¯
ï£°

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£»

Square root. Now, for a public bound ğµ > 0 and a private ğ‘¥ âˆˆ
ğ‘¥. Let ğ›¾ = âŒŠlog2 (ğµ)âŒ‹ + 1. We choose
2 , 1) and an integer ğ‘’ âˆˆ [âˆ’ğœ“, ğ›¾] such that ğ‘¥ = 2ğ‘’ğ‘¥ â€², and we

[0, ğµ], we prove that ğ‘  =
ğ‘¥ â€² âˆˆ [ 1
have that

âˆš

âˆš

ğ‘¥ =

(cid:40)2ğ‘’/2âˆš
ğ‘¥ â€²
2(ğ‘’+1)/2(cid:112)ğ‘¥ â€²/2

if ğ‘’ is even
if ğ‘’ is odd.

We break the proof in several circuits to handle different cases. For
that we use bit variables as flags to decide which computation will
be proven. Let ğ‘›ğ‘’ âˆˆ {0, 1} be the â€œnegativity flagâ€ of ğ‘’ and ğ‘’ â€² â‰¥ 0
such that ğ‘’ = (1 âˆ’ ğ‘›ğ‘’ )ğ‘’ â€². Let ğ‘–ğ‘’ âˆˆ {0, 1} be the â€œparity flagâ€ of
ğ‘’, such that ğ‘’ = 2ğ‘“ âˆ’ ğ‘–ğ‘’ for an integer ğ‘“ . We also define ğ‘“ â€² â‰¥ 0
such that ğ‘“ = (1 âˆ’ ğ‘›ğ‘’ )ğ‘“ â€². We first handle the relations between

9

âˆš
ğ‘¥ and ğ‘  â€² = (cid:112)ğ‘¥ â€²/(1 + ğ‘–ğ‘’ ) when ğ‘’ is non-negative, or
ğ‘¥, ğ‘¥ â€², ğ‘  =
equivalently, when ğ‘›ğ‘’ = 0. Let Iğ·1 = (ğ‘™, f, I>>), then our circuit is

Similarly, for Iğ·2 = (â„, e, Iâ€²
scribed by

>>) the case when ğ‘’ is negative is de-

ğ¶ğ‘†ğ·ğ‘œğ‘š1 (ğµ; âŸ¨ğ‘¥âŸ©, âŸ¨ğ‘ âŸ©, âŸ¨ğ‘¥ â€²âŸ©, âŸ¨ğ‘  â€²âŸ©, ğ‘–ğ‘’, ğ‘’ â€², ğ‘“ â€², Iğ·1)
ğ¶ğ‘ƒ >> (ğ›¾; âŸ¨ğ‘¥âŸ©, ğ‘’ â€² + ğ‘–ğ‘’, âŸ¨ğ‘¥ â€²âŸ©, I>>)
ï£®
ï£¯
ğ‘’ â€² âˆ’ 2ğ‘“ â€² + ğ‘–ğ‘’
ï£¯
ï£¯
ğ¶ğ¼ ğ¸ğ‘¥ (ğ›¾, 2; ğ‘“ â€², ğ‘™, f)
ï£¯
ï£¯
âŸ¨ğ‘ âŸ© âˆ’ âŸ¨ğ‘  â€²âŸ©ğ‘™
ï£¯
ï£°

(cid:66)

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£»

ğ¶ğ‘†ğ·ğ‘œğ‘š2 (ğœ“ ; âŸ¨ğ‘¥âŸ©, âŸ¨ğ‘ âŸ©, âŸ¨ğ‘¥ â€²âŸ©, âŸ¨ğ‘  â€²âŸ©, ğ‘–ğ‘’, ğ‘’ â€², ğ‘“ â€², Iğ·2)
ğ¶ğ¼ ğ¸ğ‘¥ (ğœ“ âˆ’ 1, 2; ğ‘’ â€² âˆ’ ğ‘–ğ‘’, â„, e)
ï£®
ï£¯
âŸ¨ğ‘¥ â€²âŸ© âˆ’ â„âŸ¨ğ‘¥âŸ©
ï£¯
ï£¯
ğ‘’ â€² âˆ’ 2ğ‘“ â€² âˆ’ ğ‘–ğ‘’
ï£¯
ï£¯
ğ¶ğ‘ƒ >> (ğœ“ âˆ’ 1; âŸ¨ğ‘ âŸ©, ğ‘“ â€², âŸ¨ğ‘  â€²âŸ©, Iâ€²
ï£¯
ï£°

(cid:66)

>>)

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£»

.

.

Now we describe the main circuit. For Iğ· = (âŸ¨ğ‘¥ â€²âŸ©, âŸ¨ğ‘  â€²âŸ©, ğ‘–ğ‘’, ğ‘’ â€², ğ‘“ â€²)
and Iğ‘†ğ‘” = (ğ‘›ğ‘’, sğ‘¥ â€², Iğ‘†, Iğ·, Iğ·1, Iğ·2) vectors of intermediate values,
we prove ğ‘  =

ğ‘¥ with

âˆš

ğ¶ğ‘†ğ‘ğ‘Ÿğ‘¡ğº (ğœ“, ğœˆ, ğµ; âŸ¨ğ‘¥âŸ©, âŸ¨ğ‘ âŸ©, Iğ‘†ğ‘”)

(cid:66)

ï£®
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£°

ğ¶ğ‘†ğ‘ğ‘Ÿğ‘¡ (ğœ“, ğœˆ; âŸ¨ğ‘¥ â€²âŸ©, âŸ¨ğ‘  â€²âŸ©, Iğ‘† )
ğ‘–ğ‘’ (1 âˆ’ ğ‘–ğ‘’ )
ğ‘›ğ‘’ (1 âˆ’ ğ‘›ğ‘’ )
ğ‘–ğ‘’ âˆ— ğ¶ğ‘…ğ‘ (ğœ“ âˆ’ 2; âŸ¨ğ‘¥ â€²âŸ© âˆ’ âŸ¨0.25âŸ©, sğ‘¥ â€²)
(1 âˆ’ ğ‘–ğ‘’ ) âˆ— ğ¶ğ‘…ğ‘ (ğœ“ âˆ’ 1; âŸ¨ğ‘¥ â€²âŸ© âˆ’ âŸ¨0.5âŸ©, sğ‘¥ â€²)
(1 âˆ’ ğ‘›ğ‘’ ) âˆ— ğ¶ğ‘†ğ·ğ‘œğ‘š1 (ğµ; âŸ¨ğ‘¥âŸ©, âŸ¨ğ‘ âŸ©, Iğ·, Iğ·1)
ğ‘›ğ‘’ âˆ— ğ¶ğ‘†ğ·ğ‘œğ‘š2 (ğœ“, âŸ¨ğ‘¥âŸ©, âŸ¨ğ‘ âŸ©, Iğ·, Iğ·2)

.

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£»

While the circuit above is easier to read, the practical implemen-
tation contains a number of further optimizations to reduce the
number of multiplications. In particular, additional variables are
introduced to avoid multiplying flags such as ğ‘–ğ‘’ with larger vec-
tors such as the output of a ğ¶ğ‘…ğ‘ circuit. This introduces additional
variables, e.g., ğ‘–ğ‘’ âˆ— ğ¶ğ‘…ğ‘ (ğœ“ âˆ’ 2; âŸ¨ğ‘¥ â€²âŸ© âˆ’ âŸ¨0.25âŸ©, sğ‘¥ â€²) would become
ğ‘–ğ‘’ (ğ‘¥ â€² âˆ’ ğ‘¥ â€²

ğ‘ğ‘¢ğ‘¥ ) and ğ¶ğ‘…ğ‘ (ğœ“ âˆ’ 2; âŸ¨ğ‘¥ â€²

ğ‘ğ‘¢ğ‘¥ âŸ© âˆ’ âŸ¨0.25âŸ©, sğ‘¥ â€²

ğ‘ğ‘¢ğ‘¥ ).

7 THE LAPLACE DISTRIBUTION
7.1 Private Laplace Sampling

Protocol 6 (private drawing from Laplace). First, party ğ‘ƒ1
privately draws ğ‘ 0 and ğ‘â€² uniformly at random in [0, ğ¿) with ğ¿ suf-
ficiently large (Protocol 2). Then, ğ‘ƒ1 computes ğ‘ = âˆ’ğ‘ log(1 âˆ’ ğ‘â€²/ğ¿),
ğ‘  = 2(ğ‘ 0 mod 2) âˆ’ 1 and ğ‘Ÿ = ğ‘ ğ‘, and provides a ZKP for these relations
(in Section 6.3 we showed a ZKP for the logarithm function, in Section
6.1 for approximate division).

As Protocol 2 verifiably draws random numbers uniformly and
for the other computations in Protocol 6 a ZKP is provided, Protocol
6 verifiably draws random numbers from the ğ¿ğ‘ğ‘ (ğ‘) distribution.
An alternative method could be based on work by [26] (see also
[19] for related ideas). In particular, [26] proposes a technique to
sample directly from the exponential distribution using a range of
independent biased coin flips. The main advantage of our method
is that we only need one uniformly sampled public random number,
which strongly reduces the communication cost.

This remark also holds for the protocol of Laplace hidden draws

which we will present in Section 7.2 below.

Proceedings on Privacy Enhancing Technologies YYYY(X)

CÃ©sar Sabater, Florian Hahn, Andreas Peter, and Jan Ramon

7.2 Hidden Laplace Sampling
We can also make hidden draws from the Laplace distribution, i.e.,
drawing a Laplace-distributed random number ğ‘Ÿ as a secret share
âŸ¦ğ‘Ÿ âŸ§. For this, we build on the basic operations discussed in Section
2.5.

(cid:19)

First, we observe that one can sample a sign ğ‘  uniformly from
{âˆ’1, 1} as follows: the parties apply Protocol 3 to draw a secret
shared random number uniformly distributed in Zğ‘ , obtaining the
(cid:19)
(cid:18)
ğ‘¡ 2
sharing âŸ¦ğ‘¡âŸ§, next they multiply the sharing with itself to obtain
to reveal ğ‘¡ 2, and finally they multiply âŸ¦ğ‘¡âŸ§ with the
and open
(cid:20)
public constant 1/
âˆˆ {âˆ’1, 1}. Drawing
ğ‘¡/
a secret shared random bit ğ‘ âˆˆ {0, 1} is then just drawing a sign
âŸ¦ğ‘ âŸ§ and computing âŸ¦ğ‘âŸ§ = (âŸ¦ğ‘ âŸ§ + 1) /2 (this is protocol ğ‘…ğ´ğ‘2 in
[23]).

ğ‘¡ 2 to obtain âŸ¦ğ‘ âŸ§ =

(cid:18)
ğ‘¡ 2

ğ‘¡ 2

âˆš

âˆš

(cid:21)

The Cordic algorithm for logarithm computation described in
Section 6.2 requires only additions, bit shifts and comparisons (when
setting ğœ‰ğ‘– = sign (âˆ’ğ‘Œğ‘–âˆ’1)). While it does not directly use multipli-
cations, implementations of bit operations and comparisons, e.g.,
as in [23], often are using multiplications so the use of multiplica-
tions cannot be fully avoided. Alternative strategies to compute the
logarithm suffer from similar challenges.

As in Section 7.1, we want to draw a number ğ‘â€² uniformly from
[0, ğ¿), compute ğ‘ = âˆ’ğ‘ log(1 âˆ’ ğ‘â€²/ğ¿) and multiply it with a random
sign ğ‘  to get the random number ğ‘ğ‘  distributed according to ğ¿ğ‘ğ‘ (ğ‘).
To compute log(ğ‘¥), Cordic expects ğ‘¥ âˆˆ [1/4, 1), so before applying
Cordic we may need to scale its input to fit this interval.

We set ğ¿ = 2ğ‘™ for some sufficiently large integer ğ‘™ and generate ğ‘â€²
(cid:21)
(cid:20)
2ğ‘– where ğ‘ (ğ‘–) are random
ğ‘ (ğ‘–)

as an ğ‘™-bit number, i.e., âŸ¦ğ‘â€²âŸ§ = (cid:205)ğ‘™âˆ’1
ğ‘–=0
bits.

(cid:19)

(cid:19)

(cid:19)(cid:20)

(cid:18)
â„â€²
ğ‘–

(cid:18)
â„â€²
ğ‘–

We can find the highest zero bit of ğ‘â€² as follows: set â„ğ‘™ = 0, â„â€²

ğ‘™ = 1
and ğ‘ (âˆ’1) = 0, and for ğ‘– = ğ‘™ âˆ’ 1 . . . âˆ’ 1, set
âŸ¦1 âˆ’ â„ğ‘–+1âŸ§
=
(cid:21)
1 âˆ’ ğ‘ (ğ‘–)
. The meaning of â„ğ‘– then is â€™bit ğ‘– is the
and âŸ¦â„ğ‘– âŸ§ =
highest 0-bitâ€™, and the meaning of â„â€²
ğ‘– is â€™the bits higher than bit ğ‘–
are all onesâ€™. Exactly one â„ğ‘– equals 1 and all others are 0 among
ğ‘– = âˆ’1 . . . ğ‘™ âˆ’ 1. We then can write log(1 âˆ’ ğ‘â€²/ğ¿) = ğ‘h + log(ğ‘¥) with
(cid:18)
ğ‘h

ğ‘–=0 âŸ¦â„ğ‘– âŸ§ log(2ğ‘–+1âˆ’ğ‘™ ) and ğµğ¼ğ‘‡ ğ‘† (ğ‘¥, (ğ‘¥ (ğ‘–) )ğ‘™

ğ‘–=0) where

(cid:18)
â„â€²
ğ‘–+1

= (cid:205)ğ‘™âˆ’1

(cid:19)

(âŸ¦ğ‘¥ (ğ‘–) âŸ§)ğ‘™

ğ‘–=0 = Bit-add(2ğ‘™ , (âŸ¦ğ‘¥ (ğ‘–)

âˆ’ âŸ§)ğ‘™âˆ’1
ğ‘–=0 )

and âŸ¦ğ‘¥ (ğ‘–)

âˆ’ âŸ§ = (cid:205)ğ‘™âˆ’1

ğ‘—=0 âŸ¦â„ ğ‘— âŸ§âŸ¦ğ‘ (ğ‘–+ğ‘—+1âˆ’ğ‘™) âŸ§ (with ğ‘ (ğ‘–) = 0 for ğ‘– < 0).

Now we can apply Cordic on ğ‘¥. Cordic needs additions (using
the Bit-add protocol), bit shifts (moving bits to the right and dupli-
cating the highest bit), the sign(Â·) function (check the highest bit)
and negation (invert all bits and add 1).

Protocol 7 (hidden drawing from Laplace). One can verifi-
ably draw a hidden Laplace-distributed random number by following
the steps explained above, and by providing ZKP for all computations.
The ZKP are similar to those for private sampling, where parts of
secret shares are transfered between parties, the parties can agree on
the commitment which will represent the shared number.

8 THE GAUSSIAN DISTRIBUTION
In this section we elaborate several strategies to sample from the
Gaussian distribution.

10

In particular, we are interested in protocols such that upon termi-
nation one party has a private number ğ‘¦ âˆˆ QâŸ¨ğ‘,ğœ“ âŸ© and has provided
a zero knowledge argument that ğ‘¦ âˆ¼ N (ğœ‡, ğœ2) for some public ğœ‡
and ğœ.

All methods require as a subprotocol sampling uniformly dis-
tributed numbers. Therefore all our protocols for private drawing
numbers from the Gaussian distribution follow the same high-level
structure:

(1) use Protocol 2 to verifiably draw uniformly distributed num-

ber(s),

(2) transform the uniformly distributed number(s) into Gaussian

distributed number(s), and

(3) use an arithmetic circuit matching this transformation to-
gether with compressed Î£-protocols (see Section 2.4) to prove
the transformation.

We implement ZKPs of the correct execution of Gaussian draws.
The sampling methods we implement are (1) the central limit theo-
rem approach (averaging over uniform samples), (2) the Box MÃ¼ller
method [12], (3) the Polar Method [39], (4) the inversion method
using a series expansion for erf âˆ’1 [18], and (5) the inversion method
using a fractional polynomial to approximate erf âˆ’1 [28].

8.1 The Central Limit Theorem Method
The uniform distribution over the interval [0, ğ¿) has variance ğ¿2/12.
Let a party privately draw ğ‘ random numbers {ğ‘¥ğ‘– }ğ‘
ğ‘–=1 uniformly
(cid:17).
(cid:16)
distributed over [0, ğ¿), and compute ğ‘¥ = ğœ‡ + ğœ
ğ‘¥ğ‘– âˆ’ ğ¿
(cid:205)ğ‘
ğ‘–=1
2
ğ¿
Then, ğ‘¥ is N (ğœ‡, ğœ2) distributed. For a ZKP for this relation between
ğ‘¥ and the ğ‘¥ğ‘– we only need the homomorphic property of the Ped-
ersen commitment (for the additions and the multiplication with
a constant) and a range proof (for the rounding). This method
is essentially the technique of [26] to sample from the Gaussian
distribution.

12
ğ‘

âˆš
âˆš

8.2 The Box MÃ¼ller Method
The Box MÃ¼ller method [12] consists of drawing two uniform sam-
ples ğ‘ˆ1 and ğ‘ˆ2 in the interval (0, 1) and to compute

ğœŒ = (cid:112)âˆ’2 ln(ğ‘ˆ1), ğ‘‹1 = ğœŒ cos(2ğœ‹ğ‘ˆ2)

ğ‘ğ‘›ğ‘‘ ğ‘‹2 = ğœŒ sin(2ğœ‹ğ‘ˆ2).

Then, ğ‘‹1 and ğ‘‹2 are distributed according to N (0, 1). Now we use
circuits of elementary functions defined in Section 6 to construct
our proof. Recall parameters ğœ“ and the number of Cordic iterations
ğœˆ defined therein. Let

Iğµğ‘€ = (s1, s2, s3, âŸ¨ğ‘ âŸ©, âŸ¨ğ‘âŸ©, Iğ‘‡ğ‘”, âŸ¨ğ‘ğœ‹ âŸ©, âŸ¨ğ‘‹ â€²
1, Uâ€²

Iğ‘†ğ‘”, âŸ¨ğœŒâŸ©, Iğ¿ğ‘”, âŸ¨ğ‘™âŸ©, aâ€²

1âŸ©, âŸ¨ğ‘‹ â€²
2âŸ©
2 , Uâ€²â€²
1 , aâ€²â€²
2, aâ€²â€²

2, Uâ€²

1, aâ€²

1 , Uâ€²â€²
2 )

Private Sampling with Identifiable Cheaters

Proceedings on Privacy Enhancing Technologies YYYY(X)

be a vector containing all intermediate values of the computation.
Then the approximation circuit is

extra samples is negligible. To obtain a distribution with different
mean and variance, we scale ğ‘‰1 and ğ‘‰2 with addition and product.

(cid:66)

1, Uâ€²
2)
1 , Uâ€²â€²
2 )

ğ¶ğµğ‘€ (ğœ“, ğœˆ, ğ‘§1, ğ‘§2; âŸ¨ğ‘ˆ1âŸ©, âŸ¨ğ‘ˆ2âŸ©, âŸ¨ğ‘‹1âŸ©, âŸ¨ğ‘‹2âŸ©, Iğµğ‘€ )
ğ¶ğ‘€ğ‘œğ‘‘ (2ğœ“ âˆ’ 1, ğ‘§1; ğ‘1, âŸ¨ğ‘ˆ1âŸ© âˆ’ 1, aâ€²
2, Uâ€²
ï£®
ï£¯
ğ¶ğ‘€ğ‘œğ‘‘ (2ğœ“ âˆ’ 1, ğ‘§2; ğ‘2, âŸ¨ğ‘ˆ2âŸ© âˆ’ 1, aâ€²â€²
2 , Uâ€²â€²
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£°

1, aâ€²
1 , aâ€²â€²
ğ¶ğ¿ğ‘œğ‘”ğº (ğœ“, ğœˆ; âŸ¨ğ‘ˆ1âŸ©, âŸ¨ğ‘™âŸ©, Iğ¿ğ‘”)
ğ¶ğ‘†ğ‘ğ‘Ÿğ‘¡ğº (ğœ“, ğœˆ, 2ğœ“ ln(2); âˆ’2âŸ¨ğ‘™âŸ©, âŸ¨ğœŒâŸ©, Iğ‘†ğ‘”)
ğ¶ğ‘ƒğ‘Ÿğ‘œğ‘‘ (ğœ“ ; 2âŸ¨ğœ‹âŸ©, âŸ¨ğ‘ˆ2âŸ©, âŸ¨ğ‘ğœ‹ âŸ©, s1)
ğ¶ğ‘‡ ğ‘Ÿğº (ğœˆ; âŸ¨ğ‘ğœ‹ âŸ©, âŸ¨ğ‘ âŸ©, âŸ¨ğ‘âŸ©, Iğ‘‡ğ‘”)
ğ¶ğ‘ƒğ‘Ÿğ‘œğ‘‘ (ğœ“ ; âŸ¨ğœŒâŸ©, âŸ¨ğ‘âŸ©, âŸ¨ğ‘‹ â€²
1âŸ©, s2)
ğ¶ğ‘ƒğ‘Ÿğ‘œğ‘‘ (ğœ“ ; âŸ¨ğœŒâŸ©, âŸ¨ğ‘ âŸ©, âŸ¨ğ‘‹ â€²
2âŸ©, s3)
Private values ğ‘1 and ğ‘2 and public challenges ğ‘§1 and ğ‘§2 are used
in the modular proofs of circuit ğ¶ğ‘€ğ‘œğ‘‘ to generate ğ‘ˆ1 and ğ‘ˆ2 with
Protocol 2. To obtain a sample with standard deviation different
than 1, the resulting samples can be scaled with an extra ğ¶ğ‘ƒğ‘Ÿğ‘œğ‘‘
circuit. Different mean requires an extra addition gate.

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£»

.

8.3 The Polar Box-MÃ¼ller Method
The polar method [36] is an optimization of Box-MÃ¼ller that avoids
the computation of sine and cosine by the use of rejection sampling.
It samples two uniform values ğ‘‰1 and ğ‘‰2 in the (âˆ’1, 1) interval, and
keeps the result only if 0 < ğ‘‰ 2
1 + ğ‘‰ 2
2 â‰¤ 1. Otherwise ğ‘‰1 and ğ‘‰2 are
re-sampled. For non rejected ğ‘‰1 and ğ‘‰2 it computes
ğ›¼ = ğ‘‰ 2

(cid:112)âˆ’2 ln(ğ›¼)/ğ›¼ .

(cid:112)âˆ’2 ln(ğ›¼)/ğ›¼,

ğ‘ğ‘›ğ‘‘ ğ‘Œ2 = ğ‘‰2

ğ‘Œ1 = ğ‘‰1

1 + ğ‘‰ 2
2 ,

ğ‘Œ1 and ğ‘Œ2 have distribution N (0, 1).

In the private sampling, if ğ‘‰1 and ğ‘‰2 are rejected, the prover can
just reveal them and start new uniform draws until acceptance,
when it proves the correctness of accepting pairs. As in Box MÃ¼ller,
parameters ğœˆ and ğœ“ define our elementary function approximations,
and ğ‘1, ğ‘2, ğ‘§1, ğ‘§2 are used to generate ğ‘‰1 and ğ‘‰2 in Protocol 2. Let

Iğ‘ƒğ‘œğ‘™ = (âŸ¨ğ‘ âŸ©, Iğ‘†ğ‘”, âŸ¨ğ‘‘âŸ©, âŸ¨ğ›¼âŸ©, âŸ¨ğ‘™âŸ©, Iğ¿ğ‘”, s6, s5, s4, s3, s2, s1, âŸ¨ğ›¼âŸ©,
1, aâ€²
1 , Vâ€²â€²
2 )
be a vector of intermediate computation values, then the imple-
mented circuit is

1 âŸ©, vâ€², v, aâ€²

2 âŸ©, âŸ¨ğ‘‰ â€²

2 , Vâ€²â€²

1 , aâ€²â€²

2, aâ€²â€²

1, Vâ€²

2, Vâ€²

âŸ¨ğ‘‰ â€²

(cid:66)

aâ€²
1, aâ€²

1, Vâ€²
2)

aâ€²â€²
1 , aâ€²â€²

1 , Vâ€²â€²
2 )

ğ¶ğ‘ƒğ‘Ÿğ‘œğ‘‘ (ğœ“ ; âŸ¨ğ‘‰1âŸ©, âŸ¨ğ‘‰1âŸ©, âŸ¨ğ‘‰ â€²
1 âŸ©, v)
ğ¶ğ‘ƒğ‘Ÿğ‘œğ‘‘ (ğœ“ ; âŸ¨ğ‘‰2âŸ©, âŸ¨ğ‘‰2âŸ©, âŸ¨ğ‘‰ â€²
2 âŸ©, vâ€²)
âŸ¨ğ›¼âŸ© âˆ’ âŸ¨ğ‘‰ â€²
1 âŸ© âˆ’ âŸ¨ğ‘‰ â€²
2 âŸ©

ğ¶ğ‘ƒğ‘œğ‘™ (ğœ“, ğœˆ, ğ‘§1, ğ‘§2; âŸ¨ğ‘‰1âŸ©, âŸ¨ğ‘‰2âŸ©, âŸ¨ğ‘Œ1âŸ©, âŸ¨ğ‘Œ2âŸ©, Iğ‘ƒğ‘œğ‘™ )
ğ¶ğ‘€ğ‘œğ‘‘ (22ğœ“ âˆ’ 2, ğ‘§1; ğ‘1, âŸ¨ğ‘‰1âŸ© + âŸ¨1âŸ© âˆ’ 1,
2, Vâ€²
ğ¶ğ‘€ğ‘œğ‘‘ (22ğœ“ âˆ’ 2, ğ‘§2; ğ‘2, âŸ¨ğ‘‰2âŸ© + âŸ¨1âŸ© âˆ’ 1,
2 , Vâ€²â€²

ï£®
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ğ¶ğºğ‘…ğ‘ (1, âŸ¨1âŸ© âˆ’ 1; âŸ¨ğ›¼âŸ©, s1, s2)
ï£¯
ï£¯
ğ¶ğ¿ğ‘œğ‘”ğº (ğœ“, ğœˆ; âŸ¨ğ›¼âŸ©, âŸ¨ğ‘™âŸ©, Iğ¿ğ‘”)
ï£¯
ï£¯
ğ¶ğ·ğ‘–ğ‘£ (ğœ“ ; âˆ’2âŸ¨ğ‘™âŸ©, âŸ¨ğ›¼âŸ©, âŸ¨ğ‘‘âŸ©, s3, s4)
ï£¯
ï£¯
ğ¶ğ‘†ğ‘ğ‘Ÿğ‘¡ğº (ğœ“, ğœˆ, 2ğœ“ +1ğœ“ ln(2); âŸ¨ğ‘‘âŸ©, âŸ¨ğ‘ âŸ©, Iğ‘†ğ‘”)
ï£¯
ï£¯
ğ¶ğ‘ƒğ‘Ÿğ‘œğ‘‘ (ğœ“ ; âŸ¨ğ‘ âŸ©, âŸ¨ğ‘‰1âŸ©, âŸ¨ğ‘Œ1âŸ©, s5)
ï£¯
ï£¯
ğ¶ğ‘ƒğ‘Ÿğ‘œğ‘‘ (ğœ“ ; âŸ¨ğ‘ âŸ©, âŸ¨ğ‘‰2âŸ©, âŸ¨ğ‘Œ2âŸ©, s6)
ï£¯
ï£°
To avoid multiple interactions due to rejection, Protocol 2 is set
to draw a sufficiently large number of uniform samples such that at
least one pair is not rejected with high probability. The cost of the

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£»

.

8.4 The Inversion Method
Inverting eq. (1) we get

ğ¹ âˆ’1
N (ğ‘¥) =

âˆš

2erfâˆ’1 (2ğ‘¥ âˆ’ 1).

There are many numerical strategies to approximate either erf or
erfâˆ’1, of which we implemented two.

A first strategy due to [18] is to use the series

erf(ğ‘¥) =

2
âˆš
ğœ‹

âˆ
(cid:213)

(âˆ’1)ğ‘™ ğ‘¥ 2ğ‘™+1
ğ‘™!(2ğ‘™ + 1)

.

ğ‘™=0
However, its approximation error gets larger as ğ‘¥ gets bigger. There-
fore, when ğ‘¥ is large, it is better approximate erfc(ğ‘¥) = 1 âˆ’ erf(ğ‘¥)
using the series

erfc(ğ‘¥) =

ğ‘’âˆ’ğ‘¥ 2
âˆš
ğœ‹
ğ‘¥

(cid:32)ğ¿âˆ’1
(cid:213)

ğ‘™=0

(cid:33)

(âˆ’1)ğ‘™ (2ğ‘™ âˆ’ 1)!!
(2ğ‘¥ 2)ğ‘™

+ ğ‘…ğ¿ (ğ‘¥),

where

ğ‘…ğ¿ (ğ‘¥) â‰¤

ğ‘’âˆ’ğ‘¥ 2
âˆš
ğœ‹
ğ‘¥

(2ğ¿ âˆ’ 1)!!
(2ğ‘¥ 2)ğ¿

is the remainder, ğ‘™!! = 1 for ğ‘™ < 1 and (2ğ‘™ âˆ’ 1)!! = (cid:206)ğ‘™
ğ‘–=1 (2ğ‘– âˆ’ 1). The
number of terms ğ¿ of the series is tuned for minimal error. If we
set ğµ to be the maximum error of our approximation, we use erf if

(cid:113) ln(1/ğµ)
2

+ 0.788 and erfc otherwise. The ZKP of this method
ğ‘¥ <
proves that ğ‘¦ = erf(ğ‘¥) or 1 âˆ’ ğ‘¦ = erfc(ğ‘¥) depending on the domain
of ğ‘¥.

A second strategy is proposed in [28] and uses a rational approx-

imation. Therein, erf âˆ’1 is computed by

erfinvSP (ğ‘¥) =

(cid:40)ğ‘¥ğ‘1 (ğ‘¤)
ğ‘¥ğ‘2 (ğ‘ )
âˆš
where ğ‘¤ = âˆ’ log(1âˆ’ğ‘¥ 2), ğ‘  =
ğ‘¤ and ğ‘1 and ğ‘2 are two polynomials
of degree 8. We use Cordic, product and range ZKPs to prove its
computation.

if ğ‘¤ â‰¤ 5 (central region)
if ğ‘¤ > 5 (tail region)

8.5 Hidden Drawing
For the several strategies for sampling the Gaussian distribution
described above, one can construct a protocol based on secret shar-
ing for hidden sampling. Similar considerations apply as for the
discussion in Section 7.2. As an example, we show a protocol using
the Central Limit Theorem approach.

Protocol 8. Let ğ‘ /12 be a power of 4. For ğ‘– = 0 . . . ğ‘™ âˆ’ 1 and
ğ‘— âŸ§. This yields ğ‘ random
ğ‘—=1 in the interval [0, 2ğ‘™ ). For ğ‘— âˆˆ [ğ‘ ] and ğ‘– = ğ‘™ . . . ğ‘™ +
ğ‘— = 0. Let (âŸ¦ğ‘¦ (ğ‘–)
and for

ğ‘— = 1 . . . ğ‘ , draw a random bit sharing âŸ¦ğ‘¥ (ğ‘–)
numbers {ğ‘¥ ğ‘— }ğ‘
log2 ğ‘ , set ğ‘¥ (ğ‘–)
ğ‘— = 2 . . . ğ‘ let
(âŸ¦ğ‘¦ (ğ‘–)
Finally let âŸ¦ğ‘Ÿ âŸ§ = (cid:205)ğ‘™+log2 ğ‘
proximates N (2ğ‘™ âˆš

2ğ‘–âˆ’log2 (ğ‘ /12)/2. Then, ğ‘Ÿ ap-
3ğ‘ , 2ğ‘™ ). The computations can be made verifiable

= Bit-add((âŸ¦ğ‘¦ (ğ‘–)

ğ‘—âˆ’1âŸ§)
ğ‘¦ (ğ‘–)
ğ‘

ğ‘–=log2 (ğ‘ /12)/2

ğ‘™+log2 ğ‘
ğ‘–=0

ğ‘™+log2 ğ‘
ğ‘–=0

ğ‘™+log2 ğ‘
ğ‘–=0

ğ‘™+log2 ğ‘
ğ‘–=0

ğ‘™+log2 ğ‘
ğ‘–=0

= (âŸ¦ğ‘¥1âŸ§)

, (âŸ¦ğ‘¥ (ğ‘–)

1 âŸ§)

ğ‘— âŸ§)

ğ‘— âŸ§)

).

11

Proceedings on Privacy Enhancing Technologies YYYY(X)

CÃ©sar Sabater, Florian Hahn, Andreas Peter, and Jan Ramon

using a ZKP where parties send a number to each other can agree on
using the same commitment.

9 EVALUATION
In this section, we present an empirical comparison of several
methods to privately sample from the Gaussian distribution. We
will publish code to reproduce all experiments together with the
final version of this paper.

9.1 Setup
We evaluate the costs of the methods presented in Section 8. Namely,
the Central Limit Theorem approach (CLT), the Box MÃ¼ller (BM),
the Polar Method (PolM) and the inversion method. In the latter,
we evaluate the two described strategies: using series (InvM-S) and
rational approximations (InvM-R). Samples are generated for the
N (0, 1) distribution.

We evaluate the cost of each method instantiated for several
parameters against the statistical quality of the generated samples.
For the computational cost we measure the exponentiations in G
(GEX), which dominate the computation. The total communication
cost is the number of elements of G and Zğ‘ sent (see Section 2.4).
To measure the statistical quality, we generate 107 samples and
measure the Mean Squared Error (MSE) from the ideal Gaussian
CDF.

The varying parameter for BM and PolM is the number of itera-
tions ğœˆ of their Cordic approximations, which is chosen between 2
and 14. For CLT we vary the number of averaged uniform terms
between 2 and 400. For InvM-R, the number of terms of the approxi-
mation series is changed in order to obtain different approximations
with errors between 0.5 and 2âˆ’20. The rational approach InvM-R
has no varying parameter. The representation parameter ğœ“ which
defines QâŸ¨ğ‘,ğœ“ âŸ© is chosen to be the smallest as allowed by BM, PolM,
InvM-S due to approximation constraints, and for CLT is set to
optimize the quality/cost tradeoff .

9.2 Results
Figure 1 shows the communication costs, i.e., the number of el-
ements of G required to prove one Gaussian draw. Note that, as
described in Section 2.4, 6 elements of Zğ‘ must be added to ob-
tain the final cost. If high precision isnâ€™t important, CLT performs
well, but in general PolM, BM and Inv-R give the best precision
for a given computational investment. The Inv-R method is much
simpler but canâ€™t be tuned to other precisions.

Figure 2 shows the number of GEX to prove (by the party who
draws the number) or to verify (by another party) one Gaussian
draw. Here too, BM and PolM are the most efficient methods as
soon as a good statistical quality is required. We note that, as the
communication cost is logarithmic in the number of inputs and
multiplication gates, several parameter settings give different points
in Figure 2 but may have the same communication cost, so in Figure
1 we just show the proof with best statistical quality.

For illustration, if we implement Pedersen commitments using
the secp256k1 1 elliptic curve, we obtain 128 bit security and an
element of G can be represented with 257 bits. One GEX using this

1See https://www.secg.org/SEC2-Ver-1.0.pdf and https://github.com/bitcoin-core/
secp256k1

Figure 1: (Comm. costs) Required Group Elements for one
sample against the MSE for BM, PolM, InvM and CLT ap-
proaches.

(a) Proving cost.

(b) Verification cost.

Figure 2: (Comp. costs) Required group exponentiations for
one sample against the MSE for BM, PolM, InvM and CLT
approaches. Costs in the left side plots are in logarithmic
scale. The right side plots are zooms of their left plots, in
linear scale and with a detailed view on the most efficient
methods.

curve takes no more than 30 microseconds on an Intel Core i7-6600U
at 2.60 GHz CPU. With BM, PolM and InvM-R, a sample with MSE
< 2âˆ’20 requires less than 900 Bytes of communication. With PolM,
such sample takes less than 360 milliseconds (ms) to prove and 75
ms for its verification. While CLT quickly gets very expensive, if
quality is less important and an MSE > 2âˆ’13 is satisfactory, it is
the most efficient approach. A proof of a sample using CLT with
MSE 0.01 can be generated in less than 10 ms, verified in 3 ms and
has a size of 482 Bytes. We also note that it is possible to further
optimize our implementation using special-purpose algorithms [46]
to compute multiple exponentiations in the form gb.

Finally, in Figure 3 we show the gap in the communication cost
between our PolM and CLT sampling techniques implemented
with classic (non-compressed) Î£-protocols [21, 22] to the presented
compressed techniques.

12

Private Sampling with Identifiable Cheaters

Proceedings on Privacy Enhancing Technologies YYYY(X)

Even if the corrupted parties would collect all noise they have
ğœ‚ğ‘– and subtracts it from Ë†ğœƒ to obtain
contributed ğœ‚ğ‘ğ‘œğ‘™ğ‘™ = (cid:205)ğ‘– âˆˆPğ‘ğ‘œğ‘Ÿ
ğœƒğ‘ğ‘œğ‘™ğ‘™ = Ë†ğœƒ âˆ’ ğœ‚ğ‘ğ‘œğ‘™ğ‘™ /ğ‘›, then there is still Gaussian noise with variance
1âˆ’ğœŒ âˆ’ ğœŒ ğœ 2
ğœ 2
1âˆ’ğœŒ = ğœ2 left on their best estimation of ğœƒ . This strategy,
which adopts some ideas from [26], works best for Gaussian noise,
as the sum of Gaussian distributions is again a Gaussian distribution.

Protocol 10 (DP learning using hidden sampling). Let all
parties ğ‘ƒğ‘– (with ğ‘– âˆˆ [ğ‘›]) represent their private number ğ‘¥ğ‘– as a shared
secret. Let the parties next together verifiably drawn a hidden random
number ğœ‚, i.e., a random number they obtain only as a shared secret.
Finally, let them sum the secret shares and reveal Ë†ğœƒ = (cid:205)ğ‘›

ğ‘–=1 ğ‘¥ğ‘– + ğœ‚

The advantage of this protocol is that no parties see ğœ‚ or parts of
it, so it is impossible to get back towards the sensitive statistic ğœƒ . On
the other hand, the full computation needs to be performed through
multi-party computations, e.g., using shared secrets, which is clearly
more expensive than the ZKPs which are needed in Protocol 9,
especially as compressed Î£-protocols allow for ZKPs of size only
logarithmic in the circuit size while calculations on secret shares
have a linear communication cost.

As such drawing of random noise is a basic building block and
needs to be performed repeatedly by secure federated differentially
private machine learning algorithms, being able to draw from these
probability distributions with low communication cost is essential
to make algorithms more efficient.

Issues of finite precision. The work of [42] shows the impact that
finite precision approximation of continuous distributions can have
on DP guarantees. As explained in [42, Sec. 5.2], these vulnerabili-
ties can be overcome by appropriately adjusting the precision and
truncating the outcome after the noise is added to private values.
This can be achieved in our protocols by using the correct precision
parameters and range proofs.

To overcome vulnerabilities of finite precision approximations,
other lines of work have explored the use of discrete distributions
[17, 34]. These methods require in expectation comparable compu-
tational effort as our protocols. However, sampling from a discrete
distribution requires in the worst case many iterations which results
in longer zero-knowledge proofs.

11 CONCLUSION
We have presented novel methods for drawing random numbers in
a verifiable way in a public, private and hidden setting. We applied
the ideas to the Laplace and Gaussian distribution, and evaluated
several alternatives to sample from the Gaussian distribution.

We see several interesting directions for future work. First, we
hope to develop novel strategies to let our methods scale better
when in the course of an algorithm many random numbers are
needed. Second, we would like to develop new methods which
allow for more efficient sampling in the hidden setting where the
random numbers are output as shared secrets. In particular, our
current methods based on generic secret sharing techniques require
multiple rounds of computation and communication, it may be
possible to develop more efficient special-purpose strategies.

Figure 3: (Comparison w. classic Î£-protocols) Required Group El-
ements for one sample against the MSE using compressed
and classic Î£-protocols for PolM (left) and CLT (right).

10 APPLICATION: DIFFERENTIALLY

PRIVATE MACHINE LEARNING

(cid:205)ğ‘›

ğ‘–=1 ğ‘¥ğ‘– .

An important application of verifiable sampling can be found in
the field of federated machine learning under differential privacy.
Consider parties P = {ğ‘ƒğ‘– }ğ‘›
ğ‘–=1 where each party ğ‘ƒğ‘– has some sensitive
private data ğ‘¥ğ‘– . The parties P want to keep their data ğ‘¥ğ‘– private but
want to collaborate to obtain statistical information ğœƒ of common
interest. For example, assume that ğ‘¥ğ‘– âˆˆ R and the parties in P would
like to compute ğœƒ = 1
ğ‘›

Even if no inputs nor intermediate results are revealed, com-
puting and sharing the exact statistic ğœƒ may impact privacy. For
example, suppose thet ğ‘¥ğ‘– = 1 if ğ‘ƒğ‘– likes a particular idea or ğ‘¥ğ‘– = 0
if ğ‘ƒğ‘– doesnâ€™t like it. It may turn out that no party likes the idea of
interest, in which case we would get ğœƒ = 0. If we publish that ğœƒ = 0
no party can claim anymore that it liked the idea, so its privacy is
lost. Statistical notions of privacy, such as differential privacy [27],
add noise to guarantee the privacy of the individuals independently
of the output. In particular, let ğœƒ be a function mapping datasets on
values in X. We say datasets are adjacent if they differ in the data
of only one party. Then, we say a randomized algorithm ğ´ is (ğœ–, ğ›¿)-
differentially private (DP) if for any two adjacent datasets ğ·1 and
ğ·2 and for any subset ğ‘‹ âˆˆ X, ğ‘ƒ (ğ´(ğ·1) âˆˆ ğ‘‹ ) â‰¤ ğ‘’ğœ– ğ‘ƒ (ğ´(ğ·2) âˆˆ ğ‘‹ ) +ğ›¿.
ğ´ is ğœ–-DP if it is (ğœ–, 0)-DP.

The most common strategy to make information DP before pub-
lication is to add noise from appropriately scaled Laplace or Gauss-
ian distributions. For example, consider again the above example
where the parties in P want to average their private ğ‘¥ğ‘– . Assume
that âˆ€ğ‘– âˆˆ [ğ‘›] : 0 â‰¤ ğ‘¥ğ‘– â‰¤ 1. Then, for any ğœ– > 0, if we set Ë†ğœƒ = ğœƒ + ğœ‚
with ğœ‚ âˆ¼ Lap(1/ğœ–) there holds that Ë†ğœƒ is ğœ–-DP. Alternatively, for any
ğœ– > 0 and ğ›¿ > 0, if we set Ë†ğœƒ = ğœƒ + ğœ‚ with ğœ‚ âˆ¼ N (0, 2ln(1.25/ğ›¿)/ğœ–2)
there holds that Ë†ğœƒ is (ğœ–, ğ›¿)-DP.

It is important that no party knows the added noise ğœ‚, because
knowing both Ë†ğœƒ and ğœ‚ would allow to reconstruct ğœƒ = Ë†ğœƒ âˆ’ ğœ‚. We
present two protocols, one privately drawing random numbers,
which produces a less accurate result, and one based on the more
expensive hidden drawing which has optimal precision.

Protocol 9 (DP learning using private sampling). Let Pğ‘ğ‘œğ‘Ÿ âŠ‚
P be the set of corrupted parties of size at most ğœŒğ‘› (with 0 â‰¤ ğœŒ < 1). As
described in Section 8, let all parties ğ‘ƒğ‘– (ğ‘– âˆˆ [ğ‘›]) privately verifiably
draw a Gaussian random number ğœ‚ âˆ¼ N (0, ğœ2/ğ‘›(1 âˆ’ ğœŒ)), where
noise with variance ğœ2 on ğœƒ would be sufficient to achieve the desired
ğ‘–=1 (ğ‘¥ğ‘– + ğœ‚ğ‘– ) and publish Ë†ğœƒ .
privacy level. Then, securely sum Ë†ğœƒ = 1
(cid:205)ğ‘›
ğ‘›

13

Proceedings on Privacy Enhancing Technologies YYYY(X)

CÃ©sar Sabater, Florian Hahn, Andreas Peter, and Jan Ramon

ACKNOWLEDGMENTS
We thank Christian Weinert for fruitful discussions. This project
was partially supported by ANR project ANR-20-CE23-0013 â€™PMRâ€™,
the â€™Chair TIPâ€™ project funded by ANR and MEL, and the Horizon
Europe TRUMPET project grant no. 101070038.

REFERENCES
[1] Abdelrahaman Aly and Nigel P. Smart. 2019. Benchmarking Privacy Preserving
Scientific Operations. In Applied Cryptography and Network Security (Lecture
Notes in Computer Science), Robert H. Deng, ValÃ©rie Gauthier-UmaÃ±a, MartÃ­n
Ochoa, and Moti Yung (Eds.). Springer International Publishing, Cham, 509â€“529.
[2] Thomas Attema and Ronald Cramer. 2020. Compressed Î£-Protocol Theory
and Practical Application to Plug & Play Secure Algorithmics. In Advances in
Cryptology â€“ CRYPTO 2020 (Lecture Notes in Computer Science), Daniele Mic-
ciancio and Thomas Ristenpart (Eds.). Springer International Publishing, Cham,
513â€“543. https://doi.org/10.1007/978-3-030-56877-1_18

[3] Yonatan Aumann and Yehuda Lindell. 2010. Security against covert adversaries:
Efficient protocols for realistic adversaries. Journal of Cryptology 23, 2 (2010),
281â€“343.

[4] Fattaneh Bayatbabolghani, Marina Blanton, Mehrdad Aliasgari, and Michael

Goodrich. 2017. Secure fingerprint alignment and matching protocols.

[5] Amos Beimel, Eran Omri, and Ilan Orlov. 2010. Protocols for Multiparty Coin
Toss with Dishonest Majority. In Advances in Cryptology â€“ CRYPTO 2010, Tal
Rabin (Ed.). Springer Berlin Heidelberg, Berlin, Heidelberg, 538â€“557.

[6] Mihir Bellare and Phillip Rogaway. 1993. Random oracles are practical: a paradigm
for designing efficient protocols. In Proceedings of the 1st ACM conference on
Computer and communications security (CCS â€™93). Association for Computing
Machinery, New York, NY, USA, 62â€“73. https://doi.org/10.1145/168588.168596
[7] Danial Benarroch, Matteo Campanelli, Dario Fiore, Kobi Gurkan, and Dimitris
Kolonelos. 2019. Zero-Knowledge Proofs for Set Membership: Efficient, Succinct,
Modular. Cryptology ePrint Archive, Report 2019/1255. https://ia.cr/2019/1255.
[8] David Bernhard, Olivier Pereira, and Bogdan Warinschi. 2012. How Not to Prove
Yourself: Pitfalls of the Fiat-Shamir Heuristic and Applications to Helios. In
Advances in Cryptology â€“ ASIACRYPT 2012 (Lecture Notes in Computer Science),
Xiaoyun Wang and Kazue Sako (Eds.). Springer, Berlin, Heidelberg, 626â€“643.
https://doi.org/10.1007/978-3-642-34961-4_38

[9] Ari Biswas and Graham Cormode. 2022. Verifiable Differential Privacy For When
The Curious Become Dishonest. https://doi.org/10.48550/ARXIV.2208.09011

[10] Manuel Blum. 1983. Coin flipping by telephone a protocol for solving impossible
problems. ACM SIGACT News 15, 1 (Jan. 1983), 23â€“27. https://doi.org/10.1145/
1008908.1008911

[11] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe
Petit. 2016. Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the
Discrete Log Setting. In Advances in Cryptology â€“ EUROCRYPT 2016 (Lecture Notes
in Computer Science), Marc Fischlin and Jean-SÃ©bastien Coron (Eds.). Springer,
Berlin, Heidelberg, 327â€“357. https://doi.org/10.1007/978-3-662-49896-5_12
[12] G. E. P. Box and Mervin E. Muller. 1958. A Note on the Generation of Random
Normal Deviates. Annals of Mathematical Statistics 29, 2 (June 1958), 610â€“611.
https://doi.org/10.1214/aoms/1177706645 Publisher: Institute of Mathematical
Statistics.

[13] A.Z. Broder and D. Dolev. 1984. Flipping Coins In Many Pockets (Byzan-
tine Agreement On Uniformly Random Values). In 25th Annual Symposium on
Foundations of Computer Science, 1984. IEEE, Singer Island, FL, USA, 157â€“170.
https://doi.org/10.1109/SFCS.1984.715912

[14] Benedikt Bunz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and
Greg Maxwell. 2018. Bulletproofs: Short Proofs for Confidential Transactions and
More. In 2018 IEEE Symposium on Security and Privacy (SP). IEEE, San Francisco,
CA, 315â€“334. https://doi.org/10.1109/SP.2018.00020

[15] Jan Camenisch, Rafik Chaabouni, and abhi shelat. 2008. Efficient Protocols for
Set Membership and Range Proofs. In Advances in Cryptology - ASIACRYPT
2008 (Lecture Notes in Computer Science), Josef Pieprzyk (Ed.). Springer, Berlin,
Heidelberg, 234â€“252. https://doi.org/10.1007/978-3-540-89255-7_15

[16] Jan Camenisch and Markus Michels. 1999. Proving in Zero-Knowledge that a
Number is the Product of Two Safe Primes. In Advances in Cryptology â€” EU-
ROCRYPT â€™99 (Lecture Notes in Computer Science), Jacques Stern (Ed.). Springer,
Berlin, Heidelberg, 107â€“122. https://doi.org/10.1007/3-540-48910-X_8

[17] ClÃ©ment L Canonne, Gautam Kamath, and Thomas Steinke. 2020. The Discrete
Gaussian for Differential Privacy. In Advances in Neural Information Processing
Systems, H. Larochelle, M. Ranzato, R. Hadsell, M.F. Balcan, and H. Lin (Eds.),
Vol. 33. Curran Associates, Inc., Virtual, 15676â€“15688.
https://proceedings.
neurips.cc/paper/2020/file/b53b3a3d6ab90ce0268229151c9bde11-Paper.pdf
[18] S. Chevillard. 2012. The functions erf and erfc computed with arbitrary precision
and explicit error bounds. Information and Computation 216 (July 2012), 72â€“95.
https://doi.org/10.1016/j.ic.2011.09.001

14

[19] Seung Geol Choi, Dana Dachman-Soled, Mukul Kulkarni, and Arkady Yerukhi-
movich. 2020. Differentially-Private Multi-Party Sketching for Large-Scale Statis-
tics. Cryptology ePrint Archive, Paper 2020/029. https://eprint.iacr.org/2020/029
https://eprint.iacr.org/2020/029.

[20] R Cleve. 1986. Limits on the Security of Coin Flips When Half the Processors
Are Faulty. In Proceedings of the Eighteenth Annual ACM Symposium on Theory
of Computing (Berkeley, California, USA) (STOC â€™86). Association for Computing
Machinery, New York, NY, USA, 364â€“369. https://doi.org/10.1145/12130.12168
[21] Ronald Cramer. 1997. Modular Design of Secure yet Practical Cryptographic
Protocols. Ph. D. Dissertation. University of Amsterdam. https://ir.cwi.nl/pub/
21438

[22] Ronald Cramer and Ivan DamgÃ¥rd. 1998. Zero-knowledge proofs for finite field
arithmetic, or: Can zero-knowledge be for free?. In Advances in Cryptology â€”
CRYPTO â€™98 (Lecture Notes in Computer Science), Hugo Krawczyk (Ed.). Springer,
Berlin, Heidelberg, 424â€“441. https://doi.org/10.1007/BFb0055745

[23] I. Damgard, M. Fitzi, E. Kiltz, J.B. Nielsen, and T. Toft. 2006. Unconditionally
secure constant rounds multi-party computation for equality, comparison, bits
and exponentiation. In TCC 2006 (LNCS, Vol. 3876). Springer, New York, NY USA,
285â€“304.

[24] Ivan Damgard, Marcel Keller, Enrique Larraia, Valerio Pastro, Peter Scholl, and
Nigel P. Smart. 2013. Practical Covertly Secure MPC for Dishonest Majority â€“
Or: Breaking the SPDZ Limits. In ESORICS (LNCS, Vol. 8134). Springer, Egham,
UK, 1â€“18.

[25] Vassil Dimitrov, Liisi Kerik, Toomas Krips, Jaak Randmets, and Jan Willemson.
2016. Alternative Implementations of Secure Real Numbers. In Proceedings of
the 2016 ACM SIGSAC Conference on Computer and Communications Security
(CCS â€™16). Association for Computing Machinery, New York, NY, USA, 553â€“564.
https://doi.org/10.1145/2976749.2978348

[26] Cynthia Dwork, Krishnaram Kenthapadi, Frank McSherry, Ilya Mironov, and
Moni Naor. 2006. Our Data, Ourselves: Privacy Via Distributed Noise Generation.
In Advances in Cryptology - EUROCRYPT 2006, Serge Vaudenay (Ed.). Springer
Berlin Heidelberg, Berlin, Heidelberg, 486â€“503.

[27] Cynthia Dwork and Aaron Roth. 2014. The algorithmic foundations of differential
privacy. Foundations and Trends in Theoretical Computer Science 9, 3-4 (2014),
211â€“407.

[28] Mike Giles. 2012. Approximating the erfinv function. In GPU Computing Gems

Jade Edition. Elsevier, Amsterdam, Netherlands, 109â€“116.

[29] Oded Goldreich. 2009. Foundations of cryptography: volume 2, basic applications.

Cambridge university press, Cambridge, England.

[30] O. Goldreich, S. Micali, and A. Wigderson. 1987. How to Play ANY Mental Game.
In Proceedings of the Nineteenth Annual ACM Symposium on Theory of Computing
(New York, New York, USA) (STOC â€™87). Association for Computing Machinery,
New York, NY, USA, 218â€“229. https://doi.org/10.1145/28395.28420

[31] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. 1989. The Knowledge
Complexity of Interactive Proof Systems. SIAM J. Comput. 18, 1 (Feb. 1989),
186â€“208. https://doi.org/10.1137/0218012 Publisher: Society for Industrial and
Applied Mathematics.

[32] Kanav Gupta, Deepak Kumaraswamy, Nishanth Chandran, and Divya Gupta.
2022. LLAMA: A Low Latency Math Library for Secure Inference. Cryptology
ePrint Archive, Paper 2022/793. https://eprint.iacr.org/2022/793 https://eprint.
iacr.org/2022/793.

[33] Yuval Ishai, Rafail Ostrovsky, and Vassilis Zikas. 2014. Secure Multi-Party Compu-
tation with Identifiable Abort. In Advances in Cryptology â€“ CRYPTO 2014, Juan A.
Garay and Rosario Gennaro (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg,
369â€“386. The full version can be found at https://eprint.iacr.org/2015/325.pdf..
[34] Peter Kairouz, Ziyu Liu, and Thomas Steinke. 2021. The Distributed Discrete
Gaussian Mechanism for Federated Learning with Secure Aggregation. In Pro-
ceedings of the 38th International Conference on Machine Learning (Proceedings
of Machine Learning Research, Vol. 139), Marina Meila and Tong Zhang (Eds.).
PMLR, Virtual, 5201â€“5212. https://proceedings.mlr.press/v139/kairouz21a.html
[35] Fumiyuki Kato, Yang Cao, and Masatoshi Yoshikawa. 2021. Preventing Ma-
nipulation Attack in Local Differential Privacy Using Verifiable Randomization
Mechanism. In Data and Applications Security and Privacy XXXV, Ken Barker
and Kambiz Ghazinour (Eds.). Springer International Publishing, Cham, 43â€“60.
[36] R. Knop. 1969. Remark on algorithm 334 [G5]: normal random deviates. Commun.

ACM 12, 5 (1969), 281. Publisher: ACM New York, NY, USA.

[37] Manuel Liedel. 2012. Secure Distributed Computation of the Square Root and
Applications. In Information Security Practice and Experience, Mark D. Ryan, Ben
Smyth, and Guilin Wang (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg,
277â€“288.

[38] Lindell. 2003. Parallel Coin-Tossing and Constant-Round Secure Two-Party
Computation. Journal of Cryptology 16, 3 (June 2003), 143â€“184. https://doi.org/
10.1007/s00145-002-0143-7

[39] G. Marsaglia and T. A. Bray. 1964. A Convenient Method for Generating Normal
Variables. SIAM Rev. 6, 3 (July 1964), 260â€“264. https://doi.org/10.1137/1006063
Publisher: Society for Industrial and Applied Mathematics.

[40] George Marsaglia and Wai Wan Tsang. 2000. The ziggurat method for generating

random variables. Journal of statistical software 5, 8 (2000), 1â€“7.

Private Sampling with Identifiable Cheaters

Proceedings on Privacy Enhancing Technologies YYYY(X)

[41] Sahar Mazloom and S. Dov Gordon. 2018. Secure Computation with Differentially
Private Access Patterns. In Proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security (Toronto, Canada) (CCS â€™18). Association
for Computing Machinery, New York, NY, USA, 490â€“507. https://doi.org/10.
1145/3243734.3243851

[42] Ilya Mironov. 2012. On Significance of the Least Significant Bits for Differential
Privacy. In Proceedings of the 2012 ACM Conference on Computer and Commu-
nications Security (Raleigh, North Carolina, USA) (CCS â€™12). Association for
Computing Machinery, New York, NY, USA, 650â€“661. https://doi.org/10.1145/
2382196.2382264

[43] Tal Moran, Moni Naor, and Gil Segev. 2009. An Optimally Fair Coin Toss. In
Theory of Cryptography, Omer Reingold (Ed.). Springer Berlin Heidelberg, Berlin,
Heidelberg, 1â€“18.

[44] Jean-Michel Muller. 2016. Elementary Functions: Algorithms and Implementation
(3 ed.). BirkhÃ¤user Basel, Basel, Switzerland. https://doi.org/10.1007/978-1-4899-
7983-4

[45] Gonzalo Munilla Garrido, Johannes Sedlmeir, and Matthias Babel. 2022. Towards
Verifiable Differentially-Private Polling. In Proceedings of the 17th International
Conference on Availability, Reliability and Security (Vienna, Austria) (ARES â€™22).
Association for Computing Machinery, New York, NY, USA, Article 6, 11 pages.
https://doi.org/10.1145/3538969.3538992

[46] Bodo MÃ¶ller. 2001. Algorithms for Multi-exponentiation. In Selected Areas in
Cryptography (Lecture Notes in Computer Science), Serge Vaudenay and Amr M.
Youssef (Eds.). Springer, Berlin, Heidelberg, 165â€“180. https://doi.org/10.1007/3-
540-45537-X_13

[47] Torben Pryds Pedersen. 1992. Non-Interactive and Information-Theoretic Secure
Verifiable Secret Sharing. In Advances in Cryptology â€” CRYPTO â€™91 (Lecture
Notes in Computer Science), Joan Feigenbaum (Ed.). Springer, Berlin, Heidelberg,
129â€“140. https://doi.org/10.1007/3-540-46766-1_9

[48] David Pointcheval and Jacques Stern. 1996. Security Proofs for Signature Schemes.
In Advances in Cryptology â€” EUROCRYPT â€™96, Ueli Maurer (Ed.). Springer Berlin
Heidelberg, Berlin, Heidelberg, 387â€“398.

[49] Meital Ben Sinai, Nimrod Partush, Shir Yadid, and Eran Yahav. 2014. Exploiting

Social Navigation. https://doi.org/10.48550/ARXIV.1410.0151

[50] Georgia Tsaloli and Aikaterini Mitrokotsa. 2019. Differential Privacy meets
Verifiable Computation: Achieving Strong Privacy and Integrity Guarantees. In
Proceedings of the 16th International Joint Conference on e-Business and Telecom-
munications, ICETE 2019 - Volume 2: SECRYPT, Prague, Czech Republic, July 26-28,
2019. SciTePress, Prague, Czech Republic, 425â€“430. https://doi.org/10.5220/
0007919404250430

[51] C. S. Wallace. 1996. Fast pseudorandom generators for normal and exponential
variates. ACM Trans. Math. Software 22, 1 (March 1996), 119â€“127. https://doi.
org/10.1145/225545.225554

[52] J. S. Walther. 1971. A unified algorithm for elementary functions. In Proceedings
of the May 18-20, 1971, spring joint computer conference (AFIPS â€™71 (Spring)).
Association for Computing Machinery, New York, NY, USA, 379â€“385. https:
//doi.org/10.1145/1478786.1478840

[53] Simon Weckert. 2020. Google Maps hacks. Retrieved Dec 6, 2022 from http:

//www.simonweckert.com/googlemapshacks.html

[54] Lingchen Zhao, Qian Wang, Cong Wang, Qi Li, Chao Shen, and Bo Feng. 2021.
VeriML: Enabling Integrity Assurances and Fair Payments for Machine Learning
as a Service. IEEE Transactions on Parallel and Distributed Systems 32, 10 (2021),
2524â€“2540. https://doi.org/10.1109/TPDS.2021.3068195

A COMPRESSED Î£-PROTOCOLS
In this appendix, we explain all necessary notions to understand
compressed Î£-protocols [2]. In Appendix A.1, we explain the basic
concepts of ZKP. Classic approaches to construct ZKP of linear
relations are shown in Appendix A.2 and techniques to compress
the communication cost in Appendix A.3. In Appendix A.4 we
explain how linear proofs can be used to construct ZKP involving
circuit computations. Finally, Appendix A.5 has an application for
range proofs and Appendix A.6 discusses the costs of the techniques.

A.1 Zero Knowledge Proofs and Arguments
An interactive proof of knowledge (PoK) for an NP relation R is
a protocol between a prover P and a verifier V in which P tries
to prove to V that they know a witness ğ‘¤ such that (ğ‘, ğ‘¤) âˆˆ R for
a public statement ğ‘. At the end of the protocol, V either accepts
or rejects the proof. We denote by (ğ‘; ğ‘¤) a member of a relation

15

or an input of a protocol, using a semicolon to separate the public
statement ğ‘ from the private witness ğ‘¤. The tuple of all messages
in a proof is called the conversation or transcript. Proofs may satisfy
the following properties:

â€¢ Completeness: a proof is complete if V always accepts the

proof when (ğ‘; ğ‘¤) âˆˆ R and P knows ğ‘¤.

â€¢ Soundness: a proof is sound if any prover whose proof for
statement ğ‘ is accepted by the verifier knows a valid wit-
ness ğ‘¤ such that (ğ‘; ğ‘¤) âˆˆ R with overwhelming probability.
The notion of soundness we use is called witness extended
emulation [38]. Proofs that are sound only if the prover is
computationally bounded are also called arguments.

â€¢ Zero Knowledge: a proof is zero knowledge if its transcript
reveals no or negligible information about the witness other
than its validity.

A.2 Î£-protocols for Linear Relations
We now show how to prove linear relations over secret committed
values. Recall the definition of Pedersen vector commitments pre-
sented in Section 2.2, which defines the commitment domain Zğ‘ ,
our underlying cryptographic group G and vector of elements g.
As explained in Section 2.2, we reserve one of the components of g
for randomness so that commitments are hiding. For ğ¿ : Zğ‘˜
ğ‘ â†’ Zğ‘
a linear function in Zğ‘ , that is ğ¿(ğ‘¥1, . . . , ğ‘¥ğ‘˜ ) = ğ‘1ğ‘¥1 + Â· Â· Â· + ğ‘ğ‘˜ğ‘¥ğ‘˜
for coefficiens ğ‘1, . . . , ğ‘ğ‘˜ âˆˆ Zğ‘ , a vector commitment ğ‘ƒ âˆˆ G and a
value ğ‘¦ âˆˆ Zğ‘ , a prover P proves to know an opening x âˆˆ Zğ‘˜
ğ‘ of ğ‘ƒ
such that ğ¿(x) = ğ‘¦. We formally describe our linear relation by

Rğ¿ = {(ğ‘ƒ âˆˆ G, ğ‘¦ âˆˆ Zğ‘ ; x âˆˆ Zğ‘˜

ğ‘ ) : ğ‘ƒ = gx âˆ§ ğ‘¦ = ğ¿(x)}.

Note that in our case x has a coordinate reserved for randomness,
so in valid relations the correspondent coefficient of ğ¿ must be
0. However, in later auxiliary protocols we will not impose such
restriction. To provide a zero knowledge proof for Rğ¿ we use a
family of zero knowledge proofs called Î£-protocols [21] and its
compressed version proposed in [2]. They provide soundness un-
der the Discrete Logarithm Assumption (DLA). Protocol Î 0 below
describes a classic proof of Rğ¿ originally stated for more general
types of commitments defined in [21, 22] and which we instantiate
for the Pedersen scheme. Î 0 takes as input (ğ‘ƒ, ğ‘¦; x):
Protocol Î 0 (ğ‘ƒ, ğ‘¦, x):

ğ‘ , ğ´ = gr, ğ‘¡ = ğ¿(r)

(1) P computes: r â†ğ‘… Zğ‘˜
(2) P sends to V: ğ´, ğ‘¡
(3) V sends to P: ğ‘ â†ğ‘… Zğ‘
(4) P sends to V: z = ğ‘x + r
(5) V: if gz = ğ´ğ‘ƒğ‘ and ğ¿(z) = ğ‘ğ‘¦ + ğ‘¡ then accept, else reject.

Theorem 2. Î 0 is a complete, sound and zero knowledge proof of

Rğ¿.

We provide an intuition of how these properties are obtained.
Completeness follows directly from the homomorphic property. For
soundness, consider a prover Pâˆ— that by following Î 0 can produce
an accepting transcript ((ğ´, ğ‘¡), ğ‘1, z1) with significant probability.
Then it is shown that also with non-negligible probability, by using
Pâˆ—â€™s strategy many times, another accepting transcript of the form
((ğ´, ğ‘¡), ğ‘2, z2) can be produced, where the first message is equal

Proceedings on Privacy Enhancing Technologies YYYY(X)

CÃ©sar Sabater, Florian Hahn, Andreas Peter, and Jan Ramon

in both transcripts and such that ğ‘1 â‰  ğ‘2. Now, since both tran-
scripts are accepting, we have gz1 = ğ´ğ‘ƒğ‘1 and gz2 = ğ´ğ‘ƒğ‘2 so Pâˆ—
can efficiently compute the witness x = z1âˆ’z2
such that gx = ğ‘ƒ.
ğ‘1âˆ’ğ‘2
Acceptance also implies that ğ¿(z1) = ğ‘1ğ‘¦ + ğ‘¡ and ğ¿(z2) = ğ‘2ğ‘¦ + ğ‘¡
and it follows that ğ¿(x) = ğ‘¦. Therefore is x a valid witness. Either
Pâˆ— already knew it or they can efficiently compute the discrete
logarithms between components of g, which is a contradiction due
to the DLA.

Zero knowledge is obtained by showing that all information
seen in the proof is random that does not depend on the secrets.
By only knowing the statement (ğ‘ƒ, ğ‘¦) one can compute zâ€² â†ğ‘… Zğ‘ ,
ğ‘ â€² â†ğ‘… Zğ‘ , ğ´â€² = ğ‘ƒ âˆ’ğ‘â€²
gzâ€² and ğ‘¡ â€² = ğ¿(zâ€²) âˆ’ ğ‘ â€²ğ‘¦, and the transcript
((ğ´â€², ğ‘¡ â€²), ğ‘ â€², zâ€²) has the same distribution as a conversation between
an honest prover and a honest verifier. Note that, as it is computed
in reverse, ((ğ´â€², ğ‘¡ â€²), ğ‘ â€², zâ€²) cannot be efficiently produced in the
actual protocol by a dishonest prover. Note that this reasoning
only holds if the verifier is honest and generates its messages uni-
formly at random. To circumvent this, we implement our proofs
transforming them into non-interactive proofs using the Strong
Fiat-Shamir heuristic [8], where the verifier is replaced by a hash
function and therefore without the need of involving a trusted party.
The construction is secure under the Random Oracle Model [6].

A.3 Compression Mechanism
Now we reduce the communication cost of Î 0 using ideas of com-
pressed Î£-protocols [2] and also present in [11, 14]. The transfer in
Î 0 is dominated by the third message of the protocols in Step 4, with
size of ğ‘˜ elements of Zğ‘ . It can be reduced if instead of sending z, P
proves that (ğ´ğ‘ƒğ‘, ğ‘ğ‘¦ + ğ‘¡; z) âˆˆ Rğ¿ which would imply the condition
tested in Step 5. Note that this proof does not need to be zero knowl-
edge as z is originally revealed in Î 0. We first present Î 1, a proof
of R that halves communication cost by â€œfoldingâ€ z before sending
it. Next, we show how to use this protocol to reduce cost of Î 0. By
assuming that ğ‘˜ is even, we define gğ¿ = (ğ‘”1, . . . , ğ‘”ğ‘˜/2) âˆˆ Gğ‘˜/2 and
gğ‘… = (ğ‘”(ğ‘˜/2)+1, . . . , ğ‘”ğ‘˜ ) âˆˆ Gğ‘˜/2 and analogously for xğ¿ âˆˆ Zğ‘˜/2
and
xğ‘… âˆˆ Zğ‘˜/2
ğ‘ â†’ Zğ‘
such that ğ¿ğ¿ (a) = ğ¿(a, 0) and ğ¿ğ‘… (a) = ğ¿(0, a). We use, an additional
group element Ë†ğ‘” âˆˆ G generated in the same way as the components
of g.

ğ‘
ğ‘ â†’ Zğ‘ and ğ¿ğ‘… : Zğ‘˜/2

ğ‘ . We also define ğ¿ğ¿ : Zğ‘˜/2

Protocol Î 1 (ğ‘ƒ, ğ‘¦; x):

Ë†ğ‘”ğ¿ğ‘… (xğ¿) , ğµ = gxğ‘…
ğ¿

Ë†ğ‘”ğ¿ğ¿ (xğ‘… )

(1) P computes: ğ´ = gxğ¿
ğ‘…
(2) P sends to V: ğ´, ğµ
(3) V sends to P: ğ‘ â†ğ‘… Zğ‘
(4) P sends to V: z = xğ¿ + ğ‘xğ‘…
(5) V: if (gğ‘

else reject

ğ¿ âˆ— gğ‘…)z Ë†ğ‘”ğ‘ğ¿ğ¿ (z)+ğ¿ğ‘… (z) = ğ´(ğ‘ƒ Ë†ğ‘”ğ¿ (x) )ğ‘ ğµğ‘2 then accept,

Î 1 is a complete and sound proof of Rğ¿ with half the communica-
tion of Î 0. The communication of Step 4, can be further reduced
by applying Î 1 recursively until the size of z is sufficiently small.
Let Î ğµ â‹„ Î ğ´ be the interactive proof obtained executing Î ğ´ except
for the last message and then executing Î ğµ. Now we can define to
Î ğ‘ = Î 1 â‹„ . . . â‹„ Î 1 â‹„ Î 0 where the â‹„ is applied log2 (ğ‘˜) âˆ’ 2 times.
Note that ğ‘˜ requires to be a power of 2, but padding vectors with
0â€™s is sufficient to fix this. Presented with more detail, it is proven

16

in Theorem 3 of [2], that Î ğ‘ is a complete, sound and zero knowl-
edge protocol for Rğ¿. Completeness is straightforward, and for zero
knowledge it is sufficient to see that Î 0 is already zero knowledge,
and the rest of the protocol only reveals as much as Î 0. Soundness
follows from similar ideas than those shown for Theorem 2.

Amortization techniques can be applied to prove many nul-
lity checks, where the prover claims for linear relations ğ¿1, . . . , ğ¿ğ‘Ÿ
that ğ¿ğ‘– (x) = 0 for all ğ‘– âˆˆ {1, . . . , ğ‘Ÿ }. For that, V sends a ran-
dom value ğœŒ â† Zğ‘ and then P and V execute Î ğ‘ on input
(ğ‘ƒ, (cid:205)ğ‘Ÿ
ğ‘–=1 ğœŒğ‘–âˆ’1ğ¿ğ‘–, 0; x). If ğ¿(x) = 0 then ğ¿ğ‘– (x) = 0 for all ğ‘– with
overwhelming probability 1 âˆ’ (ğ‘Ÿ âˆ’ 1)/ğ‘. Amortized nullity checks
also hold when replacing linear forms by affine forms Î¦1, . . . , Î¦ğ‘Ÿ
where each one is the application of a linear form plus a constant.
We denote this protocol by Î ğ‘ and its input by (ğ‘ƒ, (Î¦1, . . . , Î¦ğ‘Ÿ ); x).
A prover can prove the opening of an affine map Î¦ : Zğ‘˜
ğ‘ to
y = (ğ‘¦1, . . . , ğ‘¦ğ‘Ÿ ) âˆˆ Zğ‘Ÿ
ğ‘ by running Î ğ‘ on input (ğ‘ƒ, (Î¦1 âˆ’ğ‘¦1, . . . , Î¦ğ‘Ÿ âˆ’
ğ‘¦ğ‘Ÿ ); x) where Î¦1, . . . , Î¦ğ‘Ÿ : Zğ‘˜
ğ‘ â†’ Zğ‘ are the affine forms that com-
pose Î¦. The communication cost of these protocols sends ğ‘Ÿ âˆ’ 1
elements of Zğ‘ more than Î ğ‘ , which account for the size of y.

ğ‘ â†’ Zğ‘Ÿ

A.4 Proving Multiplications and Circuits
Now, we show the idea of [2] to prove multiplicative relations only
with black-box access to Î ğ‘ . For a set committed triplets

(ğ›¼1, ğ›½1, ğ›¾1), . . . , (ğ›¼ğ‘š, ğ›½ğ‘š, ğ›¾ğ‘š),

P proves to V that ğ›¼ğ‘– ğ›½ğ‘– = ğ›¾ğ‘– for all ğ‘– âˆˆ {1, . . . , ğ‘š}. Let ğ›¼ =
(ğ›¼1, . . . , ğ›¼ğ‘š), ğ›½ = (ğ›½1, . . . , ğ›½ğ‘š) and ğ›¾ = (ğ›¾1, . . . , ğ›¾ğ‘š).

Protocol Î ğ‘€ :
(1) P: samples random polynomials ğ‘“ (ğ‘‹ ), ğ‘”(ğ‘‹ ) in Zğ‘ of degree
at most ğ‘š that define a secret sharing over ğ›¼ and ğ›½ by fixing
ğ‘“ (ğ‘–) = ğ›¼ğ‘– and ğ‘”(ğ‘–) = ğ›½ğ‘– for all ğ‘– âˆˆ {1, . . . , ğ‘š} and sampling
ğ‘“ (0), ğ‘”(0) â†ğ‘… Zğ‘ .

(2) P: computes the product polynomial â„(ğ‘‹ ) = ğ‘“ (ğ‘‹ )ğ‘”(ğ‘‹ )

which has degree at most 2ğ‘š.

(3) P sends to V: a vector commitment of

x = (ğ›¼, ğ›½, ğ‘“ (0), ğ‘”(0), â„(0), . . . , â„(2ğ‘š)).

Note that ğ›¾ = (â„(1), . . . , â„(ğ‘›)).
(4) V sends to P: ğ‘ â†ğ‘… Zğ‘ \ {0, . . . , ğ‘š}
(5) P and V run Î ğ‘ to prove that ğ‘“ (ğ‘), ğ‘”(ğ‘), â„(ğ‘) open to some
points ğ‘¢, ğ‘£ and ğ‘¤ respectively. This is possible by Lagrange
interpolation, where by having sufficient points of ğ‘“ ,ğ‘” and
â„, which are in the commitment of x, they can be evaluated
its domain by applying an affine form to x

(6) V: if ğ‘¢ğ‘£ = ğ‘¤ then accept else reject
As before, completeness is straightforward. Zero knowledge fol-
lows from fact that ğ‘“ , ğ‘” and â„ are random polynomials and their
evaluations do not reveal information and that Î ğ‘ is zero knowl-
edge. If the multiplicative relations does not hold in all triplets, the
probability that ğ‘¢ğ‘£ = ğ‘¤ is negligible. From that and the soundness
of Î ğ‘ , soundness is obtained.

ğ‘ â†’ Zğ‘ 

Now, let ğ¶ : Zğ‘˜

ğ‘ be a circuit, i.e. a function that only
contains addition and multiplication gates in Zğ‘ . For a vector com-
mitment ğ‘ƒ, we adapt ideas from Î ğ‘€ to construct a proof that P
knows a opening x âˆˆ Zğ‘˜
ğ‘ of ğ‘ƒ such that ğ¶ (x) = 0. Suppose that ğ¶
has ğ‘š multiplication gates. We enumerate the multiplication gates

Private Sampling with Identifiable Cheaters

Proceedings on Privacy Enhancing Technologies YYYY(X)

from 1 to ğ‘š. For ğ‘– âˆˆ {1, . . . , ğ‘š}, let ğ›¼ğ‘– and ğ›½ğ‘– be inputs of the ğ‘–th
multiplication gate, and ğ›¾ğ‘– its output. Let ğ›¼,ğ›½ and ğ›¾ as defined in
the multiplication protocol. It is not necessary to commit to ğ›¼ and
ğ›½ as a commitment of them can be obtained from affine forms on
inputs (x, ğ›¾) which are only dependent on ğ¶. Similarly, the output
of ğ¶ can be computed from an affine map ğœ” : Zğ‘˜+2ğ‘š
ğ‘ that
takes as input (x, ğ›¾). When committing to x and ğ›¾, the prover only
needs to prove that multiplication gates hold and that ğœ” opens to 0.
This can be done with amortized nullity checks. Let [a] be a hiding
vector commitment of a i.e., [a] = g(a,ğ‘Ÿ ) where ğ‘Ÿ âˆˆ Zğ‘ is chosen at
random.

ğ‘ â†’ Zğ‘ 

Protocol Î ğ‘ğ‘  (ğ¶):
(1) P: Computes ğ‘“ , ğ‘” and â„ from ğ›¼, ğ›½ as in Steps 1 and 2 of Î ğ‘€ .
(2) P sends to V: [y], where

y = (x, ğ‘“ (0), ğ‘”(0), â„(0), â„(1), . . . , â„(2ğ‘š)) âˆˆ Zğ‘˜+2ğ‘š+3

ğ‘

.

(3) V sends to P: ğ‘ â†ğ‘… Zğ‘ \ {1, . . . , ğ‘š}.
(4) P sends to V: ğ‘§1 = ğ‘“ (ğ‘), ğ‘§2 = ğ‘“ (ğ‘), ğ‘§3 = ğ‘“ (ğ‘).
(5) P and V run Î ğ‘ with input

([y], (ğœ”, ğ‘“ (ğ‘) âˆ’ ğ‘§1, ğ‘”(ğ‘) âˆ’ ğ‘§2, â„(ğ‘) âˆ’ ğ‘§3); y) ,

where linear forms are obtained by Lagrange interpolation
as in Step 5 of Î ğ‘€ .

(6) V: if ğ‘§1ğ‘§2 = ğ‘§3 then accept else reject

Note that [y], additionally to ğ›¼ and ğ›½, is an implicit commitment to
ğ›¾ = (â„(1), . . . , â„(ğ‘š)). Properties of completeness, zero knowledge
and soundness, which can be found in Theorem 4 of [2], follow
from the same arguments as the multiplication protocol.

A.5 Range Proofs
A straightforward application of circuit proofs are range proofs.
Namely, for a secret ğ‘¥ âˆˆ Zğ‘ and an integer ğ‘˜ < log2 (ğ‘), that
ğ‘¥ âˆˆ [0, 2ğ‘˜ ). For that you commit to the first ğ‘˜ bits ğ‘1, . . . , ğ‘ğ‘˜ of ğ‘¥.
Then, for b = (ğ‘1, . . . , ğ‘ğ‘˜ ), a circuit proof for circuit

ğ¶ğ‘…ğ‘ (ğ‘¥, b) (cid:66)

b âˆ— (1 âˆ’ b)

(cid:20)
ğ‘¥ âˆ’ (cid:205)ğ‘˜

ğ‘–=1 2ğ‘–âˆ’1ğ‘ğ‘–

(cid:21)

implies the range constraint. Note that in ğ¶ğ‘…ğ‘ the output of the
multiplication gates is 0. Therefore, in protocol Î ğ‘ğ‘  , it is not neces-
sary to include in y the elements â„(1), . . . , â„(ğ‘˜), which reduces the
proof cost.

A.6 Cost of Proofs
We now briefly summarize communication and computational cost
of the proofs. As previously stated in the Appendix, ğ‘˜ is the number
of inputs and ğ‘š of multiplication gates in circuits.

Theorems 3 and 4 of [2] give the communication costs for Î ğ‘ and
Î ğ‘ğ‘  respectively. As we use versions of the protocols transformed
by the Fiat-Shamir heuristic, the verifier does not send any message.
Therefore, the proof sizes are 2âŒˆlog(ğ‘˜ + 1)âŒ‰ elements of G and 3
elements of Zğ‘ for Î ğ‘ , and 2âŒˆlog(ğ‘˜ + 2ğ‘š + 4)âŒ‰ âˆ’ 1 elements of G
and 6 elements of Zğ‘ for Î ğ‘ğ‘  .

For the computational cost, we count the amount of group ex-
ponentiations in G (GEX) as they dominate the work. In protocol
Î 0, P performs ğ‘˜ GEX to compute ğ´, and V performs ğ‘˜ + 1 GEX,
which corresponds to the verification of Step 5. In Î 1, P performs

17

ğ‘˜ + 2 GEX to compute ğ´ and ğµ, and V does ğ‘˜/2 + 4 GEX in the
verification of Step 4. Î ğ‘ is a composition of one instance of Î 0 and
ğœ‡ = âŒˆlog2 (ğ‘˜)âŒ‰ âˆ’ 2 instances of Î 1. After the first Î 1 proof, ğ‘˜ halves
at each instance of Î 1. Additionally, P and V have to compute
gâ€² = gğ‘
ğ¿ + gğ‘… after the first Î 1 to update parameters for each of
following sub-protocols. V avoids each of the verification checks
except for the last one, which requires a constant amount of GEX.
Therefore, P performs ğ‘˜ + 2 + (cid:205)ğœ‡
2ğ‘– = 4ğ‘˜ + 2ğœ‡ âˆ’ 10 GEX
ğ‘–=1
and V does 3 + (cid:205)ğœ‡
ğ‘˜
2ğ‘– + 2 = ğ‘˜ + 2ğœ‡ âˆ’ 1 GEX. Protocol Î ğ‘ requires
ğ‘–=1
the same amount of GEX than Î ğ‘ .

2ğ‘–âˆ’1 + ğ‘˜

ğ‘˜

ğ‘

In Î ğ‘ğ‘  , P is required to compute a (hiding) commitment of y âˆˆ
Zğ‘˜+2ğ‘š+3
, which costs ğ‘™ = ğ‘˜ + 2ğ‘š + 4 GEX. Then P and V engage
in Î ğ‘ for an affine form of ğ‘™ inputs. The final costs for Î ğ‘ğ‘  are
then 5ğ‘˜ + 8ğ‘š + 2âŒˆlog2 (ğ‘˜ + 2ğ‘š + 4)âŒ‰ + 6 GEX for P and ğ‘˜ + 2ğ‘š +
2âŒˆlog2 (ğ‘˜ + 2ğ‘š + 4)âŒ‰ âˆ’ 1 GEX for V. For a proof of membership to
the range [0, 2ğ‘˜ ), as discussed in Appendix A.5, â„(1), . . . , â„(ğ‘˜) are
not included in y which then has 2ğ‘˜ + 4 elements. The costs are of
9ğ‘˜ + 2âŒˆlog2 (2ğ‘˜ + 5)âŒ‰ + 11 GEX for P, and 2ğ‘˜ + 2âŒˆlog2 (2ğ‘˜ + 5)âŒ‰ GEX
for V.

We apply the same optimization done for range proofs to all
of our circuits. That is, multiplication gates that are expected to
be equal to 0 are not included in y. Therefore, for circuits with ğ‘˜
inputs, ğ‘š multiplication gates, and ğ‘š0 multiplication gates that will
be equal to 0,

â€¢ P performs 5ğ‘˜ + 8ğ‘š âˆ’ 4ğ‘š0 + 2âŒˆlog2 (ğ‘˜ + 2ğ‘š âˆ’ ğ‘š0 + 4)âŒ‰ + 6

GEX

â€¢ V performs ğ‘˜ + 2ğ‘š âˆ’ğ‘š0 + 2âŒˆlog2 (ğ‘˜ + 2ğ‘š âˆ’ğ‘š0 + 4)âŒ‰ âˆ’ 1 GEX.

B SECURITY OF OUR PROTOCOLS
In this section, we prove the security of the protocols presented in
the main paper. In the sequel, we will often restate in more detail
and more formally the protocols. We consider a set of ğ‘› parties
P = {ğ‘ƒ1 . . . ğ‘ƒğ‘› }. We will denote by ğ‘ƒâˆ’ğ‘– the set of all parties except
ğ‘–, i.e., ğ‘ƒâˆ’ğ‘– = P \ {ğ‘ƒğ‘– }. We assume that a subset of parties Pğ‘ğ‘œğ‘Ÿ âŠ‚ P
is corrupted and controlled by an adversary A. The set Pğ‘ğ‘œğ‘Ÿ of
corrupted parties is static, i.e. does not change after the beginning
of the execution.

For the description of our protocols, we will denote the fact that
a party ğ´ sends a message ğ‘€ to a party ğµ by â€œğ´ â†’ ğµ: ğ‘€â€. Recall
that we use a bulletin board for communication. Among others, this
means that when a protocol contains a broadcast instruction a single
message is sent from one party to all others, in practice by sending
it from that party to the bulletin board, which forwards it to all
other agents. We will also use hiding vector Pedersen commitments
defined in Section 2.2. Recall the finite groups Zğ‘ and G defined
therein. For any integer ğ‘˜ > 0, we will denote by ğ¶ğ‘œğ‘š(x; ğ‘Ÿ ) âˆˆ G the
commitment of the ğ‘˜-dimension vector x âˆˆ Zğ‘˜
ğ‘ with randomness
ğ‘Ÿ âˆˆ Zğ‘ .

We describe our security framework in Appendix B.1. In Appen-
dix B.2, we describe our model of compressed Î£-protocols in our
security analysis. In appendices B.3 and B.4 we prove the security
of Protocols 1 and 2 respectively. We conclude by discussing the
security of our protocols for public and private draws from some
other distributions in Appendix B.5.

Proceedings on Privacy Enhancing Technologies YYYY(X)

CÃ©sar Sabater, Florian Hahn, Andreas Peter, and Jan Ramon

B.1 Security Definitions
We prove security in the simulation paradigm, using the model of
malicious security with identifiable abort [33] in the stand-alone
setting [29]. Therefore, we assume parties are able to detect mali-
cious actions and can in such cases abort the protocol. Deterrence
measures may be in place to discourage parties from being detected
as malicious. In fact, unless parties stop participating our protocols
either complete successfully or abort while detecting that a specific
party is a cheater.

We start by introducing the key concepts of multiparty compu-
tation under the model of security with identifiable abort in the
stand-alone setting (see [33, App. B of the full version]). A multi-
party computation between our ğ‘› parties in P is a protocol that
computes a stochastic process F : ({0, 1}âˆ—)ğ‘› â†’ ({0, 1}âˆ—)ğ‘›, which
is also called an ideal functionality, where for all ğ‘– âˆˆ {1, . . . , ğ‘›}, the
ğ‘–th component of the input and output of F maps respectively to
the private input and output of party ğ‘ƒğ‘– .

In the simulation paradigm, a multiparty protocol securely com-
putes an ideal functionality in the presence of malicious adversaries
if any possible malicious behavior in the protocol caused by col-
luding malicious parties is not more harmful than what such party
can cause in the ideal model as defined below.

Ideal model. In this model, it is assumed that there exists a trusted
party that computes F. A malicious adversary S controls a set of
corrupted parties Pğ‘ğ‘œğ‘Ÿ . The ideal execution comprises 7 phases and
goes as follows:

(1) Inputs: Each party ğ‘ƒğ‘– receives a private input ğ‘¢ğ‘– . Addition-
ally, S has an auxiliary input ğ‘¢âˆ— which represents the extra
knowledge other than its regular input.

(2) Send inputs to the trusted party: All honest parties send
their input to the trusted party, while parties controlled by
S might deviate and send what S wishes.

(3) Early abort or corrupted input: S can send abortğ‘– in-
stead of a valid input, which means that some corrupted
party ğ‘ƒğ‘– performed an early abortion or sent a corrupted
input. In that case, the trusted party sends abortğ‘– (choosing
the index ğ‘– deterministically if many parties aborted or sent
a corrupted input) to all honest parties and halts.

(4) Detect cheating parties: During the execution, S can send
abortğ‘– to the trusted party, which means that a corrupted
party ğ‘ƒğ‘– attempted to cheat. In that case, the trusted party
sends abortğ‘– to all parties (i.e. the attempt of cheating is
detected).

(5) Trusted party answers the adversary: If no abortğ‘– is
sent, then the trusted party sends to S the outputs of F
of the corrupted parties. After receiving them, S can send
abortğ‘– to the trusted party or instruct it to continue.
(6) Trusted party answers the honest parties: If S instructed
the trusted party to continue, then the latter sends their out-
puts of F to the honest parties.

(7) Output: The honest parties always output what the trusted
party sent to them. S outputs any arbitrary computable
function of the inputs {ğ‘¢ğ‘– }ğ‘– âˆˆPğ‘ğ‘œğ‘Ÿ , the auxiliary input ğ‘¢âˆ— and
the messages obtained from the trusted party.

18

Let Â¯ğ‘¢ = (ğ‘¢1 . . . ğ‘¢ğ‘›) be the vector of inputs of all parties and ğ‘¢âˆ—
the auxiliary input of S. Recall that ğœ† is the security parameter. We
denote by idealF,S (ğ‘¢âˆ—),Pğ‘ğ‘œğ‘Ÿ ( Â¯ğ‘¢, ğœ†) to the vector of outputs of parties
in the above execution.

The real model. The real model of an ğ‘›-party protocol Î  describes
its execution in the presence of non-uniform probabilistic polyno-
mial time advesary A that corrupts a set of parties Pğ‘ğ‘œğ‘Ÿ . Parties in
P \ Pğ‘ğ‘œğ‘Ÿ behave as described by Î . We denote by realÎ ,A (ğ‘¢âˆ—) ( Â¯ğ‘¢, ğœ†)
the vector of outputs of parties in the real execution of Î  with input
Â¯ğ‘¢ and where A has auxiliary input ğ‘¢âˆ—.

We formalize the notion of security with identifiable abort [33,

Def. 16 of the full version] below.

Definition 3 (Security with identifiable abort in the stand-alone
setting). Let ğœ† be the security parameter and F : ({0, 1}âˆ—)ğ‘› â†’
({0, 1}âˆ—)ğ‘› be an ğ‘›-party ideal functionality. A protocol Î  securely
computes F with identifiable abort if for every non-uniform proba-
bilistic polynomial time (PPT) adversary A in the real model, there
exist a non-uniform PPT adversary S in the ideal model such that
the distributions of

{idealF,S (ğ‘¢âˆ—),Pğ‘ğ‘œğ‘Ÿ ( Â¯ğ‘¢, ğœ†)} Â¯ğ‘¢,ğ‘¢âˆ— âˆˆ ( {0,1}âˆ—)ğ‘›+1,ğœ† âˆˆN

and

{realÎ ,A (ğ‘¢âˆ—),Pğ‘ğ‘œğ‘Ÿ ( Â¯ğ‘¢, ğœ†)} Â¯ğ‘¢,ğ‘¢âˆ— âˆˆ ( {0,1}âˆ—)ğ‘›+1,ğœ† âˆˆN

are computationally indistinguishable.

Hybrid model. In addition to the security definition, the simula-
tion paradigm facilitates tools to prove security of protocols which
use sub-protocols already known to be secure. Given functionalities
F1, . . . , Fğ‘˜ , where ğ‘˜ is polynomial in ğœ†, it allows to define a protocol
in which both parties can send messages to each other and place
â€œideal callsâ€ to a trusted party that computes Fğ‘– for ğ‘– âˆˆ {1, . . . , ğ‘˜ }.
In these ideal calls, parties can send their input to the trusted party
and wait for the output of Fğ‘– . However, (1) they cannot send any
messages between each other after invoking an ideal functional-
ity and before its response is returned by the trusted party and
(2) functionalities cannot be called concurrently. In other words,
functionalities can only be sequentially composed with all other in-
teractions. We denote such model as the (F1, . . . , Fğ‘˜ )-hybrid model.
When we describe a protocol in the (F1, . . . , Fğ‘˜ )-hybrid model, we
say that F1, . . . , Fğ‘˜ are hybrid functionalities.

Sequential composition. Consider the protocol Î  and functionali-
ties F1, . . . , Fğ‘˜ as defined above and let ğœŒ1, . . . , ğœŒğ‘˜ be protocols. We
define the protocol Î ğœŒ1,...,ğœŒğ‘˜ to be the protocol in the ideal model
that behaves exactly as Î  in real messages, but for all ğ‘– âˆˆ {1, . . . , ğ‘˜ }
each ideal call to Fğ‘– is replaced by the execution of protocol ğœŒğ‘– .
We now state conditions such in which sequential composition is
secure.

Theorem 4 (Seqential composition [29]). Let F1, . . . , Fğ‘˜ be
secure multiparty functionalities and let ğœŒ1, . . . , ğœŒğ‘˜ be protocols that
securely compute F1, . . . , Fğ‘˜ respectively with identifiable abort. Let
G be a multiparty functionality and let Î  be a multiparty protocol
that securely computes G in the (F1, . . . , Fğ‘˜ )-hybrid model with
identifiable abort. Then Î ğœŒ1,...,ğœŒğ‘˜ securely computes G in the real
model with identifiable abort.

Private Sampling with Identifiable Cheaters

Proceedings on Privacy Enhancing Technologies YYYY(X)

We note that the model of [33] is defined for more general types
of composition. Nevertheless, it is compatible with the definition
described above.

Assumptions on adversaries. We can see A as a deterministic
algorithm with a special input which is a random tape of uniformly
distributed bits. In the ideal model, we can also rewind A to a
previous state in execution, where the random tape also rewinds.

B.2 Compressed Î£-protocols as Ideal

Functionalities

We will use compressed Î£-protocols implemented with the Fiat-
Shamir heuristic which are proven secure in the random oracle
model [48]. They have been proven secure against (by definition)
malicious provers and there is no interaction with malicious veri-
fiers. Therefore we can consider them as secure and abstract them
as hybrid functionalities. In particular, when we write ğ‘ƒ â†’ F ğ‘…
:
Î£
(ğ‘¥; ğ‘¤); F ğ‘…
gets as input from
party ğ‘ƒ the public data ğ‘¥ and secret witness ğ‘¤, gets from all other
relevant parties as input the empty string, and returns to all parties
in O the same pair [ğ‘, ğ‘¥ â€²] where ğ‘¥ â€² is the data provided as input by
ğ‘ƒ and ğ‘ is 1 if (ğ‘¥; ğ‘¤) âˆˆ ğ‘… (the proof succeeds) and 0 otherwise.

Î£ â†’ O : [ğ‘, ğ‘¥ â€²], we mean that F ğ‘…
Î£

B.3 Proof of Protocol 1
Let ğ‘ˆ be the random variable uniformly distributed over the interval
[0, ğ¿) for ğ¿ â‰¤ ğ‘. We consider the ideal functionality

Fğ‘1 ({} . . . {}) = (ğ‘ˆ . . . ğ‘ˆ ),

i.e., Fğ‘1 takes as input from each of the ğ‘› parties an empty string
and outputs to every party the same uniformly distributed ğ‘ˆ .

Protocol. The protocol Î ğ‘1 is explained below.

Protocol Î ğ‘1:
Security Parameter: ğœ†
ğ‘…1
Hybrid Functionality sub-protocols: Functionalities F
Î£
F

are zero knowledge proofs of respectively

ğ‘…2
Î£

and

â€¢ ğ‘…1 = {(ğ¶; ğ‘¥, ğ‘Ÿ ) : ğ¶ = ğ¶ğ‘œğ‘š(ğ‘¥, ğ‘Ÿ )}
â€¢ ğ‘…2 = {(ğ¶, ğ‘¥; ğ‘Ÿ ) : ğ¶ = ğ¶ğ‘œğ‘š(ğ‘¥, ğ‘Ÿ )} (only ğ‘Ÿ is secret),

Protocol:

(1) For ğ‘– = 1 . . . ğ‘› :

â€¢ ğ‘ƒğ‘– : choose ğ‘¥ğ‘– âˆˆ [0, ğ¿), ğ‘Ÿğ‘– âˆˆ Zğ‘ at random
â€¢ ğ‘ƒğ‘– : compute the commitment ğ¶ğ‘– = ğ¶ğ‘œğ‘š(ğ‘¥ğ‘–, ğ‘Ÿğ‘– )
â€¢ ğ‘ƒğ‘– : broadcast ğ¶ğ‘–
ğ‘…1
â€¢ ğ‘ƒğ‘– â†’ F
Î£
ğ‘…1
Î£

: (ğ¶ğ‘– ; ğ‘¥ğ‘–, ğ‘Ÿğ‘– )
: broadcast [ğ‘ğ‘–, ğ¶ â€²
ğ‘– ]

â€¢ F
â€¢ ğ‘ƒâˆ’ğ‘– : if ğ‘ğ‘– â‰  1 or ğ¶ â€²

ğ‘– â‰  ğ¶ğ‘– , detect ğ‘ƒğ‘– as a cheater and abort

(2) For ğ‘– = 1 . . . ğ‘›:
ğ‘…2
â€¢ ğ‘ƒğ‘– â†’ F
Î£
ğ‘…2
Î£

: broadcast [ğ‘ â€²
â€¢ F
â€¢ ğ‘ƒâˆ’ğ‘– : if ğ‘¥ğ‘– âˆ‰ [0, ğ¿), ğ‘ â€²

: (ğ¶ğ‘–, ğ‘¥ğ‘– ; ğ‘Ÿğ‘– )
ğ‘– , ğ¶ â€²â€²
ğ‘– , ğ‘¥ â€²
ğ‘– ]
ğ‘– â‰  1 or ğ¶ â€²â€²

and abort

ğ‘– â‰  ğ¶ğ‘– , detect ğ‘ƒğ‘– as a cheater

(3) For ğ‘– = 1 . . . ğ‘›:
â€¢ output (cid:205)ğ‘›

ğ‘–=1 ğ‘¥ â€²

ğ‘– mod ğ¿.

We state the security of protocol Î ğ‘1 in the theorem below.

19

ğ‘…2
Î£

Theorem 5 (Security of Î ğ‘1). Let ğ¶ğ‘œğ‘š be a computationally
and

ğ‘…1
binding and perfectly hiding commitment scheme and let F
Î£

be secure multiparty functionalities of computationally sound
F
zero-knowledge proofs of relations ğ‘…1 and ğ‘…2 respectively. Then, Pro-
ğ‘…2
tocol Î ğ‘1 securely computes Fğ‘1 in the (F
Î£ )-hybrid model
with identifiable abort if at least one party is honest.

ğ‘…1
Î£ , F

Proof. It is clear that Î ğ‘1 securely computes Fğ‘1 in the honest-

but-curious setting.

Below, we will use A to denote a non-uniform probabilistic

polynomial-time (PPT) adversary that controls covert parties.

In Figure 4, we define four very similar algorithms Sğ‘£, ğ‘£ âˆˆ
{0, 1, 2, 3} where S0 is a simulator and for which we will prove that
their ideal execution output is indistinguishable from the hybrid
execution output. Each simulator Sğ‘£ will internally run a copy of
A which we will denote by Ağ‘£. Without loss of generality, we
can assume that at the points where all parties send messages,
the messages of the honest parties arrive first, as everything an
adversary can infer from the messages of a subset of honest parties
it can also infer from the messages of all honest parties.

To see that the simulation of S0 is indistinguishable from the
ğ‘…1
ğ‘…2
Î£ )-hybrid model with adversary A, we define our simula-
Î£ , F
(F
tors such that

â€¢ The outputs of S0 and S1 are identically distributed, because
their only difference is the moment on which ğ‘§ is chosen
uniformly at random (and hence independently from other
variables).

â€¢ The outputs of S1 and S2 are identically distributed, the only
difference is that S1 first draws ğ‘§ in line 28 and then com-
putes ğ‘¥ğ‘–â€² from it, while S2 first draws ğ‘¥ğ‘–â€² and then computes
ğ‘§ from it.

â€¢ The outputs of S2 and S3 are indistinguishable. All inputs to
A are the same, except for a commitment ğ¶ğ‘œğ‘š(0, ğ‘Ÿğ‘–â€²) versus
a commitment ğ¶ğ‘œğ‘š(ğ‘¥ğ‘–â€², ğ‘Ÿğ‘–â€²). As the commitment scheme is
hiding and ğ‘Ÿğ‘–â€² is chosen independetly, the distributions of
these commitments are indistinguishable and for any A3
getting input ğ¶ğ‘œğ‘š(ğ‘¥ğ‘–â€², ğ‘Ÿğ‘–â€²) there is an A2 producing a com-
putationally indistinguishable output.

â€¢ The output of S3 is identically distributed as the output of

Î ğ‘1 in the hybrid model.

â–¡

Vectorized version. We can now consider the ideal functionality

F (ğ‘˜)
ğ‘1 ({} . . . {}) = ((ğ‘ˆ1 . . . ğ‘ˆğ‘˜ ) . . . (ğ‘ˆ1 . . . ğ‘ˆğ‘˜ )),

i.e., F (ğ‘˜)
ğ‘1 takes as input from each of the ğ‘› parties an empty string
and outputs to every party the same vector (ğ‘ˆ1 . . . ğ‘ˆğ‘˜ ) where every
ğ‘ˆğ‘– is uniformly distributed in [0, ğ¿) independently for ğ‘– = 1 . . . ğ‘˜.
We can then similarly construct a protocol Î  (ğ‘˜)
ğ‘1 that draws a vector
ğ‘§ uniformly distributed in [0, ğ¿)ğ‘˜ .

In this protocol we will use a pseudo-random number generator
as we defined in 2.6. We use a similar but equivalent definition which
is more convenient in our proof, in particular, for some polynomial
ğ‘, this is a function ğº : {0, 1}ğ‘ â†’ [0, ğ¿)ğ‘ (ğ‘) such that for any

Proceedings on Privacy Enhancing Technologies YYYY(X)

CÃ©sar Sabater, Florian Hahn, Andreas Peter, and Jan Ramon

Fğ‘1 â†’ S0 : ğ‘§ (S0 invokes trusted party delivering ideal functionality)

1: Phase 1: choosing ğ‘§ (see also phase 4)
2:

if ğ‘£ = 0 then

end if

4:
5: Phase 2: Sğ‘£ simulates honest parties:
6:

Sğ‘£ : ğ‘– â€² = max{ğ‘– | ğ‘ƒğ‘– âˆˆ P \ Pğ‘ğ‘œğ‘Ÿ }
for ğ‘ƒğ‘– âˆˆ (P \ Pğ‘ğ‘œğ‘Ÿ ) \ {ğ‘ƒğ‘–â€² } do

Sğ‘£: choose ğ‘¥ğ‘– randomly in [0, ğ¿) and ğ‘Ÿğ‘– randomly in Zğ‘
Sğ‘£: ğ¶ğ‘– = ğ¶ğ‘œğ‘š(ğ‘¥ğ‘–, ğ‘Ÿğ‘– ); [ğ‘ğ‘–, ğ¶ â€²
Sğ‘£ â†’ Ağ‘£ : [ğ‘ğ‘–, ğ¶ â€²

ğ‘– ] = F
ğ‘– ] (as if it is sent by ğ‘ƒğ‘– )

ğ‘…1
Î£ (ğ¶ğ‘– ; ğ‘¥ğ‘–, ğ‘Ÿğ‘– )

end for
if ğ‘£ âˆˆ {0, 1, 2} then

draw ğ‘Ÿğ‘–â€² randomly; ğ¶ğ‘–â€² = ğ¶ğ‘œğ‘š(0, ğ‘Ÿğ‘–â€²); [ğ‘ğ‘–â€², ğ¶ â€²

ğ‘–â€²] = [1, ğ¶ğ‘–â€²]

else

draw ğ‘¥ğ‘–â€² and ğ‘Ÿğ‘–â€² randomly; ğ¶ğ‘–â€² = ğ¶ğ‘œğ‘š(ğ‘¥ğ‘–â€²; ğ‘Ÿğ‘–â€²); [ğ‘ğ‘–â€², ğ¶ â€²

ğ‘–â€²] = F

ğ‘…1
Î£ (ğ¶ğ‘–â€²; ğ‘¥ğ‘–â€², ğ‘Ÿğ‘–â€²)

16:

end if
Sğ‘£ â†’ Ağ‘£ : [1, ğ¶ â€²
17:
18: Phase 3: Sğ‘£ simulates Ağ‘£:
for ğ‘– âˆˆ Pğ‘ğ‘œğ‘Ÿ do
19:

ğ‘–â€²] (as if it is the answer of F

ğ‘…1
Î£ (ğ¶ğ‘–â€²; ğ‘¥ğ‘–â€², ğ‘Ÿğ‘–â€²))

: (ğ¶ğ‘– ; ğ‘¥ğ‘–, ğ‘Ÿğ‘– ); Sğ‘£ records ğ¶ğ‘– , ğ‘¥ğ‘– and ğ‘Ÿğ‘– .

Ağ‘£ â†’ Sğ‘£ : ğ¶ğ‘–
ğ‘…1
Ağ‘£ â†’ F
Î£
ğ‘…1
Î£ â†’ Sğ‘£ : [ğ‘ğ‘–, ğ¶ â€²
F
If ğ¶ â€²
ğ‘– â‰  ğ¶ğ‘– or ğ¶ğ‘– â‰  ğ¶ğ‘œğ‘š(ğ‘¥ğ‘–, ğ‘Ÿğ‘– ) detect ğ‘ƒğ‘– as cheater
end for

ğ‘– ] (as if sent to members of P \ Pğ‘ğ‘œğ‘Ÿ )

24:
25: Phase 4: choosing ğ‘§ and ğ‘¥ğ‘–â€²
if ğ‘£ âˆˆ {0, 1} then
26:
if ğ‘£ = 1 then

27:

S1 chooses ğ‘§ uniformly at random

end if
ğ‘¥ğ‘–â€² = ğ‘§ âˆ’ (cid:205)ğ‘–â‰ ğ‘–â€² ğ‘¥ğ‘– mod ğ¿

else (i.e., if ğ‘£ âˆˆ {2, 3})

draw ğ‘¥ğ‘–â€² uniformly at random and set ğ‘§ = (cid:205)ğ‘– âˆˆP ğ‘¥ğ‘– mod ğ¿

end if

33:
34: Phase 5:
35:

for ğ‘ƒğ‘– âˆˆ P \ Pğ‘ğ‘œğ‘Ÿ do
Sğ‘£: set ğ‘¥ â€²
Sğ‘£ â†’ Ağ‘£: [ğ‘ â€²

ğ‘– = ğ‘¥ğ‘– ; ğ¶ â€²â€²
ğ‘– , ğ¶ â€²â€²

ğ‘– = ğ¶ğ‘– ; ğ‘ â€²
ğ‘– , ğ‘¥ â€²

ğ‘– = 1

end for

38:
39: Phase 6: Sğ‘£ continues simulation of Ağ‘£
40:

for ğ‘ƒğ‘– âˆˆ Pğ‘ğ‘œğ‘Ÿ do
Ağ‘£ â†’ F ğ‘…2
: (ğ¶ â€²â€²
Î£
F ğ‘…2
Î£ â†’ Sğ‘£ : [ğ‘ â€²
If ğ‘¥ â€²
ğ‘– â‰  ğ‘¥ğ‘– or ğ¶ â€²â€²
end for

ğ‘– ); Sğ‘£ records ğ¶ â€²â€²
ğ‘– , ğ‘¥ â€²
ğ‘– ; ğ‘Ÿ â€²
ğ‘– , ğ¶ â€²â€²
ğ‘– , ğ‘¥ â€²
ğ‘– ]
ğ‘– â‰  ğ¶ğ‘– or ğ‘ â€²

ğ‘– = 0 detect ğ‘ƒğ‘– as cheater

ğ‘– , ğ‘¥ â€²

ğ‘– and ğ‘Ÿ â€²
ğ‘–

44:
45: Phase 7: Output
46:

Ağ‘£ â†’ Sğ‘£ : ğ‘§ â€² (the output of Ağ‘£)
output ğ‘§ â€²

ğ‘…2
ğ‘– ] (as if it is sent by F
Î£

in answer to (ğ‘¥ğ‘–, ğ¶ğ‘– ; ğ‘Ÿğ‘– ))

3:

7:

8:

9:

10:

11:

12:

13:

14:

15:

20:

21:

22:

23:

28:

29:

30:

31:

32:

36:

37:

41:

42:

43:

47:

Figure 4: Simulators Sğ‘£, for ğ‘£ âˆˆ {0, 1, 2, 3}.

randomized polynomial time algorithm ğ´ : [0, ğ¿)ğ‘ (ğ‘) â†’ {0, 1}
there holds that |ğ‘ƒğ‘¥â†ğ‘… {0,1}ğ‘ (ğ´(ğº (ğ‘¥)) = 1) âˆ’ğ‘ƒğ‘¥â†ğ‘… [0,ğ¿)ğ‘ (ğ‘) (ğ´(ğ‘¥) =
1)| â‰¤ ğœ‡ (ğ‘) with ğœ‡ a negligible function. We choose ğ‘ sufficiently
large such that ğ‘ (ğ‘) â‰¥ ğ‘˜ âŒˆlog(ğ¿)âŒ‰ and ğœ‡ (ğ‘) is sufficiently small.

20

We describe this protocol in the hybrid model using the ideal
, which is a variant on the Fğ‘1 functionality

functionality Fğ‘1[0, 2ğ‘)

Private Sampling with Identifiable Cheaters

Proceedings on Privacy Enhancing Technologies YYYY(X)

we introduced above where ğ¿ is set to 2ğ‘. The protocol Î  (ğ‘˜)
described below:
1: Protocol Î  (ğ‘˜)
ğ‘1
2: Security parameter: ğœ†
3: Hybrid functionality sub-protocols:

ğ‘1 is

: draws a single public random number in [0, 2ğ‘).

â€¢ Fğ‘1[0, 2ğ‘)

4: Protocol:
5: All parties collaboratively perform:
ğ‘§ â€² = Fğ‘1[0, 2ğ‘) ({} . . . {})
6:
7: For ğ‘ƒğ‘– âˆˆ P:
8:

ğ‘ƒğ‘– : Output ğ‘§ = (ğ‘§1 . . . ğ‘§ğ‘˜ ) with ğ‘§ ğ‘— containing bits

( ğ‘— âˆ’ 1) âŒˆlog(ğ¿)âŒ‰ + 1 . . . ğ‘— âŒˆlog(ğ¿)âŒ‰

of ğº (ğ‘§ â€²) for ğ‘— = 1 . . . ğ‘˜

Theorem 6 (Security of Î  (ğ‘˜)

ğ‘1 ). Let Fğ‘1[0, 2ğ‘)

be a secure mul-

tiparty functionality and G be a PRG as defined above. Then, Protocol
ğ‘1 securely computes F (ğ‘˜)
Î  (ğ‘˜)
-hybrid model with
ğ‘1 in the Fğ‘1[0, 2ğ‘)
identifiable abort if at least one party is honest.

Proof. It follows from the definition of random number gener-
ator that the output of the protocol is indistinguishable from the
output of the ideal functionality when all parties are honest-but-
curious.

The protocol consists of first a call to a secure sub-protocol and
then a public computation which each agent can do for himself
without any interaction. It is hence easy to see that the protocol is
â–¡
secure.

B.4 Proof of Protocol 2
Now we prove the security of Protocol 2, which performs a pri-
vate uniform draw. Without loss of generality, we assume that
the drawn sample should be private to ğ‘ƒ1. The ideal functionality
Fğ‘2 : ({0, 1}âˆ—)ğ‘› â†’ ({0, 1}âˆ—)ğ‘› is defined as

Fğ‘2 ({} . . . {}) = ((ğ‘§, ğ‘Ÿğ‘§), ğ¶ğ‘§, . . . , ğ¶ğ‘§)

where ğ¶ğ‘§ = ğ¶ğ‘œğ‘š(ğ‘§, ğ‘Ÿğ‘§), ğ‘§ is uniformly randomly distributed in
[0, ğ¿)ğ‘˜ and ğ‘Ÿğ‘§ is uniformly randomly distributed in Zğ‘ (as a conse-
quence of the distributions of ğ‘§ and ğ‘Ÿğ‘§, ğ¶ğ‘§ is uniformly distributed
over G). The pair (ğ‘§, ğ‘Ÿğ‘§) is private to ğ‘ƒ1 while ğ¶ğ‘§ is known by all
parties. We will describe a detailed version of Protocol 2 in the hy-
brid model. Our hybrid functionalities will be Fğ‘1 and F (ğ‘˜)
ğ‘1 , which
ğ‘…ğ‘š
correspond to Protocol 1, and F
, which, for some modulus ğ¿ â‰¤ ğ‘
Î£
is the ideal functionality of a zero knowledge proof for relation

ğ‘…ğ‘š = {(ğ‘¦ âˆˆ [0, ğ¿)ğ‘˜, ğ‘Ÿğ‘¦ âˆˆ Zğ‘, ğ¶ğ‘¥ âˆˆ G, ğ¶ğ‘§ âˆˆ G;

ğ‘¥ âˆˆ [0, ğ¿)ğ‘˜, ğ‘Ÿğ‘¥ âˆˆ Zğ‘, ğ‘§ âˆˆ [0, ğ¿)ğ‘˜, ğ‘Ÿğ‘§ âˆˆ Zğ‘ ) :
ğ¶ğ‘¥ = ğ¶ğ‘œğ‘š(ğ‘¥, ğ‘Ÿğ‘¥ ) âˆ§ ğ¶ğ‘§ = ğ¶ğ‘œğ‘š(ğ‘§, ğ‘Ÿğ‘§) âˆ§ ğ‘¥ âˆˆ [0, ğ¿)
âˆ§ ğ‘§ = ğ‘¥ + ğ‘¦ mod ğ¿ âˆ§ ğ‘Ÿğ‘§ = ğ‘Ÿğ‘¥ + ğ‘Ÿğ‘¦ mod Zğ‘ }.

Such proof can be performed by applying the techiques decribed in
Section 6.1. In Figure 5, we define the protocol Î ğ‘2 which describes
Protocol 2 in more detail.

21

Theorem 7. Let ğ¶ğ‘œğ‘š be a computationally binding and perfectly
ğ‘…ğ‘š
hiding commitment scheme and let F
be a secure multiparty func-
Î£
tionality of a computationally sound zero-knowledge proof of relation
ğ‘…ğ‘š. Let F (ğ‘˜)
be secure multiparty functionalities
as defined above. Then, protocol Î ğ‘2 securely computes Fğ‘2 in the
(F (ğ‘˜)
ğ‘…ğ‘š
Î£ )-hybrid model with identifiable abort if at least
ğ‘1 , Fğ‘1Zğ‘
one party is honest.

ğ‘1 and Fğ‘1[0, 2ğ‘)

, F

Proof. First note that, except for ğ‘ƒ1, the other parties are only
supposed to perform ideal calls and do not interact with each other.
We will consider first the most difficult case in which ğ‘ƒ1 is among
the corrupted parties controlled by A. In Figure 6, we define our
adversary S that simulates the output of A in the ideal model.

We show that the ideal and hybrid execution outputs are indis-
tinguishable. We first start by analyzing the view of A in the hybrid
protocol and when interacting with S.

â€¢ Since A has not seen any other message, the first commit-
ment ğ¶ğ‘¥ of A is the same in both hybrid and ideal executions
â€¢ ğ‘¦ and ğ‘Ÿğ‘¦ have the same distribution in the hybrid and ideal
model as they are part of an ideal call. Therefore, also the
ğ¶ğ‘§ broadcasted by A follows the same distribution in the
hybrid and ideal model.

â€¢ if A cheats in ğ¶ğ‘§ (i.e., ğ¶ğ‘§ is not a commitment according
to relation ğ‘…ğ‘š), it gets caught both in the hybrid and ideal
executions

â€¢ before rewinding A, S recovers ğ‘¥ and ğ‘Ÿğ‘¥ such that ğ¶ğ‘¥ =
ğ¶ğ‘œğ‘š(ğ‘¥, ğ‘Ÿğ‘¥ ) with overwhelming probability (this is because
ğ‘…ğ‘š
A cannot fake the zero knowledge proof in F
except with
Î£
negligible probability)

â€¢ in the ideal world, S sets ğ‘¦ and ğ‘Ÿğ‘¦ such that ğ‘§ = ğ‘¥ + ğ‘¦ mod ğ¿
and ğ‘Ÿğ‘§ = ğ‘Ÿğ‘¥ + ğ‘Ÿğ‘¦ mod ğ‘, where ğ‘¥ and ğ‘Ÿğ‘¥ are chosen by A, ğ‘§
and ğ‘¦ are uniformly randomly distributed in [0, ğ¿)ğ‘˜ and ğ‘Ÿ
and ğ‘Ÿğ‘¦ are uniformly randomly distributed in Zğ‘ . This is the
same distribution as in the hybrid world.

â€¢ now A broadcast ğ¶ â€²â€²

ğ‘§ and either is detected as cheater or
ğ¶ â€²â€²
ğ‘§ = ğ¶ğ‘œğ‘š(ğ‘§, ğ‘Ÿğ‘§) with overwhelming probability both in the
hybrid or ideal executions

Up to this point, from the view of A the transcripts simulated by
S in the ideal execution and the transcript in the hybrid execution
are indistinguishable. Since A runs in polynomial time, his output
must be indistinguishable in both executions.

Now we analyze the case where ğ‘ƒ1 is among then honest parties.
Particularly, consider the worst case where all other parties are
malicious and ğ‘ƒ1 is the only honest party. This case is still easy
since the only interaction of malicious users is to perform ideal calls
to F (ğ‘˜)
. The only role of S is to send inputs that
might be consistent according to the behavior of A. Even if all the
verifiers are malicious, the honest party can still detect them. â–¡

ğ‘1 , Fğ‘1Zğ‘

ğ‘…ğ‘š
and F
Î£

B.5 Non-uniform Public and Private Draws
Public and Private draws from many distributions such as Gaus-
sians or Laplace distributions can be performed by first drawing uni-
formly distributed samples with either Protocol 1 for public draws
or Protocol 2 for private draws, then applying a non-interactive

Proceedings on Privacy Enhancing Technologies YYYY(X)

CÃ©sar Sabater, Florian Hahn, Andreas Peter, and Jan Ramon

1: Protocol Î ğ‘2 (to generate single private sample):
2: Security Parameter: ğœ†
3: Hybrid Functionalitiy sub-protocols:

ğ‘1 draws publicly a random number from [0, ğ¿)ğ‘˜ .

is a variant of Fğ‘1 that draws a random number from Zğ‘ rather than from [0, ğ¿).

performs a zero-knowledge proof for the relation ğ‘…ğ‘š defined above

â€¢ F (ğ‘˜)
â€¢ Fğ‘1Zğ‘
ğ‘…ğ‘š
â€¢ F
Î£
4: Protocol:
5: ğ‘ƒ1:
6:

7:

11:
12: ğ‘ƒ1:
13:

14:

draw ğ‘¥ âˆˆ [0, ğ¿)ğ‘˜ and ğ‘Ÿğ‘¥ âˆˆ Zğ‘ uniformly at random
compute ğ¶ğ‘¥ = ğ¶ğ‘œğ‘š(ğ‘¥, ğ‘Ÿğ‘¥ )
broadcast ğ¶ğ‘¥

8:
9: All parties in P collaboratively:
10:

call F (ğ‘˜)
call Fğ‘1Zğ‘

ğ‘1 to obtain a public ğ‘¦ uniformly distributed over [0, ğ¿)ğ‘˜
to obtain a public ğ‘Ÿğ‘¦ uniformly distributed over Zğ‘

Compute ğ‘§ = ğ‘¥ + ğ‘¦ mod ğ¿ and ğ‘Ÿğ‘§ = ğ‘Ÿğ‘¥ + ğ‘Ÿğ‘¦ mod ğ‘
Compute ğ¶ğ‘§ = ğ¶ğ‘œğ‘š(ğ‘§, ğ‘Ÿğ‘§)
broadcast ğ¶ğ‘§

17:

15:
ğ‘…ğ‘š
16: Parties perform an ideal call to F
Î£
ğ‘…ğ‘š
ğ‘ƒ1 â†’ F
Î£
ğ‘…ğ‘š
F
Î£
ğ‘ƒâˆ’1: if ğ‘ = 0 âˆ¨ ğ‘Ÿğ‘¢ â‰  ğ‘Ÿ â€²

: (ğ‘¦, ğ‘Ÿğ‘¦, ğ¶ğ‘¥ , ğ¶ğ‘§; ğ‘¥, ğ‘Ÿğ‘¥ , ğ‘§, ğ‘Ÿğ‘§)
ğ‘¦, ğ¶ â€²

: broadcast [ğ‘, ğ‘¦ â€², ğ‘Ÿ â€²

ğ‘¥ , ğ¶ â€²
ğ‘§]
ğ‘¦ âˆ¨ ğ‘¦ â‰  ğ‘¦ â€² âˆ¨ ğ¶ğ‘¥ â‰  ğ¶ â€²

18:

:

19:
20: ğ‘ƒ1: output (ğ‘§, ğ‘Ÿğ‘§)
21: ğ‘ƒâˆ’1: output ğ¶ğ‘§

ğ‘¥ âˆ¨ ğ¶ğ‘ â‰  ğ¶ â€²

ğ‘§, detect ğ‘ƒ1 as a cheater and abort, otherwise continue the execution

Figure 5: Protocol Î ğ‘2, a detailed description of Protocol 2.

transformation. For private draws, this transformation is a non-
interactive compressed Î£-protocol as described in Appendix B.2.
For each technique, we explain the appropriate transformation in
Sections 7.1, 8.1, 8.2, 8.3 and 8.4. This procedure is secure as it is
essentially a secure drawing of a uniformly distributed random
number as discussed in the previous sections followed by a private
but verifiable single-party post-processing.

22

Private Sampling with Identifiable Cheaters

Proceedings on Privacy Enhancing Technologies YYYY(X)

1: S: internally run A until broadcast ğ¶ğ‘¥ (line 8 in Î ğ‘2)
2: A â†’ S : ğ¶ğ‘¥
3: S: continue the run of A until after the ideal call to F (ğ‘˜)
4: S: draw a random value ğ‘¦ âˆˆ [0, ğ¿)ğ‘˜
5: S â†’ A : ğ‘¦ (as if it came from F (ğ‘˜)
ğ‘1 )
6: S: continue the run of A until after the ideal call to Fğ‘1Zğ‘
7: S: draw a random value ğ‘Ÿğ‘¦ âˆˆ Zğ‘
8: S â†’ A : ğ‘Ÿğ‘¦ (as if it came from Fğ‘1Zğ‘
9: A â†’ S : ğ¶ğ‘§
ğ‘…ğ‘š
10: S: continue run of A: ğ‘ƒ1 â†’ F
Î£
ğ‘¥ , ğ¶ â€²
: broadcast [ğ‘, ğ‘¦ â€², ğ‘Ÿ â€²
ğ‘¦, ğ¶ â€²
ğ‘§]
ğ‘¥ â‰  ğ¶ğ‘¥ âˆ¨ ğ¶ â€²
ğ‘¦ â‰  ğ‘Ÿğ‘¦ âˆ¨ ğ¶ â€²

ğ‘…ğ‘š
Î£
if ğ‘ = 0 âˆ¨ ğ‘¦ â€² â‰  ğ‘¦ âˆ¨ ğ‘Ÿ â€²

ğ‘§, ğ‘¥ â€², ğ‘Ÿ â€²

: (ğ‘¦ â€², ğ‘Ÿ â€²

ğ‘¥ , ğ¶ â€²

ğ‘¦, ğ¶ â€²

)

ğ‘¥ , ğ‘§ â€², ğ‘Ÿ â€²
ğ‘§)

ğ‘1 (line 10 in Î ğ‘2)

(line 11 in Î ğ‘2)

ğ‘§ â‰  ğ¶ğ‘§, detect ğ‘ƒ1 as a cheater

11: F
12:
13: S: invoke trusted party computing Fğ‘2
14: Fğ‘2 returns ((ğ‘§, ğ‘Ÿğ‘§) âˆˆ [0, ğ¿)ğ‘˜ Ã— Zğ‘, (ğ¶ğ‘§, . . . , ğ¶ğ‘§) âˆˆ G|Pğ‘ğ‘œğ‘Ÿ |âˆ’1) to S and (ğ¶ğ‘§, . . . , ğ¶ğ‘§) âˆˆ G|P\Pğ‘ğ‘œğ‘Ÿ | to the honest parties
15: S sets ğ‘¦ = ğ‘§ âˆ’ ğ‘¥ mod ğ¿ and ğ‘Ÿğ‘¦ = ğ‘Ÿğ‘§ âˆ’ ğ‘Ÿğ‘¥ mod ğ‘
16: S rewinds A to before the invocation of F (ğ‘˜)
ğ‘1
17: S continues the internal run of A, which performs ideal calls to F (ğ‘˜)
18: S â†’ A : ğ‘¦, ğ‘Ÿğ‘¦ (as if they were sent by F (ğ‘˜)
19: A â†’ S : ğ¶ â€²â€²
ğ‘§ ; if ğ¶ â€²â€²
ğ‘§ â‰  ğ¶ğ‘§, detect ğ‘ƒ1 as a cheater
ğ‘…ğ‘š
ğ‘¦ , ğ¶ â€²â€²
20: S continues to run A: ğ‘ƒ1 â†’ F
Î£
ğ‘¦ , ğ¶ â€²â€²
ğ‘¥ , ğ¶ â€²â€²
ğ‘§ ]
ğ‘¦ â‰  ğ‘Ÿğ‘¦ âˆ¨ ğ¶ â€²â€²
ğ‘¥ â‰  ğ¶ğ‘¥ âˆ¨ ğ¶ â€²â€²

ğ‘§ â‰  ğ¶ğ‘§, detect ğ‘ƒ1 as a cheater

: broadcast [ğ‘ â€², ğ‘¦ â€²â€², ğ‘Ÿ â€²â€²

ğ‘1 and Fğ‘1Zğ‘

ğ‘1 and Fğ‘1Zğ‘

ğ‘¥ , ğ‘§ â€²â€², ğ‘Ÿ â€²â€²
ğ‘§ )

ğ‘§ , ğ‘¥ â€²â€², ğ‘Ÿ â€²â€²

: (ğ‘¦ â€²â€², ğ‘Ÿ â€²â€²

ğ‘¥ , ğ¶ â€²â€²

)

.

ğ‘…ğ‘š
21: F
Î£
if ğ‘ â€² = 0 âˆ¨ ğ‘¦ â€²â€² â‰  ğ‘¦ âˆ¨ ğ‘Ÿ â€²â€²
22:
23: output whatever A outputs

Figure 6: Simulator of advesary A in Protocol Î ğ‘2, for the case when ğ‘ƒ1 is corrupted.

23

