The Regular Languages of First-Order Logic with One
Alternation
Corentin Barloy, Michael Cadilhac, Charles Paperman, Thomas Zeume

To cite this version:

Corentin Barloy, Michael Cadilhac, Charles Paperman, Thomas Zeume. The Regular Languages of
First-Order Logic with One Alternation. LICS 2022 - 37th Annual ACM/IEEE Symposium on Logic
in Computer Science, Aug 2022, HaÃ¯fa, Israel. pp.1-11, ï¿¿10.1145/3531130.3533371ï¿¿. ï¿¿hal-03934389ï¿¿

HAL Id: hal-03934389

https://hal.science/hal-03934389

Submitted on 11 Jan 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

Lâ€™archive ouverte pluridisciplinaire HAL, est
destinÃ©e au dÃ©pÃ´t et Ã  la diffusion de documents
scientifiques de niveau recherche, publiÃ©s ou non,
Ã©manant des Ã©tablissements dâ€™enseignement et de
recherche franÃ§ais ou Ã©trangers, des laboratoires
publics ou privÃ©s.

The Regular Languages of First-Order Logic
with One Alternation

2
2
0
2

r
a

M
1
1

]

O
L
.
s
c
[

1
v
5
7
0
6
0
.
3
0
2
2
:
v
i
X
r
a

Corentin Barloy
corentin.barloy@inria.fr
Univ. Lille, CNRS, INRIA, Centrale Lille, UMR 9189
CRIStAL
France

Charles Paperman
charles.paperman@univ-lille.fr
Univ. Lille, CNRS, INRIA, Centrale Lille, UMR 9189
CRIStAL
France

Abstract
The regular languages with a neutral letter expressible
in first-order logic with one alternation are characterized.
Specifically, it is shown that if an arbitrary Î£2 formula
defines a regular language with a neutral letter, then there is
an equivalent Î£2 formula that only uses the order predicate.
This shows that the so-called Central Conjecture of Straub-
ing holds for Î£2 over languages with a neutral letter, the first
progress on the Conjecture in more than 20 years. To show
the characterization, lower bounds against polynomial-size
depth-3 Boolean circuits with constant top fan-in are
developed. The heart of the combinatorial argument resides
in studying how positions within a language are determined
from one another, a technique of independent interest.

Keywords: automata theory, first-order logic, descriptive
complexity, circuit complexity.

1 Introduction

Circuits and regular languages. Since the works of
Barrington and ThÃ©rien [2, 5] in the early 1990s, regular
languages have emerged as the backbone of small-depth cir-
cuit complexity. Despite being the most elementary class of
languages, regular languages seem to embody the intrinsic
power of circuit classes. Under a suitable notion of reduction,
a lot of relevant circuit classes even admit complete regular
languages (this is at the heart of Barringtonâ€™s Theorem [2]).
In addition, it seems that each natural restriction of small-
depth circuits defines its own class of regular languages.

More precisely, consider the following families:
â€¢ AC0

ğ‘– is the class of Boolean circuits families of depth ğ‘–

and polynomial size,

ğ‘– is the same as AC0

ğ‘– but with additional modulo

â€¢ ACC0
gates,

â€¢ TC0

ğ‘– is the same as AC0

ğ‘– but with additional threshold

gates (more than half of the inputs are 1).

The hierarchy in depth of AC0 is known to be strict [26], but
this is open for the other classes (for TC0 this is known up

MichaÃ«l Cadilhac
michael@cadilhac.name
DePaul University
USA

Thomas Zeume
thomas.zeume@rub.de
Ruhr-UniversitÃ¤t Bochum
Germany

to depth 3 [13]). It is however conjectured that each of these
hierarchies is strict and that strictness can always be wit-
nessed by regular languages; in other words, as mentioned,
each of these classes is conjectured to have its own subset of
regular languages.

Over the past 30 years, abundant literature has provided
a sophisticated toolset to show separation (and sometimes
decidability) of classes of regular languages. This toolset
relies on algebraic objects that characterize the complexity
of regular languages; this object satisfies some properties
iff the language belongs to some class. It is thus tempting
to, first, characterize the regular languages that belong to
a circuit class, and, second, separate the classes that arise.
This paper is focused on that first step, for a specific class of
circuits (loosely speaking, AC0
3).
Logic. Wishing to provide a guiding light, Straubing [30]
presented in a succinct but beautiful way the links between
circuit complexity and automata theory, and formulated a
conjecture on. . . logics. Indeed, circuits themselves are ill-
formed for statements of the form â€œa circuit family AC0
ğ‘– rec-
ognizes a regular language iff it has this specific shape.â€ Logic
came to the rescue by giving a descriptional tool for circuits.
This started with the work of Barrington et al. [3] and Straub-
ing [29] who showed that AC0 (= (cid:208)ğ‘– AC0
ğ‘– ) is equivalent to
first-order logic. This means that for any AC0 circuit family,
there is a first-order formula, with quantifiers over positions,
that recognizes the same language. For instance, over the
alphabet ğ´ = {ğ‘, ğ‘, ğ‘} the language ğ´âˆ—ğ‘ğ‘âˆ—ğ‘ğ´âˆ—, which is in
AC0

2, can be written as:

(âˆƒğ‘¥, ğ‘¦) [ğ‘¥ < ğ‘¦ âˆ§ ğ‘(ğ‘¥) âˆ§ ğ‘(ğ‘¦) âˆ§

(find the 2 ğ‘s)

(âˆ€ğ‘§) [ğ‘¥ < ğ‘§ < ğ‘¦ â†’ ğ‘ (ğ‘§)]]

(everything in between is a ğ‘)
In this formula, we used the numerical predicate <; numer-
ical predicates speak about the numerical value of positions
but not their contents. The class of (languages recognized
by) formulas FO[arb] is that of first-order formulas where
we allow any numerical predicate (even undecidable ones!).

 
 
 
 
 
 
The aforementioned characterization reads: AC0 = FO[arb].
Extensions of this tight relationship between circuits and
logics exist for ACC0, TC0, and other classes (see [30]).

Equipped with this, the characterization of the regular

languages of AC0 is given by this striking statement [29]:

FO[arb] âˆ© Reg = FO[reg],

where reg is the set of numerical predicates <, +1, and divisi-
bility by constants. Straubing notes â€œthis phenomenon appears
to be quite generalâ€ and postulates that for well-behaved log-
ics L, it holds that

L [arb] âˆ© Reg = L [reg].

This is known as the Straubing Property for L (simply Cen-
tral Conjecture in [30]) and it is explicitly stated for the logics
Î£ğ‘– . Straubing [30, p. 169] explains: â€œThis has the look of a
very natural principle. It says, in effect, that the only numer-
ical predicates we need in a sentence that defines a regular
language are themselves recognized by finite automata.â€

The Program for Separation in circuit complexity then

becomes:

1. Identify a logic that corresponds to the circuit class,
2. Prove the Straubing Property for the class,
3. Show separation over regular languages.

In this work, we apply this approach to the lower reaches
of the AC0
ğ‘– hierarchy. Step 1 in the Program is covered by a
result of [20]; we will be focusing on the subset Î£ğ‘– of FO of
formulas with ğ‘– quantifier alternations, starting with an ex-
istential one. For instance, the above formula is in Î£2 [<, +1].
The Straubing Properties for these logics are very much
open: it is known to hold for Î£1 [30] and its Boolean clo-
sure [20, 31], but no progress has been made on Straubing
Properties since the end of the 1990s.

We will be mostly focusing on languages with a neutral
letter, this means that the languages will admit a letter ğ‘ that
can be added or removed from words without impacting their
membership in the language. This is usually not a restric-
tion to the Program for Separation, since it is conjectured
that circuit classes are separated by regular languages with
neutral letters. See, in particular, the fascinating survey by
KouckÃ½ [17]. Write Neut for the set of languages that have a
neutral letter. The Neutral Straubing Property is that for a
logic L, it holds that:

L [arb] âˆ© Reg âˆ© Neut = L [<] âˆ© Neut.

Contributions. We show that Î£2 has the Neutral Straub-
ing Property and that Î”2 = (Î£2 âˆ© Î 2) has the Straubing Prop-
erty, where Î 2 is defined as Î£2 but with âˆƒ and âˆ€ swapped.
Consequently, we exhibit some natural regular languages
that separate AC0

2 and AC0
3.

Related work. In [12], the authors study the model of so-
called programs over DA. This defines another subclass of

Corentin Barloy, MichaÃ«l Cadilhac, Charles Paperman, and Thomas Zeume

AC0, but it is not known to have any equivalent characteri-
zation in terms of circuits. It is in particular not known to be
equivalent to Î£2 [arb] âˆ© Î 2 [arb] or to the two-variable frag-
ment of FO[arb], classes that we will explore in Section 6.
They give a precise description of the regular languages
computable with programs over DA, but their proof uses
the algebraic structure of DA, which is not available in our
setting.

The class Î£2 [<] corresponds to the second level of the
Straubing-ThÃ©rien hierarchy, an extensively studied hierar-
chy that is closely tied to the famous dot-depth hierarchy.
A major open problem is to decide whether a given regular
language belongs to a given level of this hierarchy. See the
survey of Pin [21] for a modern account on this topic and
the recent major progress of Place and Zeitoun [25].

Organization of the paper. We introduce circuits, logic,
and a bit of algebra in Section 2. In Section 3, we introduce so-
called limits, a classical tool in devising lower bounds against
depth-3 circuits. In Section 4, we present a simple lower
bound against a language in Î£2; this serves as both a warm-
up for the main proof and to identify the difficulties ahead.
In Section 5, we prove our main result, that is, the Neutral
Straubing Property for Î£2. In Section 6, we derive some
consequences of our main result, in particular the Straubing
Property for Î”2. We conclude in Section 7.

2 Preliminaries
We assume familiarity with regular languages, logic, and
circuits, although we strive to keep this presentation self-
contained. We write Reg for the class of regular languages.

Word, languages, neutral letters. Following Lothaire [19],

a word ğ‘£ = ğ‘1ğ‘2 . . . ğ‘ğ‘›, with each ğ‘ğ‘– in an alphabet ğ´, is a sub-
word of a word ğ‘£ if ğ‘£ can be written as ğ‘£ = ğ‘£0ğ‘1ğ‘£1ğ‘2 Â· Â· Â· ğ‘ğ‘›ğ‘£ğ‘›,
with each ğ‘£ğ‘– in ğ´âˆ—. We say that a language ğ¿ separates ğ‘‹
from ğ‘Œ if ğ‘‹ âŠ† ğ¿ and ğ¿ âˆ© ğ‘Œ = âˆ…. A language ğ¿ has a neutral
letter if there is a letter ğ‘ such that ğ‘¢ Â· ğ‘ Â· ğ‘£ âˆˆ ğ¿ â‡” ğ‘¢ Â· ğ‘£ âˆˆ ğ¿
for all words ğ‘¢, ğ‘£. We write Neut for the class of languages
with a neutral letter.

Monoids, ordered monoids, morphisms. A monoid is a
set equipped with a binary associative operation, denoted
multiplicatively, with a identity element. An idempotent of ğ‘€
is an element ğ‘’ âˆˆ ğ‘€ that satisfies ğ‘’2 = ğ‘’. For an alphabet ğ´,
the set ğ´âˆ— is the free monoid generated by ğ´, its identity ele-
ment being the empty word. An ordered monoid is a monoid
equipped with a partial order â‰¤ compatible with the product,
i.e., ğ‘¥ â‰¤ ğ‘¦ implies ğ‘¥ğ‘§ â‰¤ ğ‘¦ğ‘§ and ğ‘§ğ‘¥ â‰¤ ğ‘§ğ‘¦ for any ğ‘¥, ğ‘¦, ğ‘§ âˆˆ ğ‘€.
Any monoid can be seen as an ordered monoid, using equal-
ity as order. An upper set of an ordered monoid ğ‘€ is a set ğ‘†
such that for any ğ‘¥, ğ‘¦ âˆˆ ğ‘€, if ğ‘¥ âˆˆ ğ‘† and ğ‘¥ â‰¤ ğ‘¦ then ğ‘¦ âˆˆ ğ‘†. A
morphism is a map â„ : ğ‘€ â†’ ğ‘ satisfying â„(ğ‘ğ‘) = â„(ğ‘)â„(ğ‘)
and â„(1) = 1, with ğ‘, ğ‘ âˆˆ ğ‘€ and 1 denoting the identity
element of ğ‘€ and ğ‘ .

The Regular Languages of First-Order Logic with One Alternation

Monoids as recognizers. An ordered monoid ğ‘€ recog-
nizes a language ğ¿ âŠ† ğ´âˆ— if there is a morphism â„ : ğ´âˆ— â†’ ğ‘€
and an upper set ğ‘ƒ of ğ‘€ such that ğ¿ = â„âˆ’1(ğ‘ƒ). The ordered
syntactic monoid of ğ¿ is the smallest ordered monoid that
recognizes ğ¿; it is finite iff ğ¿ is regular, in which case it is
unique.1

Logic. We work with first-order logics recognizing lan-

guages. For instance, the formula over the alphabet {ğ‘, ğ‘}

(âˆ€ğ‘¥)(âˆƒğ‘¦) [mod2(ğ‘¥) âˆ¨ (ğ‘¦ = ğ‘¥ + 1) âˆ§ (ğ‘(ğ‘¥) â†” ğ‘ (ğ‘¦))]

asserts that, in a given word ğ‘¤, for every position ğ‘¥ there is
another position ğ‘¦ such that either ğ‘¥ is divisible by 2 (mod2)
or ğ‘¦ is just after ğ‘¥ and ğ‘¤ has different letters at ğ‘¥ and ğ‘¦. The
predicates mod2 and +1 are examples of numerical predicates,
i.e., they only speak about the numerical positions, not the
contents of the input word. The predicates ğ‘(Â·) and ğ‘ (Â·) are
the letter predicates.

In this paper, first-order logics are specified by restricting

two aspects:

â€¢ The number of quantifier alternations. We write Î£2 for
the subset of first-order formulas that can be written
as (âˆƒğ‘¥1, ğ‘¥2, . . .)(âˆ€ğ‘¦1, ğ‘¦2, . . .) [ğœ™] with ğœ™ a quantifier-free
formula, that is, Î£2 is the set of formulas starting with
an existential quantifier and alternating once. In Sec-
tion 6.1, we will briefly mention Î 2 (defined as Î£2 but
with âˆƒ and âˆ€ swapped) and Î”2, the set of formulas
that are equivalent to both a Î£2 and a Î 2 formula (this
describes, a priori, fewer languages than Î£2 or Î 2).
â€¢ The numerical predicates allowed. Except for a quick
detour in Section 6.1, we will only be using two sets:
<, that is, the sole order relation (e.g., Î£2 [<]) and arb
the set of all predicates (e.g., Î£2 [arb]). In the latter
set, there would be predicates asserting that two posi-
tions are coprime or that a position encodes an halting
Turing machine, there is no restriction whatsoever.

The language of a formula is the set of words that satisfy
it. We commonly identify a class of formulas with the class
of languages they recognize.

Languages of a syntactic ordered monoid. Let ğ‘€ be
an ordered monoid. For any element ğ‘¥ âˆˆ ğ‘€, the up-word
problem for ğ‘€ and ğ‘¥ is the following language over ğ‘€ seen
as an alphabet:

Lemma 2.1 (From [23, Lemma 5.6]). A regular language
with a neutral letter is in Î£2 [arb] iff all the up-word problems
for its ordered syntactic monoid are in Î£2 [arb].

Circuits. We will study languages computed by fami-
lies of constant-depth, polynomial-size circuits consisting of
unbounded fan-in âˆ§- and âˆ¨-gates. A circuit with ğ‘› inputs
ğ‘¥1, ğ‘¥2, . . . , ğ‘¥ğ‘› in some alphabet ğ´ can query whether any in-
put contains any given letter in ğ´. The depth of the circuit is
the maximal number of gates appearing on a path from an
input to the output. A circuit family is an infinite set (ğ¶ğ‘›)ğ‘› â‰¥0
where the circuit ğ¶ğ‘› has ğ‘› inputs and one output gate; a word
ğ‘¤ is deemed accepted if the circuit ğ¶ |ğ‘¤ | outputs 1 when ğ‘¤ is
placed as input. We identify classes of circuits with the class
of languages they recognize.

For a circuit ğ¶ we visualize the inputs on top and the
one output gate at the bottom.2 The top fan-in of ğ¶ is the
maximum fan-in of the gates that receive an input letter
directly. We say that ğ¶ is a âˆƒâˆ€âˆƒ circuit if it is layered with
a bottom OR gate with AND gates as inputs, each of these
having OR gates as inputs.

We let Î£2 be the class of families of âˆƒâˆ€âˆƒ circuits of
polynomial-size and constant top fan-in. In the literature,
this circuit family is also called Î£Î Î£(ğ‘˜) in [10] and Î£poly,ğ‘˜
2
in [9], where ğ‘˜ is the top fan-in. It is a subclass of AC0
3, the
class of polynomial-size, depth-3 circuits, a class we will
discuss in Section 6.2. The name â€œÎ£2 circuit familyâ€ is all the
more justified that:

Lemma 2.2 (From [20, Proposition 11]). A language is rec-
ognized by a Î£2 [arb] formula iff it is recognized by a Î£2 circuit
family.

We will often exploit this equivalence without pointing at

this lemma.

A decidable characterization of Î£2 [<]. Let ğ‘¥, ğ‘¦ âˆˆ ğ‘€;
we say that ğ‘¦ is a subword of ğ‘¥ if there are two words
ğ‘¤ğ‘¥, ğ‘¤ğ‘¦ âˆˆ ğ‘€ âˆ— that evaluate, using ğ‘€â€™s product, to ğ‘¥ and
ğ‘¦, respectively, and ğ‘¤ğ‘¦ is a subword of ğ‘¤ğ‘¥ . The following is a
characterization of the languages in Î£2 [<] that is due to Pin
and Weil [22], and we use a version proposed by BojaÅ„czyk:
Theorem 2.3 (From [6]). A regular language is in Î£2 [<] iff
its ordered syntactic monoid ğ‘€ is such that for any ğ‘¥, ğ‘¦ âˆˆ ğ‘€
such that ğ‘¥ is an idempotent3 and ğ‘¦ a subword of ğ‘¥, it holds
that

{ğ‘¤ âˆˆ ğ‘€ âˆ— | ğ‘¤ evaluates in ğ‘€ to an element â‰¥ ğ‘¥ }.

ğ‘¥ â‰¤ ğ‘¥ğ‘¦ğ‘¥ .

In some precise sense, a regular language has the same com-
plexity as the hardest of the up-word problems for its ordered
syntactic monoid; in the case on Î£2 [arb], we can state:

1The ordered syntactic monoid is usually defined as the quotient of ğ´âˆ— by
the so-called syntactic order induced by ğ¿; the definition proposed here is
equivalent [23, Corollary 4.4] and allows to introduce one fewer concept.

Equivalently, this could be worded over languages directly:
a regular language ğ¿ is in Î£2 [<] iff for any three words

2The literature has been flip-flopping between putting the inputs at the
bottom or at the top, with a semblance of stability for â€œtopâ€ achieved in the
late 90s. This explains that some references mention â€œbottom fan-in.â€
3This is usually written by letting ğ‘¥ be any element, and considering ğ‘¥ğœ” ,
which is the unique idempotent that is a power of ğ‘¥; we simplify the pre-
sentation slightly by simply requiring ğ‘¥ to be an idempotent.

Corentin Barloy, MichaÃ«l Cadilhac, Charles Paperman, and Thomas Zeume

ğ‘¤1, ğ‘¤2, ğ‘¤3 that map to the same idempotent in ğ‘€ and ğ‘£ a
subword of ğ‘¤2, if a word ğ‘¤0 Â· ğ‘¤1ğ‘¤2ğ‘¤3 Â· ğ‘¤4 is in ğ¿, for some
words ğ‘¤0, ğ‘¤4, then so is ğ‘¤0 Â· ğ‘¤1ğ‘£ğ‘¤3 Â· ğ‘¤4. We will allude to
this wording in some proofs in the Consequences section
(Section 6.2).

Corollary 3.3. Let ğ¿ be a language and write ğ¿ğ‘› for the subset
of words of length ğ‘› in ğ¿. Assume that for any ğ‘˜, ğ‘‘ âˆˆ N, there
is an ğ‘› âˆˆ N and a subset ğ¿â€² âŠ† ğ¿ğ‘› such that every subset ğ¹ âŠ† ğ¿â€²
of size at least |ğ¿â€²|/ğ‘›ğ‘‘ admits a ğ‘˜-limit outside of ğ¿. Then ğ¿ is
not in Î£2 [arb].

3 Limits and lower bounds against Î£2 [arb]
We present a tool that has been used several times to show
lower bounds against depth-3 circuits, in particular in [14].
The following definition is attributed to Sipser therein:
Definition 3.1 (From [27]). Let ğ¹ be a set of words, all of
same length ğ‘›, and ğ‘˜ > 0. A ğ‘˜-limit for ğ¹ is a word ğ‘¢ of
length ğ‘› such that for any set of ğ‘˜ positions, a word in ğ¹
matches ğ‘¢ on all these positions. In symbols, ğ‘¢ satisfies:

(âˆ€ğ‘ƒ âŠ† [ğ‘›].|ğ‘ƒ | = ğ‘˜)(âˆƒğ‘£ âˆˆ ğ¹ )(âˆ€ğ‘ âˆˆ ğ‘ƒ) (cid:2)ğ‘¢ğ‘ = ğ‘£ğ‘ (cid:3) .
Naturally, we will be interested in ğ‘˜-limits that fall out-
side of ğ¹ , otherwise finding ğ‘˜-limits is trivial. In fact, we
will consider sets ğ¹ that are included in a subset of a target
language, and find ğ‘˜-limits outside of the target language
itself. We include a short proof of the following statement
for completeness and because it makes the statement itself
more readily understandable.
Lemma 3.2 (From [14, Lemma 2.2]). Let ğ¿ be a set of words
all of same length ğ‘› and ğ¶ be a âˆƒâˆ€âˆƒ circuit that accepts at
least all the words of ğ¿. Let ğ‘˜ be the top fan-in of ğ¶ and ğ‘  its
size.

Assume there is a subset ğ¿â€² âŠ† ğ¿ such that for any ğ¹ âŠ† ğ¿â€² of
size at least |ğ¿â€²|/ğ‘  there is a ğ‘˜-limit for ğ¹ that does not belong
to ğ¿. Then ğ¶ accepts a word outside of ğ¿. The hypothesis can
be represented graphically as:

ğ¿

âˆƒğ¿â€²

âˆ€ğ¹
|ğ¹ | â‰¥ |ğ¿â€²|/ğ‘ 

âˆƒğ‘¢
ğ‘˜-lim. for ğ¹

Proof. At the bottom of ğ¶, we have an OR gate of fan-in
at most ğ‘  that receives the result of some AND gates. By
counting, one of these AND gates should accept a subset ğ¹
of ğ¿â€² of size at least |ğ¿â€²|/ğ‘ ; we will now focus on that gate. Let
ğ‘¢ âˆ‰ ğ¿ be the ğ‘˜-limit for ğ¹ that exists by hypothesis. Consider
an OR gate that feeds into the AND gate under consideration.
This OR gate checks the contents of a subset ğ‘ƒ âŠ† [ğ‘›] of ğ‘˜
positions of the input. By hypothesis, there is a word ğ‘£ in ğ¹
that matches ğ‘¢ on all the positions in ğ‘ƒ, hence the OR gate
cannot distinguish between ğ‘¢ and ğ‘£ and must output 1 (true)
as ğ‘£ must be accepted. This holds for all the OR gates feeding
into the AND gate under consideration, hence the AND gate
â–¡
must accept ğ‘¢, and so does ğ¶.

Proof. For a contradiction, assume there is a Î£2 circuit family
for ğ¿, with top fan-in ğ‘˜ and size ğ‘›ğ‘‘ . Let ğ‘› be the value pro-
vided by the hypothesis, then the circuit ğ¶ for ğ¿ğ‘› satisfies the
hypotheses of Lemma 3.2, hence ğ¶ accepts a word outside
â–¡
of ğ¿, a contradiction.

4 Warm-up: ğ¾ = (ğ‘ğ‘âˆ—ğ‘ + ğ‘)âˆ— âˆ‰ Î£2 [arb]
In this section, we follow the approach of HÃ¥stad, Jukna, and
PudlÃ¡k [14] to show the claim of the section title. We present
it in a specific way that will help us stress the commonality
and the differences of this approach with our main proof.

To show the claim of the section title, we consider a
slightly different language. For any ğ‘› that is a perfect square,
we let Goodğ‘› be the set of words of length ğ‘› over {ğ‘, ğ‘} of
the following shape:

ğ‘›

ğ‘ Â· Â· Â· ğ‘ğ‘ğ‘ Â· Â· Â· ğ‘

. . .

ğ‘ Â· Â· Â· ğ‘ğ‘ğ‘ Â· Â· Â· ğ‘

âˆš
ğ‘›

âˆš
ğ‘›

In words, a word is in Goodğ‘› if it can be decomposed into
âˆš
ğ‘›, such that each of them has exactly

ğ‘› blocks of length

âˆš

one ğ‘. We let Good = (cid:208)ğ‘› Goodğ‘›.

Lemma 4.1. If ğ¾ is in Î£2 [arb], then so is Good.

âˆš

Proof. This is easier to see on circuits, so assume there is a
Î£2 circuit family for ğ¾. For ğ‘› a perfect square, we design a
circuit for Goodğ‘›. On any input, we convert the ğ‘â€™s to ğ‘â€™s and
insert a ğ‘ every
ğ‘› positions; we call this the expansion of the
input word. For instance, with ğ‘› = 9, the input ğ‘ğ‘ğ‘ ğ‘ğ‘ğ‘ ğ‘ğ‘ğ‘
is expanded to ğ‘ğ‘ğ‘ğ‘ ğ‘ğ‘ğ‘ğ‘ ğ‘ğ‘ğ‘ğ‘. Clearly, if the input word is
in Goodğ‘›, then its expansion is in ğ¾. Conversely, if a block
of the input had two ğ‘â€™s, the expansion will not add a ğ‘ in
between, so the expansion is not in ğ¾; similarly, if a block of
the input contains only ğ‘â€™s, it will be expanded to only ğ‘â€™s
sandwiched between two ğ‘â€™s, and the expansion will not be
in ğ¾ (in the case where the block containing only ğ‘â€™s is the
first one, the expansion starts with ğ‘ Â· Â· Â· ğ‘ğ‘, again putting the
expansion outside of ğ¾).

Thus a circuit for Goodğ‘› can be constructed by computing
the expansion (this only requires wires and no gates), then
feeding that expansion to a circuit for ğ¾. If the circuit family
for ğ¾ were in Î£2, so would the circuit family for Good. â–¡

We use Corollary 3.3 to show that Good âˆ‰ Î£2 [arb]. Let
then ğ‘˜, ğ‘‘ âˆˆ N. The value of ğ¿â€² in Corollary 3.3 will simply be
Goodğ‘›, and we show:

The Regular Languages of First-Order Logic with One Alternation

Lemma 4.2. If ğ‘› is large enough, any subset ğ¹ âŠ† Goodğ‘›
âˆš
ğ‘› has a ğ‘˜-limit outside of Goodğ‘›. This holds in
with |ğ¹ | > ğ‘˜
particular if |ğ¹ | â‰¥ |Goodğ‘› |/ğ‘›ğ‘‘ .

Proof. We rely on the Flower Lemma, a combinatorial lemma
that is a relaxation of the traditional Sunflower Lemma. We
first need to introduce some vocabulary.

We consider families F containing sets of size ğ‘  for some ğ‘ .
The core of the family is the set ğ‘Œ = (cid:209)ğ‘† âˆˆ F ğ‘†. The coreless
version of F is the family Fğ‘Œ = {ğ‘† \ ğ‘Œ | ğ‘† âˆˆ F }. A set ğ‘†
intersects a family F if all the sets of F have a nonempty
intersection with ğ‘†. Finally, a flower with ğ‘ petals is a family
F of size ğ‘ with core ğ‘Œ such that any set which intersects
Fğ‘Œ is of size at least ğ‘.
Lemma 4.3 (Flower Lemma [16, Lemma 6.4]). Let F be
a family containing sets of cardinality ğ‘  and ğ‘ â‰¥ 1 be an
integer. If |F | > (ğ‘ âˆ’ 1)ğ‘  , then there is a subfamily F â€² âŠ† F
that is a flower with ğ‘ petals.
To apply this lemma, consider the mapping ğœ from words
in Goodğ‘› to 2[ğ‘›] that lists all the positions where a word
has an ğ‘. For instance, with ğ‘› = 9, ğœ (ğ‘ğ‘ğ‘ ğ‘ğ‘ğ‘ ğ‘ğ‘ğ‘) = {3, 4, 8}.
ğ‘›. We let F =
For any word ğ‘¤ in Goodğ‘›, ğœ (ğ‘¤) is of size
{ğœ (ğ‘¤) | ğ‘¤ âˆˆ ğ¹ }.
âˆš

We now apply the lemma with ğ‘  =

ğ‘› and ğ‘ = ğ‘˜ + 1.
Since |F | = |ğ¹ |, we can apply the lemma on F and obtain a
subfamily F â€² that is a flower with ğ‘˜ + 1 petals. Let ğ‘Œ be its
core. Consider the word ğ‘¢ of length ğ‘› over {ğ‘, ğ‘} which has
ğ‘â€™s exactly at the positions in ğ‘Œ . Then:

âˆš

âˆš
âˆš

â€¢ ğ‘¢ is outside of Goodğ‘›. Indeed, |ğ‘Œ | <
ğ‘›, since it is the
ğ‘›. Hence one of
intersection of distinct sets of size
the blocks of ğ‘¢ will contain only ğ‘â€™s, putting it outside
of Goodğ‘›.

â€¢ ğ‘¢ is a ğ‘˜-limit. Let ğ‘ƒ be a set of ğ‘˜ positions, we will
find a word that is mapped to F â€² that matches ğ‘¢ on
ğ‘ƒ. If a position in ğ‘ƒ points to an ğ‘ in ğ‘¢, then every
word in F â€² has an ğ‘ at that position (by construction,
since this position would belong to the core ğ‘Œ ). So we
assume that ğ‘ƒ contains only positions on which ğ‘¢ is
ğ‘. Since |ğ‘ƒ | is ğ‘˜, it cannot intersect F â€², hence there is
a set ğ‘† âˆˆ F â€² such that ğ‘† âˆ© ğ‘ƒ = âˆ…. The set ğ‘† is thus
ğœ (ğ‘¤) for a word ğ‘¤ âˆˆ ğ¹ that has a ğ‘ on all positions in
ğ‘ƒ. This word ğ‘¤ thus matches ğ‘¢ on ğ‘ƒ, concluding the
proof of the main statement.

The â€œin particularâ€ part is implied by the fact that, for ğ‘›

large enough:

|Goodğ‘› |
ğ‘›ğ‘‘

=

âˆš

ğ‘›

âˆš
ğ‘›
ğ‘›ğ‘‘ â‰¥ ğ‘˜

âˆš
ğ‘›.

â–¡

Theorem 4.4. The language ğ¾ = (ğ‘ğ‘âˆ—ğ‘+ğ‘)âˆ— is not in Î£2 [arb].
Proof. Corollary 3.3 applied on Good, using Lemma 4.2, im-
plies that Good âˆ‰ Î£2 [arb]. Lemma 4.1 then asserts that ğ¾
â–¡
cannot be in Î£2 [arb] either.

5 The regular languages with a neutral
letter not in Î£2 [<] are not in Î£2 [arb]
The proof of the statement of the section title is along two
main steps:

Section 5.1. We will start with a language with a neutral
letter ğ¿ âˆ‰ Î£2 [<]. Since it is not in Î£2 [<], there are ğ‘¥, ğ‘¦ âˆˆ ğ‘€
that falsify the equations of Theorem 2.3. We use these wit-
nesses to build a up-word problem ğ‘‡ of the ordered syntactic
monoid of ğ¿ and show that it lies outside of Î£2 [arb], implying
that ğ¿ âˆ‰ Î£2 [arb] by Lemma 2.1.

To show ğ‘‡ out of Î£2 [arb], we identify (Section 5.1.1) a
subset of well-behaved words of ğ‘‡ , and make some simple
syntactical changes (in Section 5.1.2) on them so that they
look like words in Good, in a similar fashion as the â€œexpan-
sionsâ€ of Lemma 4.1. The argument used in Lemma 4.1 then
needs to be refined, as we do not have that any word outside
of Good comes from a word outside of ğ‘‡ . We will define a
set Bad of words that look like words in Good except for
one block that contains only ğ‘â€™s; Lemma 4.1 is then worded
as: if ğ¾ is in Î£2 [arb], then there is a Î£2 [arb] language that
separates Good from Bad (Lemma 5.1).

âˆš

ğ‘›]

Section 5.2. We show that no language of Î£2 [arb] can
separate Good from Bad. We thus need to provide a state-
ment in the spirit of Lemma 4.2. We first write good and bad
âˆš
ğ‘›, the
words in a succinct (â€œpackedâ€) way, as words in [
ğ‘–-th letter being some value ğ‘£ if the original word had the ğ‘ of
its ğ‘–-th block in position ğ‘£ (Section 5.2.1). We then translate
the notion of ğ‘˜-limit to packed words (Lemma 5.3). Finally,
we provide a measure of how diverse a set of (packed) good
words is (Definition 5.4), and show that such a set is either
not diverse and small (Lemma 5.5), or diverse and admits
a ğ‘˜-limit (Lemma 5.6). Our term for â€œnot diverseâ€ will be
tangled, referring to the fact that there is a strong correlation
between the contents of positions within words.

5.1 If a language not in Î£2 [<] is in Î£2 [arb], we can
separate Good from Bad with a language in
Î£2 [arb]

5.1.1 Target up-word problem and some of its words.
For the rest of this section, let ğ¿ âŠ† ğ´âˆ— be a regular language
with a neutral letter that lies outside of Î£2 [<] and let ğ‘€ be its
ordered syntactic monoid. Since ğ¿ is not in Î£2 [<], there are
elements ğ‘¥, ğ‘¦ âˆˆ ğ‘€ such that ğ‘¥ â‰° ğ‘¥ğ‘¦ğ‘¥ with ğ‘¥ an idempotent
and ğ‘¦ a subword of ğ‘¥. Let ğ‘‡ be the up-word problem of ğ‘€
for ğ‘¥. Clearly, any word of ğ‘€ âˆ— that evaluates to ğ‘¥ğ‘¦ğ‘¥ does not
belong to ğ‘‡ .

Naturally, ğ‘¦ is thus also a subword of ğ‘¥; this provides us

with words that evaluate to ğ‘¥ and ğ‘¦ of the shape:

ğ‘¥1ğ‘¦1 . . . ğ‘¥ğ‘¡ğ‘¦ğ‘¡ evaluates to ğ‘¥,

ğ‘¦1 . . . ğ‘¦ğ‘¡ evaluates to ğ‘¦,

with each ğ‘¥ğ‘– and ğ‘¦ğ‘– in ğ‘€. (Note that we can use the identity
element of ğ‘€ as needed to ensure we have as many ğ‘¥ğ‘– â€™s as
ğ‘¦ğ‘– â€™s.)

Let ğ‘› âˆˆ N be a large enough perfect square (â€œlarge enoughâ€
only depends on ğ‘¡, the length of the word for ğ‘¦). We define
âˆš

âˆš

ğ‘› + 1 words of length

ğ‘› + ğ‘¡ over ğ‘€:

âˆš

ğ‘›],

â€¢ For ğ‘– âˆˆ [
(cid:16)

ğ‘¥ (ğ‘–) =

ğ‘–âˆ’1ğ‘¥11
1

âˆš
ğ‘›âˆ’ğ‘– Â· ğ‘¦1

(cid:17)

(cid:16)

ğ‘–âˆ’1ğ‘¥ğ‘¡ 1
1

âˆš
ğ‘›âˆ’ğ‘– Â· ğ‘¦ğ‘¡

(cid:17)

.

Â· Â· Â·

Corentin Barloy, MichaÃ«l Cadilhac, Charles Paperman, and Thomas Zeume

would turn into:
âˆš
(cid:16)
ğ‘›âˆ’8 Â· ğ‘¦1

17ğ‘¥11

(cid:17)

(cid:16)

Â· Â· Â·

17ğ‘¥ğ‘¡ 1

âˆš
ğ‘›âˆ’8 Â· ğ‘¦ğ‘¡

(cid:17)

= ğ‘¥ (8) .

In particular, if the block were all ğ‘â€™s, we would obtain the
word ğ‘¦, which has no letter ğ‘¥ ğ‘— .

We can do this to each block of

ğ‘› letters, concatenate
the resulting words, then add the word ğ‘¥ (1) at the beginning
and the end. Note that these operations can be done with
only wires, with no gates involved.

âˆš

Here 1 âˆˆ ğ‘€ is the neutral element of ğ‘€. Note that
these words evaluate to ğ‘¥.

â€¢ Additionally, we consider the word 1

âˆš
âˆš
ğ‘›ğ‘¦ğ‘¡ ,
ğ‘›ğ‘¦1 . . . 1
which evaluates to ğ‘¦, and we simply write ğ‘¦ for it.
Note that ğ‘¦ can be obtained by removing all the letters
ğ‘¥ ğ‘— from any word ğ‘¥ (ğ‘–) .
Call ğ‘‡ -good a concatenation of

ğ‘› words of the form ğ‘¥ (ğ‘–)
sandwiched between two words ğ‘¥ (1) (the 1 is arbitrary), and
ğ‘‡ -bad a word obtained by changing, in a ğ‘‡ -good word, ex-
actly one of the words ğ‘¥ (ğ‘–) to ğ‘¦ (but for the ğ‘¥ (1) at the begin-
ning and end). By construction, any ğ‘‡ -good word evaluates
to ğ‘¥ in ğ‘€, so belongs to ğ‘‡ , while any ğ‘‡ -bad word evaluates
to ğ‘¥ğ‘¦ğ‘¥, hence does not belong to ğ‘‡ . Note that if we had
switched two blocks of a ğ‘‡ -good word to ğ‘¦, we would not be
able to say whether it belonged to ğ‘‡ or not.

âˆš

âˆš

5.1.2 ğ‘‡ -good, ğ‘‡ -bad to Good and Bad. The ğ‘‡ -good and
ğ‘‡ -bad words contain a lot of redundant information, for
instance ğ‘¥ (ğ‘–) is of length
ğ‘› + ğ‘¡, while all the information it
âˆš
really contains is ğ‘– âˆˆ [
ğ‘›]. Recall the set Goodğ‘› of Section 4
which contains all words of length ğ‘› over {ğ‘, ğ‘} that can
ğ‘›, each containing a
be divided into
single ğ‘. Again, we let Good be all such words, of any perfect
square length. Define similarly Badğ‘› as the set of words that
are like Goodğ‘› except for one block which has only ğ‘â€™s, and
let Bad = (cid:208)ğ‘› Badğ‘›.

ğ‘› blocks of length

âˆš

âˆš

In the next lemma, we show that we can modify, using
only wires in a circuit, words over {ğ‘, ğ‘} so that if they are
in Good they become ğ‘‡ -good, and if they are in Bad they
become ğ‘‡ -bad. This modification is simple enough that we
can take a Î£2 [arb] circuit family forğ‘‡ , apply the modification
at the top of each circuit, and still have a circuit family in
Î£2 [arb]; the resulting circuit family separates Good from
Bad:

Lemma 5.1. If ğ‘‡ âˆˆ Î£2 [arb], then there is a Î£2 [arb] language
that separates Good from Bad.

Proof. As in Lemma 4.1, this is easier seen on circuits: we de-
sign a circuit for inputs of length ğ‘› over {ğ‘, ğ‘} that separates
Good from Bad.

Consider the first block of

ğ‘› letters of the input. We
replicate it ğ‘¡ times, with the ğ‘–-th replication changing ğ‘â€™s to 1
and ğ‘â€™s to ğ‘¥ğ‘– . We then concatenate these and add ğ‘¦ğ‘– between
ğ‘›âˆ’8
the ğ‘–-th and (ğ‘– + 1)-th replication. For instance, ğ‘7ğ‘ğ‘

âˆš

âˆš

If the input word is in Good, then the word produced is
ğ‘‡ -good, hence in ğ‘‡ . If it was in Bad, then the resulting word
would be ğ‘‡ -bad, hence would lie outside of ğ‘‡ . This shows
that the desired circuit can be constructed using the above
wiring followed by the circuit for ğ‘‡ for inputs of length
(ğ‘¡
ğ‘›). Since ğ‘¡ is a constant and depends solely
on ğ¿, the resulting circuit is of polynomial size and of the
â–¡
correct shape.

ğ‘› + ğ‘¡)(2 +

âˆš

âˆš

5.2 No language in Î£2 [arb] separates Good from Bad
Note that this section is independent from the previous one.
We will now rely on Corollary 3.3 to show that any Î£2 [arb]
language ğ¿ that accepts all of Good must accept a word in
Bad. To apply Corollary 3.3, from this point onward we let
ğ‘˜, ğ‘‘ âˆˆ N, and set ğ‘› to be a large enough value that depends
only on ğ‘˜ and ğ‘‘. The role of ğ¿â€² in the statement of Corol-
lary 3.3 will be played by Goodğ‘› and we will build ğ‘˜-limits
belonging to Badğ‘›, which we call bad ğ‘˜-limits. The reader
may check that the statements of the forthcoming Lemma 5.5
and Lemma 5.6 conclude the proof.

âˆš

ğ‘›. We make this explicit, by seeing [

5.2.1 Packed words. Words in Goodğ‘› and Badğ‘› can be
described by the position of the letter ğ‘ in each block of size
âˆš
âˆš
ğ‘›] âˆª{âŠ¥} as
âˆš
ğ‘›. We call
an alphabet, and working with words in [
these words packed and will use Greek letters ğœ†, ğœ‡, ğœˆ for them;
we also call the letter at some position in packed words its
contents at this position, only to stress that we are working
with packed words. We define the natural functions to pack
and unpack words:
âˆš

ğ‘›, âŠ¥] = [
âˆš
ğ‘›, âŠ¥]

â€¢ unpack : [
âŠ¥ to ğ‘

ğ‘›, âŠ¥] â†’ {ğ‘, ğ‘}

âˆš
ğ‘› maps ğ‘– to ğ‘ğ‘–âˆ’1ğ‘ğ‘

âˆš
ğ‘›. This extends naturally to words over [

âˆš
ğ‘›âˆ’ğ‘– and
âˆš
ğ‘›, âŠ¥].
ğ‘›, âŠ¥]âˆ— is the inverse of unpack. We
will use that function on sets of words too, with the
natural meaning.

â€¢ pack : {ğ‘, ğ‘}âˆ— â†’ [

âˆš

Example 5.2. With ğ‘› = 9, pack(ğ‘ğ‘ğ‘ ğ‘ğ‘ğ‘ ğ‘ğ‘ğ‘) = 1âŠ¥2, and
unpack(31âŠ¥) = ğ‘ğ‘ğ‘ ğ‘ğ‘ğ‘ ğ‘ğ‘ğ‘.

We can now rephrase the notion of ğ‘˜-limit using packed

words:

Lemma 5.3. Let ğ¹ âŠ† Goodğ‘› and define Î¦ = pack(ğ¹ ). If ğœ‡ is a
packed word that has the following properties, then unpack(ğœ‡)
is a bad ğ‘˜-limit for ğ¹ :

The Regular Languages of First-Order Logic with One Alternation

1. There is a word ğœˆ âˆˆ Î¦ that differs on a single position ğ‘–

with ğœ‡, at which ğœ‡ has contents âŠ¥:

ğœ‡ğ‘– = âŠ¥ âˆ§ (âˆ€ğ‘— â‰  ğ‘–) [ğœˆ ğ‘— = ğœ‡ ğ‘— ].

âˆš
ğ‘›] of contents that contains ğœˆğ‘–
2. For every set ğ¶ âŠ† [
âˆš
and every set ğ‘ƒ âŠ† [
ğ‘›] \ {ğ‘–} of positions such that
|ğ¶ | + |ğ‘ƒ | = ğ‘˜, there is a word ğœ† âˆˆ Î¦ whose contents at
position ğ‘– is not in ğ¶ and that matches ğœˆ on ğ‘ƒ:

ğœ†ğ‘– âˆ‰ ğ¶ âˆ§ (âˆ€ğ‘ âˆˆ ğ‘ƒ) [ğœ†ğ‘ = ğœˆğ‘ ].

of ğ·; additionally, the position ğ‘– should not appear in ğ‘†:

((cid:154)ğ‘) [(ğ‘–, ğ‘) âˆˆ ğ‘†]âˆ§
(âˆ€ğœ‡ âˆˆ Î¦) [(âˆ€( ğ‘—, ğ‘‘) âˆˆ ğ‘†) [ğœ‡ ğ‘— = ğ‘‘] â†’

(âˆƒ(ğ‘–, ğ‘) âˆˆ ğ·) [ğœ‡ğ‘– = ğ‘]].

âˆš

The set ğ¹ is said to be ğ‘˜-tangled if for any word ğœ‡ âˆˆ Î¦ and
any position ğ‘– âˆˆ [
ğ‘›], there is an ğ‘–-set of pairs of size â‰¤ ğ‘˜
that contains (ğ‘–, ğœ‡ğ‘– ) and that is entailed by a set of size ğ‘˜ that
agrees with ğœ‡. In other words, every position of ğœ‡ is entailed
by a subset of its positions. We drop the ğ‘˜ in ğ‘˜-tangled if it
is clear from context.

Proof. Write ğ‘¢ for unpack(ğœ‡). That ğ‘¢ âˆˆ Bad is immediate
from Property 1: ğ‘¢ is but a word ğ‘£ of Good in which one
block was set to all ğ‘â€™s.

We now show that ğ‘¢ is a ğ‘˜-limit. Let ğ‘‡ be a set of ğ‘˜ posi-

tions, we split ğ‘‡ into two sets:

â€¢ ğ‘‡ â€² is the set of positions that do not belong to the ğ‘–-th
ğ‘›âŒ‰ = ğ‘–. We
ğ‘›, that

block of ğ‘¢, that is, they do not satisfy âŒˆğ‘/
let ğ‘ƒ be each of the elements of ğ‘‡ â€² divided by
is, for any ğ‘ âˆˆ ğ‘‡ â€² we add âŒˆğ‘/

ğ‘›âŒ‰ to ğ‘ƒ.

âˆš

âˆš

âˆš

â€¢ ğ‘‡ â€²â€² is the set of positions that do fall in the ğ‘–-th block.
Note that ğ‘¢ only has ğ‘â€™s at the positions of ğ‘‡ â€²â€². We let
ğ‘›, that is, for any ğ‘ âˆˆ ğ‘‡ â€²â€², we
ğ¶ be that set, modulo
âˆš
ğ‘› if this value is 0.
ğ‘› to ğ¶ or
add ğ‘ mod

âˆš
âˆš

First, if ğœ‡ğ‘– âˆ‰ ğ¶, then ğ‘‡ indicates positions of ğ‘¢ that have
the same letter as in unpack(ğœˆ) âˆˆ ğ¹ , so a word of ğ¹ matches
ğ‘¢ over ğ‘‡ , as required. We thus assume next that ğœ‡ğ‘– âˆˆ ğ¶.

Let ğœ† âˆˆ Î¦ be the word given by Property 2 for ğ¶ and ğ‘ƒ,
we claim that ğ‘¤ = unpack(ğœ†) matches ğ‘¢ on the positions of
ğ‘‡ , concluding the proof.

First note that the ğ‘–-th block of ğ‘¤ has its ğ‘ in a position
that is not in ğ‘‡ â€²â€², hence ğ‘¤ matches ğ‘¢ on ğ‘‡ â€²â€². Consider next
any position ğ‘ âˆˆ ğ‘‡ â€² and write ğ‘— for the block in which ğ‘ falls
ğ‘›âŒ‰). Since ğœ‡ ğ‘— = ğœ† ğ‘— by hypothesis, the ğ‘—-th block
(i.e., ğ‘— = âŒˆğ‘/
â–¡
of ğ‘¢ and ğ‘¤ are the same, hence ğ‘¢ğ‘ = ğ‘¤ğ‘ .

âˆš

5.2.2 Tangled sets of good words are small, nontan-
gled ones have a bad ğ‘˜-limit. Consider a ğ¹ âŠ† Goodğ‘›. To
find a bad ğ‘˜-limit for ğ¹ , we need a lot of diversity in ğ¹ ; see in
particular Prop. 2 of Lemma 5.3. Hence having some given
contents at a given position in a word of Î¦ should not force
too many other positions to have a specific value. We make
this notion formal:

Definition 5.4. Let ğ¹ âŠ† Goodğ‘› and Î¦ = pack(ğ¹ ). The en-
tailment relation of Î¦ is relating sets of pairs (ğ‘–, ğ‘) of posi-
tion/contents in words of Î¦. Let us say that a word and a
pair position/contents (ğ‘–, ğ‘) agree if the contents at position
ğ‘– of the word is ğ‘, and that a word and a set of such pairs
agree if they agree on all the pairs. We say that a set of pairs
is an ğ‘–-set if all its pairs have ğ‘– as position.

A set ğ‘† of pairs position/contents entails an ğ‘–-set ğ· if all
words in Î¦ that agree with ğ‘† also agree with at least one pair

âˆš

ğ‘›2ğ‘˜

ğ‘›/(2ğ‘˜+1)

Lemma 5.5. Let ğ¹ âŠ† Goodğ‘›. If ğ¹ is ğ‘˜-tangled, then |ğ¹ | <
âˆš
. In particular, |ğ¹ | < |Goodğ‘› |/ğ‘›ğ‘‘ .
Proof. Assume ğ¹ is ğ‘˜-tangled and let Î¦ = pack(ğ¹ ). We show
that every word in Î¦ can be fully described in Î¦ by fully
specifying a portion ğ‘˜/(ğ‘˜ + 1) of its positions and encoding
the contents of each of the other 1/(ğ‘˜ + 1) positions with
elements from [ğ‘˜]. That is, if two words in Î¦ have the same
such description, they are the same, hence Î¦ cannot be larger
than the number of such descriptions. We first show this
property, then derive the numerical implication on |ğ¹ |.

Let ğœ‡ âˆˆ Î¦, we construct iteratively a set ğ¾ of positions
that we will fully specify and a set ğ¾ + of positions that are
restricted when setting the positions in ğ¾.

First consider the pair (1, ğœ‡1). Since ğ¹ is tangled, there is
an 1-set containing (1, ğœ‡1), entailed by a set ğ‘† that agrees
with ğœ‡. We add to ğ¾ the positions of ğ‘† and to ğ¾ + the positions
of ğ‘† and position 1.

We now iterate this process: Take a pair (ğ‘–, ğœ‡ğ‘– ) such that
ğ‘– âˆ‰ ğ¾ +. There is an ğ‘–-set containing (ğ‘–, ğœ‡ğ‘– ) that is entailed by
a set ğ‘† that agrees with ğœ‡. Let ğ‘† â€² be the set of positions of ğ‘†
that are not in ğ¾ +. We add ğ‘† â€² to ğ¾, and ğ‘† â€² âˆª {ğ‘–} to ğ¾ +. Note
that the size increase for ğ¾ + is one more than that for ğ¾. We
continue iterating until all positions appear in ğ¾ +.

We now bound the size of ğ¾ at the end of the computa-
tion. For each iteration, in the worst case, we need to add
ğ‘˜ positions to ğ¾ to obtain ğ‘˜ + 1 new positions in ğ¾ + (this is
the worst case in the sense that this is the worst ratio of the
number of positions we need to pick in ğ¾ to the number of
positions that are put in ğ¾ +). In that case, after ğ‘  steps, we
have |ğ¾ | = ğ‘ ğ‘˜ and |ğ¾ +| = ğ‘ ğ‘˜ + ğ‘ . Thus when |ğ¾ +| =
ğ‘›, that
is, when no more iterations are possible, we have:

âˆš

âˆš

ğ‘› â‡’ ğ‘  =

âˆš
ğ‘›
ğ‘˜ + 1

.

ğ‘ ğ‘˜ + ğ‘  =
âˆš

This shows that |ğ¾ | â‰¤ ğ‘˜

ğ‘›/(ğ‘˜ + 1).
We now turn to describing the word ğœ‡ using ğ¾. We first
provide all the contents of ğœ‡ at positions in ğ¾; call ğ‘ the set
of pairs position/contents of ğœ‡ that correspond to positions
in ğ¾. We mark the positions of ğ¾ as specified, and carry on
to specify the other positions in a deterministic fashion.

We first fix an arbitrary order on sets of pairs of posi-
tion/contents. We iterate through all the subsets of ğ‘ of size

ğ‘˜, in order. For each such subset ğ‘†, we consider, in order again,
the subsets ğ· that are entailed by ğ‘†. Assume ğ· is an ğ‘–-set; if
position ğ‘– is already specified, we do nothing, otherwise, we
describe which element of ğ· is (ğ‘–, ğœ‡ğ‘– ) using an integer in [ğ‘˜],
and mark ğ‘– as specified. We proceed until all the subsets of
ğ‘ have been seen, at which point, by construction of ğ¾, all
the positions will have been specified. As claimed, given ğ‘
and the description of which elements in sets ğ· correspond
to the correct contents, we can reconstruct ğœ‡.

âˆš

âˆš

âˆš

âˆš

ğ‘›ğ‘˜

Summing up, to fully describe ğœ‡, we had to specify the
ğ‘›
(cid:1) possible choices), their
ğ‘›/(ğ‘˜+1)

positions of ğ¾ (one of (cid:0)
ğ‘˜
ğ‘›/(ğ‘˜+1)

contents (one of
possible choices), and for each
position not specified by ğ¾, we needed to provide an integer
âˆš
ğ‘›/(ğ‘˜+1) possible choices). This shows that:
in [ğ‘˜] (one of ğ‘˜
âˆš
ğ‘›
ğ‘›/(ğ‘˜ + 1)
âˆš

âˆš
ğ‘›ğ‘˜

|ğ¹ | â‰¤

ğ‘›/(ğ‘˜+1)

ğ‘›/(ğ‘˜+1)

Â· ğ‘˜

âˆš

âˆš

âˆš

âˆš

(cid:19)

(cid:18)

Â·

ğ‘›/(ğ‘˜+1)) log(ğ‘˜)

ğ‘˜
âˆš
ğ‘› Â· 2(
âˆš
ğ‘›/(ğ‘˜+1)) ( (ğ‘˜+1)+ğ‘˜ log

ğ‘›/(ğ‘˜+1)) (ğ‘˜ log

âˆš
ğ‘›) Â· 2(
ğ‘›+log ğ‘˜)

âˆš

ğ‘›/(ğ‘˜+1)) ( (ğ‘˜+ 1

ğ‘˜ ) log

âˆš

ğ‘›)

(n large enough)

âˆš

ğ‘›/(ğ‘˜+1)

âˆš
ğ‘›2ğ‘˜

âˆš
ğ‘›/(2ğ‘˜+1) .

â‰¤

â‰¤ 2
= 2(
â‰¤ 2(
âˆš
ğ‘› (ğ‘˜+ 1
ğ‘˜ )

âˆš

â‰¤

The â€œin particularâ€ part is a consequence of the fact that,

for ğ‘› large enough:

|Goodğ‘› |
ğ‘›ğ‘‘

=

âˆš

ğ‘›

âˆš
ğ‘›
ğ‘›ğ‘‘ â‰¥

âˆš
ğ‘›2ğ‘˜

âˆš
ğ‘›/(2ğ‘˜+1) .

â–¡

Lemma 5.6. Let ğ¹ âŠ† Goodğ‘›. If ğ¹ is not ğ‘˜-tangled, then ğ¹ has
a bad ğ‘˜-limit.

Proof. Write Î¦ = pack(ğ¹ ). That ğ¹ is not tangled means that
there is a word ğœˆ âˆˆ Î¦ and a position ğ‘– such that for any set
of pairs position/contents ğ‘† and any ğ‘–-set ğ· that contains
(ğ‘–, ğœˆğ‘– ), ğ‘† does not entail ğ·. We define ğœ‡ to be the word ğœˆ but
with ğœ‡ğ‘– set to âŠ¥. We show that unpack(ğœ‡) is a bad ğ‘˜-limit
using Lemma 5.3. Property 1 therein is true by construction,
so we need only show Property 2.

Let ğ¶ âŠ† [

ğ‘›] \ {ğ‘–} with
ğ‘›] with ğœ‡ğ‘– âˆˆ ğ¶ and ğ‘ƒ âŠ† [
|ğ¶ | + |ğ‘ƒ | = ğ‘˜. We add some more arbitrary positions in ğ‘ƒ so
that |ğ‘ƒ | = ğ‘˜, avoiding ğ‘–. Define:

âˆš

âˆš

ğ‘† = {(ğ‘, ğœ‡ğ‘ ) | ğ‘ âˆˆ ğ‘ƒ }, ğ· = {(ğ‘–, ğ‘) | ğ‘ âˆˆ ğ¶}.
By hypothesis, since (ğ‘–, ğœ‡ğ‘– ) âˆˆ ğ·, ğ‘† does not entail ğ·. This
means that there is a word ğœ† âˆˆ Î¦ such that ğ‘† and ğœ† agree, but
ğœ†ğ‘– âˆ‰ ğ¶. This is the word needed for Property 2 of Lemma 5.3,
â–¡
concluding the proof.

Corollary 5.7. No Î£2 [arb] language can separate Good from
Bad.

Proof. We apply Corollary 3.3 on any language ğ¿ that sepa-
rates Good from Bad. We let ğ‘˜, ğ‘‘ âˆˆ N, and ğ‘› large enough;

Corentin Barloy, MichaÃ«l Cadilhac, Charles Paperman, and Thomas Zeume

ğ¿â€² in the statement of Corollary 3.3 is set to Goodğ‘›. We are
then given a set ğ¹ of size at least |Goodğ‘› |/ğ‘›ğ‘‘ and Lemma 5.5
shows that ğ¹ is not tangled. Lemma 5.6 then implies that ğ¹
has a bad ğ‘˜-limit. Corollary 3.3 concludes that ğº is not in
â–¡
Î£2 [arb], showing the statement.
Theorem 5.8 (Neutral Straubing Property for Î£2).

Î£2 [arb] âˆ© Reg âˆ© Neut âŠ† Î£2 [<].
Proof. Let ğ¿ âˆ‰ Î£2 [<] with a neutral letter and ğ‘‡ be the lan-
guage defined in Section 5.1.1. Corollary 5.7 and Lemma 5.1
imply that ğ‘‡ cannot be in Î£2 [arb], and in turn, Lemma 2.1
â–¡
shows that ğ¿ cannot be in Î£2 [arb].

6 Consequences
6.1 Life without neutral letters

The regular numerical predicates, denoted reg, are the numer-
ical predicates +1, <, and for any ğ‘ > 0, modğ‘ which is true
of a position if it is divisible by ğ‘. The term â€œregularâ€ stems
from the fact that these are the properties on numerical po-
sitions that automata can express. Recall that the Straubing
Property for a logic L expresses that L [arb] âˆ©Reg = L [reg].
The Straubing Property does not immediately imply the
Neutral Straubing Property; for this, one would need in ad-
dition that L [reg] âˆ© Neut âŠ† L [<]. This latter property is
called the Crane Beach Property of L [reg], and also stems
from the natural idea that if a language has a neutral letter,
then numerical predicates do not provide any useful infor-
mation. Albeit natural, this property is false for FO[arb] [4],
but Theorem 5.8 shows that Î£2 [reg] does have the Crane
Beach Property.

Relying on Theorem 4.4 and some results from [8], we can

show:
Theorem 6.1 (Straubing Property of Î”2).
Î”2 [arb] âˆ© Reg = Î”2 [reg].

Proof. The proof structure is as follows: We first show that
Î”2 [arb] âˆ© Reg has some closure properties, so that it is a
so-called lm-variety. We then show that Î”2 [reg] recognizes
precisely all the regular languages definable with a first-order
formula with two variables that uses reg as numerical predi-
cates; that class of languages is denoted FO2 [reg]. We then
rely on the following lemma, where ğ¾ = (ğ‘ğ‘âˆ—ğ‘ + ğ‘)âˆ—:

Lemma 6.2 (From [8, Lemma 8]). If an lm-variety of regu-
lar languages V satisfies:

FO2 [reg] âŠ† V âŠ† FO[arb] and ğ¾ âˆ‰ V

then V = FO2 [reg].
Since Î”2 [arb] âˆ© Reg satisfies the hypotheses, it is equal to
FO2 [reg] = Î”2 [reg], concluding the proof.

ğš«2[arb] âˆ© Reg is an lm-variety. We ought to first define
lm-variety. If for a morphism â„ : ğ´âˆ— â†’ ğµâˆ— there is a ğ‘˜ such
that â„(ğ´) âŠ† ğµğ‘˜ , we call â„ an lm-morphism, where lm stands

The Regular Languages of First-Order Logic with One Alternation

for length-multiplying. Given a language ğ¿ and a letter ğ‘, the
left quotient of ğ¿ by ğ‘ is the set ğ‘âˆ’1ğ¿ = {ğ‘£ | ğ‘ğ‘£ âˆˆ ğ¿}. The
right quotient ğ¿ğ‘âˆ’1 is defined symmetrically. An lm-variety
of languages is a set of languages closed under the Boolean
operations, quotient, and inverse lm-morphisms.

Since Reg is an lm-variety of languages, it is sufficient to

show that Î”2 [arb] is too; this is not hard:

â€¢ Boolean operations: Both Î£2 [arb] and Î 2 [arb] formu-
las are closed under Boolean OR and AND, hence the
classes of languages they recognize are closed under
union and intersection, and so is Î”2 [arb]. Also, since
the negation of a Î£2 [arb] formula is a Î 2 [arb] formula,
and vice versa, Î”2 [arb] is closed under complement.
â€¢ Quotient: We show that Î£2 [arb] is closed under quo-
tient; the proof is the same for Î 2 [arb], and this im-
plies that Î”2 [arb] is also closed under quotient. Let
ğ¿ âˆˆ Î£2 [arb] and ğ‘ be a letter. Consider the circuit for
the words of length ğ‘› in ğ¿. We can hardwire the first
letter to ğ‘; the resulting circuit has ğ‘› âˆ’1 inputs, and rec-
ognizes a word ğ‘¤ iff ğ‘ğ‘¤ âˆˆ ğ¿. The family thus obtained
recognizes ğ‘âˆ’1ğ¿. The argument for right quotient is
similar.

â€¢ Lm-morphisms: Again, we show this holds for Î£2 [arb],
the proof for Î 2 [arb] being similar, and these two
facts imply closure under lm-morphisms of Î”2 [arb].
Let ğ¿ âˆˆ Î£2 [arb] over the alphabet ğµ and â„ be an lm-
morphism such that â„(ğ´) âŠ† ğµğ‘˜ for some ğ‘˜. Consider
the circuit for the words of ğ¿ of length ğ‘˜ğ‘› for some ğ‘›.
Given a word in ğ´ğ‘›, we can use wires to map each input
letter ğ‘ âˆˆ ğ´ to â„(ğ‘), and we can feed the resulting word
to the circuit for ğ¿. A word ğ‘¤ âˆˆ ğ´ğ‘› is thus accepted
iff â„(ğ‘¤) âˆˆ ğ¿, hence the circuit family thus defined
recognizes â„âˆ’1(ğ¿).

ğš«2[reg] and FO2[reg] recognize the same languages.
We show the inclusion from left to right, the converse being
similar. We rely on the fact that FO2 [<, +1] = Î”2 [<, +1], a
result due to ThÃ©rien and Wilke [33, Theorem 7]. The rest
of our proof is fairly simple: we put the information given
by the modğ‘ predicates within the alphabet, show that this
information is easily checked with one universal quantifier
if we have reg predicates, and that if the modular predicates
are put within the alphabet, the only required predicates
to express our Î”2 [reg] formula are < and +1. We then rely
on the equivalence of FO2 and Î”2 over these predicates to
conclude.

Formally, let ğœ™ âˆˆ Î”2 [reg] be a formula over the alphabet
ğ´. Let ğ‘ƒ be the set of moduli used in ğœ™, that is, the predicate
modğ‘ appears in ğœ™ iff ğ‘ âˆˆ ğ‘ƒ. The ğ‘ƒ-annotation of a word
ğ‘¤ âˆˆ ğ´âˆ— is the word in (ğ´ âˆª 2ğ‘ƒ )âˆ— that indicates, for each
position ğ‘–, the set of moduli in ğ‘ƒ that divide ğ‘–. In other words,
the ğ‘ƒ-annotation of ğ‘¤ = ğ‘¤1ğ‘¤2 Â· Â· Â· ğ‘¤ğ‘›, with each ğ‘¤ğ‘– âˆˆ ğ´, is

the word of length ğ‘› whose ğ‘–-th letter is:

(cid:18)

ğ‘¤ğ‘–
{ğ‘ âˆˆ ğ‘ƒ | ğ‘ divides ğ‘–}

(cid:19)

âˆˆ (ğ´ âˆª 2

ğ‘ƒ ).

Let W be the set of words in (ğ´âˆª2ğ‘ƒ )âˆ— that are ğ‘ƒ-annotations.
Then:

â€¢ W âˆˆ FO2 [reg] âˆ© Î”2 [reg]. Indeed, a formula for W
need only assert that for all positions ğ‘–, the 2ğ‘ƒ part
of the letter at position ğ‘– is exactly the set {ğ‘ âˆˆ ğ‘ƒ |
ğ‘ divides ğ‘–}. This can be written as a single universal
quantifier followed by a quantifier-free formula.
â€¢ There is a ğœ™ â€² âˆˆ Î”2 [<, +1] such that the words of W
that satisfy ğœ™ â€² are precisely the ğ‘ƒ-annotations of words
that satisfy ğœ™. The formula ğœ™ â€² is simply the formula ğœ™
in which each predicate modğ‘ (ğ‘¥) is replaced with the
property â€œğ‘ belongs to the 2ğ‘ƒ part of the letter at posi-
tion ğ‘¥,â€ which can be written as a simple disjunction.
If the input word is a ğ‘ƒ-annotation, modğ‘ (ğ‘¥) is indeed
equivalent to that property.

Since FO2 [<, +1] = Î”2 [<, +1], there is a formula ğœ“ of
FO2 [<, +1] that accepts the same language as ğœ™ â€². With ğœ“W
the FO2 [reg] formula for W, we conclude that ğœ“ âˆ§ ğœ“W is a
â–¡
FO2 [reg] formula that is equivalent to ğœ™.

The proof of the previous statement hinged on the char-
acterization given by Lemma 6.2. To show the (nonneutral)
Straubing Property of Î£2 [arb], a similar statement will need
to be proved. To make the similarity more salient, we reword
Lemma 6.2 as the equivalent statement:

Lemma 6.3. If an lm-variety of regular languages V satisfies:
Î”2 [reg] âŠ† V âŠ† FO[arb] and V âˆ© Neut âŠ† Î”2 [<].

then V = Î”2 [reg].

Proof. The second part of the proof of Theorem 6.1 shows
that FO2 [reg] = Î”2 [reg], while the same was already known
if < is the only available numerical predicate, so we can
freely swap FO2 for Î”2 in the statement of Lemma 6.2. We
need to show that the hypothesis V âˆ© Neut âŠ† Î”2 [<] is
equivalent to ğ¾ âˆ‰ V. For the left-to-right implication, it is
known [18] that ğ¾ âˆ‰ FO2 [<] = Î”2 [<]. For the right-to-left
implication, we use the hypothesis that V âŠ† FO[arb]: [8,
Theorem 9] shows that V âŠ† FO[arb] and ğ¾ âˆ‰ V implies that
V âŠ† FO2 [reg] and [8, Theorem 15] asserts that FO2 [reg] âˆ©
Neut âŠ† FO2 [<]. Hence V âˆ© Neut âŠ† FO2 [<] and replacing
â–¡
FO2 with Î”2 concludes the proof.

A positive lm-variety is defined just as lm-variety, but
without requiring closure under complement. The statement
we need for Î£2 thus reads:

Conjecture 6.4. If a positive lm-variety of regular languages
V satisfies:

Î£2 [reg] âŠ† V âŠ† FO[arb] and V âˆ© Neut âŠ† Î£2 [<]

then V = FO2 [reg].

If the conjecture held, then using V = Î£2 [arb] âˆ© Reg

would show the Straubing Property for Î£2 [arb].

6.2 On the fine structure of AC0
For this section, we use notations similar to [20] on circuit
complexity (these correspond to the classes BC0

ğ‘– therein):

â€¢ AC0

ğ‘– is the class of polynomial-size, depth-ğ‘˜ Boolean
circuit families, where all the circuits in a family have
the same kind of output gate (AND or OR);

â€¢ (cid:100)AC0

ğ‘– is defined similarly, the only difference being that
the input gates of the circuits are allowed to compute
any function of at most a constant number of positions
of the input string. This class is equivalent to Î£ğ‘– [arb] âˆª
Î ğ‘– [arb] (the ğ‘– here is the number of quantifiers blocks,
so that there are ğ‘– âˆ’ 1 alternations between âˆƒ and âˆ€).

The implied hierarchies interleave in a strict way:

AC0
1

âŠŠ (cid:100)AC0
1

âŠŠ AC0
2

âŠŠ Â· Â· Â·

The strictness of the hierarchy was independently obtained
by [20] and [9], both relying on previous bounds by HÃ¥s-
tad [15], but with very different approaches. However, the
question of finding explicit languages that separate this hier-
archy is still open, to the best of our knowledge. We make
some modest progress towards this:

Corentin Barloy, MichaÃ«l Cadilhac, Charles Paperman, and Thomas Zeume

without changing membership to ğ¾ â€². Also, the word ğ‘ğ‘ ap-
pears as a subword of (ğ‘ğ‘)2. However (ğ‘ğ‘)6 Â· ğ‘ğ‘ âˆˆ ğ¾, but
(ğ‘ğ‘)2(ğ‘ğ‘)(ğ‘ğ‘)2 Â· ğ‘ğ‘ âˆ‰ ğ¾ â€², showing that ğ¾ â€² âˆ‰ Î£2 [<].

If we assume that ğ¾ â€² âˆˆ Î 2 [arb], we have to show that the
complement of ğ¾ â€² is not in Î£2 [<]. This time, we pick (ğ‘ğ‘)3
as the idempotent, and ğ‘ğ‘ğ‘ as the subword. Then (ğ‘ğ‘)9 âˆ‰ ğ¾ â€²
but (ğ‘ğ‘)3(ğ‘ğ‘ğ‘)(ğ‘ğ‘)3 âˆˆ ğ¾ â€², hence the complement of ğ¾ â€² is
â–¡
not in Î£2 [<].

The language ğ¾ itself appears very often in the literature
pertaining to the fine separation of small circuit classes [7,
18]. This is no surprise: The language is the first of the fam-
ily of bounded-depth Dyck languages. These are the well-
parenthesized expressions that nest no more than a fixed
value:

ğ· (1)
1 = ğ¾ = (ğ‘ğ‘âˆ—ğ‘ + ğ‘)âˆ—,
1 = (ğ‘ğ· (ğ‘–âˆ’1)
ğ· (ğ‘–)
ğ‘ + ğ‘)âˆ—.

1

(Here, ğ‘ can be interpreted as â€œopening parenthesisâ€ and ğ‘
as â€œclosing.â€)

Saliently, these languages separate the class Î£ğ‘– [<] from
Î£ğ‘–+1 [<], with ğ· (ğ‘–)
1 belonging to the latter but not the for-
mer [7]. It is open whether these languages also separate the
Î£ğ‘– [arb] hierarchy, and thus the AC0
ğ‘– one. We can show that:

Theorem 6.5. The language ğ¾ â€² = ğ¾ Â·ğ‘ğ‘âˆ—ğ‘ Â·ğ´âˆ— is in AC0

3\ (cid:100)AC0
2.
It is easily seen that a word is in the

Proof. Upper bound.
language ğ¾ iff:

â€¢ Between every two ğ‘â€™s there is a ğ‘, and vice versa;
â€¢ The first (resp. last) nonneutral letter of the word is ğ‘

(resp. ğ‘).

Each of these statements can be written as an AND of ORs;
for the first one, it is easier seen on the complement: we have
an OR gate that selects two positions ğ‘1, ğ‘2 and checks that
there is an ğ‘ at both positions and only ğ‘â€™s in between. Thus
ğ¾ can be written as an AND of these, and so ğ¾ has a circuit
of depth exactly 2.

To build a circuit for ğ¾ â€², we start with an OR gate that
selects two positions ğ‘1, ğ‘2, and checks with an AND gate
that they both contain a ğ‘ and that only ğ‘â€™s appear in between.
We add as input to that AND gate the inputs of the AND
gate for ğ¾ where the positions considered are restricted to
be smaller than ğ‘1. This thus correctly checks that the prefix
up to ğ‘1 is in ğ¾, and that it is followed by a word starting
with ğ‘ğ‘âˆ—ğ‘.

Lower bound. If ğ¾ â€² âˆˆ (cid:100)AC0

2, then ğ¾ â€² is either in Î£2 [arb]

or Î 2 [arb].

Assume ğ¾ â€² âˆˆ Î£2 [arb], then ğ¾ â€² âˆˆ Î£2 [<] by Theorem 5.8.
We show that ğ¾ â€² âˆ‰ Î£2 [<] using the equations provided by
Theorem 2.3 with the wording appearing after the Theorem.
First, the word (ğ‘ğ‘)2 is mapped to an idempotent: if (ğ‘ğ‘)2
appears in a word, we can repeat it any number of times

Theorem 6.6. ğ· (2)

1 âˆˆ AC0

Proof. Upper bound.

.
3 \ (cid:154)AC0
2
It can be shown [7, Lemma 4+] that:

ğ· (2)
1 = ğ¾ğ‘ğ´âˆ— âˆª ğ´âˆ—ğ‘ğ‘âˆ—ğ‘ğ¾ğ‘ğ´âˆ— âˆª ğ´âˆ—ğ‘ğ¾ âˆª ğ´âˆ—ğ‘ğ¾ğ‘ğ‘âˆ—ğ‘ğ´âˆ—.
We can use an OR gate to select the positions of the letters
ğ‘, ğ‘ mentioned in that expression, and then either use an
AND gate to verify that only ğ‘â€™s appear between them, or
use the AND of ORs circuit for ğ¾ from the previous proof to
check that a word of ğ¾ appears between two positions.

Lower bound. We again use the wording appearing af-
ter Theorem 2.3. As in the previous proof, we need to show
that neither ğ· (2)
1 nor its complement are in Î£2 [<]. For the
language itself, we pick (ğ‘ğ‘)3 as the word mapping to an
idempotent and ğ‘ğ‘ğ‘ as the subword. We indeed have that
(ğ‘ğ‘)9 âˆˆ ğ· (2)
. For the comple-
1
ment, we pick (ğ‘ğ‘)2 as the word mapping to an idempotent
and ğ‘ğ‘ğ‘ as the subword; they satisfy (ğ‘ğ‘)6 Â· ğ‘ âˆ‰ ğ· (2)
but
1
(ğ‘ğ‘)2(ğ‘ğ‘ğ‘)(ğ‘ğ‘)2 Â· ğ‘ âˆˆ ğ· (2)
â–¡
.
1

, but (ğ‘ğ‘)3(ğ‘ğ‘ğ‘)(ğ‘ğ‘)3 âˆ‰ ğ· (2)
1

7 Conclusion
We have shown the Neutral Straubing Property for Î£2:

Î£2 [arb] âˆ© Reg âˆ© Neut = Î£2 [<] âˆ© Neut.
To do so, we developed a new lower bound technique against
circuits of depth 3 that relies on the entailment relation of
a language. This relation indicates how dependent the posi-
tions within a language are on one another. We believe that

The Regular Languages of First-Order Logic with One Alternation

this relation may be exploited to show Straubing Properties
at higher levels of the Î£ğ‘– hierarchy.

Dropping the neutral-letter restriction from our main re-
sult is an interesting task. Although it would not imply a
much stronger statement in terms of circuits, it is still a stain
on the clean statement that is the Straubing Property. We
note that Conjecture 6.4 is implied by the so-called locality
property of the algebraic counterpart of Î£2 [<]; showing lo-
cality is a notoriously hard problem in algebraic language
theory (see, e.g., [1, 28, 32, 34]).

Showing Straubing Properties remains a challenging and
wide open problem. If we are to follow our approach for Î£ğ‘– ,
ğ‘– â‰¥ 3, it requires in particular a decidable characterization
of the form of Theorem 2.3. This is usually provided by an
equational characterization of the class, and although the
general shape of the equations for each Î£ğ‘– [<] is known [25,
Theorem 6.2], they do not readily imply decidability; in fact,
the decidability of Î£ğ‘– [<] for ğ‘– â‰¥ 5 is open [24].

An outstanding example of the connection between the
Straubing Property of a circuit class and its computational
power is given in [8, 18]: FO2 [arb] has the Straubing Prop-
erty if and only if addition cannot be computed with a lin-
ear number of gates. This latter question, pertaining to the
precise complexity of addition, was asked, in particular, by
Furst, Saxe, and Sipser [11, Section 5]. Note that even though
Î”2 [reg] = FO2 [reg], this is not known to hold for the set of
arbitrary numerical predicates.

Acknowledgments
We wish to thank Nikhil Balaji and SÃ©bastien Tavenas. The
last author acknowledges financial support by the DFG grant
ZE 1235/2-1.

References
[1] Jorge Almeida. 1996. A Syntactical Proof of Locality of da.

Int.
https://doi.org/10.1142/

J. Algebra Comput. 6, 2 (1996), 165â€“178.
S021819679600009X

[2] David A. Mix Barrington. 1989. Bounded-Width Polynomial-Size
Branching Programs Recognize Exactly Those Languages in NC1. J.
Comput. Syst. Sci. 38, 1 (1989), 150â€“164. https://doi.org/10.1016/0022-
0000(89)90037-8

[3] David A. Mix Barrington, Kevin J. Compton, Howard Straubing, and
Denis ThÃ©rien. 1992. Regular Languages in NC1. J. Comput. Syst. Sci.
44, 3 (1992), 478â€“499. https://doi.org/10.1016/0022-0000(92)90014-A
[4] David A. Mix Barrington, Neil Immerman, Clemens Lautemann, Nicole
Schweikardt, and Denis ThÃ©rien. 2005. First-order expressibility of
languages with neutral letters or: The Crane Beach conjecture. J.
Comput. Syst. Sci. 70, 2 (2005), 101â€“127. https://doi.org/10.1016/j.jcss.
2004.07.004

[5] David A. Mix Barrington and Denis ThÃ©rien. 1988. Finite monoids
and the fine structure of NC1. J. ACM 35, 4 (1988), 941â€“952. https:
//doi.org/10.1145/48014.63138

[6] Mikolaj Bojanczyk. 2009. Factorization Forests. In Developments in
Language Theory, 13th International Conference, DLT 2009, Stuttgart,
Germany, June 30 - July 3, 2009. Proceedings (Lecture Notes in Computer
Science, Vol. 5583), Volker Diekert and Dirk Nowotka (Eds.). Springer,
1â€“17. https://doi.org/10.1007/978-3-642-02737-6_1

[7] Janusz A. Brzozowski and Robert Knast. 1978. The Dot-Depth Hierar-
chy of Star-Free Languages is Infinite. J. Comput. Syst. Sci. 16, 1 (1978),
37â€“55. https://doi.org/10.1016/0022-0000(78)90049-1

[8] MichaÃ«l Cadilhac and Charles Paperman. 2021. The Regular Languages
of Wire Linear AC0. (Dec. 2021). https://hal.archives-ouvertes.fr/hal-
03466451 Submitted to Acta Informatica, special issue for the 70th
birthday of Klaus-JÃ¶rn Lange.

[9] Liming Cai, Jianer Chen, and Johan HÃ¥stad. 1998. Circuit Bottom Fan-
In and Computational Power. SIAM J. Comput. 27, 2 (1998), 341â€“355.
https://doi.org/10.1137/S0097539795282432

[10] Ning Ding, Yanli Ren, and Dawu Gu. 2017. PAC Learning Depth-
3 AC0 Circuits of Bounded Top Fanin. In International Conference
on Algorithmic Learning Theory, ALT 2017, 15-17 October 2017, Kyoto
University, Kyoto, Japan (Proceedings of Machine Learning Research,
Vol. 76), Steve Hanneke and Lev Reyzin (Eds.). PMLR, 667â€“680. http:
//proceedings.mlr.press/v76/ding17a.html

[11] Merrick L. Furst, James B. Saxe, and Michael Sipser. 1984. Parity,
Circuits, and the Polynomial-Time Hierarchy. Math. Syst. Theory 17, 1
(1984), 13â€“27. https://doi.org/10.1007/BF01744431

[12] Nathan Grosshans, Pierre McKenzie, and Luc Segoufin. 2017. The
Power of Programs over Monoids in DA. In 42nd International Sym-
posium on Mathematical Foundations of Computer Science, MFCS 2017,
August 21-25, 2017 - Aalborg, Denmark (LIPIcs, Vol. 83), Kim G. Larsen,
Hans L. Bodlaender, and Jean-FranÃ§ois Raskin (Eds.). Schloss Dagstuhl
- Leibniz-Zentrum fÃ¼r Informatik, 2:1â€“2:20. https://doi.org/10.4230/
LIPIcs.MFCS.2017.2

[13] AndrÃ¡s Hajnal, Wolfgang Maass, Pavel PudlÃ¡k, Mario Szegedy, and
GyÃ¶rgy TurÃ¡n. 1993. Threshold Circuits of Bounded Depth. J. Comput.
Syst. Sci. 46, 2 (1993), 129â€“154. https://doi.org/10.1016/0022-0000(93)
90001-D

[14] Johan HÃ¥stad, Stasys Jukna, and Pavel PudlÃ¡k. 1995. Top-Down Lower
Bounds for Depth-Three Circuits. Comput. Complex. 5, 2 (1995), 99â€“112.
https://doi.org/10.1007/BF01268140

[15] John HÃ¥stad. 1989. Almost Optimal Lower Bounds for Small Depth

Circuits. Adv. Comput. Res. 5 (1989), 143â€“170.

[16] Stasys Jukna. 2011. Extremal Combinatorics - With Applications in
Computer Science (second ed.). Springer. https://doi.org/10.1007/978-
3-642-17364-6

[17] Michal KouckÃ½. 2009. Circuit Complexity of Regular Languages. The-
ory Comput. Syst. 45, 4 (2009), 865â€“879. https://doi.org/10.1007/s00224-
009-9180-z

[18] Michal KouckÃ½, Pavel PudlÃ¡k, and Denis ThÃ©rien. 2005. Bounded-depth
circuits: separating wires from gates. In Proceedings of the 37th Annual
ACM Symposium on Theory of Computing, Baltimore, MD, USA, May
22-24, 2005, Harold N. Gabow and Ronald Fagin (Eds.). ACM, 257â€“265.
https://doi.org/10.1145/1060590.1060629

[19] M. Lothaire. 1997. Combinatorics on words (second ed.). Cambridge

University Press.

[20] Alexis Maciel, Pierre PÃ©ladeau, and Denis ThÃ©rien. 2000. Programs
over semigroups of dot-depth one. Theor. Comput. Sci. 245, 1 (2000),
135â€“148. https://doi.org/10.1016/S0304-3975(99)00278-9

[21] Jean-Ã‰ric Pin. 2017. The Dot-Depth Hierarchy, 45 Years Later. In
The Role of Theory in Computer Science - Essays Dedicated to Janusz
Brzozowski, Stavros Konstantinidis, Nelma Moreira, RogÃ©rio Reis, and
Jeffrey O. Shallit (Eds.). World Scientific, 177â€“202. https://doi.org/10.
1142/9789813148208_0008

[22] Jean-Ã‰ric Pin and Pascal Weil. 1997. Polynomial Closure and Un-
ambiguous Product. Theory Comput. Syst. 30, 4 (1997), 383â€“422.
https://doi.org/10.1007/BF02679467

[23] Jean-Ã‰ric Pin. 1995. A variety theorem without complementation.

Russian Mathematics (Izvestija vuzov. Matematika) 39 (1995), 80â€“90.

[24] Thomas Place. 2018. Separating regular languages with two quantifier
alternations. Log. Methods Comput. Sci. 14, 4 (2018). https://doi.org/
10.23638/LMCS-14(4:16)2018

[25] Thomas Place and Marc Zeitoun. 2019. Going Higher in First-Order
Quantifier Alternation Hierarchies on Words. J. ACM 66, 2 (2019),
12:1â€“12:65. https://doi.org/10.1145/3303991

[26] Michael Sipser. 1983. Borel Sets and Circuit Complexity. In Proceedings
of the 15th Annual ACM Symposium on Theory of Computing, 25-27
April, 1983, Boston, Massachusetts, USA, David S. Johnson, Ronald Fagin,
Michael L. Fredman, David Harel, Richard M. Karp, Nancy A. Lynch,
Christos H. Papadimitriou, Ronald L. Rivest, Walter L. Ruzzo, and Joel I.
Seiferas (Eds.). ACM, 61â€“69. https://doi.org/10.1145/800061.808733

[27] Michael Sipser. 1984. A Topological View of Some Problems in Com-
plexity Theory. In Mathematical Foundations of Computer Science 1984,
Praha, Czechoslovakia, September 3-7, 1984, Proceedings (Lecture Notes
in Computer Science, Vol. 176), Michal Chytil and VÃ¡clav Koubek (Eds.).
Springer, 567â€“572. https://doi.org/10.1007/BFb0030341

[28] Howard Straubing. 1985. Finite semigroup varieties of the form ğ‘‰ â˜… ğ·.
Journal of Pure and Applied Algebra 36 (1985), 53â€“94. https://doi.org/
10.1016/0022-4049(85)90062-3

[29] Howard Straubing. 1991. Constant-Depth periodic Circuits.

Int.
https://doi.org/10.1142/

J. Algebra Comput. 1, 1 (1991), 49â€“88.

Corentin Barloy, MichaÃ«l Cadilhac, Charles Paperman, and Thomas Zeume

S0218196791000043

[30] Howard Straubing. 1994. Finite Automata, Formal Logic, and Circuit
Complexity. BirkhÃ¤user, Boston. https://doi.org/10.1007/978-1-4612-
0289-9

[31] Howard Straubing. 2001. Languages Defined with Modular Counting
Quantifiers. Inf. Comput. 166, 2 (2001), 112â€“132. https://doi.org/10.
1006/inco.2000.2923

[32] Howard Straubing. 2015. A new proof of the locality of R.

Int. J.
https://doi.org/10.1142/

Algebra Comput. 25, 1-2 (2015), 293â€“300.
S0218196715400111

[33] Denis ThÃ©rien and Thomas Wilke. 1998. Over Words, Two Variables
Are as Powerful as One Quantifier Alternation. In Proceedings of the
Thirtieth Annual ACM Symposium on the Theory of Computing, Dallas,
Texas, USA, May 23-26, 1998, Jeffrey Scott Vitter (Ed.). ACM, 234â€“240.
https://doi.org/10.1145/276698.276749

[34] Bret Tilson. 1987. Categories as algebra: An essential ingredient in the
theory of monoids. Journal of Pure and Applied Algebra 48, 1 (1987),
83â€“198. https://doi.org/10.1016/0022-4049(87)90108-3

