Deciding Hyperproperties Combined with Functional
Specifications
Raven Beutner, David Carral, Bernd Finkbeiner, Jana Hofmann, Markus

KrÃ¶tzsch

To cite this version:

Raven Beutner, David Carral, Bernd Finkbeiner, Jana Hofmann, Markus KrÃ¶tzsch. Deciding Hy-
perproperties Combined with Functional Specifications. LICS 2022 - 37th Annual ACM/IEEE Sym-
posium on Logic in Computer Science, Aug 2022, Haifa, Israel. pp.1-13, ï¿¿10.1145/3531130.3533369ï¿¿.
ï¿¿lirmm-03833578ï¿¿

HAL Id: lirmm-03833578

https://hal-lirmm.ccsd.cnrs.fr/lirmm-03833578

Submitted on 20 Sep 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

Lâ€™archive ouverte pluridisciplinaire HAL, est
destinÃ©e au dÃ©pÃ´t et Ã  la diffusion de documents
scientifiques de niveau recherche, publiÃ©s ou non,
Ã©manant des Ã©tablissements dâ€™enseignement et de
recherche franÃ§ais ou Ã©trangers, des laboratoires
publics ou privÃ©s.

Distributed under a Creative Commons Attribution 4.0 International License

Deciding Hyperproperties Combined
with Functional Specifications
David Carral
LIRMM, Inria, University of
Montpellier, CNRS
France

Raven Beutner
CISPA Helmholtz Center for
Information Security
Germany

Bernd Finkbeiner
CISPA Helmholtz Center for
Information Security
Germany

2
2
0
2

y
a
M
0
3

]

O
L
.
s
c
[

1
v
8
3
1
5
1
.
5
0
2
2
:
v
i
X
r
a

Jana Hofmann
CISPA Helmholtz Center for
Information Security
Germany

Markus KrÃ¶tzsch
Technische UniversitÃ¤t Dresden
Germany

Abstract
We study satisfiability for HyperLTL with a âˆ€âˆ—âˆƒâˆ— quantifier
prefix, known to be highly undecidable in general. HyperLTL
can express system properties that relate multiple traces (so-
called hyperproperties), which are often combined with trace
properties that specify functional behavior on single traces.
Following this conceptual split, we first define several safety
and liveness fragments of âˆ€âˆ—âˆƒâˆ— HyperLTL, and character-
ize the complexity of their (often much easier) satisfiability
problem. We then add LTL trace properties as functional
specifications. Though (highly) undecidable in many cases,
this way of combining â€œsimpleâ€ HyperLTL and arbitrary LTL
also leads to interesting new decidable fragments. This sys-
tematic study of âˆ€âˆ—âˆƒâˆ— fragments is complemented by a new
(incomplete) algorithm for âˆ€âˆƒâˆ—-HyperLTL satisfiability.

CCS Concepts: â€¢ Theory of computation â†’ Logic and
verification; Modal and temporal logics.
Keywords: Hyperproperties, HyperLTL, Satisfiability

ACM Reference Format:
Raven Beutner, David Carral, Bernd Finkbeiner, Jana Hofmann,
and Markus KrÃ¶tzsch. 2022. Deciding Hyperproperties Combined
with Functional Specifications. In 37th Annual ACM/IEEE Sym-
posium on Logic in Computer Science (LICS) (LICS â€™22), August 2â€“
5, 2022, Haifa, Israel. ACM, New York, NY, USA, 19 pages. https:
//doi.org/10.1145/3531130.3533369

1 Introduction
Hyperproperties are properties that relate multiple execu-
tion traces of a system [13] and comprise a range of relevant
properties from many areas of computer science. Examples
are symmetry, optimality, robustness, and noninterference.
The most prominent logic for expressing hyperproperties

LICS â€™22, August 2â€“5, 2022, Haifa, Israel
Â© 2022 Copyright held by the owner/author(s).
This is the authorâ€™s version of the work. It is posted here for your personal
use. Not for redistribution. The definitive Version of Record was published in
37th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS) (LICS
â€™22), August 2â€“5, 2022, Haifa, Israel, https://doi.org/10.1145/3531130.3533369.

is HyperLTL [12], which extends LTL with trace quantifica-
tion. Generalized noninterference [33], for example, states
that high-security inputs do not influence the input-output
behavior observable by a low-security user, which can be
expressed in HyperLTL as follows.

âˆ€ğœ‹âˆ€ğœ‹ â€²âˆƒğœ‹ â€²â€².

(cid:16) (cid:219)

(ğ‘ğœ‹ â†” ğ‘ğœ‹ â€²â€²) âˆ§

(cid:219)

(ğ‘ğœ‹ â€² â†” ğ‘ğœ‹ â€²â€²)

(cid:17)

ğ‘ âˆˆğ¿out âˆªğ¿in

ğ‘ âˆˆğ»in

The formula states that for every two traces ğœ‹, ğœ‹ â€², there exists
a trace ğœ‹ â€²â€² that combines the low-security inputs and outputs
on ğœ‹ and the high-security inputs on ğœ‹ â€².

In this paper, we study the satisfiability problem of Hyper-
LTL. For LTL, satisfiability is PSPACE-complete [39]. For hy-
perproperties, satisfaction cannot be decided by analyzing
single traces in isolation, making formal reasoning challeng-
ing. Deciding satisfiability in the âˆƒâˆ—âˆ€âˆ— fragment of HyperLTL
is already EXPSPACE-complete [19]; and deciding hyperprop-
erties with a âˆ€âˆ—âˆƒâˆ— trace quantifier alternations is, in gen-
eral, strongly undecidable, namely Î£1
1-complete [24]. The
âˆ€âˆ—âˆƒâˆ— fragment contains many relevant properties like gen-
eralized noninterference, program refinement, and software
doping [15, 33]. However, positive results for this important
fragment have been very rare and were only obtained by
heavy restrictions on the use of temporal operators or by
assuming finite models [32] (see related work below). Algo-
rithms, even if incomplete, are similarly missing.

In this work, we address these shortcomings by studying
ways of solving satisfiability of âˆ€âˆ—âˆƒâˆ— HyperLTL specifica-
tions. We identify simple yet expressive fragments of âˆ€âˆ—âˆƒâˆ—
with better computational properties, where our approach
derives interesting fragments in two steps. First, we split
a specification into hyperproperty and trace property, so
that we can focus on â€œsimpleâ€ hyperproperties. Second, to
find such simple hyperproperties, we systematically study
fragments of temporal safety and temporal liveness hyper-
properties. This work towards new decidable fragments is
complemented by a new (incomplete but often successful)
algorithm that is applicable to arbitrary âˆ€âˆƒâˆ— specifications.

 
 
 
 
 
 
LICS â€™22, August 2â€“5, 2022, Haifa, Israel

Beutner et al.

Splitting in Hyperproperties and Trace Properties. So
far, all HyperLTL decidability results were obtained by con-
sidering HyperLTL specifications in isolation. Most of the
time, however, specifications refer to a specific system. The
hyperproperty itself is often relatively simple (like the non-
interference property above) and only gets difficult to sat-
isfy given a specification of the functional behavior of the
system.1 The following example highlights this interplay
between functional property and hyperproperty.

Example 1.1. Consider a system of agents that send and re-
ceive data. Each trace describes the behavior of a single agent.
We want the system to satisfy the following hyperproperty.

ğœ‘ (cid:66) âˆ€ğœ‹âˆƒğœ‹ â€².

(sendğœ‹ âˆ§ recğœ‹ â€²)

The formula states that each agent eventually sends its in-
formation and that there exists some agent receiving it. The
formula on its own is easily satisfiable already by a one-trace
model. In addition to the hyperproperty we add the simple
functional specification (trace property)

ğœ“ (cid:66) (Â¬rec) U (rec âˆ§

Â¬rec) âˆ§ (rec â†” send)

which expresses that each agent receives data exactly once
and sends it forth in the next step. Every model that satisfies
the combination of ğœ‘ and ğœ“ needs to be infinite. Automat-
ically checking satisfiability is thus complex as we cannot
â—
iteratively search for models of bounded (finite) size.

A satisfiability checker that distinguishes between a func-
tional specification and hyperproperties could be used to
sanity-check whether a hyperproperty is satisfiable in com-
bination with the specification of the system at hand.

Temporal Safety and Temporal Liveness. The classifi-
cation into safety and liveness has a long tradition in the
study of trace properties, where especially safety often al-
lows for easier algorithms. For our analysis, we define anal-
ogous fragments: a HyperLTL formula is temporal safety
(resp. temporal liveness) if its LTL body describes a safety
(resp. liveness) property. We study the relationship to the
existing notations of hypersafety and hyperliveness defined
by Clarkson and Schneider [13]. Guided by our insights into
the complete fragments, we derive several more specific
classes of temporal safety and liveness properties, for which
satisfiability is easier to decide.

Main Results. Our results are summarized in Table 1,
where each line represents a class of HyperLTL properties,
and the columns distinguish whether or not additional (arbi-
trarily complex) LTL specifications are allowed. All hardness
results for âˆ€âˆ—âˆƒâˆ— fragments, except in the NEXP cases, already
hold for âˆ€âˆƒâˆ—. The restriction to temporal safety makes the
satisfiability of HyperLTL drop from Î£1
1 to coRE, which we
1Of course, we can incorporate the LTL property in the HyperLTL formula:
we conceptually divide the specification into a (complicated) trace property
and a (simple) hyperproperty.

Table 1. Deciding satisfiability of HyperLTL specifications.
All results, expect for decidability (dec.), denote complete-
ness. Our notation is found in Section 2.3, e.g., âˆ€âˆ—âˆƒâˆ—.
âˆ—)
is the class of âˆ€âˆ—âˆƒâˆ— formulas whose LTL body uses a single

(

operator with optional

operators in its scope.

l
a
r
o
p
m
e
T

y
t
e
f
a
S

l
a
r
o
p
m
e
T

s
s
e
n
e
v
i
L

complete fragment

âˆ€âˆ—âˆƒâˆ—.
âˆ€âˆ—âˆƒâˆ—.
(

âˆ€âˆ—âˆƒâˆ—.

âˆ—

âˆ—)

complete fragment
âˆ€âˆƒâˆ—. det-liveness

âˆ€âˆƒâˆ—.

âˆ—)
âˆ€âˆ—âˆƒâˆ—. âˆ§ Â· Â· Â· âˆ§

(

no LTL spec. with LTL spec.
Î£1
coRE [Thm. 3.7]
1 [Thm. 3.11]
NEXP [Thm. 3.12] NEXP [Thm. 3.12]
Î£1
NEXP [Lem. 3.13]
1 [Thm. 3.11]
Î£1
1 [Thm. 3.11]
coRE [Lem. 3.10]
Î£1
Î£1
1 [Thm. 4.2]
1 [Thm. 4.2]
Î£1
1 [Cor. 4.15]
trivial [Prop. 4.14]
dec. [Thm. 4.5]
NP [Lem. 4.4]
Î£1
1 [Thm. 4.11]
NP [Lem. 4.4]

show by an effective reduction to satisfiability of first-order
logic. While still undecidable, this enables the use of com-
mon first-order techniques such as resolution, tableaux, and
related methods [36]. Hardness already holds for simple for-
mulas consisting only of a single with s in its scope. If we
add (non-safety) functional specifications, hardness jumps
back to Î£1
1. In contrast to temporal safety properties, the
class of temporal liveness HyperLTL formulas is of analyti-
cal complexity, even without additional LTL specifications.
However, again in contrast to
âˆ—), formulas from the
(
âˆ—) fragment are decidable, even when combined
âˆ€âˆƒâˆ—.
with an arbitrary LTL specification. This is the first Hyper-
LTL decidability result for formulas that can enforce models
with infinitely many traces. The class also contains the spec-
ification from Example 1.1. This decidability result is tight in
the sense that already conjunctions of multiple eventualities
are analytical again.

(

Finally, to complement our decidability results, we propose
a general approximation algorithm to find the largest model
for specifications consisting of a HyperLTL formula and an
LTL formula. Our experimental evaluation shows that our
algorithm performs significantly better than approaches that
iteratively search for models of bounded size [20, 32] and
can even show unsatisfiability for many formulas (which is
impossible in bounded approaches).

Structure. The remainder of this paper is structured as
follows. We give some basic preliminaries and introduce
HyperLTL in Section 2. We study the fragment of temporal
safety in Section 3. We begin this study with the full frag-
ment, and then gradually decrease in expressiveness all the
way to the fragment containing only
operators. We then
move to temporal liveness in Section 4. Analogous to the
safety case, we begin with the full fragment, gradually de-
creasing to the fragment of pure eventualities, for which we
establish decidability. Finally, in Section 5, we describe our

Deciding Hyperproperties Combined with Functional Specifications

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

approximation for finding the largest models and report on
experimental results in Section 6.

Related Work. In recent years, many logics to express hy-
perproperties have been developed. Most approaches extend
existing logics with trace or path quantification, examples
besides HyperLTL are HyperCTLâˆ— [13], HyperQPTL [35],
HyperPDL-Î” [26], and HyperATLâˆ— [6]. Monadic first-order
logics can be extended by adding a special equal-level predi-
cate [22] or using different types of quantifiers [4]. Recently,
hyperproperties have also been obtained via a team seman-
tics for trace logics [29, 42]. Apart from plain temporal logics,
there are also hyperlogics for hyperproperties that are asyn-
chronous [5, 11, 27], quantitative [21], or probabilistic [1, 16].
HyperLTL remains the most used among the proposed
hyperlogics. Its satisfiability problem is known to be challeng-
ing: if we define fragments based on quantifier prefixes (but
with an arbitrary body), then âˆƒâˆ—âˆ€âˆ— is the most general frag-
ment for which satisfiability is still decidable (and EXPSPACE-
complete), whereas âˆ€âˆƒâˆ— already leads to undecidability [19].
In fact, the âˆ€âˆ—âˆƒâˆ— fragment is already satisfiability-complete:
any HyperLTL formula can be effectively translated into
equisatisfiable âˆ€âˆ—âˆƒâˆ— formula [32]. Analyzing the case of (un-
restricted) HyperLTL in more detail, Fortin et al. show satisfi-
ability to be Î£1
1-complete, and therefore above all problems in
the arithmetic hierarchy [24]. In a more fine-grained analysis,
Mascle and Zimmermann show that the problem becomes
decidable if one only considers models of a bounded size or
if, for selected quantifier prefixes, temporal operators are
not nested [32]. In particular, âˆ€âˆƒâˆ— properties using only
s) are decidable (and always have a finite
and
model), as no â€œdiagonalâ€ comparison between trace positions
is possible [32]. The satisfiability of the logics HyperQPTL
and HyperCTLâˆ—, which both subsume HyperLTL, has been
studied as well [14].

(without

2 Preliminaries
We assume a fixed, finite set of atomic propositions AP and
write Î£ (cid:66) 2AP . Given a symbol ğœ‹, we write APğœ‹ for the set
{ğ‘ğœ‹ | ğ‘ âˆˆ AP }. A trace ğ‘¡ is an element in Î£ğœ” . For ğ‘– âˆˆ N,
ğ‘¡ (ğ‘–) denotes the ğ‘–th element in ğ‘¡ (starting with the 0th) and
ğ‘¡ [ğ‘–, âˆ] is the suffix of a trace starting in point in time ğ‘–. For
a finite trace ğ‘¢ âˆˆ Î£âˆ— and an infinite trace ğ‘¡ âˆˆ Î£ğœ” , ğ‘¢ is a prefix
of ğ‘¡ (written ğ‘¢ â‹– ğ‘¡) if for every 0 â‰¤ ğ‘– < |ğ‘¢ |, ğ‘¢ (ğ‘–) = ğ‘¡ (ğ‘–). A
trace property ğ‘ƒ is a set of traces, whereas a hyperproperty
ğ» is a set of sets of traces [13].

2.1 Trace Properties and LTL
Linear temporal logic (LTL) defines trace properties by com-
bining temporal operators with boolean connectives. Its syn-
tax is defined by the following grammar.

ğœ“ (cid:66) ğ‘ | Â¬ğœ“ | ğœ“ âˆ§ ğœ“ | ğœ“ | ğœ“ U ğœ“

where ğ‘ âˆˆ AP. We also use the standard Boolean connectives
âˆ§, â†’, â†” and constants âŠ¤, âŠ¥, as well as the derived LTL
ğœ“ (cid:66)
ğœ“ (cid:66) âŠ¤ U ğœ“ , and globally
operators eventually
Â¬ Â¬ğœ“ . The semantics of LTL is defined as usual.

ğ‘¡ |= ğ‘
ğ‘¡ |= Â¬ğœ“
ğ‘¡ |= ğœ“1 âˆ§ ğœ“2
ğ‘¡ |= ğœ“
ğ‘¡ |= ğœ“1 U ğœ“2

iff ğ‘ âˆˆ ğ‘¡ (0)
iff ğ‘¡ Ì¸|= ğœ“
iff ğ‘¡ |= ğœ“1 and ğ‘¡ |= ğœ“2
iff ğ‘¡ [1, âˆ] |= ğœ“
iff âˆƒğ‘–. ğ‘¡ [ğ‘–, âˆ] |= ğœ“2 and âˆ€ğ‘— < ğ‘–. ğ‘¡ [ ğ‘—, âˆ] |= ğœ“1
Safety and liveness properties are prominent classes of
trace properties [2]. Safety properties are characterized by
the fact that each violation is caused after a finite time. Live-
ness properties characterize that something good happens
eventually.

Definition 2.1. A property ğ‘ƒ is safety if it holds that for
every trace ğ‘¡ âˆ‰ ğ‘ƒ, there exists a ğ‘¢ â‹– ğ‘¡ such that for every ğ‘¡ â€²
with ğ‘¢ â‹– ğ‘¡ â€², we have ğ‘¡ â€² âˆ‰ ğ‘ƒ. A property ğ‘ƒ is liveness if for
every ğ‘¢ âˆˆ Î£âˆ—, there exists a ğ‘¡ âˆˆ Î£ğœ” with ğ‘¢ â‹– ğ‘¡ and ğ‘¡ âˆˆ ğ‘ƒ.

2.2 Hyperproperties and HyperLTL
HyperLTL [12] extends LTL with explicit quantification over
traces, thereby lifting it from a logic expressing trace prop-
erties to one expressing hyperproperties [13]. Let V be a set
of trace variables. We define HyperLTL formulas with the
following grammar.

ğœ‘ (cid:66) âˆƒğœ‹ . ğœ‘ | âˆ€ğœ‹ . ğœ‘ | ğœ™
ğœ™ (cid:66) ğ‘ğœ‹ | Â¬ğœ™ | ğœ™ âˆ§ ğœ™ |

ğœ™ | ğœ™ U ğœ™

Here, ğœ‹ âˆˆ V and ğ‘ âˆˆ AP. We consider only closed formulas,
i.e., formulas where for each atom ğ‘ğœ‹ the trace variable ğœ‹ is
bound by some trace quantifier. The semantics of HyperLTL
is given with respect to a set of traces ğ‘‡ and a trace assign-
ment Î , which is a partial mapping Î  : V â‡€ Î£ğœ” . For ğœ‹ âˆˆ V
and ğ‘¡ âˆˆ ğ‘‡ , we write Î [ğœ‹ â†¦â†’ ğ‘¡] for the trace assignment
obtained by updating the value of ğœ‹ to ğ‘¡. We write Î [ğ‘–, âˆ]
for the assignment Î [ğ‘–, âˆ] (ğœ‹) (cid:66) Î (ğœ‹) [ğ‘–, âˆ].

Î  |=ğ‘‡ ğ‘ğœ‹
Î  |=ğ‘‡ Â¬ğœ™
Î  |=ğ‘‡ ğœ™1 âˆ§ ğœ™2
Î  |=ğ‘‡
Î  |=ğ‘‡ ğœ™1 U ğœ™2

ğœ™

Î  |=ğ‘‡ âˆƒğœ‹ . ğœ‘
Î  |=ğ‘‡ âˆ€ğœ‹ . ğœ‘

iff ğ‘ âˆˆ Î (ğœ‹)(0)
iff Î  Ì¸|=ğ‘‡ ğœ™
iff Î  |=ğ‘‡ ğœ™1 and Î  |=ğ‘‡ ğœ™2
iff Î [1, âˆ] |=ğ‘‡ ğœ™
iff âˆƒğ‘–. Î [ğ‘–, âˆ] |=ğ‘‡ ğœ™2 and

âˆ€ğ‘— < ğ‘–. Î [ ğ‘—, âˆ] |=ğ‘‡ ğœ™1
iff âˆƒğ‘¡ âˆˆ ğ‘‡ . Î [ğœ‹ â†¦â†’ ğ‘¡] |=ğ‘‡ ğœ‘
iff âˆ€ğ‘¡ âˆˆ ğ‘‡ . Î [ğœ‹ â†¦â†’ ğ‘¡] |=ğ‘‡ ğœ‘

We say that ğ‘‡ is a model of ğœ‘ (written ğ‘‡ |= ğœ‘) if âˆ… |=ğ‘‡ ğœ‘,
where âˆ… denotes the empty trace assignment.

Remark 2.2. HyperLTL is closed under conjunction (and,
more generally, under any boolean combination). For two

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

Beutner et al.

HyperLTL formulas ğœ‘1, ğœ‘2, we therefore write ğœ‘1 âˆ§ ğœ‘2 for
some HyperLTL formula expressing the conjunction of ğœ‘1, ğœ‘2.
ğ‘ğœ‹ ) can be
For examples (âˆ€ğœ‹âˆƒğœ‹ â€².
â—
expressed as âˆ€ğœ‹âˆ€ğœ‹ â€²âˆƒğœ‹ â€²â€².

(ğ‘ğœ‹ â†® ğ‘ğœ‹ â€²)) âˆ§ (âˆ€ğœ‹ .

(ğ‘ğœ‹ â†® ğ‘ğœ‹ â€²â€²) âˆ§ ğ‘ğœ‹ â€².

Analogous to trace properties, we can characterize hyper-
properties as hypersafety and hyperliveness [13]. We lift the
prefix relation â‹– to sets of traces: a set ğ‘ˆ âŠ† Î£âˆ— of finite traces
is a prefix of a set ğ‘‡ âŠ† Î£ğœ” (written ğ‘ˆ â‹–ğ‘‡ ) if, for every ğ‘¢ âˆˆ ğ‘ˆ ,
there exists a ğ‘¡ âˆˆ ğ‘‡ such that ğ‘¢ â‹– ğ‘¡.

Definition 2.3. A hyperproperty ğ» is hypersafety if for ev-
ery ğ‘‡ âŠ† Î£ğœ” with ğ‘‡ âˆ‰ ğ» , there exists a finite set ğ‘ˆ âŠ† Î£âˆ— with
ğ‘ˆ â‹– ğ‘‡ such that, for every ğ‘‡ â€² âŠ† Î£ğœ” with ğ‘ˆ â‹– ğ‘‡ â€², we have
ğ‘‡ â€² âˆ‰ ğ» . A property ğ» is hyperliveness if for every finite set
ğ‘ˆ âŠ† Î£âˆ—, there exists ğ‘‡ âŠ† Î£ğœ” with ğ‘ˆ â‹– ğ‘‡ and ğ‘‡ âˆˆ ğ» .

Intuitively, a violation of a hypersafety property can be
explained by the finite interaction of finitely many traces.
Conversely, a hyperproperty is hyperliveness, if such a set
can always be extended to a set satisfying the property.

2.3 Specifications and Notation
We study the combination of âˆ€âˆ—âˆƒâˆ— HyperLTL formulas and
arbitrary LTL formulas, and call such pairs specifications.

Definition 2.4. A specification is a pair (ğœ“, ğœ‘) where ğœ“ is an
LTL formula and ğœ‘ a HyperLTL formula. We say that (ğœ“, ğœ‘)
is satisfiable iff there exists a non-empty set of traces ğ‘‡ âŠ† Î£ğœ”
such that âˆ€ğ‘¡ âˆˆ ğ‘‡ . ğ‘¡ |= ğœ“ and ğ‘‡ |= ğœ‘.

In general, we write (ğœ“, ğœ‘) for specifications with arbi-
trary LTL and HyperLTL formulas. We use the following
notation for fragments of specifications. We write (âŠ¤, ğœ‘)
to indicate that no LTL formula is given or, equivalently,
the trace specification is true. We represent the quantifier
prefix of the HyperLTL property using regular expressions.
For example, âˆ€âˆƒâˆ— is a prefix consisting of a single univer-
sal quantifier followed by any number of existential quan-
tifiers. We write ğ‘„ âˆ— for an arbitrary prefix. The body of a
HyperLTL formula is structured based on the use of temporal
operators. We allow propositional (temporal-operator-free)
formulas as conjuncts if not stated otherwise Consider the
following example. A âˆ€âˆ—âˆƒâˆ—.
âˆ—) formula is of the form
(
âˆ€ğœ‹1 . . . âˆ€ğœ‹ğ‘›âˆƒğœ‹ğ‘›+1 . . . âˆƒğœ‹ğ‘›+ğ‘š. ( ğœ™) âˆ§ ğœ™ â€², where ğœ™ may con-
tain (potentially nested)
operators and ğœ™ â€² does not contain
any temporal operators. Analogously, a formula in âˆ€âˆ—âˆƒâˆ—.
describes formulas as the one above but ğœ™ may not contain
uses a conjunction of two

s. A formula in âˆ€âˆ—âˆƒâˆ—. âˆ§

eventualities (also without

s).

2.4 Complexity of Undecidable Problems
Many problems considered in this paper are highly undecid-
able. To enable precise quantification of â€œhow undecidableâ€,
we briefly recall the arithmetic and analytical hierarchy. We
only provide a brief overview and refer to [37] for details.

The arithmetic hierarchy contains all problems (languages)
that can be expressed in first-order arithmetic over the natu-
ral numbers. It contains the class of recursively enumerable
(RE) and co-enumerable problems (coRE) in its first level. The
class Î£1
1 (sitting in the analytical hierarchy) contains all prob-
lems that can be expressed with existential second-order
quantification (over sets of numbers) followed by a first-
order arithmetic formula. Analogously, the class Î 1
1 contains
all problems expressible using universal second-order quan-
tification. Consequently, both Î£1
1 (strictly) contain
the entire arithmetic hierarchy.

1 and Î 1

2.5 Machines
As a basic model of computation to show hardness we use
two-counter machines. A nondeterministic 2-counter machine
(2CM) consists of a finite set of instructions ğ‘™1, . . . ğ‘™ğ‘›, which
modify two counters ğ‘1, ğ‘2. Each instruction ğ‘™ğ‘– is of one of
the following forms, where ğ‘¥ âˆˆ {1, 2} and 1 â‰¤ ğ‘–, ğ‘—, ğ‘˜ â‰¤ ğ‘›.
1) ğ‘™ğ‘– : ğ‘ğ‘¥ (cid:66) ğ‘ğ‘¥ + 1; goto {ğ‘™ ğ‘—, ğ‘™ğ‘˜ }
2) ğ‘™ğ‘– : ğ‘ğ‘¥ (cid:66) ğ‘ğ‘¥ âˆ’ 1; goto {ğ‘™ ğ‘—, ğ‘™ğ‘˜ }
3) ğ‘™ğ‘– : if ğ‘ğ‘¥ = 0 then goto ğ‘™ ğ‘— else goto ğ‘™ğ‘˜
4) ğ‘™ğ‘– : halt
Here, goto {ğ‘™ ğ‘—, ğ‘™ğ‘˜ } indicates that the machine nondetermin-
istically chooses between instructions ğ‘™ ğ‘— and ğ‘™ğ‘˜ . A config-
uration of a 2CM is a tuple (ğ‘™ğ‘–, ğ‘£1, ğ‘£2), where ğ‘™ğ‘– is the next
instruction to be executed, and ğ‘£1, ğ‘£2 âˆˆ N denote the values
of the counters. The initial configuration of a 2CM is (ğ‘™1, 0, 0).
The transition relation between configurations is defined as
expected. Decrementing a counter that is already 0 leaves
the counter unchanged. A 2CM halts if a configuration with
a halt instruction is reached. Deciding if a machine has a
halting computation is RE-complete and deciding if it has an
infinite computation is coRE-complete [34]. An infinite com-
putation is recurring if it visits instruction ğ‘™1 infinitely many
times. Deciding if a machine has a recurring computation, is
Î£1
1-hard [3, 23].

3 Temporal Safety
In this section, we study the satisfiability problem of tem-
poral safety HyperLTL formulas. We begin by defining tem-
poral safety and argue why, compared to hypersafety, it is
the more suitable fragment in the context of satisfiability.
Subsequently, we show that temporal safety specifications
improve the general Î£1
1-hardness of âˆ€âˆ—âˆƒâˆ— hyperproperties
[24] to coRE-complete. We obtain this result by a reduction
to satisfiability of first-order logic. In the next step, we inves-
tigate the combination of temporally safe hyperproperties
with arbitrary functional trace specifications given in LTL.
The complexity jumps again to Î£1
1-completeness, perhaps
surprisingly already for very basic âˆ€âˆƒâˆ— formulas only us-
as temporal operator. We, therefore, analyze the
ing one
remaining fragments for decidability results and establish
s as temporal operators
that hyperproperties that only use

Deciding Hyperproperties Combined with Functional Specifications

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

are NEXPTIME-complete, even when adding arbitrary LTL
specifications. The same holds for hyper-invariants (using

) without an LTL specification.

3.1 Hypersafety and Temporal Safety
The safety fragment of LTL is one of the most successful
fragments of temporal logics as it is amendable to easier
monitoring and verification than arbitrary ğœ”-regular proper-
ties [30]. The concept of a safety property (i.e., every viola-
tion is caused after a finite time) naturally extends to hyper-
properties, giving the general class of hypersafety (cf. Defi-
nition 2.3) [13]. However, hypersafety is not well suited for
a systematic study of the decidability of hyperproperties.
Deciding if a property is hypersafety is already highly unde-
cidable and deciding if a hypersafety property is satisfiable
is directly reducible to LTL satisfiability.

1-hard.

Proposition 3.1. Deciding if a HyperLTL formula ğœ‘ is hy-
persafety is Î 1
Proof. As shown in [18, Thm. 23], for any HyperLTL formula
ğœ‘ we can effectively construct a formula ğœ‘ â€² such that ğœ‘ is
unsatisfied iff ğœ‘ â€² is hypersafety. As HyperLTL unsatisfiability
is Î 1
â–¡

1-hard [24], the hardness follows.

Proposition 3.2. Given a HyperLTL formula ğœ‘ that is hy-
persafety, satisfiability of ğœ‘ is decidable in PSPACE.

Proof. As hypersafety properties are closed under subsets
[13], ğœ‘ is satisfiable iff it is satisfiable by a single trace model.
Therefore, we can collapse all quantifiers in ğœ‘ to universal
ones, giving an equisatisfiable (but not equivalent) âˆ€âˆ— for-
mula for which satisfiability is decidable in PSPACE [19]. â–¡

Instead of focusing on hypersafety, we study the satisfia-
bility problem for a broader fragment of formulas which we
call temporally safe.

Definition 3.3. A HyperLTL formula ğ‘„ğœ‹1 . . . ğ‘„ğœ‹ğ‘›. ğœ™ is tem-
poral safety if ğœ™ (interpreted as an LTL formula over APğœ‹1 âˆª
. . . âˆª APğœ‹ğ‘› ) describes a safety property.

Similar to the case of LTL [30], the safety restriction on the
body of the HyperLTL formula allows for easier verification
(see, e.g., [7, 8]). We argue that temporal safety is also an
interesting fragment to study in the context of satisfiability.
First, compared with hypersafety, it is decidable whether
a formula is temporally safe, as safety is recognizable for
LTL [38]. Second, the next two propositions show that tem-
poral safety defines an expressive fragment: it subsumes all
âˆ€âˆ—âˆƒâˆ— hypersafety properties.

Proposition 3.4. For any âˆ€âˆ— hypersafety property, there ex-
ists an equivalent âˆ€âˆ— property that is temporally safe.

Proof. Let ğœ‘ = âˆ€ğœ‹1 . . . ğœ‹ğ‘›. ğœ™ be the hypersafety property. For
any function ğ‘“ : {1, . . . , ğ‘›} â†’ {1, . . . , ğ‘›} (of which there are
ğ‘›ğ‘› many) we define the formula ğœ™ [ğ‘“ ] as the formula obtained

by replacing each trace variable ğœ‹ğ‘– for 1 â‰¤ ğ‘– â‰¤ ğ‘š with ğœ‹ğ‘“ (ğ‘–) .
Define ğœ‘ â€² (cid:66) âˆ€ğœ‹1 . . . ğœ‹ğ‘›. ğœ™ â€² where
(cid:219)

ğœ™ â€² (cid:66)

ğœ™ [ğ‘“ ]

ğ‘“ :{1,...,ğ‘› }â†’{1,...,ğ‘› }
It is easy to see that ğœ‘ â‰¡ ğœ‘ â€² (using the semantics of universal
quantification). We claim that ğœ™ â€² expresses a safety property
when interpreted as trace property over APğœ‹1 âˆª Â· Â· Â· âˆª APğœ‹ğ‘› .
Take any trace ğ‘¡ over APğœ‹1 âˆª Â· Â· Â· âˆªAPğœ‹ğ‘› with ğ‘¡ Ì¸|= ğœ™ â€² (as in the
definition of safety, cf. Definition 2.1). Let ğ‘‡ = {ğ‘¡1, . . . , ğ‘¡ğ‘› }
be the set obtained by splitting ğ‘¡ into ğ‘› traces, i.e., ğ‘¡ğ‘– is a
trace over AP that copies the assignments to APğœ‹ğ‘– on ğ‘¡. By
construction of ğ‘‡ we get ğ‘‡ Ì¸|= ğœ‘ â€² and, as ğœ‘ â‰¡ ğœ‘ â€² is hypersafety,
we get a finite set of finite traces ğ‘ˆ â‹–ğ‘‡ such that no extension
of ğ‘ˆ satisfies ğœ‘. We assume that ğ‘ˆ = {ğ‘¢1, . . . , ğ‘¢ğ‘› } where ğ‘¢ğ‘– â‹–ğ‘¡ğ‘–
for each ğ‘–. This assumption is w.l.o.g., as we can replace
multiple prefixes of the same ğ‘¡ğ‘– by the longest among those
prefixes, and add an arbitrary prefix of each ğ‘¡ğ‘– that previously
had no prefix in ğ‘ˆ . We further assume, again w.l.o.g., that
all ğ‘¢ğ‘– s have the same length, say ğ‘˜. Now define ğ‘¢ as the
finite trace (of length ğ‘˜) over APğœ‹1 âˆª Â· Â· Â· âˆª APğœ‹ğ‘› , where the
assignment to APğœ‹ğ‘– is taken from ğ‘¢ğ‘– . As ğ‘¢ğ‘– â‹– ğ‘¡ğ‘– for each ğ‘–,
we get ğ‘¢ â‹– ğ‘¡. It remains to argue that ğ‘¢ is a bad prefix of
ğœ™ â€². Let ğ‘¡ â€² be any trace with ğ‘¢ â‹– ğ‘¡ â€². We, again, split ğ‘¡ â€² into
ğ‘› } satisfies ğ‘ˆ â‹– ğ‘‡ â€², so
traces ğ‘¡ â€²
ğ‘‡ â€² Ì¸|= ğœ‘. By the semantics of universal quantification, there
thus exists a ğ‘“ such that [ğœ‹1 â†¦â†’ ğ‘¡ â€²
ğ‘“ (ğ‘›) ] Ì¸|= ğœ™
, . . . , ğœ‹ğ‘› â†¦â†’ ğ‘¡ â€²
ğ‘›] Ì¸|= ğœ™ [ğ‘“ ]. This implies that
and so [ğœ‹1 â†¦â†’ ğ‘¡ â€²
â–¡
ğ‘¡ â€² Ì¸|= ğœ™ [ğ‘“ ] in the LTL semantics so ğ‘¡ â€² Ì¸|= ğœ™ â€² as required.

ğ‘›. Now ğ‘‡ â€² (cid:66) {ğ‘¡ â€²

1, . . . , ğœ‹ğ‘› â†¦â†’ ğ‘¡ â€²

1, . . . , ğ‘¡ â€²

1, . . . , ğ‘¡ â€²

ğ‘“ (1)

Remark 3.5. We do not claim that every âˆ€âˆ— hypersafety
property is temporally safe. Instead, Proposition 3.4 only
states that there exists an equivalent temporally safe prop-
(ğ‘ğœ‹ âˆ§ Â¬ğ‘ğœ‹ â€²) is unsatisfiable and
erty. For example, âˆ€ğœ‹âˆ€ğœ‹ â€².
(ğ‘ğœ‹ âˆ§ Â¬ğ‘ğœ‹ â€²) is not a safety prop-
thus hypersafety but
â—
erty.

Proposition 3.6. For any âˆ€âˆ—âˆƒâˆ— hypersafety property, there
exists an equivalent âˆ€âˆ— property that is temporally safe.

Proof. Let ğœ‘ = âˆ€ğœ‹1 . . . ğœ‹ğ‘›âˆƒğœ‹ â€²
ğ‘š. ğœ™ be hypersafety. For a
1 . . . ğœ‹ â€²
function ğ‘” : {1, . . . , ğ‘š} â†’ {1, . . . , ğ‘›} we define the formula
ğœ™ [ğ‘”] as the formula obtained by replacing each trace variable
ğ‘– for 1 â‰¤ ğ‘– â‰¤ ğ‘š with ğœ‹ğ‘” (ğ‘–) . Now define:
ğœ‹ â€²

ğœ‘ â€² (cid:66) âˆ€ğœ‹1 . . . ğœ‹ğ‘›.

(cid:220)

ğœ™ [ğ‘”]

ğ‘”:{1,...,ğ‘š }â†’{1,...,ğ‘› }

We claim that ğœ‘ â‰¡ ğœ‘ â€². Showing that ğœ‘ â€² implies ğœ‘ is easy as
the disjunction gives an explicit witness for the existential
quantifiers. For the other direction, assume ğ‘‡ |= ğœ‘ for some
model ğ‘‡ . Let ğ‘¡1, . . . , ğ‘¡ğ‘› âˆˆ ğ‘‡ be arbitrary. As ğœ‘ is a hypersafety
property and {ğ‘¡1, . . . , ğ‘¡ğ‘› } âŠ† ğ‘‡ , we get that {ğ‘¡1, . . . , ğ‘¡ğ‘› } |= ğœ‘. In
particular, if we bind each ğœ‹ğ‘– to ğ‘¡ğ‘– (in ğœ‘), we get witness traces
ğ‘š âˆˆ {ğ‘¡1, . . . , ğ‘¡ğ‘› } for the existential quantifiers in ğœ‘.
ğ‘¡ â€²
1, . . . , ğ‘¡ â€²
Now define ğ‘” by mapping each 1 â‰¤ ğ‘— â‰¤ ğ‘š to ğ‘– âˆˆ {1, . . . , ğ‘›}

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

Beutner et al.

ğ‘— = ğ‘¡ğ‘– . The trace assignment [ğœ‹1 â†¦â†’ ğ‘¡1, . . . , ğœ‹ğ‘› â†¦â†’ ğ‘¡ğ‘›]
with ğ‘¡ â€²
satisfies ğœ™ [ğ‘”]. As we can find such a ğ‘” for every ğ‘¡1, . . . , ğ‘¡ğ‘› âˆˆ ğ‘‡ ,
we get that ğ‘‡ |= ğœ‘ â€² as required. As ğœ‘ â€² is a âˆ€âˆ— formula, we can
â–¡
conclude using Proposition 3.4.

While temporal safety subsumes âˆ€âˆ—âˆƒâˆ— hypersafety, it is a
strictly larger fragment as shown by the following formula.

(cid:0)âˆƒğœ‹ . ğ‘ğœ‹ (cid:1) âˆ§ (cid:0)âˆ€ğœ‹ .
(cid:0)âˆ€ğœ‹âˆƒğœ‹ â€².

(ğ‘ğœ‹ â†’ Â¬ğ‘ğœ‹ )(cid:1)âˆ§

(ğ‘ğœ‹ â†” ğ‘ğœ‹ â€²)(cid:1)
Every model of this property must contain infinitely many
traces. Hypersafety properties, on the other hand, are closed
under subsets and are therefore always satisfiable by a single
trace model (if satisfiable at all) [13].

3.2 Temporal Safety without Functional

Specifications

Having established that temporal safety spans a broad spec-
trum of properties, we now establish that the general analyt-
ical hardness of HyperLTL [24] drops to coRE-completeness
for temporal safety.

Theorem 3.7. The satisfiability problem of temporally safe
HyperLTL is coRE-complete.

We show the upper bound of Theorem 3.7 by giving an
effective translation from temporally safe HyperLTL to first-
order logic using the fact that satisfiability of first-order
logic is coRE-complete [25]. Our translation enables the ap-
plication of first-order satisfiability solvers in the realm of
hyperproperties.

Definition 3.8. A safety automaton over alphabet Î£ is a
tuple A = (ğ‘„, ğ‘0, ğ›¿) where ğ‘„ is a finite set of states, ğ‘0 âˆˆ ğ‘„
the initial state, and ğ›¿ âŠ† ğ‘„ Ã—Î£Ã—ğ‘„ is the transition relation. A
trace ğ‘¡ âˆˆ Î£ğœ” is accepted by A if there exists some infinite run
ğ‘Ÿ âˆˆ ğ‘„ğœ” such that ğ‘Ÿ (0) = ğ‘0 and for all ğ‘–, (ğ‘Ÿ (ğ‘–), ğ‘¡ (ğ‘–), ğ‘Ÿ (ğ‘– + 1)) âˆˆ
ğ›¿. For every safety trace property ğœ™, there exists a safety
automaton that accepts ğœ™ [30].

Proposition 3.9. The satisfiability problem of temporally
safe HyperLTL is in coRE.
Proof. Let ğœ‘ = ğ‘„1ğœ‹1 . . . ğ‘„ğ‘›ğœ‹ğ‘›. ğœ™ be a temporally safe Hyper-
LTL formula. Let Ağœ™ = (ğ‘„ğœ™, ğ‘0,ğœ™, ğ›¿ğœ™ ) be a safety automaton
over Î£ (cid:66) 2APğœ‹1 âˆªÂ·Â·Â·âˆªAPğœ‹ğ‘› that accepts ğœ™ (when interpreted
as an LTL formula over APğœ‹1 âˆª Â· Â· Â· âˆª APğœ‹ğ‘› ). We define in
the following an equisatisfiable first-order formula Î˜, which
can be computed from ğœ‘. For readability, we use two-sorted
first-order logic, which is equisatisfiable to standard first-
order logic. We use two sorts: Trace, which contains trace
variables, and TimePoint, which contains time variables. We
use the constant ğ‘–0 : TimePoint to indicate the initial time
point. The predicate Succ(Â·, Â·) over TimePoint Ã— TimePoint
encodes the successor relation on time. For each ğ‘ âˆˆ AP,
we use a predicate ğ‘ƒğ‘ (Â·, Â·) over Trace Ã— TimePoint to indicate

that on trace ğ‘¡, ğ‘ holds at point in time ğ‘–. For each state
ğ‘ âˆˆ ğ‘„ğœ™ we use a predicate Stateğ‘ over Traceğ‘› Ã— TimePoint.
Informally, Stateğ‘ (ğ‘¥1, . . . , ğ‘¥ğ‘›, ğ‘–) indicates that a run of A on
traces ğ‘¥1, . . . , ğ‘¥ğ‘› is in state ğ‘ at timepoint ğ‘–.

We first ensure that each point in time has a successor

and that the set of traces is non-empty.

(cid:66) âˆ€ğ‘– : TimePoint. âˆƒğ‘– â€² : TimePoint. Succ(ğ‘–, ğ‘– â€²)

ğœ™succ
ğœ™non-empty (cid:66) âˆƒğ‘¥ : Trace. âŠ¤

For each state ğ‘ âˆˆ ğ‘„ğœ™ , we construct a formula ğœŒğ‘ (over free
variables ğ‘¥1, . . . , ğ‘¥ğ‘›), describing that, for any choice of traces
and at any point in time, there is a transition in A.

ğœŒğ‘ (cid:66) âˆ€ğ‘–, ğ‘– â€² : TimePoint. Stateğ‘ (ğ‘¥1, . . . , ğ‘¥ğ‘›, ğ‘–) âˆ§ Succ(ğ‘–, ğ‘– â€²)

â†’

(cid:220)

(cid:16) (cid:219)

ğ‘ƒğ‘ (ğ‘¥ ğ‘—, ğ‘–) âˆ§

(cid:219)

Â¬ğ‘ƒğ‘ (ğ‘¥ ğ‘—, ğ‘–) âˆ§

(ğ‘,ğœ,ğ‘â€²) âˆˆğ›¿ğœ™

ğ‘ğœ‹ ğ‘— âˆˆğœ

ğ‘ğœ‹ ğ‘— âˆ‰ğœ
(cid:17)

Stateğ‘â€² (ğ‘¥1, . . . , ğ‘¥ğ‘›, ğ‘– â€²)

Now, Î˜ is defined as follows

Î˜ (cid:66) ğ‘„1ğ‘¥1 : Trace. . . . ğ‘„ğ‘›ğ‘¥ğ‘› : Trace. ğœ™succ âˆ§ ğœ™non-empty
ğœŒğ‘ âˆ§ Stateğ‘0 (ğ‘¥1, . . . , ğ‘¥ğ‘›, ğ‘–ğ‘œ ).

(cid:219)

âˆ§

ğ‘ âˆˆğ‘„

The last conjunct ensures that all trace tuples chosen by the
quantifiers have an infinite run in A starting in the initial
state and in the initial time point. If Î˜ is satisfiable, we can
construct a trace assignment by setting the propositions
based on the evaluation of ğ‘ƒğ‘ (Â·, Â·) in a satisfying first-order
model of Î˜ and vice versa. A detailed proof can be found in
â–¡
Appendix A.

To complement the upper bound, we show coRE-hardness
by reducing the complement of the halting problem of deter-
ministic Turing machines. The proof shows that already a
single with nested

suffices for coRE-hardness.

Lemma 3.10. The satisfiability problem is coRE-hard for
specifications (âŠ¤, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒâˆ—.

âˆ—).

(

Proof sketch. We encode the non-termination of determinis-
tic Turning machines, which is coRE-hard. Each trace rep-
resents a configuration of the machine and the âˆ€âˆƒ formula
demands that each configuration encoded in trace ğœ‹ has a
successor configuration on some trace ğœ‹ â€². As the transitions
of a TM can be checked locally, we can encode a successor
configuration by comparing every three consecutive posi-
tions on ğœ‹ and ğœ‹ â€², which is possible with a single globally.
â–¡
We give a detailed proof in Appendix A.

This completes the proof of Theorem 3.7.

3.3 Temporal Safety with Functional Specifications
We now investigate satisfiability for the combination of tem-
porally safe HyperLTL formulas and LTL properties. If the
LTL specification is safety, we can simply merge the trace

Deciding Hyperproperties Combined with Functional Specifications

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

property with the temporally safe hyperproperty, maintain-
ing the applicability of Theorem 3.7. The situation changes
if we allow non-safety trace properties.

.

1-complete for

Theorem 3.11. The satisfiability problem is Î£1
specifications (ğœ“, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒâˆ—.
Proof sketch. Membership in Î£1
1 follows from [24]. For hard-
ness, we encode recurring computations of nondeterministic
two-counter machines. We represent each configuration by
encoding the current instruction and two atomic proposi-
tions c1, c2 that hold exactly once, i.e., counter ğ‘¥ has value ğ‘£
if cğ‘¥ occurs in the ğ‘£th position. To ensure a recurring com-
putation, we add a third counter ğ‘¡ that decreases in each
step. When it reaches 0, the trace must encode the initial
instruction, at which point ğ‘¡ is reset to any value. The key
idea of the proof is that each trace in the model represents
two consecutive configurations, which are encoded over dis-
joint copies of AP (for ğ‘– âˆˆ {1, 2}, APğ‘– = {ğ‘ğ‘–
| ğ‘ âˆˆ AP}). In
LTL, we can express that the second configuration encoded
in a trace is a successor of the first configuration in that
trace. Furthermore, we express in LTL that the value of ğ‘¡
either decreases or the initial instruction is executed. In the
HyperLTL property we ensure the existence of the initial
configuration, and state that for each trace ğœ‹, there exist a
ğœ‹ â€² such that the second configuration on ğœ‹ equals the first
on ğœ‹ â€². We can express the latter as

âˆ€ğœ‹âˆƒğœ‹ â€². (cid:211)ğ‘ âˆˆAP

ğœ‹ â†” ğ‘1
ğ‘2
ğœ‹ â€².

The resulting specification is satisfiable if and only if the
machine has a recurring computation. We give a detailed
â–¡
proof in Appendix A.

operator suffices to jump to Î£1

3.4 Propositional Hyperproperties and Invariants
As we have seen, with arbitrary LTL properties present, a
1. This leaves hyper-
single
properties expressed using only s as the only sub-analytical
fragment. We settle the precise complexity of the resulting
problem to be NEXPTIME-complete.

Theorem 3.12. The satisfiability problem is NEXPTIME-com-
plete for specifications (ğœ“, ğœ‘) where ğœ‘ is of the form ğ‘„ âˆ—.
âˆ—.
Hardness holds already for ğœ“ = âŠ¤, a âˆ€âˆ—âˆƒâˆ— prefix, and no
s.
Proof sketch. To show containment, we nondeterministically
guess a set of finite traces ğ‘€ âŠ† Î£ğ‘˜ , where ğ‘˜ is the number
of
operators in the formula. We then verify that each
trace in ğ‘€ can be extended to one satisfying ğœ“ and that
ğ‘€ is a model of the hyperproperty. For the lower bound,
we reduce the acceptance of an exponential-time bounded
nondeterministic Turing machine to a HyperLTL formula.
Our encoding is a âˆ€âˆ—âˆƒâˆ—-formula, which does not contain any
temporal operators (not even ) and no trace property. Each
trace in our model encodes a piece of information (ğ‘ , ğ‘, ğ›¾, ğ‘),
where ğ‘ , ğ‘ âˆˆ N, ğ›¾ is a tape symbol of the TM, and ğ‘ either
a state of the TM or âŠ¥. The tuple (ğ‘ , ğ‘, ğ‘¡, ğ‘) encodes that

in time-step ğ‘  and at position ğ‘, the tape content is ğ›¾, and
either the head is at position ğ‘ and the machine is in state
ğ‘, or the head is not at position ğ‘ (if ğ‘ = âŠ¥). As the TM
is time (and thus space) bounded, ğ‘  and ğ‘ are bound by 2ğ‘›
for some ğ‘›. We show that we can express in HyperLTL that
the information encoded in a given model defines a valid
accepting run of the TM. The resulting formula is satisfiable
iff TM has an accepting computation. As we can never refer
to all exponentially many positions explicitly, we use âˆ€âˆ—âˆƒâˆ—
formulas to encode a counter that references all positions.
â–¡
We give a formal proof in the Appendix A.
We note that HyperLTL without temporal operators has
a strong connection to quantified boolean formulas (QBF),
the validity of which is a standard PSPACE-complete problem
[40]. In contrast to QBF, where the quantifier structure spans
the polynomial hierarchy, our proof shows that in Hyper-
LTL, the âˆ€âˆ—âˆƒâˆ— fragment suffices to show NEXPTIME-hardness
(refuting a conjecture in [32] that temporal-operator-free
HyperLTL is equivalent to QBF). The reason is that Hyper-
LTL satisfiability asks for the existence of some model for
which the formula holds (which is related to the more general
second-order QBF problem [31]).

If we forgo the additional trace property, we can also show
the following lemma. Hardness already holds if we disallow
propositional formulas outside of the

.

Lemma 3.13. The satisfiability problem is NEXPTIME-com-
plete for specifications (âŠ¤, ğœ‘) where ğœ‘ is of the form âˆ€âˆ—âˆƒâˆ—.
.
Proof. A property ğœ‘ = âˆ€ğ‘›âˆƒğ‘š. ( ğœ™) âˆ§ ğœ™ â€² (where ğœ™, ğœ™ â€² do not
contain any temporal operators) is satisfiable iff âˆ€ğ‘›âˆƒğ‘š. ğœ™ âˆ§ğœ™ â€²
is satisfiable. The result then follows using Theorem 3.12. â–¡

4 Temporal Liveness
The natural counterparts of safety properties are liveness
properties, which postulate that â€œsomething good happens
eventuallyâ€. Similar to the case of hypersafety, hyperliveness
as a fragment is not well-suited when studying satisfiability:
any hyperliveness property is, by definition, satisfiable. Anal-
ogously to our study of temporal safety, we instead study
HyperLTL properties whose body is a liveness property.

Definition 4.1. A HyperLTL formula ğ‘„ğœ‹1 . . . ğ‘„ğœ‹ğ‘›. ğœ™ is a
temporal liveness property if ğœ™ (interpreted as an LTL formula
over APğœ‹1 âˆª Â· Â· Â· âˆª APğœ‹ğ‘› ) describes a liveness property.

We examine the temporal liveness fragment following
the structure of Section 3 and point out analogous results
wherever possible. As in Section 3, we first examine the
entire class of temporal liveness and then gradually restrict
this class to obtain new decidability results.

4.1 Hyperliveness and Temporal Liveness
As opposed to the safety case (cf. Proposition 3.6), temporal
liveness and hyperliveness are incomparable. In temporal
liveness, we can easily express falsity via âˆ€ğœ‹âˆ€ğœ‹ â€².
(ğ‘ğœ‹ âˆ§

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

Beutner et al.

Â¬ğ‘ğœ‹ â€²), which is not hyperliveness. Conversely, the property
(ğ‘ğœ‹ â†® ğ‘ğœ‹ â€²) is hyperliveness (as we can always add
âˆ€ğœ‹âˆƒğœ‹ â€².
more witness traces) but not expressible in temporal liveness.

an equisatisfiable âˆ€2âˆƒâˆ— HyperLTL formula [32, Thm. 5], so
Theorem 4.3 shows that deciding temporal liveness can be
used to decide full HyperLTL.

1-hard.
1-hard for âˆ€âˆƒâˆ—

4.2 General Temporal Liveness
Analogous to Theorem 3.7, we consider the full fragment of
temporal liveness. Different from the fragment of temporal
safety, the class of temporal liveness is already Î£1

Theorem 4.2. The satisfiability problem is Î£1
temporal liveness HyperLTL formulas.

To prove Theorem 4.2, we show a stronger result: we
can effectively reduce every âˆ€âˆ—âˆƒâˆ— HyperLTL property to an
equisatisfiable temporal liveness property.

Theorem 4.3. Let (ğœ“, ğœ‘) be a specification where ğœ‘ is of the
form âˆ€ğ‘›âˆƒğ‘š. ğœ™, and ğœ“ and ğœ™ are arbitrary but satisfiable LTL
formulas. Then there is an effectively computable specifica-
tion (ğœ“ â€², ğœ‘ â€²) such that ğœ“ â€² is an LTL liveness property, ğœ‘ â€² is a
âˆ€ğ‘›âˆƒğ‘š temporal liveness property, and (ğœ“, ğœ‘) and (ğœ“ â€², ğœ‘ â€²) are
equisatisfiable.
Proof. The idea is to move the start position of the formula
under a
operator. We introduce a fresh atomic proposi-
tion â€  and ensure that all traces satisfy the liveness prop-
erty
Â¬â€ 
holds (the last time that â€  is true) is then the â€œstart posi-
tionâ€ to evaluate the formula. Let ğœ‘ = ğ‘„ âˆ—. ğœ™ where ğ‘„ âˆ— =
âˆ€ğœ‹1 . . . ğœ‹ğ‘›âˆƒğœ‹ğ‘›+1 . . . ğœ‹ğ‘›+ğ‘š is the quantifier prefix of ğœ‘. Define

Â¬â€ ). The unique position where â€  âˆ§

(â€  âˆ§

ğœ‘ â€² (cid:66) ğ‘„ âˆ—.

(cid:20) ğ‘›+ğ‘š
(cid:219)

ğ‘–=1

(cid:104)

â€ ğœ‹ğ‘– âˆ§

(cid:21)

(cid:105)

âˆ§ ğœ™

Â¬ â€ ğœ‹ğ‘–

ğ‘›+ğ‘š
(cid:219)

ğ‘–=1

In similar fashion, we define ğœ“ â€² (cid:66) (â€  âˆ§ (
Â¬â€ ) âˆ§ğœ“ ). It is
easy to see that both the LTL body of ğœ‘ â€² and ğœ“ â€² are liveness
properties. Here it is crucial that we assumed that ğœ“ and ğœ™
are satisfiable.

We now claim that (ğœ“, ğœ‘) is satisfiable if and only if (ğœ“ â€²ğœ‘ â€²)
is satisfiable. For the first direction, assume that ğ‘‡ is a model
for (ğœ“, ğœ‘). The model with â€  added to the first step of all
traces satisfies (ğœ“ â€², ğœ‘ â€²). For the other direction, let ğ‘‡ be a
model of (ğœ“ â€², ğœ‘ â€²). We assume w.l.o.g. that there is no subset
ğ‘‡ â€² âŠŠ ğ‘‡ such that ğ‘‡ â€² is also a model for (ğœ“ â€², ğœ‘ â€²). The property
enforces that for any traces ğ‘¡1, . . . , ğ‘¡ğ‘›+ğ‘š, where ğ‘¡ğ‘›+1, . . . , ğ‘¡ğ‘›+ğ‘š
are the witness traces for ğ‘¡1, . . . , ğ‘¡ğ‘š, â€  holds for the last time
at a common time point. As ğ‘‡ â€² is minimal, every trace serves
as a witness for some other traces. Therefore the last position
where â€  holds is the same for all traces in ğ‘‡ â€². Let ğ‘– be this
â–¡
position. Then {ğ‘¡ [ğ‘–, âˆ] | ğ‘¡ âˆˆ ğ‘‡ â€²} is a model of (ğœ“, ğœ‘).

By Theorem 3.11, satisfiability of âˆ€âˆƒâˆ— HyperLTL is Î£1
1-
hard (note that we transform any specification (ğœ“, âˆ€ğ‘›âˆƒğ‘š. ğœ™)
with ğ‘› â‰¥ 1 into a specification (âŠ¤, âˆ€ğ‘›âˆƒğ‘š. ğœ™ â€²) by integrating
the trace property into the body of the HyperLTL formula).
Theorem 4.3 thus gives a proof of Theorem 4.2. More gener-
ally, every HyperLTL formula can be effectively reduced to

4.3 Simple Liveness Properties
The general class of temporal liveness thus does not define
an â€œeasierâ€ fragment of HyperLTL. As in the case of safety
properties, we study the precise boundary at which the jump
to Î£1
1 occurs by restricting to simpler forms of temporal
liveness. Analogously to the case of invariants (described
with ), we study eventualities (

).

(

Lemma 4.4. The satisfiability problem is NP-complete for
specifications (âŠ¤, ğœ‘) where ğœ‘ is of the form âˆ€âˆ—âˆƒâˆ—.
âˆ—) âˆ§
âˆ—) and no propositional formulas occur outside of the
Â· Â· Â· âˆ§ (
operators. Hardness already holds for a single eventuality.
Proof sketch. We collapse all universal quantifiers in ğœ‘ and
thereby reduce satisfiability of (âŠ¤, ğœ‘) to boolean satisfiability.
â–¡
We give a detailed proof in Appendix B.
Note that if we allow properties where propositional for-
mulas occur outside of the
operators, the complexity
jumps back to NEXPTIME (see Lemma B.1). It is worth to con-
trast this result with the analogous findings for simple tempo-
rally safe formulas. Lemma 4.4 shows that when adding an
operator around a propositional formula, the problem drops
from NEXPTIME (Theorem 3.12) to NP. This is in contrast
operators, which remains NEXPTIME-complete
to adding
(Lemma 3.13). Invariants with nested
and propositional
conjuncts are undecidable (Lemma 3.10), whereas eventual-
operators and propositional conjuncts
ities with nested
remain decidable (see Lemma B.1).

4.4 Eventualities with Functional Specifications
Surprisingly, the sharp contrast between
continues
if we add functional specifications as LTL trace properties.
, the resulting problem directly jumps to full analytical
For
hardness (cf. Theorem 3.11). For
, we now show that the
problem remains decidable. Our result reads as follows.

and

Theorem 4.5. The satisfiability problem is decidable for spec-
ifications (ğœ“, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒâˆ—.

âˆ—).

(

This result is interesting for two reasons. First, it outlines
. Second, it defines a
the precise difference between
new decidable class that contains many properties of interest.
In particular, formulas of the fragment can enforce infinite
models.2 For example, the specification in Example 1.1 falls
in this newly identified fragment.

and

The remainder of this subsection provides a proof for
Theorem 4.5. We introduce necessary concepts along the
way.

2Existing decidability results for HyperLTL consider fragments that, if
satisfiable, are satisfiable by a finite set of traces of bounded size. This
includes the âˆƒâˆ— âˆ€âˆ— fragment studied in [19] and the decidable fragments
identified in [32].

Deciding Hyperproperties Combined with Functional Specifications

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

4.4.1 Eliminating Nexts. We first show how to eliminate
the

operators in ğœ‘.

ğ‘Ÿ0

ğ‘Ÿ1

ğ‘Ÿ2

ğ‘Ÿ3

ğ‘Ÿ4

W

(

Lemma 4.6. Let (ğœ“, ğœ‘) be a specification where ğœ‘ is of the
form âˆ€ğ‘›âˆƒğ‘š.
âˆ—). There exists an effectively computable
specification (ğœ“ â€², ğœ‘ â€²) where ğœ‘ â€² is the of the form âˆ€ğ‘›âˆƒğ‘š.
such
that (ğœ“, ğœ‘) and (ğœ“ â€², ğœ‘ â€²) are equisatisfiable.
Proof sketch. Let ğœ‘ = âˆ€ğ‘›âˆƒğ‘š. ( ğœ™) âˆ§ ğœ™ â€². We eliminate
op-
erators in ğœ™ by letting traces range over tuples. Instead of
considering traces in Î£ğœ” , we consider traces in (Î£ğ‘˜ )ğœ” , where
ğ‘˜ is the lookahead needed to evaluate ğœ™ (which is upper
s in ğœ™). For each trace ğ‘¡ âˆˆ Î£ğœ” ,
bounded by the number of
we define ğ‘¡ â€² âˆˆ (Î£ğ‘˜ )ğœ” by ğ‘¡ â€²(ğ‘–) (cid:66) (ğ‘¡ (ğ‘–), ğ‘¡ (ğ‘– + 1), . . . , ğ‘¡ (ğ‘– + ğ‘˜)).
s.
This reduces the evaluation of ğœ™ to a formula without
We also modify the LTL formula (which is allowed to con-
tain
operators) to assert that the tuples in each tuple trace
are consistent, i.e., for each step ğ‘– if ğ‘¡ (ğ‘–) = (ğ‘™1, . . . , ğ‘™ğ‘˜ ) then
ğ‘¡ (ğ‘– + 1) = (ğ‘™2, . . . , ğ‘™ğ‘˜, ğ‘™ğ‘˜+1). A detailed proof can be found in
â–¡
Appendix B.
Using Lemma 4.6, we can assume that in Theorem 4.5, the
HyperLTL formula ğœ‘ contains a single
as the only tem-
poral operator. For now, we make two further assumptions:
First, we assume that ğœ‘ contains only a single âˆƒ quantifier,
and, second, we assume that there are no additional proposi-
tional conjuncts outside the
ğœ™ where
ğœ™ contains no temporal operators. We begin by translating
the trace property ğœ“ into a BÃ¼chi automaton.

. So let ğœ‘ = âˆ€ğœ‹âˆƒğœ‹ â€².

Definition 4.7. A state-labeled BÃ¼chi automaton over al-
phabet Î£ is a tuple A = (ğ‘„, ğ‘„0, ğ›¿, ğ¹, ğ¿), where ğ‘„ is a fi-
nite set of states, ğ‘„0 âŠ† ğ‘„ the initial states, ğ›¿ âŠ† ğ‘„ Ã— ğ‘„ the
transition relation, ğ¹ âŠ† ğ‘„ the set of accepting states, and
ğ¿ : ğ‘„ â†’ Î£ a state labeling function. An accepting run ğ‘Ÿ of
A is an infinite sequence ğ‘Ÿ âˆˆ ğ‘„ğœ” such that 1) ğ‘Ÿ (0) âˆˆ ğ‘„0,
2) (ğ‘Ÿ (ğ‘–), ğ‘Ÿ (ğ‘– + 1)) âˆˆ ğ›¿ for every ğ‘–, and 3) ğ‘Ÿ (ğ‘–) âˆˆ ğ¹ for in-
finitely many ğ‘–. The trace ğ¿(ğ‘Ÿ ) âˆˆ Î£ğœ” associated to a run is
defined by ğ¿(ğ‘Ÿ )(ğ‘–) (cid:66) ğ¿(ğ‘Ÿ (ğ‘–)). For a set ğ‘‹ âŠ† ğ‘„, we define
Step A (ğ‘‹ ) (cid:66) {ğ‘ âˆˆ ğ‘„ | âˆƒğ‘â€² âˆˆ ğ‘‹ . (ğ‘â€², ğ‘) âˆˆ ğ›¿ } as all states
reachable in one step from ğ‘‹ and ReachA (ğ‘›) as all states
reachable in ğ‘› steps from a state in ğ‘„0.

Note that we use state-labeled automata (as opposed to
transition-labeled automata) to simplify our construction.
Let Ağœ“ = (ğ‘„ğœ“ , ğ‘„0,ğœ“ , ğ›¿ğœ“ , ğ¹ğœ“ , ğ¿ğœ“ ) be a (state-labeled) BÃ¼chi
automaton over 2AP accepting ğœ“ [41]. A state ğ‘ âˆˆ ğ‘„ğœ“ is non-
empty if there exists an accepting infinite run starting in ğ‘.
W.l.o.g., we assume that Ağœ“ only includes non-empty states,
as we can remove all empty states without changing the
language of Ağœ“ . Detecting if a state is non-empty can be
done easily using, e.g., nested depth-first search.

4.4.2 Models for âˆ€âˆƒ. Intuitively, our decidability result
can be derived as follows. Assume we had a model ğ‘‡ of (ğœ“, ğœ‘).
Let ğ‘… âŠ† ğ‘„ğœ”
be a set of accepting runs of Ağœ“ associated to ğ‘‡ ,
ğœ“
i.e., ğ‘‡ = {ğ¿ğœ“ (ğ‘Ÿ ) | ğ‘Ÿ âˆˆ ğ‘…}. As we consider a âˆ€âˆƒ formula, we

W

F

B

B

W

F

F

W

B

Â· Â· Â·

Figure 1. Model for âˆ€ğœ‹ . âˆƒğœ‹ â€².
indicate the witness points for the

operator.

ğœ™ formulas. Dashed boxes

can arrange the runs in ğ‘… as a sequence: we choose ğ‘Ÿ0, ğ‘Ÿ1, . . . âˆˆ
ğ‘… (not necessarily distinct) such that, for each ğ‘–, ğ‘Ÿğ‘–+1 serves
ğœ™.
as a witness for ğ‘Ÿğ‘– , i.e., [ğœ‹ â†¦â†’ ğ¿ğœ“ (ğ‘Ÿğ‘– ), ğœ‹ â€² â†¦â†’ ğ¿ğœ“ (ğ‘Ÿğ‘–+1)] |=
We say ğ‘›0, ğ‘›1, . . . are witness points if [ğœ‹ â†¦â†’ ğ¿ğœ“ (ğ‘Ÿğ‘– ), ğœ‹ â€² â†¦â†’
ğ¿ğœ“ (ğ‘Ÿğ‘–+1)] [ğ‘›ğ‘–, âˆ] |= ğœ™ for every ğ‘–, i.e., the ğ‘›ğ‘– point to a step
at which the eventuality holds. The trace arrangement is
depicted in Figure 1 (ignoring the blue smaller nodes and
gray edges for now). For each ğ‘–, the dashed box denotes the
witness point ğ‘›ğ‘– where ğ‘Ÿğ‘– and ğ‘Ÿğ‘–+1 satisfy ğœ™.

As an intermediate step, we describe an infinite-state
BÃ¼chi system (a BÃ¼chi automaton without labels) that guesses
such a â€œlinearâ€ model of (ğœ“, ğœ‘). The states of the system are
triples (ğ‘, ğ‘, ğ‘›), where ğ‘ âˆˆ ğ‘„ğœ“ is a state in Ağœ“ , ğ‘ âˆˆ {â‡›, â‡š}
gives a running direction, and ğ‘› âˆˆ N. Each state (ğ‘, ğ‘, ğ‘›) ad-
ditionally satisfies ğ‘ âˆˆ ReachAğœ“ (ğ‘›). The initial states of the
system are all states (ğ‘0, â‡›, 0) with ğ‘0 âˆˆ ğ‘„0,ğœ“ . In each step,
the system has three options: it can either run forwards,
run backwards, or claim to have found a witness. In a for-
ward step (F-step), the automaton moves from (ğ‘, â‡›, ğ‘›) to
(ğ‘â€², â‡›, ğ‘› + 1), where (ğ‘, ğ‘â€²) âˆˆ ğ›¿ğœ“ . Similarly, in a backwards
step (B-step), it runs from (ğ‘, â‡š, ğ‘› + 1) to (ğ‘â€², â‡š, ğ‘›), where
(ğ‘â€², ğ‘) âˆˆ ğ›¿ğœ“ . Note that in the backwards step, we always
ensure that ğ‘â€² âˆˆ ReachAğœ“ (ğ‘›). Lastly, the system can claim
to have found a witness (W-step): if in state (ğ‘, ğ‘, ğ‘›), it can
select any ğ‘â€² âˆˆ ReachAğœ“ (ğ‘›) such that ğ¿ğœ“ (ğ‘) Ã— ğ¿ğœ“ (ğ‘â€²) |= ğœ™.
Afterwards, the system continues in state (ğ‘â€², ğ‘ â€², ğ‘›), where
ğ‘ â€² âˆˆ {â‡›, â‡š} is chosen nondeterministically. Call the result-
ing system S. We claim the following.

Lemma 4.8. S has an infinite run that uses W-steps infinitely
often if and only if (ğœ“, ğœ‘) is satisfiable.
Proof. We sketch both directions. For the â€œifâ€ direction, as-
sume there is a model for (ğœ“, ğœ‘). We can arrange a subset of
this model as depicted in Figure 1. Let ğ‘Ÿ0, ğ‘Ÿ1, . . . , with ğ‘Ÿğ‘– âˆˆ ğ‘„ğœ”
ğœ“
be the sequence of accepting runs in Ağœ“ and ğ‘›ğ‘– the witness
points. Traversing the graph as shown by the small blue
states in Figure 1 creates a run of S. We start in (ğ‘Ÿ0(0), â‡›, 0)
and move forward (using F-steps) until the counter reaches
ğ‘›0. At this point, we take the W-step from (ğ‘Ÿ0(ğ‘›0), â‡›, ğ‘›0) to

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

Beutner et al.

(ğ‘Ÿ1(ğ‘›0), ğ‘, ğ‘›0) and run towards counter value ğ‘›1. If ğ‘›1 < ğ‘›0,
we set the running direction ğ‘ to â‡š and otherwise to â‡›.
We continue this procedure to construct an infinite run. For
the example situation depicted in Figure 1, the resulting run
would start with:

(ğ‘Ÿ0(0), â‡›, 0)

F
âˆ’â†’ (ğ‘Ÿ0(1), â‡›, 1)

W
âˆ’âˆ’â†’ (ğ‘Ÿ1(1), â‡›, 1)

F
âˆ’â†’ (ğ‘Ÿ1(2), â‡›, 2)

W
âˆ’âˆ’â†’ (ğ‘Ÿ2(3), â‡š, 3)

F
âˆ’â†’ (ğ‘Ÿ1(3), â‡›, 3)
The resulting sequence is a run of S and uses W-steps infin-
itely many times.

B
âˆ’â†’ (ğ‘Ÿ2(2), â‡š, 2)

W
âˆ’âˆ’â†’ Â· Â· Â·

For the â€œonly ifâ€ direction, assume an infinite run ğ‘Ÿ =
(ğ‘0, ğ‘0, ğ‘š0) â†’ (ğ‘1, ğ‘1, ğ‘š1) â†’ Â· Â· Â· of S. We split ğ‘Ÿ into infin-
itely many finite segments ğ‘¥0, ğ‘¥1, . . . , by splitting each time ğ‘Ÿ
takes a W-step. In the example run above we would get ğ‘¥0 =
(ğ‘Ÿ0(0), 0)(ğ‘Ÿ0(1), 1), ğ‘¥1 = (ğ‘Ÿ1(1), 1)(ğ‘Ÿ1(2), 2)(ğ‘Ÿ1(3), 3), . . .. In
ğ‘– ) . . . (ğ‘ğ‘˜ğ‘–
, ğ‘›ğ‘˜ğ‘–
general, let ğ‘¥ğ‘– be the sequence (ğ‘0
ğ‘– , ğ‘›0
ğ‘– ). From ğ‘¥ğ‘– ,
of Ağœ“ starting in a state
we construct a finite run ğ‘Ÿğ‘– âˆˆ ğ‘„ âˆ—
ğœ“
ğ‘– ) = ğ‘ ğ‘—
in ğ‘„0,ğœ“ such that for every 0 â‰¤ ğ‘— â‰¤ ğ‘˜ğ‘– , ğ‘Ÿğ‘– (ğ‘› ğ‘—
ğ‘– . Using
the fact that for each (ğ‘, ğ‘, ğ‘›) in S, we have ğ‘ âˆˆ ReachAğœ‹ (ğ‘›),
this is always possible. It is crucial that we cannot reverse
directions between two W-steps. The finite ğ‘Ÿğ‘– ends in a
state in Ağœ“ , so by the assumption that all states are non-
empty, we can extend it into an infinite accepting run. The
â–¡
set {ğ¿ğœ“ (ğ‘Ÿ0), ğ¿ğœ“ (ğ‘Ÿ1), . . .} is a model of (ğœ“, ğœ‘).

ğ‘–

4.4.3 From Infinite State to Pushdown. The construc-
tion of S requires infinitely many states as we need to carry
the natural number ğ‘› to ensure valid B and W steps (which
need access to ReachAğœ“ (ğ‘›)). We show next that we can re-
place this infinite state space by a finite pushdown system.

Definition 4.9. A BÃ¼chi pushdown system is a tuple P =
(ğ‘„, Î“, ğ‘„0, ğ›¾0, ğ›¿, ğ¹ ), where ğ‘„ is a finite set of states, Î“ the finite
stack alphabet, ğ‘„0 âŠ† ğ‘„ initial states, ğ›¾0 âˆˆ Î“ the initial stack
symbol, ğ›¿ âŠ† (ğ‘„ Ã— Î“+) Ã— (ğ‘„ Ã— Î“âˆ—) a finite transition relation,
and ğ¹ âŠ† ğ‘„ a set of accepting states. The system operates on
configuration âŸ¨ğ‘, ğ›¼âŸ©, where ğ‘ âˆˆ ğ‘„ and ğ›¼ âˆˆ Î“âˆ—. A transition
âŸ¨ğ‘, ğ›¼âŸ© â‡ âŸ¨ğ‘â€², ğ›¼ â€²âŸ© âˆˆ ğ›¿ describes that the system, if in state ğ‘
and ğ›¼ âˆˆ Î“+ is a prefix of the current stack, pops ğ›¼, pushes
ğ›¼ â€² âˆˆ Î“âˆ— to the stack and moves to state ğ‘â€². An accepting
run is an infinite sequence of configurations that starts in
âŸ¨ğ‘0, [ğ›¾0]âŸ© for some ğ‘0 âˆˆ ğ‘„0, respects ğ›¿, and visits states in ğ¹
infinitely many times. It is decidable in polynomial time if a
BÃ¼chi pushdown system has an accepting run [10].

We replace S with a pushdown system P. Conceptually,
we represent a state (ğ‘, ğ‘, ğ‘›) in S by the pushdown configu-
ration with state (ğ‘, ğ‘) and stack content [ReachAğœ“ (ğ‘›), . . . ,
ReachAğœ“ (0)], i.e., the length of the stack is ğ‘› + 1 and the
ğ‘–th element are all states reachable in ğ‘– steps. The states
in the pushdown system thus have the form (ğ‘, ğ‘) with
ğ‘ âˆˆ ğ‘„ğœ“ , ğ‘ âˆˆ {â‡›, â‡š} and the stack alphabet is 2ğ‘„ğœ“ . The
initial stack symbol is ğ›¾0 (cid:66) ğ‘„0,ğœ“ and the initial states are
{(ğ‘0, â‡›) | ğ‘0 âˆˆ ğ‘„0,ğœ“ }. The transitions are of the following
form:

(F)

(ğ‘, ğ‘â€²) âˆˆ ğ›¿ğœ“
(cid:10)(ğ‘, â‡›), [ğ´](cid:11) â‡ (cid:10)(ğ‘â€², â‡›), [Step Ağœ“ (ğ´), ğ´](cid:11)

(B)

ğ‘â€² âˆˆ ğ´2

(ğ‘â€², ğ‘) âˆˆ ğ›¿ğœ“

(cid:10)(ğ‘, â‡š), [ğ´1, ğ´2](cid:11) â‡ (cid:10)(ğ‘â€², â‡š), [ğ´2](cid:11)

ğ‘â€² âˆˆ ğ´

(W)

ğ¿ğœ“ (ğ‘) Ã— ğ¿ğœ“ (ğ‘â€²) |= ğœ™
(cid:10)(ğ‘, ğ‘), [ğ´](cid:11) â‡ (cid:10)(ğ‘â€², ğ‘ â€²), [ğ´](cid:11)

ğ‘, ğ‘ â€² âˆˆ {â‡›, â‡š}

Note the close correspondence with the transitions in S. In
particular, in F-steps, we compute ReachAğœ“ (ğ‘› + 1) based on
ReachAğœ“ (ğ‘›). In B-steps, the stack provides access to all states
that are reachable, and thus guarantees the invariant that
ğ‘ âˆˆ ReachAğœ“ (ğ‘›) for each state (ğ‘, ğ‘, ğ‘›) in S. It is not hard to
see that P has a run that uses W-steps infinitely often iff S
has a run that uses W-steps infinitely often. Combined with
Lemma 4.8 we thus get:

Lemma 4.10. P has an accepting run that uses W-steps in-
finitely often if and only if (ğœ“, ğœ‘) is satisfiable.

Lastly, we can easily translate a BÃ¼chi pushdown system
with transition-based acceptance (as in P) to state-based
acceptance (as in Definition 4.9). Using the decidability of
pushdown systems [10], we thus get that the satisfiability of
(ğœ“, ğœ‘) is decidable. Note that our proof gives an elementary
upper bound of 2EXPTIME (for âˆ€âˆƒ properties).3

4.4.4 Propositional Conjuncts and âˆ€âˆƒâˆ—. We can now
lift the two assumptions we made earlier. As a first extension,
we modify our construction to also support formulas of the
form âˆ€ğœ‹âˆƒğœ‹ â€².( ğœ™) âˆ§ ğœ™ â€². To do so, we keep track of the first
state of the run we are currently considering. In a W-step,
we then only select a witness state ğ‘â€² that stems from an
initial state which satisfies the propositional requirement
ğœ™ â€² when combined with the initial state of the current run.
We can access the set of all such states by keeping track of
the set of states reachable from every individual state (by
changing the stack alphabet to functions ğ‘„ğœ“ â†’ 2ğ‘„ğœ“ ).

As a second extension, we can show decidability for a âˆ€âˆƒğ‘š
prefix by moving to alternating BÃ¼chi pushdown systems
(defined as expected, see [10] for details). For âˆ€âˆƒğ‘š, we can
no longer arrange the traces of a model in a linear sequence
(as depicted in Figure 1) and instead use ğ‘š-ary trees labeled
by traces such that the children of a node correspond to
witness traces of that trace. In a W-step from a state (ğ‘, ğ‘),
we now select ğ‘š states ğ‘1, . . . , ğ‘ğ‘š (whereas we previously
picked only ğ‘â€²) such that ğ‘ together with ğ‘1, . . . , ğ‘ğ‘š satisfy
ğœ™. Afterwards, we need to find a new witnesses for each
of the ğ‘ğ‘– . We accomplish this by introducing a universal
transition that branches into states (ğ‘ğ‘–, ğ‘ğ‘– ) for each 1 â‰¤ ğ‘– â‰¤
ğ‘š (leaving the stack unchanged as before). The F and B
3The size of ğ‘„ğœ“ is at most exponential in ğœ“ [41], so the size of the stack
alphabet of P (which is 2ğ‘„ğœ“ ) is at most double exponential in ğœ“ . As deciding
the emptiness of a BÃ¼chi pushdown system is polynomial, the 2EXPTIME
upper bound follows.

Deciding Hyperproperties Combined with Functional Specifications

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

step stay purely nondeterministic. The resulting alternating
pushdown system has an accepting run (which now has
the form of a tree) iff (ğœ“, ğœ‘) is satisfiable. As emptiness of
alternating pushdown systems is still decidable (albeit only
in exponential time) [10], we get a proof of Theorem 4.5 for
the full âˆ€âˆƒâˆ—-fragment. For the âˆ€âˆƒâˆ—-fragment, our proof gives
an elementary upper bound of 3EXPTIME.

4.5 Conjunctions of Eventualities
We show that Theorem 4.5 is tight in the sense that already
a conjunction of eventualities combined with an arbitrary
trace property is undecidable (and even Î£1

1-hard).

(cid:26)

1-hard for spec-

Theorem 4.11. The satisfiability problem is Î£1
ifications (ğœ“, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒâˆ—. âˆ§ âˆ§ .
Proof. We encode the problem of whether a nondeterministic
2CM with instructions ğ‘™1, . . . , ğ‘™ğ‘› has a recurring computation
[3, 23]. Let AP = (cid:208)ğ‘¥ âˆˆ {1,2,ğ‘¡ }{
ğ‘¥, â– ğ‘¥, isZeroğ‘¥ } âˆª {l1, . . . , lğ‘› }.
(cid:26)
Each trace encodes a configuration of the machine as follows.
The current value of counter ğ‘¥ âˆˆ {1, 2} is encoded as a
ğ‘¥ }{â– ğ‘¥ }âˆ…ğœ” such that the (unique) step at which
trace in âˆ…âˆ—{
ğ‘¥ holds indicates the current value of ğ‘ğ‘¥ . We later use
(cid:26)
proposition â– ğ‘¥ (which always holds the step after
ğ‘¥ ) to
encode the update of the counter. The proposition isZeroğ‘¥
holds exactly if the counter is zero. The current instruction
is encoded by propositions {l1, . . . , lğ‘› }, of which exactly one
holds globally along a trace. Finally, to ensure a recurring
computation, we use a third counter ğ‘¡, which is encoded
analogously to the counters above and counts down the
steps to the next visit to ğ‘™1. It is easy to see that we can
encode the validity of a configuration in an LTL formula ğœ“ .
For ğ‘¥ âˆˆ {1, 2, ğ‘¡ } we ensure a valid counter via

(cid:26)

(Â¬

ğ‘¥ âˆ§Â¬â– ğ‘¥ ) U (cid:0)(

(cid:26)

ğ‘¥ âˆ§ Â¬â– ğ‘¥ )
(cid:26)
âˆ§ (â– ğ‘¥ âˆ§ Â¬

ğ‘¥ âˆ§Â¬â– ğ‘¥ )(cid:1)

(cid:0)

(cid:26)

(cid:26)

(cid:26)

ğ‘¥ ) âˆ§

(Â¬
and ensure correct placement of isZeroğ‘¥ by (
isZeroğ‘¥ ) âˆ¨
( Â¬isZeroğ‘¥ ) together with isZeroğ‘¥ â†”
ğ‘¥ . Finally, we as-
sert that the propositions {l1, . . . , lğ‘› } are set correctly via
lğ‘– âˆ§ (cid:211)ğ‘—â‰ ğ‘– Â¬lğ‘— (cid:1). In the hyperproperty, we encode that
(cid:212)ğ‘–
there exists a trace representing the initial configuration as
follows (note that we allow counter ğ‘¡ to have any value):
ğœ‘init (cid:66) âˆƒğœ‹ .(l1)ğœ‹ âˆ§ (isZero1)ğœ‹ âˆ§ (isZero2)ğœ‹
Lastly, we express that each trace has a successor. For each
instruction ğ‘™ğ‘– , we write ğ‘ (ğ‘™ğ‘– ) âˆˆ {1, 2} for the counter that
is changed or tested in instruction ğ‘™ğ‘– . We define 1 (cid:66) 2 and
2 (cid:66) 1 for the other counter. We then define

ğœ‘ (cid:66) âˆ€ğœ‹âˆƒğœ‹ â€².

(cid:104) (cid:220)

(lğ‘– )ğœ‹ âˆ§ exec(ğ‘™ğ‘– )

(cid:105)

âˆ§

ğ‘– âˆˆ {1,...,ğ‘› }

(cid:104) (cid:220)

(lğ‘– )ğœ‹ âˆ§ (

(cid:26)

ğ‘– âˆˆ {1,...,ğ‘› }
(cid:0)(isZeroğ‘¡ )ğœ‹ âˆ§ (l1)ğœ‹ (cid:1) âˆ¨ (cid:0)(

(cid:104)

ğ‘ (ğ‘™ğ‘– ) )ğœ‹ âˆ§ (

ğ‘ (ğ‘™ğ‘– ) )ğœ‹ â€²

(cid:105)

âˆ§

(cid:26)
ğ‘¡ )ğœ‹ âˆ§ (â– ğ‘¡ )ğœ‹ â€² (cid:1) (cid:105)
(cid:26)

.

Here, exec(ğ‘™ğ‘– ) denotes that the action or test of instruction
ğ‘™ğ‘– is performed on ğ‘ (ğ‘™ğ‘– ). For example, if ğ‘™ğ‘– = (cid:2)ğ‘ğ‘¥ (cid:66) ğ‘ğ‘¥ +
1; goto{ğ‘™ ğ‘—, ğ‘™ğ‘˜ }(cid:3), we define exec(ğ‘™ğ‘– ) as

(cid:0)(lğ‘— )ğœ‹ â€² âˆ¨ (lğ‘˜ )ğœ‹ â€² (cid:1) âˆ§ (â– ğ‘¥ )ğœ‹ âˆ§ (

ğ‘¥ )ğœ‹ â€².

(cid:26)
Note that (â– ğ‘¥ )ğœ‹ âˆ§ (
ğ‘¥ )ğœ‹ â€² encodes that the counter ğ‘¥ is in-
creased. For a decrement operation, we can replace this with
ğ‘¥ )ğœ‹ . If ğ‘™ğ‘– = (cid:2)if ğ‘ğ‘¥ = 0 then goto ğ‘™ ğ‘— else
(â– ğ‘¥ )ğœ‹ â€² âˆ§ (
goto ğ‘™ğ‘˜ (cid:3), we define exec(ğ‘™ğ‘– ) as

(cid:26)

(cid:26)

ğ‘¥ )ğœ‹ â€² âˆ§ (cid:0)(isZeroğ‘¥ )ğœ‹ â†’ (lğ‘— )ğœ‹ â€² (cid:1)

ğ‘¥ )ğœ‹ âˆ§ (

(
(cid:26)
âˆ§ (cid:0)Â¬(isZeroğ‘¥ )ğœ‹ â†’ (lğ‘˜ )ğœ‹ â€² (cid:1).

(cid:26)

In ğœ‘, the first conjunct thus encodes that the counter ğ‘ (ğ‘™ğ‘– ) is
updated and/or tested as required by ğ‘™ğ‘– . The second conjunct
states that the counter that is not involved in ğ‘™ğ‘– is left un-
changed. As the current instruction is set consistently along
a trace, both eventualities refer to the same instruction. Fi-
nally, the third conjunct ensures that the counter ğ‘¡ either
decreases or is already zero, at which point the current in-
struction is ğ‘™1. In case the ğ‘¡-counter is zero, it can be reset
to any value on ğœ‹ â€². This ensures a recurring computation of
the machine. It is easy to see that (ğœ“, ğœ‘init âˆ§ ğœ‘) is satisfiable
iff the 2CM has a recurring computation (note that ğœ‘init âˆ§ ğœ‘
is a âˆ€âˆƒ2-formula).
â–¡

While Theorem 4.11 requires three conjunctions of eventu-
alities to show Î£1
1-hardness, already two eventualities suffice
to show undecidability. To do so, we can encode the non-
termination of a 2CM (avoiding the ğ‘¡ counter). This further
underlines the tightness of Theorem 4.5.

Lemma 4.12. The satisfiability problem is undecidable for
specifications (ğœ“, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒâˆ—. âˆ§ .

Example 4.13. Using similar ideas as in Theorem 4.11, we
can encode that a one-counter machine has an infinite com-
putation with only a single eventuality (as we only need
to ensure that the single counter is updated consistently).
Combined with Theorem 4.5, we derive that we can decide
the existence of an infinite computation in a one-counter
machine. While this is long known (see, e.g., [28]), it never-
theless emphasizes that our newly identified decidable class
â—
is broader than it seems at first glance.

4.6 Deterministic Liveness
Livness for trace properties (cf. Definition 2.1) and hyper-
liveness (cf. Definition 2.3) already imply that a property is
satisfiable. As demonstrated by Theorem 4.2, the same does
not hold for temporal liveness hyperproperties. We can, how-
ever, identify a fragment within temporal liveness for which
the intuition that liveness implies satisfiability transfers to
the realm of hyperproperties. We say an LTL property ğœ™ is a
deterministic liveness property if it is a liveness property and
can be recognized by a deterministic BÃ¼chi automaton.

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

Beutner et al.

Proposition 4.14. HyperLTL formulas of the form ğœ‘ = âˆ€âˆƒâˆ—. ğœ™
where ğœ™ is a deterministic liveness property are always satisfi-
able and have a finite model.
Proof sketch. In a deterministic automaton describing a live-
ness property, any reachable state has a path to an accepting
state. We use this to iteratively construct a model. The full
â–¡
proof can be found in Appendix B.
Note that the same does not hold if we consider more
than one universal quantifier. As an example, the formula
(ğ‘ğœ‹ âˆ§ Â¬ğ‘ğœ‹ â€²) is a
âˆ€ğœ‹âˆ€ğœ‹ â€².
deterministic liveness property. If we consider determinis-
tic liveness in combination with trace properties, we again
obtain a jump to Î£1

(ğ‘ğœ‹ âˆ§ Â¬ğ‘ğœ‹ â€²) is unsatisfiable but

1-hardness.

Corollary 4.15. Satisfiability is Î£1
1-hard for specifications
of the form (ğœ“, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒâˆ—. ğœ™ and ğœ™ is a
deterministic liveness property.
Proof. Follows directly from Theorem 4.11 as conjunctions
â–¡
of eventualities are deterministic liveness.

4.7 Overview: Liveness vs Safety
Our results provide a clear picture of the (un)decidability
boundaries within fragments of HyperLTL. In particular, our
systematic study allows a direct comparison between tempo-
ral safety and temporal liveness. For the full fragment, tempo-
ral liveness already subsumes satisfiability of full HyperLTL,
which contrasts strongly with the much cheaper (albeit still
undecidable) problem for temporal safety. This changes if
we consider simpler fragments. Here, the
fragment is
drastically better behaved in terms of complexity and even
admits large decidable fragments for cases where the safety
counterpart already exhibits full analytical hardness.

5 Finding Largest Models
To complement the decidability results from the previous
sections, we propose a new (incomplete) algorithm to detect
(un)satisfiability of âˆ€âˆƒâˆ— HyperLTL formulas. So far, the only
available algorithm checks for finite models of bounded size
and then iteratively increases the bound [20, 32]. Such an
approach finds smallest models and cannot determine un-
satisfiability. The key insight for our algorithm is that âˆ€âˆƒâˆ—
formulas are closed under union, therefore, a formula ğœ‘ is
satisfiable iff there is a (unique) largest model satisfying ğœ‘.
To find such models algorithmically, we iteratively eliminate
choices for the âˆƒâˆ— quantifiers that admit no witness trace
when chosen for the âˆ€ quantifier. Thereby, we do not only
find largest models but can also detect unsatisfiability. Our
incremental elimination is closely related to a recent algo-
rithm used in the context of finite-trace properties (which
was developed independently) [9].

For presentation reasons, we present the algorithm for âˆ€âˆƒ
formulas. Our implementation (see Section 6) supports full
âˆ€âˆƒâˆ— properties.

Algorithm 1 Algorithm that searches for the largest model
of a âˆ€âˆƒ property. Initially, A is a BÃ¼chi automaton that ac-
cepts the body the HyperLTL property.

1: procedure findModel(A)
if L (A âˆ€) = âˆ… then
2:
return UNSAT;
3:

4:
5:

6:
7:

if L (A âˆƒ) âŠ† L (A âˆ€) then

return SAT, model: L (A âˆ€);
Anew (cid:66) A âˆ© A âˆ€
ğœ‹ â€²;
findModel(Anew);

5.1 Algorithm
For a BÃ¼chi automaton A over APğœ‹ âˆª APğœ‹ â€², we define A âˆ€
and A âˆƒ as the automata (over AP) that (existentially) project
A on the alphabet APğœ‹ and APğœ‹ â€², respectively. Now let a
HyperLTL formula ğœ‘ = âˆ€ğœ‹âˆƒğœ‹ â€². ğœ™ be given and let Ağœ™ be
an automaton over APğœ‹ âˆª APğœ‹ â€² accepting ğœ™. In particular,
accepts all words for which there exists a witness trace
A âˆ€
ğœ™
for the existential quantifier. Our algorithm is depicted in
Algorithm 1. Initially, we call findModel(Ağœ™ ).

The first candidate is A = Ağœ™ . If L (A âˆ€) = âˆ…, i.e., no trace
has a witness trace in A, ğœ‘ is unsatisfiable. If all potential
witness traces in L (A âˆƒ) are contained in L (A âˆ€) (so they
have a witness trace themself), ğœ‘ is satisfiable and L (A âˆ€)
is a model. If neither is the case, we refine A by removing
all traces whose âˆƒ component is not in L (A âˆ€). We define
Anew as the intersection A âˆ© A âˆ€
ğœ‹ â€² is A âˆ€ with
the alphabet changed from AP to APğœ‹ â€². We can compute
Anew via a standard intersection construction on BÃ¼chi au-
tomata. Note that Anew might again contain witness traces
that themselves have no witness trace, so we recurse.

ğœ‹ â€² where A âˆ€

5.2 Correctness
The algorithm maintains the following invariants.

Lemma 5.1. In every iteration of the algorithm it holds that
L (Anew) âŠ† L (A), and for any trace setğ‘‡ withğ‘‡ |= âˆ€ğœ‹âˆƒğœ‹ â€². ğœ™,
ğ‘‡ âŠ† L (A âˆ€).

Using Lemma 5.1 it is easy to see the following.

Proposition 5.2. Given a formula ğœ‘ = âˆ€ğœ‹âˆƒğœ‹ â€². ğœ™, if Algo-
rithm 1 terminates with UNSAT, the formula is unsatisfiable.
If it terminates with SAT and model L (A âˆ€), then L (A âˆ€) is
the unique largest model of ğœ‘.

To generalize to âˆ€âˆƒâˆ—, we intersect the universal projection
with each of the projections on existentially quantified posi-
tions. Models for âˆ€âˆ—âˆƒâˆ—-properties are, in general, not closed
under union, so our algorithm does not extend beyond âˆ€âˆƒâˆ—.

6 Implementation and Experiments
We have implemented the algorithm described in Section 5
in a tool called LMHyper (short for Largest Model of Hy-
perLTL). LMHyper reads both a âˆ€âˆƒâˆ— HyperLTL formula ğœ‘ and

Deciding Hyperproperties Combined with Functional Specifications

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

Table 2. Comparison of LMHyper and MGHyper on 100 ran-
dom formulas generated with randltl [17]. Size refers to
the size of the AST, ğ‘ is the percentage of solved formulas,
ğ‘¡ the average time spent on solved cases in milliseconds,
and #Iter is the average number of iterations (number of
recursive calls) used by LMHyper. The timeout is set to 5sec.

Size

15
16
17
18
19
20

MGHyper
ğ‘¡
ğ‘

95% 40
93% 39
95% 39
92% 38
95% 40
97% 42

LMHyper
ğ‘¡

#Iter

ğ‘

100% 235
99% 239
100% 221
100% 201
100% 180
100% 215

0.38
0.44
0.43
0.39
0.43
0.27

Table 3. Comparison of LMHyper and MGHyper on hand-
crafted specifications. We give the result (âœ“ if the speci-
fication is satisfiable and âœ— if it is unsatisfiable), the time in
ms, and the number of iterations needed by LMHyper. The
timeout is set to 5min.

Problem

Inf
Example 1.1
Enforce-2
Enforce-3
Enforce-5
Unsat-3
Unsat-5
Unsat-9

MGHyper
Res
ğ‘¡

LMHyper

Res

ğ‘¡

#Iter

TO
-
-
TO
âœ“ 444
TO
-
TO
-
TO
-
TO
-
TO
-

âœ“
âœ“
âœ“
âœ“
âœ“
âœ—
âœ—
âœ—

350
232
262
334
491
777
1363
1681

1
1
0
0
0
3
5
9

LTL formula ğœ“ and searches for an (un)satisfiability proof
for (ğœ“, ğœ‘). Internally, we represent the current candidate as a
generalized BÃ¼chi automaton and use spot [17] to perform
automata operations. The only other available tool for âˆ€âˆƒâˆ—
HyperLTL satisfiability is MGHyper [20], which implements
the incremental approach to find models of bounded size.

6.1 Random Benchmarks
We compare LMHyper against MGHyper on random formulas
where we sample the LTL body of a formula using randltl
[17]. The results are given in Table 2. On our benchmarks,
LMHyper usually takes longer than MGHyper but can handle
a larger percentage of formulas. We observe that randomly
generated HyperLTL formulas are, in most cases, satisfiable
by a model with a single trace, as the atomic propositions
are seldom shared between different trace variables. This
explains the high success rate of MGHyper (see [20]) even
though MGHyper cannot prove unsatisfiability.

6.2 Infinite and Large Models
We compiled a small number of more interesting proper-
ties that do not have single-trace models. Our results are
depicted in Table 3. The Inf specification expresses that a
model has infinitely many traces. Example 1.1 is the exam-
ple from the introduction. The Enforce-ğ‘› specification en-
forces a model that has at least ğ‘› traces. It is defined as
âˆ€ğœ‹âˆƒğœ‹1 . . . ğœ‹ğ‘›. (cid:211)ğ‘–â‰ ğ‘—
(ğ‘ğœ‹ğ‘– â†® ğ‘ğœ‹ ğ‘— ). The Unsat-ğ‘› specifica-
tions are unsatisfiable. Their definition is a trace property
Â¬ğ‘) âˆ§ ğ‘› Â¬ğ‘ combined with the
ğœ“ (cid:66) (Â¬ğ‘) U (ğ‘ âˆ§
hyperproperty ğœ‘ (cid:66) âˆ€ğœ‹âˆƒğœ‹ â€².
(ğ‘ğœ‹ âˆ§ ğ‘ğœ‹ â€²). The formula is
designed such that Algorithm 1 requires ğ‘› iterations to dis-
cover unsatisfiability. MGHyper times out for most of the ex-
amples; even on simple properties like Enforce-3. In contrast,
LMHyper can verify properties enforcing many traces in a sin-
gle iteration because the number of iterations is independent
of the number of traces in a model. As expected, Unsat-ğ‘›
is unsatisfiable and LMHyper requires multiple iterations to
show this.

7 Conclusion
We have studied the satisfiability problem for âˆ€âˆ—âˆƒâˆ— Hyper-
LTL formulas in combination with LTL formulas describ-
ing functional behavior. To obtain results below the gen-
eral Î£1
1 complexity of HyperLTL, we have focused on sim-
pler hyperproperties belonging to the classes of temporal
safety and temporal liveness as well as fragments thereof.
We have shown that temporal safety is an expressive class
that is very well suited for satisfiability studies and enjoys
coRE-completeness. In combination with general LTL prop-
erties, already very simple formulas like invariants cause
Î£1
1-completeness. The temporal liveness class, on the other
hand, is Î£1
1-complete in general but contains non-trivial frag-
ments that are decidable, even in combination with arbitrary
LTL formulas.

We have shown that functional specifications given in
LTL play a significant role in the undecidability of general
hyperproperties. The main open question for future work is
whether further decidable fragments can be found by restrict-
ing the operator structure of the functional specification.

Acknowledgments
All authors are partially supported by the German Research
Foundation (DFG) in project 389792660, TRR 248 (Center for
Perspicuous Systems). M. KrÃ¶tzsch is additionally supported
by the Bundesministerium fÃ¼r Bildung und Forschung (BMBF)
in project ScaDS.AI (Center for Scalable Data Analytics and
Artificial Intelligence), and by the Center for Advancing Elec-
tronics Dresden (cfaed). R. Beutner, B. Finkbeiner and J. Hof-
mann are additionally supported by the European Research
Council (ERC) in project OSARES (No. 68330). R. Beutner
and J. Hofmann carried out this work as members of the
SaarbrÃ¼cken Graduate School of Computer Science.

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

Beutner et al.

References
[1] Erika ÃbrahÃ¡m, Ezio Bartocci, Borzoo Bonakdarpour, and Oyendrila
Dobe. 2020. Probabilistic Hyperproperties with Nondeterminism. In
International Symposium on Automated Technology for Verification and
Analysis, ATVA 2020 (Lecture Notes in Computer Science, Vol. 12302).
Springer. https://doi.org/10.1007/978-3-030-59152-6_29

[2] Bowen Alpern and Fred B. Schneider. 1985. Defining Liveness. Inf.
Process. Lett. 21, 4 (1985). https://doi.org/10.1016/0020-0190(85)90056-0
[3] Rajeev Alur and Thomas A. Henzinger. 1994. A Really Temporal Logic.

J. ACM 41, 1 (1994). https://doi.org/10.1145/174644.174651

[4] Ezio Bartocci, Thomas FerrÃ¨re, Thomas A. Henzinger, Dejan Nickovic,
and Ana Oliveira da Costa. 2022. Flavors of Sequential Information
Flow. In International Conference on Verification, Model Checking, and
Abstract Interpretation, VMCAI 2022 (Lecture Notes in Computer Science,
Vol. 13182). Springer. https://doi.org/10.1007/978-3-030-94583-1_1
[5] Jan Baumeister, Norine Coenen, Borzoo Bonakdarpour, Bernd
Finkbeiner, and CÃ©sar SÃ¡nchez. 2021. A Temporal Logic for Asynchro-
nous Hyperproperties. In International Conference on Computer Aided
Verification, CAV 2021 (Lecture Notes in Computer Science, Vol. 12759).
Springer. https://doi.org/10.1007/978-3-030-81685-8_33

[6] Raven Beutner and Bernd Finkbeiner. 2021. A Temporal Logic for
Strategic Hyperproperties. In International Conference on Concurrency
Theory, CONCUR 2021 (LIPIcs, Vol. 203). Schloss Dagstuhl.
https:
//doi.org/10.4230/LIPIcs.CONCUR.2021.24

[7] Raven Beutner and Bernd Finkbeiner. 2022. Prophecy Variables for
Hyperproperty Verification. In IEEE Computer Security Foundations
Symposium, CSF 2022. IEEE.

[8] Raven Beutner and Bernd Finkbeiner. 2022. Software Verification
of Hyperproperties Beyond ğ‘˜-Safety. In International Conference on
Computer Aided Verification, CAV 2022 (Lecture Notes in Computer
Science). Springer.

[9] Borzoo Bonakdarpour and Sarai Sheinvald. 2022. Finite-Word Hyper-

languages. arXiv:2201.01670 [cs.FL]

[10] Ahmed Bouajjani, Javier Esparza, and Oded Maler. 1997. Reachability
Analysis of Pushdown Automata: Application to Model-Checking. In
International Conference on Concurrency Theory, CONCUR 1997 (Lecture
Notes in Computer Science, Vol. 1243). Springer. https://doi.org/10.1007/
3-540-63141-0_10

[11] Laura Bozzelli, Adriano Peron, and CÃ©sar SÃ¡nchez. 2021. Asynchronous
Extensions of HyperLTL. In Annual ACM/IEEE Symposium on Logic in
Computer Science, LICS 2021. IEEE. https://doi.org/10.1109/LICS52264.
2021.9470583

[12] Michael R. Clarkson, Bernd Finkbeiner, Masoud Koleini, Kristopher K.
Micinski, Markus N. Rabe, and CÃ©sar SÃ¡nchez. 2014. Temporal Logics
for Hyperproperties. In International Conference on Principles of Secu-
rity and Trust, POST 2014 (Lecture Notes in Computer Science, Vol. 8414).
Springer. https://doi.org/10.1007/978-3-642-54792-8_15

[13] Michael R. Clarkson and Fred B. Schneider. 2008. Hyperproperties.
In IEEE Computer Security Foundations Symposium, CSF 2008. IEEE.
https://doi.org/10.1109/CSF.2008.7

[14] Norine Coenen, Bernd Finkbeiner, Christopher Hahn, and Jana Hof-
mann. 2019. The Hierarchy of Hyperlogics. In Annual ACM/IEEE
Symposium on Logic in Computer Science, LICS 2019. IEEE. https:
//doi.org/10.1109/LICS.2019.8785713

[15] Pedro R. Dâ€™Argenio, Gilles Barthe, Sebastian Biewer, Bernd Finkbeiner,
Is Your Software on Dope? - Formal
and Holger Hermanns. 2017.
Analysis of Surreptitiously "enhanced" Programs. In European Sympo-
sium on Programming, ESOP 2017 (Lecture Notes in Computer Science,
Vol. 10201). Springer. https://doi.org/10.1007/978-3-662-54434-1_4
[16] Rayna Dimitrova, Bernd Finkbeiner, and Hazem Torfah. 2020. Proba-
bilistic Hyperproperties of Markov Decision Processes. In International
Symposium on Automated Technology for Verification and Analysis,
ATVA 2020 (Lecture Notes in Computer Science, Vol. 12302). Springer.
https://doi.org/10.1007/978-3-030-59152-6_27

[17] Alexandre Duret-Lutz, Alexandre Lewkowicz, Amaury Fauchille,
Thibaud Michaud, Etienne Renault, and Laurent Xu. 2016. Spot
2.0 - A Framework for LTL and ğœ”-Automata Manipulation. In In-
ternational Symposium on Automated Technology for Verification and
Analysis, ATVA 2016 (Lecture Notes in Computer Science, Vol. 9938).
https://doi.org/10.1007/978-3-319-46520-3_8

[18] Bernd Finkbeiner, Lennart Haas, and Hazem Torfah. 2019. Canonical
Representations of k-Safety Hyperproperties. In IEEE Computer Secu-
rity Foundations Symposium, CSF 2019. IEEE. https://doi.org/10.1109/
CSF.2019.00009

[19] Bernd Finkbeiner and Christopher Hahn. 2016. Deciding Hyperprop-
erties. In International Conference on Concurrency Theory, CONCUR
2016 (LIPIcs, Vol. 59). Schloss Dagstuhl. https://doi.org/10.4230/LIPIcs.
CONCUR.2016.13

[20] Bernd Finkbeiner, Christopher Hahn, and Tobias Hans. 2018. MGHy-
per: Checking Satisfiability of HyperLTL Formulas Beyond the âˆƒâˆ— âˆ€âˆ—
Fragment. In International Symposium on Automated Technology for
Verification and Analysis, ATVA 2018 (Lecture Notes in Computer Science,
Vol. 11138). Springer. https://doi.org/10.1007/978-3-030-01090-4_31
[21] Bernd Finkbeiner, Christopher Hahn, and Hazem Torfah. 2018. Model
Checking Quantitative Hyperproperties. In International Conference
on Computer Aided Verification, CAV 2018 (Lecture Notes in Computer
Science, Vol. 10981). Springer. https://doi.org/10.1007/978-3-319-96145-
3_8

[22] Bernd Finkbeiner and Martin Zimmermann. 2017. The First-Order
Logic of Hyperproperties. In Symposium on Theoretical Aspects of
Computer Science, STACS 2017 (LIPIcs, Vol. 66). Schloss Dagstuhl. https:
//doi.org/10.4230/LIPIcs.STACS.2017.30

[23] Michael J. Fischer and Richard E. Ladner. 1979. Propositional Dynamic
Logic of Regular Programs. J. Comput. Syst. Sci. 18, 2 (1979). https:
//doi.org/10.1016/0022-0000(79)90046-1

[24] Marie Fortin, Louwe B. Kuijer, Patrick Totzke, and Martin Zimmer-
mann. 2021. HyperLTL Satisfiability is Î£1
1-complete, HyperCTL* Satis-
fiability is Î£2
1-complete. In International Symposium on Mathematical
Foundations of Computer Science, MFCS 2021 (LIPIcs, Vol. 202). Schloss
Dagstuhl. https://doi.org/10.4230/LIPIcs.MFCS.2021.47
[25] Kurt GÃ¶del. 1929. Ãœber die vollstÃ¤ndigkeit des logikkalkÃ¼ls.
[26] Jens Oliver Gutsfeld, Markus MÃ¼ller-Olm, and Christoph Ohrem. 2020.
Propositional Dynamic Logic for Hyperproperties. In International
Conference on Concurrency Theory, CONCUR 2020 (LIPIcs, Vol. 171).
Schloss Dagstuhl. https://doi.org/10.4230/LIPIcs.CONCUR.2020.50

[27] Jens Oliver Gutsfeld, Markus MÃ¼ller-Olm, and Christoph Ohrem. 2021.
Automata and fixpoints for asynchronous hyperproperties. Proc. ACM
Program. Lang. 5, POPL (2021). https://doi.org/10.1145/3434319
[28] Christoph Haase, Stephan Kreutzer, JoÃ«l Ouaknine, and James Wor-
rell. 2009. Reachability in Succinct and Parametric One-Counter
Automata. In International Conference on Concurrency Theory, CON-
CUR 2009 (Lecture Notes in Computer Science, Vol. 5710). Springer.
https://doi.org/10.1007/978-3-642-04081-8_25

[29] Andreas Krebs, Arne Meier, Jonni Virtema, and Martin Zimmermann.
2018. Team Semantics for the Specification and Verification of Hyper-
properties. In International Symposium on Mathematical Foundations
of Computer Science, MFCS 2018 (LIPIcs, Vol. 117). Schloss Dagstuhl.
https://doi.org/10.4230/LIPIcs.MFCS.2018.10

[30] Orna Kupferman and Moshe Y. Vardi. 1999. Model Checking of Safety
Properties. In International Conference on Computer Aided Verification,
CAV 1999 (Lecture Notes in Computer Science, Vol. 1633). Springer. https:
//doi.org/10.1007/3-540-48683-6_17

[31] Martin LÃ¼ck. 2016. Complete Problems of Propositional Logic for the

Exponential Hierarchy. CoRR abs/1602.03050 (2016).

[32] Corto Mascle and Martin Zimmermann. 2020. The Keys to Decidable
HyperLTL Satisfiability: Small Models or Very Simple Formulas. In
EACSL Annual Conference on Computer Science Logic, CSL 2020 (LIPIcs,
Vol. 152). Schloss Dagstuhl. https://doi.org/10.4230/LIPIcs.CSL.2020.29

Deciding Hyperproperties Combined with Functional Specifications

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

[33] Daryl McCullough. 1988. Noninterference and the composability
of security properties. In IEEE Symposium on Security and Privacy,
Oakland, SP 1988. IEEE. https://doi.org/10.1109/SECPRI.1988.8110
[34] Marvin Lee Minsky. 1967. Computation. Prentice-Hall Englewood

Cliffs.

[35] Markus N. Rabe. 2016. A temporal logic approach to Information-flow

control. Ph. D. Dissertation. Saarland University.

[36] John Alan Robinson and Andrei Voronkov (Eds.). 2001. Handbook of

Automated Reasoning. MIT Press.

[37] Hartley Rogers Jr. 1987. Theory of recursive functions and effective

computability. MIT press.

[38] A Prasad Sistla. 1994. Safety, liveness and fairness in temporal logic.

Formal Aspects of Computing 6, 5 (1994).

[39] A Prasad Sistla and Edmund M Clarke. 1985. The complexity of propo-

sitional linear temporal logics. J. ACM 32, 3 (1985).

[40] Larry J. Stockmeyer. 1976. The Polynomial-Time Hierarchy. Theor.
Comput. Sci. 3, 1 (1976). https://doi.org/10.1016/0304-3975(76)90061-X
[41] Moshe Y. Vardi and Pierre Wolper. 1994. Reasoning About Infinite
Computations. Inf. Comput. 115, 1 (1994). https://doi.org/10.1006/inco.
1994.1092

[42] Jonni Virtema, Jana Hofmann, Bernd Finkbeiner, Juha Kontinen, and
Fan Yang. 2021. Linear-Time Temporal Logic with Team Semantics:
Expressivity and Complexity. In IARCS Annual Conference on Founda-
tions of Software Technology and Theoretical Computer Science, FSTTCS
2021 (LIPIcs, Vol. 213). Schloss Dagstuhl. https://doi.org/10.4230/LIPIcs.
FSTTCS.2021.52

A Additional Material For Section 3
Definition A.1. A nondeterministic Turing machine is a
tuple ğ‘‡ = (ğ‘„, ğ‘„0, Î“, ğ›¿, ğ¹ ) where ğ‘„ is a finite set of states,
ğ‘„0 âŠ† ğ‘„ the initial states, Î“ a finite alphabet, ğ›¿ âŠ† (ğ‘„ Ã— Î“) Ã—
(ğ‘„ Ã— Î“ Ã— {ğ¿, ğ‘…}) the transition relation and ğ¹ âŠ† ğ‘„ a set of
accepting states. A transition ((ğ‘, ğ‘), (ğ‘â€², ğ‘â€², ğ‘‘)) âˆˆ ğ›¿ means
that the if the TM is in state ğ‘ and reads ğ‘, it updates its
state to ğ‘â€², writes ğ‘â€², and moves either to the left (ğ‘‘ = ğ¿)
or the right (ğ‘‘ = ğ‘…). We assume a dedicated blank symbol
# âˆˆ Î“. In an initial configuration for a finite word ğ‘¤ âˆˆ Î“ (not
containing #), the head is at position 0, the state is in some
state in ğ‘„0 and the tape contains ğ‘¤ (followed by infinitely
many #). We say that a TM accepts the empty word if there
is a run starting in an initial configuration that eventually
visits a configuration where the state is in ğ¹ . A TM is deter-
ministic if ğ‘„0 = {ğ‘0} and for each (ğ‘, ğ‘), there exists at most
one successor in ğ›¿.

Proposition 3.9. The satisfiability problem of temporally
safe HyperLTL is in coRE.
Proof. We already gave the construction of a FOL formula Î˜
in the proof sketch in the main part (in Section 3). Here we
only show its correctness, i.e., we show that the FOL formula
Î˜ and HyperLTL formula ğœ‘ are equisatisfiable.

Assume Î˜ is satisfiable and fix a first-order model. Let the
set ğ‘‹ be the set of elements from the Trace domain which
may be assigned to some variable ğ‘¥ğ‘– in any possible evalua-
tion of the quantifiers. We iteratively construct a trace for
any element of ğ‘‹ . To do so, let ğ‘–0, ğ‘–1, . . . be a fixed sequence
of element from TimePoint such that Succ(ğ‘– ğ‘—, ğ‘– ğ‘—+1) for any
ğ‘— âˆˆ N and ğ‘–0 is the constant described above. This sequence

might not be unique and elements might occur several times
but we need to fix one such sequence to obtain well-defined
traces. For each element ğ‘£ âˆˆ ğ‘‹ , we define a trace ğ‘¡ğ‘£ âˆˆ Î£ğœ” ,
by setting ğ‘¡ğ‘£ (ğ‘›) (cid:66) {ğ‘ | ğ‘ƒğ‘ (ğ‘£, ğ‘–ğ‘›)} for every ğ‘› âˆˆ N, where
we write ğ‘ƒğ‘ (ğ‘£, ğ‘–ğ‘›) whenever this holds in the fixed firs-order
model of Î˜. It is easy to see that ğ‘‡ (cid:66) {ğ‘¡ğ‘£ | ğ‘£ âˆˆ ğ‘‹ } is a
model of ğœ‘. This holds as Î˜ minims the quantification in ğœ‘,
so whenever a quantifier is instantiated with ğ‘£ âˆˆ ğ‘‹ , we use
trace ğ‘¡ğ‘£ âˆˆ ğ‘‡ for the respective quantifier in ğœ‘. By construc-
tion of ğœŒğ‘ we ensure that Ağœ™ has an accepting run on all
tuples of ğ‘› traces chosen in the quantifier prefix.

For the other direction, assume that ğœ‘ is satisfiable by
trace set ğ‘‡ , which we choose as domain for sort Trace. For
TimePoints, we choose the set of natural numbers with ğ‘–0 = 0.
We set ğ‘ƒğ‘ (ğ‘¡, ğ‘–) to true iff ğ‘ âˆˆ ğ‘¡ [ğ‘–]. For every assignment of
ğ‘¡1, . . . ğ‘¡ğ‘› to the trace variables, we fix a run through A and
set Stateğ‘ (ğ‘¡1, . . . , ğ‘¡ğ‘›, ğ‘–) to true iff the the run is in state ğ‘ in
â–¡
step ğ‘–. The resulting structure satisfies ğœ™.

Lemma 3.10. The satisfiability problem is coRE-hard for
specifications (âŠ¤, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒâˆ—.

âˆ—).

(

Proof. We reduce from the non-halting problem of determin-
istic Turing machines on the empty word, which is coRE
complete. We assume, w.l.o.g., that the tape of the Turing
machine is left-bounded and only takes a step to the left
when it is possible. We encode the position of the head with
a proposition â„. Throughout the construction, we maintain
the invariant on all relevant traces that â„ is set exactly once
on the trace. We cannot encode this property directly as it
would require to nest multiple
operators. We encode the
alphabet Î“ and the set of states ğ‘„ with sets of atomic propo-
sitions, one for each symbol and enforce that in each step,
exactly one for each set holds, for ğ‘† = Î“ or ğ‘† = ğ‘„:

âˆ€ğœ‹ .

(cid:16) (cid:220)

(cid:0)ğ‘ğœ‹ âˆ§

(cid:219)

Â¬ğ‘ğœ‹ (cid:1)(cid:17)

ğ‘ âˆˆğ‘†

ğ‘â‰ ğ‘ âˆˆğ‘†

We fix the current state to be the one that holds in the posi-
tion of the head. Initially, the TM is in state ğ‘0, the head at
position 0, and the tape is blank. We require that the initial
configuration is present in the set:

âˆƒğœ‹ . â„ğœ‹ âˆ§ ğ‘0

ğœ‹ âˆ§ (#ğœ‹ âˆ§ Â¬â„ğœ‹ )

Now we encode the possible transitions with a âˆ€ğœ‹âˆƒğœ‹ â€² for-
mula. We ensure that if the configuration encoded by ğœ‹ is a
valid one (i.e., â„ only holds once), then the successor config-
uration is also valid. For correct transitions, all positions on
ğœ‹ â€², which are not left or right of the head in ğœ‹, must remain
unchanged. Second, the head must move either left or right
and the symbol and state propositions are only allowed to

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

Beutner et al.

change in the position of the old head.

(cid:18)

ğœ“LxorR (cid:66)

(Â¬â„ğœ‹ âˆ§ (Â¬â„ğœ‹ âˆ§ Â¬â„ğœ‹ )) â†’

(cid:18)

âˆ§ â„ğœ‹ â†’

Â¬â„ğœ‹ â€² âˆ§ (â„ğœ‹ â€² âŠ•

(cid:19)

ğ‘ğœ‹ â†” ğ‘ğœ‹ â€²

(cid:219)

ğ‘ âˆˆAP

â„ğœ‹ â€²)

(ğ‘ğœ‹ â†” ğ‘ğœ‹ â€²) âˆ§

(ğ‘ğœ‹ â†” ğ‘ğœ‹ â€²)(cid:1)

(cid:19)

âˆ§ (cid:0) (cid:219)
ğ‘ âˆˆÎ“

Now we translate each transition (ğ‘, ğ‘), (ğ‘â€², ğ‘â€², ğ¿) âˆˆ ğ›¿ as
follows. If the head moves right instead of left, we change
the position of the

operator accordingly.

ğœ“trans1 (cid:66) (â„ğœ‹ âˆ§ ğ‘ğœ‹ âˆ§ ğ‘ğœ‹ ) â†’ â„ğœ‹ â€² âˆ§ ğ‘â€²
The final transition formula is the following:

ğœ‹ â€² âˆ§ ğ‘â€²
ğœ‹ â€²

âˆ€ğœ‹ . âˆƒğœ‹ â€².

(ğœ“LxorR âˆ§ (ğœ“trans1 âˆ¨ ğœ“trans2 âˆ¨ Â· Â· Â· ))

We only encode transitions where ğ‘â€² âˆ‰ ğ¹ , i.e. only those
transitions that do not make the TM halt. The conjunction
of the above formulas can be easily transformed into a âˆ€âˆƒ2
formula with a single
operators in
. Now, the TM has an infinite non-halting run
the scope of
iff the conjunction of the above formulas has a satisfying
model. The trace set might not only contain the witness-
ing run but also non-valid configurations or non-reachable
â–¡
configurations, which we can just ignore.

and only non-nested

.

1, cğ‘–

ğ‘›, cğ‘–

1, . . . , lğ‘–

1-complete for

Theorem 3.11. The satisfiability problem is Î£1
specifications (ğœ“, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒâˆ—.
Proof. Membership in Î£1
1 follows from [24]. We reduce from
the recurring computation problem of nondeterministic two-
counter machines. The key idea is to use LTL formulas
over pairs of encoded configurations and use the hyperprop-
erty only to ensure that every second component matches
with some first component of another trace. We thus set
AP = AP 1 âˆª AP 2 and each APğ‘– = {lğ‘–
2, tğ‘– }. The
counter values for counter ğ‘1, ğ‘2 are encoded by two atomic
propositions c1 and c2 which hold exactly once, i.e., counter
ğ‘¥ has value ğ‘£ if cğ‘¥ occurs in the ğ‘£th position. We use ğ‘› atomic
propositions for the instructions, and require that in the first
position, exactly one instruction label holds. Note that all of
the above requirements for a valid configuration are easily
expressible in LTL. To ensure that the computation visits the
initial instruction ğ‘™1 infinitely often, we use a proposition t,
which must also hold exactly once and decreases with every
computation step. When ğ‘¡ is in position 0, l1 must hold. We
1 âˆ¨ (t2 â†” t1). We also en-
encode this requirement as l1
code that each trace denotes an update step of the 2CM. For
example instruction ğ‘™ğ‘– = (cid:2)ğ‘1 (cid:66) ğ‘1 + 1 goto {ğ‘™ ğ‘—, ğ‘™ğ‘˜ }(cid:3) can be
encoded as:
ğ‘– â†’ (cid:2)
1
l

2
1
2) âˆ§ (c
2 â†” c

2
2
2
ğ‘— âˆ¨ l
1)) âˆ§ (l

1
1 â†” c

((c

ğ‘˜ )(cid:3)

Decrement instructions are analogous. Instructions of the
form ğ‘™ğ‘– = (cid:2)if ğ‘1 = 0 then goto ğ‘™ ğ‘— else goto ğ‘™ğ‘˜ (cid:3) can be

encoded as.
(cid:104)

1
ğ‘– â†’
l

2
1
ğ‘— ) âˆ§ (Â¬c
1 â†’ l
(c

2
1
ğ‘˜ ) âˆ§
1 â†’ l

(cid:219)

ğ‘¥ âˆˆ1,2

1
ğ‘¥ â†” c

2
ğ‘¥ )

(c

(cid:105)

We then take the conjunction over the resulting formulas
for each instruction.

What is left to state is the hyperproperty ğœ‘, which matches

second components to first components.
ğœ‹ â†” ğ‘1
ğ‘2
ğœ‹ â€²

âˆ€ğœ‹ . âˆƒğœ‹ â€². (cid:219)
ğ‘ âˆˆAP
Additionally, the initial configuration must be present in the
first component of a trace.

âˆƒğœ‹ . (c

1
1)ğœ‹ âˆ§ (c

1
1
1)ğœ‹
2)ğœ‹ âˆ§ (l

The resulting specification (ğœ“, ğœ‘) is satisfiable iff the 2CM
has a recurring computation starting in the initial state. The
formula ğœ‘ is from the âˆ€âˆƒ2 fragment and uses only a single
â–¡

without nested temporal operators.

Theorem 3.12. The satisfiability problem is NEXPTIME-com-
plete for specifications (ğœ“, ğœ‘) where ğœ‘ is of the form ğ‘„ âˆ—.
âˆ—.
Hardness holds already for ğœ“ = âŠ¤, a âˆ€âˆ—âˆƒâˆ— prefix, and no
s.
Proof. Let ğœ‘ = ğ‘„ âˆ—. ğœ™. For membership in NEXPTIME, let ğ‘˜
be the lookahead needed to evaluate ğœ™, which is upper-
bounded the number of
operators occurring in ğœ™. Now
define ğ‘€ âŠ† Î£ğ‘˜ as all finite traces ğœ of length ğ‘˜ such that ğœ can
be extended to a trace satisfying ğœ“ . ğ‘€ can be constructed in
exponential time by converting ğœ“ to a BÃ¼chi automaton and
checking if each ğœ âˆˆ ğ‘€ has an accepting run in linear time.
We then nondeterministically guess a subset ğ‘€ â€² âŠ† ğ‘€ and
verify that ğ‘€ â€² |= ğœ‘ which can easily be done in nondetermin-
istic exponential time, giving the desired NEXPTIME-upper
bound.

To show hardness we reduce the acceptance of a time-
bounded nondeterministic Turing machine on the empty
word to a HyperLTL formula (our construction does not re-
quire any temporal operators, not even s). Consequently,
only the first position of each trace is relevant. Let ğ‘‡ =
(ğ‘„, ğ‘„0, Î“, ğ›¿, ğ¹ ) be a exponential time-bounded nondetermin-
istic TM. As our formula uses no s, only the first position is
relevant so we can see each trace as a propositional evalua-
tion over AP. The idea is that each trace in the model encodes
a piece of information of an accepting run of ğ‘‡ . Such a piece
of information is a tuple (ğ‘ , ğ‘, ğ›¾, ğ‘) where ğ‘ , ğ‘ âˆˆ N, ğ›¾ âˆˆ Î“ and
ğ‘ âˆˆ ğ‘„ âˆª {âŠ¥}. The information encodes that in time-step ğ‘ 
and at position ğ‘, the tape content is ğ›¾ and the head is at that
position and the machine in state ğ‘ if ğ‘ âˆˆ ğ‘„ or the head is
not at that position (if ğ‘ = âŠ¥). As ğ‘‡ is time (and thus space)
bounded, ğ‘  and ğ‘ are bound by 2ğ‘› for some ğ‘›.

In our formula we now use propositions (cid:174)s = s1, . . . , sğ‘› to
encode a time step and (cid:174)p = p1, . . . , pğ‘› to encode a position
on the tape (both as a binary counter). Moreover, for each
state ğ‘ âˆˆ ğ‘„ âˆª {âŠ¥} and each letter ğ›¾ âˆˆ Î“, we introduce an
atomic proposition ğ‘ and ğ›¾. In each evaluation exactly one

Deciding Hyperproperties Combined with Functional Specifications

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

of the tape-content propositions holds and at most one state-
proposition holds (if none holds, the head is at a different
step).

Using HyperLTL, we specify that the information encoded
in the traces is consistent and forms an accepting run of the
TM:
(1) At most one of the state-propositions and exactly one of
the tape-propositions holds:

(cid:220)

âˆ€ğœ‹ . (cid:169)
(cid:173)
ğ›¾ âˆˆÎ“
(cid:171)

(cid:219)

ğ›¾ğœ‹ âˆ§

ğ›¾ â‰ ğ›¾ â€² âˆˆÎ“

Â¬ğ›¾ â€²

ğœ‹ (cid:170)
(cid:174)
(cid:172)

(cid:219)

âˆ§

ğ‘â‰ ğ‘â€² âˆˆğ‘„

Â¬(ğ‘ğœ‹ âˆ§ ğ‘â€²
ğœ‹ )

(2) If two traces agree in time step and position they also
agree on tape content, state (and thus head position):

âˆ€ğœ‹âˆ€ğœ‹ â€².

(cid:32) ğ‘›
(cid:219)

ğ‘–=1

(sğ‘–

ğœ‹ â†” sğ‘–

ğœ‹ â€²) âˆ§ (pğ‘–

ğœ‹ â†” pğ‘–

ğœ‹ â€²)

(cid:33)

â†’

(ğ‘ğœ‹ â†” ğ‘ğœ‹ â€²) âˆ§

(cid:219)

ğ›¾ âˆˆÎ“

(cid:219)

(cid:169)
(cid:173)
ğ‘ âˆˆğ‘„
(cid:171)

(ğ›¾ğœ‹ â†” ğ›¾ğœ‹ â€²)(cid:170)
(cid:174)
(cid:172)

(3) The TM state (and therefore also head position) agrees
across all traces that are in the same time step. Phrased
differently, for any two different traces that agree on the step
and the automaton state, are already equal. Here we write
ğœ‹ = ğœ‹ â€² to mean that ğœ‹ and ğœ‹ â€² agree (in the first position)

ğ‘›
(cid:219)
âˆ€ğœ‹âˆ€ğœ‹ â€². (cid:169)
(cid:173)
(cid:171)

ğ‘–=1

(sğ‘–

ğœ‹ â†” sğ‘–

ğœ‹ â€²) âˆ§

(cid:219)

ğ‘ âˆˆğ‘„

(ğ‘ğœ‹ â†” ğ‘ğœ‹ â€²)(cid:170)
(cid:174)
(cid:172)

â†’ ğœ‹ = ğœ‹ â€²

(4) The initial configuration of the TM is in the model. We
cannot encode this with existential quantification directly,
as we would need to refer to exponentially many positions
and therfiore also exponentially many traces. Instead, we
express it as a âˆ€âˆƒ property. We use syntactic sugar and write
(cid:174)pğœ‹ = (cid:174)pğœ‹ â€² + 1 to indicate that the binary counter increases
by one position. This can easily be encoded in propositional
logic in quadratic size. For a constant ğ‘ we write (cid:174)pğœ‹ = ğ‘ to
denote the binary counter given by (cid:174)p equals ğ‘. We express
the desired property as a conjunction of the following two
formulas. The first formula is given by:

âˆƒğœ‹ . (cid:174)sğœ‹ = 0 âˆ§ (cid:174)pğœ‹ = 0 âˆ§ #ğœ‹ âˆ§

(cid:220)

ğ‘ğœ‹

ğ‘ âˆˆğ‘„0

Which expresses that at step 0 at least the very first position
is filled with # and the head is at that poistion (in an initial
state). The second information propagates this information
to all remaining positions in the first step:
âˆ€ğœ‹âˆƒğœ‹ â€².(cid:0)(cid:174)sğœ‹ = 0 âˆ§ (cid:174)pğœ‹ â‰  2ğ‘› âˆ’ 1(cid:1) â†’

(cid:0)(cid:174)sğœ‹ â€² = 0 âˆ§ (cid:174)pğœ‹ â€² = (cid:174)pğœ‹ + 1 âˆ§ #ğœ‹ â€² (cid:1)

Note that (3) already implies that the position is set consis-
tently in the same step, so we do not need to require that
âŠ¥ğœ‹ â€² holds.

(5) The model encodes valid steps of the TM. As the tran-
sitions of a TM are local, it is sufficient to compare three
consecutive tape positions with the same three tape posi-
tions in the next step. Thus, for every three traces that share
the same time step and encode consecutive positions, there
exists three traces on the next time step with the same posi-
tions such that the step is possible in the TM. The resulting
âˆ€3âˆƒ3 formula then consists of a finite conjunction over those
valid â€œtransitions triplesâ€ of ğ‘‡ . We do not give the formula
explicitly, as the notation gets clustered.
(6) The TM is eventually in an accepting state which we can
express via âˆƒğœ‹ . (cid:212)ğ‘ âˆˆğ¹ ğ‘ğœ‹ .

Note that because of the explicit step count (via (cid:174)s), each
model directly encodes a unique run of the TM. In particular,
there can not be spurious facts that do not hold on the de-
fined run of the TM. Consequently, we get that the resulting
formula is satisfiable iff TM has a 2ğ‘›-time bounded accepting
run. The reduction outlined above can be done in logspace,
â–¡
giving the desired NEXPTIME-hardness.

B Additional Material for Section 4
Lemma 4.4. The satisfiability problem is NP-complete for
specifications (âŠ¤, ğœ‘) where ğœ‘ is of the form âˆ€âˆ—âˆƒâˆ—.
âˆ—) âˆ§
âˆ—) and no propositional formulas occur outside of the
Â· Â· Â· âˆ§ (
operators. Hardness already holds for a single eventuality.

(

ğœ™.

Proof. We first consider the case where we have only a single
eventuality. Let ğœ‘ = âˆ€ğœ‹1 . . . ğœ‹ğ‘›âˆƒğœ‹ğ‘›+1 . . . ğœ‹ğ‘›+ğ‘š.

s operators. We assume that in ğœ™ the

We claim that we can actually assume that ğœ™ contains
no
s occur di-
rectly in from of atomic proportions, i.e., ğœ™ is a boolean
formula over atoms of the form ğ‘› ğ‘ğœ‹ğ‘– . Transforming a for-
mula in this form is possible in polynomial time. Now let
ğ‘˜ be the lookahead needed to evaluate ğœ™ (which is upper
s in ğœ™). We define ğœ™ â€² as the
bounded by the number of
formula over AP 0 âˆª Â· Â· Â· âˆª APğ‘˜ (where APğ‘– = {ğ‘ğ‘–
| ğ‘ âˆˆ
AP }) obtained from ğœ™ by replacing each atom ğ‘› ğ‘ğœ‹ğ‘– with
the atomic proposition (ğ‘ğ‘›)ğœ‹ğ‘– . As ğœ™ occurs under a
, it is
ğœ™ is satisfiable
easy to see that âˆ€ğœ‹1 . . . ğœ‹ğ‘›âˆƒğœ‹ğ‘›+1 . . . ğœ‹ğ‘›+ğ‘š.
iff âˆ€ğœ‹1 . . . ğœ‹ğ‘›âˆƒğœ‹ğ‘›+1 . . . ğœ‹ğ‘›+ğ‘š.

ğœ™ â€² is satisfiable.

So let us assume in the following that ğœ™ contains no tem-
poral operators, i.e., ğœ™ is a propositional boolean formula
over APğœ‹1 âˆª Â· Â· Â· âˆª APğœ‹ğ‘›+ğ‘š . We claim that ğœ‘ is satisfiable iff

ğ‘›
(cid:219)

(cid:219)

ğœ (cid:66) ğœ™ âˆ§

(ğ‘ğœ‹ğ‘– â†” ğ‘ğœ‹1)

ğ‘–=2

ğ‘ âˆˆAP
is satisfiable (viewed as a propositional formula). For the
left to right direction, assume that ğœ‘ is satisfiable by ğ‘‡ . We
now pick any ğ‘¡ âˆˆ ğ‘‡ and instantiate all universal quanti-
fiers with ğ‘¡. Then let ğ‘¡ğ‘›+1, . . . , ğ‘¡ğ‘›+ğ‘š âˆˆ ğ‘‡ , be witness traces
for the existential quantification. So [ğœ‹1 â†¦â†’ ğ‘¡, . . . , ğœ‹ğ‘› â†¦â†’
ğœ™. Let ğ‘› âˆˆ N be
ğ‘¡, ğœ‹ğ‘›+1 â†¦â†’ ğ‘¡ğ‘›+1, . . . , ğœ‹ğ‘›+ğ‘š â†¦â†’ ğ‘¡ğ‘›+ğ‘š] |=
such that [ğœ‹1 â†¦â†’ ğ‘¡, . . . , ğœ‹ğ‘› â†¦â†’ ğ‘¡, ğœ‹ğ‘›+1 â†¦â†’ ğ‘¡ğ‘›+1, . . . , ğœ‹ğ‘›+ğ‘š â†¦â†’
ğ‘¡ğ‘›+ğ‘š] [ğ‘›, âˆ] |= ğœ™. We construct an assignment ğ›¼ : APğœ‹1 âˆª

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

Beutner et al.

Â· Â· Â·âˆªAPğœ‹ğ‘›+ğ‘š â†’ B as follows: For each ğ‘ğœ‹ğ‘– we define ğ›¼ (ğœ‹ğ‘– ) (cid:66)
ğ‘¡ (ğ‘›)(ğ‘) if 1 â‰¤ ğ‘– â‰¤ ğ‘› and ğ›¼ (ğœ‹ğ‘– ) (cid:66) ğ‘¡ğ‘– (ğ‘›)(ğ‘) if ğ‘› +1 â‰¤ ğ‘– â‰¤ ğ‘› +ğ‘š.
It is easy to see that ğ›¼ satisfies ğœ (note that all universally
quantified copies are chosen by ğ‘¡ so (cid:211)ğ‘›
ğ‘–=2 (cid:211)ğ‘ âˆˆAP (ğ‘ğœ‹ğ‘– â†” ğ‘ğœ‹1)
holds trivially).

For the reverse, assume that ğœ is satisfiable and let ğ›¼ be a
satisfying variable assignment over APğœ‹1 âˆª Â· Â· Â· âˆª APğœ‹ğ‘›+ğ‘š . We
construct a model with ğ‘› + ğ‘š traces ğ‘¡1, . . . , ğ‘¡ğ‘›+ğ‘š as follows:
For every indices ğ‘–1, . . . , ğ‘–ğ‘› âˆˆ {1, . . . , ğ‘› + ğ‘š} we choose ğ‘š dis-
tinct indices ğ‘—1, . . . , ğ‘—ğ‘š âˆˆ {1, . . . , ğ‘› +ğ‘š} that are also different
from all ğ‘–1, . . . , ğ‘–ğ‘› (this is possible as we fixed ğ‘› + ğ‘š traces).
Now fix some fresh position ğ‘› âˆˆ N and ensure that [ğœ‹1 â†¦â†’
ğ‘¡ğ‘–1, . . . , ğœ‹ğ‘› â†¦â†’ ğ‘¡ğ‘–ğ‘›, ğœ‹ğ‘›+1 â†¦â†’ ğ‘¡ ğ‘—1 . . . ğœ‹ğ‘›+ğ‘š â†¦â†’ ğ‘¡ ğ‘—ğ‘š ] [ğ‘›, âˆ] |= ğœ™.
This is always possible as we can use ğ›¼ to construct the as-
signments of all involved traces at position ğ‘˜. Here it is cru-
cial that we added the second conjunct (cid:211)ğ‘›
ğ‘–=2 (cid:211)ğ‘ âˆˆAP (ğ‘ğœ‹ğ‘– â†”
ğ‘ğœ‹1 ) to ğœ as this ensures that we construct a position at
which the property holds even if ğ‘¡ğ‘–1, . . . , ğ‘¡ğ‘–ğ‘› are not distinct.
We iterate this for every of the finitely many elements in
{1, . . . , ğ‘› + ğ‘š}ğ‘› (always choosing a fresh position ğ‘›), thereby
defining a model of ğœ‘.

To show NP-hardness, we can easily reduce from propo-
sitional SAT problem: A formula ğœ over AP is satisfiable iff
ğœğœ‹ is satisfiable (we write ğœğœ‹ for ğœ when replacing all
âˆƒğœ‹ .
atoms ğ‘ with ğ‘ğœ‹ ).

To handle multiple eventualities, reuse the above proof.
Let ğœ‘ = âˆ€âˆ—âˆƒâˆ—.
ğœ™1 âˆ§ Â· Â· Â· âˆ§ ğœ™ğ‘›. We again assume, w.l.o.g.,
that each ğœ™ğ‘– contains no s. We introduce a different copy
of APğ‘– for the ğ‘–th
-subformula, the
operator. In each
propositional variables are exchanged accordingly, i.e., let ğœ™ â€²
ğ‘–
be ğœ™ğ‘– where the atomic propositions from AP are replaced
with those from APğ‘– . It is easy to see that ğœ‘ is satisfiable iff
ğ‘›) is satisfiable, as we can simply fulfill
âˆ€âˆ—âˆƒâˆ—.
â–¡
all eventualities at different timepoints.

1 âˆ§ Â· Â· Â· âˆ§ ğœ™ â€²

(ğœ™ â€²

Lemma B.1. The satisfiability problem is NEXPTIME-complete
for specifications (âŠ¤, ğœ‘) where ğœ‘ is of the form âˆ€âˆ—âˆƒâˆ—.
âˆ—) âˆ§
âˆ—) (and we do allow propositional formulas occur
Â· Â· Â· âˆ§ (
outside of the

operators).

(

Proof. We prove this lemma by combining Lemma 4.4 and
Theorem 3.12. The crux is that we can separate the proposi-
. Assume we are given a for-
tional formulas outside the
mula ğœ‘ = âˆ€âˆ—âˆƒâˆ—. ( ğœ™1)âˆ§Â· Â· Â·âˆ§( ğœ™ğ‘›)âˆ§ğœ™ â€² where ğœ™1, . . . , ğœ™ğ‘›, ğœ™ â€²
contain only s. It it easy to see that ğœ‘ is satisfiable iff both
âˆ€âˆ—âˆƒâˆ—. ( ğœ™1) âˆ§ Â· Â· Â· âˆ§ ( ğœ™ğ‘›) and âˆ€âˆ—âˆƒâˆ—. ğœ™ â€² are satisfiable. The
former is decidable in NP (see Lemma 4.4) and the latter in
NEXPTIME (see Theorem 3.12), so the NEXPTIME upper bound
follows. For the lower bound, we can directly use the hard-
ness shown in Theorem 3.12 and ignore the ability to use
formulas.

â–¡

Lemma 4.6. Let (ğœ“, ğœ‘) be a specification where ğœ‘ is of the
form âˆ€ğ‘›âˆƒğ‘š.
âˆ—). There exists an effectively computable

(

specification (ğœ“ â€², ğœ‘ â€²) where ğœ‘ â€² is the of the form âˆ€ğ‘›âˆƒğ‘š.
that (ğœ“, ğœ‘) and (ğœ“ â€², ğœ‘ â€²) are equisatisfiable.
Proof. Let ğœ‘ = âˆ€ğ‘›âˆƒğ‘š.
evaluate ğœ™ (which is upper bounded by the number of
in ğœ™). Similar to the proof of Lemma 4.4 we eliminate
using letting traces range over tuples.

ğœ™. Let ğ‘˜ be the lookahead needed to
s
s by

such

APğ‘– = {ğ‘ğ‘–

We construct a formula ğœ™ â€² over AP 0 âˆª Â· Â· Â· âˆª APğ‘˜ (where
| ğ‘ âˆˆ AP }) as follows: We assume that in ğœ™ the
s occur directly in from of atomic proportions, i.e., ğœ™ is a
boolean formula over atoms of the form ğ‘› ğ‘ğœ‹ğ‘– . Transform-
ing a formula in this form is possible in polynomial time.
We then define ğœ™ â€² as the formula over AP 0 âˆª Â· Â· Â· âˆª APğ‘˜ ob-
tained from ğœ™ by replacing each atom ğ‘› ğ‘ğœ‹ğ‘– with the atomic
proposition (ğ‘ğ‘›)ğœ‹ğ‘– .

The traces we consider now range over letters from AP 0 âˆª
Â· Â· Â· âˆª APğ‘˜ , i.e., over the window of the next ğ‘˜ + 1 steps. In the
LTL part of the specification we assert that this window is
consistent, i.e., the ğ‘– + 1th state (evaluation over APğ‘–+1 equals
the evaluation of the ğ‘–th state in the next step). We define ğœ“ â€²
as

ğœ“ â€² (cid:66) ğœ“0 âˆ§

ğ‘˜âˆ’1
(cid:219)

(cid:219)

(cid:0)ğ‘ğ‘–+1 â†” ğ‘ğ‘– (cid:1)

ğ‘–=0

ğ‘ âˆˆAP
where ğœ“0 is obtained from ğœ“ by replacing each proposition
ğ‘ âˆˆ AP with ğ‘0 âˆˆ AP 0. We define ğœ‘ â€² = âˆ€ğ‘›âˆƒğ‘š.
ğœ™ â€². It is easy
â–¡
to see that (ğœ“, ğœ‘) and (ğœ“ â€², ğœ‘ â€²) are equisatisfiable.

Proposition 4.14. HyperLTL formulas of the form ğœ‘ = âˆ€âˆƒâˆ—. ğœ™
where ğœ™ is a deterministic liveness property are always satisfi-
able and have a finite model.

Proof. Let ğœ‘ = âˆ€ğœ‹1âˆƒğœ‹2 . . . ğœ‹ğ‘š+1. ğœ™ and let Ağœ™ be a determin-
istic BÃ¼chi automaton for ğœ™ over APğœ‹1 âˆª Â· Â· Â· âˆª APğœ‹ğ‘š+1. For
finite traces ğ‘¢1, . . . , ğ‘¢ğ‘š+1 of the same length (say ğ‘˜), we de-
fine zip(ğ‘¢1, . . . , ğ‘¢ğ‘š+1) as the finite trace (of length ğ‘˜) over
APğœ‹1 âˆª Â· Â· Â· âˆª APğœ‹ğ‘š+1 that combines ğ‘¢1, . . . , ğ‘¢ğ‘š+1, i.e., the eval-
uation of APğœ‹ğ‘– is copied from ğ‘¡ğ‘– . The crucial property we
use is that for a deterministic liveness property, we can al-
ways revisit an accepting state even after having read an
arbitrary finite word. We claim that there always exists a
finite model of size at most ğ‘š + 1. For any ğ‘– âˆˆ {1, . . . , ğ‘š +
1} define ğ‘“ (ğ‘–) as the vector (1, . . . , ğ‘– âˆ’ 1, ğ‘– + 1, . . . , ğ‘š + 1)
(which has length ğ‘š). We iteratively constructs a model
as follows: Initially, we set ğ‘¢1, . . . , ğ‘¢ğ‘š+1 = ğœ–. For each ğ‘— =
0, 1, 2, . . . let ğ‘– = ( ğ‘—%(ğ‘š + 1)) + 1 (this way we consider each
ğ‘– âˆˆ {1, . . . , ğ‘š + 1} infinitely many times) and ( ğ‘—1, . . . , ğ‘—ğ‘š) =
ğ‘“ (ğ‘–). We now extend each of the traces in ğ‘‡ by some fi-
ğ‘š+1 of the same length such
nite, non-empty word ğ‘¢ â€²
that zip(ğ‘¢ğ‘–ğ‘¢ â€²
ğ‘—ğ‘š ) reaches an accepting state
in Ağœ™ . As Ağœ™ is a deterministic liveness automaton this is
always possible.

, . . . , ğ‘¢ ğ‘—ğ‘šğ‘¢ â€²

1, . . . , ğ‘¢ â€²

ğ‘– , ğ‘¢ ğ‘—1ğ‘¢ â€²
ğ‘—1

Let ğ‘¡1, . . . ğ‘¡ğ‘š+1 be the infinite traces constructed in the
limit. It is easy to see that ğ‘‡ = {ğ‘¡1, . . . , ğ‘¡ğ‘š+1} is a model of ğœ‘.
In the limit, this constructs traces of infinite length which

Deciding Hyperproperties Combined with Functional Specifications

LICS â€™22, August 2â€“5, 2022, Haifa, Israel

serve as a model for ğœ‘. For each trace ğ‘¡ğ‘– , the traces with
index determined by ğ‘“ (ğ‘–) can be chosen as witness traces
for existential quantification. By construction, the (unique)
run of Ağœ™ on the resulting tuple of traces is accepting. â–¡

C Additional Material for Section 5
Lemma 5.1. In every iteration of the algorithm it holds that
L (Anew) âŠ† L (A), and for any trace setğ‘‡ withğ‘‡ |= âˆ€ğœ‹âˆƒğœ‹ â€². ğœ™,
ğ‘‡ âŠ† L (A âˆ€).

Proof. Initially, the property obviously holds as A encodes ğœ‘
and every trace which occurs in any satisfying trace set must
have a run through A as the âˆ€ trace. It remains to show that
Anew does not exclude traces that occur in satisfying ğ‘‡ . The
new),
construction ensures that if ğ‘¡ âˆˆ L (A âˆ€) but ğ‘¡ âˆ‰ L (A âˆ€
then there exists no witness trace ğ‘¡ â€² such that ğ‘¡ğœ‹ âˆªğ‘¡ â€²
ğœ‹ â€² âˆˆ L (A)
and ğ‘¡ â€² âˆˆ L (A âˆ€). By induction, L (A) is a superset of the
union of all satisfying trace sets, therefore, there can be no
â–¡
ğ‘‡ such that ğ‘¡ âˆˆ ğ‘‡ and ğ‘‡ |= âˆ€ğœ‹âˆƒğœ‹ â€². ğœ™.

