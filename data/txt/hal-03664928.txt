Eï¬€icient Provenance-Aware Querying of Graph
Databases with Datalog
Yann Ramusat, Silviu Maniu, Pierre Senellart

To cite this version:

Yann Ramusat, Silviu Maniu, Pierre Senellart. Eï¬€icient Provenance-Aware Querying of Graph
Databases with Datalog. GRADES-NDA 2022 - Joint Workshop on Graph Data Management Expe-
riences & Systems (GRADES) and Network Data Analytics (NDA), Jun 2022, Philadelphia, United
States. ï¿¿hal-03664928ï¿¿

HAL Id: hal-03664928

https://inria.hal.science/hal-03664928

Submitted on 11 May 2022

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

Lâ€™archive ouverte pluridisciplinaire HAL, est
destinÃ©e au dÃ©pÃ´t et Ã  la diffusion de documents
scientifiques de niveau recherche, publiÃ©s ou non,
Ã©manant des Ã©tablissements dâ€™enseignement et de
recherche franÃ§ais ou Ã©trangers, des laboratoires
publics ou privÃ©s.

Efficient Provenance-Aware Querying
of Graph Databases with Datalog

Yann Ramusat
DI ENS, ENS, PSL University, CNRS,
Inria
Paris, France
yann.ramusat@ens.fr

Silviu Maniu
UniversitÃ© Paris-Saclay, LISN, CNRS
Gif-sur-Yvette, France
silviu.maniu@lisn.upsaclay.fr

Pierre Senellart
DI ENS, ENS, PSL University, CNRS,
Inria & IUF
Paris, France
pierre@senellart.com

ABSTRACT
We establish a translation between a formalism for dynamic pro-
gramming over hypergraphs and the computation of semiring-
based provenance for Datalog programs. The benefit of this trans-
lation is a new method for computing the provenance of Data-
log programs for specific classes of semirings, which we apply to
provenance-aware querying of graph databases. Theoretical results
and practical optimizations lead to an efficient implementation us-
ing SoufflÃ©, a state-of-the-art Datalog interpreter. Experimental
results on real-world data suggest this approach to be efficient in
practical contexts, competing with dedicated solutions for graphs.

CCS CONCEPTS
â€¢ Information systems â†’ Data provenance; â€¢ Theory of com-
putation â†’ Data provenance.

KEYWORDS
Datalog, Provenance, Semirings, Graph Databases, Dynamic Pro-
gramming, Transportation Networks

1 INTRODUCTION
Data provenance [3] is meta-information that is kept along and
tracked about data throughout its life cycle, and which is prop-
agated to query results during query evaluation; applications of
such information include traceability, explainability, or uncertainty
management [21]. A notion of provenance for Datalog queries
was introduced by Green, Karvounarakis, and Tannen [9]. Based
on the algebraic structure of semirings to encode additional meta-
information about query results, it extends the notion of semiring
provenance for the positive fragment of the relational algebra, also
introduced in [9]. The full provenance of a Datalog program (i.e.,
the provenance associated to each derived tuple) is expressed as
a system of equations over an ğœ”-continuous semiring. This forms
a â€œcomputationalâ€ notion of provenance, where operations (and
queries) over provenance values are permitted.

A recent line of work has adapted this provenance model for
simple navigational queries (regular path queries [2] or RPQs) over
graph databases [18, 19]. Several provenance-aware algorithms
have been proposed, and a taxonomy of semiring classes, based
on their properties, has been established in [19]. Those works aim
at identifying, for a set of important semiring classes, the most
appropriate algorithm for provenance-aware querying, enabling
real-world applications.

The aim of the current work is to extend these approaches to
queries that go beyond the simple class of RPQs, relying on the

rich literature around Datalog provenance to provide better so-
lutions for provenance computations over graph databases. Our
objective is to obtain new effective solutions to practical scenarios
(i.e., real transportation networks over large areas). In the process,
we generalize the methods for provenance computation over graph
databases of [19] to Datalog. Our main motivation is thus is to allow
new opportunities for querying graph databases in the presence of
provenance information, as Datalog is significantly more expressive
than RPQs. Given the fact that RPQs are expressible in Datalog, we
can therefore either compose or take the union of several RPQs.
Whereas RPQs only select pair of vertices, with Datalog we can go
beyond binary output relations; this allows to retrieve, for instance,
paths that are restricted to pass through another node.

Our contributions can be organized into three parts. We first
establish a correspondence between dynamic programming over
hypergraphs (as introduced in [10] under the name of weighted hy-
pergraphs) and the proof-theoretic definition of the provenance for
Datalog programs. We provide both-way translations and charac-
terize for which class of semirings the best-weight derivation in the
hypergraph corresponds to the provenance of the initial Datalog
program.

The translation we thus introduced permits us to obtain a version
of Knuthâ€™s generalization of Dijkstraâ€™s algorithm to the grammar
problem [13], adapted to the case of Datalog provenance computa-
tion. In the special setting where all hyperedges are of arity 1, we
obtain the classical notion of semiring-based provenance for graph
databases [18]. In the general setting, the algorithm steadily gener-
alizes to Datalog the adapted Dijkstraâ€™s algorithm from [18], under
the same assumptions on the properties of the underlying semiring.
Such algorithm is unlikely to be efficient as-is in practical contexts.
The main issue is closely related to the inefficiency of basic Dat-
alog evaluation: many computations of facts (provenance values)
have already been deduced, leading to redundant computations.
Nevertheless, we show that the semi-naÃ¯ve evaluation strategy for
Datalog is also applicable in our setting. An added advantage is
that it facilitates extending existing Datalog solvers to provenance
annotations and their computation.

We implement our strategy by extending SoufflÃ© [11], a state-of-
the-art Datalog interpreter. We apply our solution to the computa-
tion of the provenance of various graph queries (translated into Dat-
alog programs) on several real-world graph datasets. Experiments
witness that the performance of the implementation competes with
previous dedicated solutions specific to graph databases, while al-
lowing much more expressive queries than the works of [18, 19]:
RPQs only select pairs of vertices joinable by a path whose label
belongs to a given regular language. We focus our experiments

on graph patterns that are combinations and/or unions of RPQs,
using the expressive power of Datalog. We show that for this wider
class of navigational queries, our method performs well in practice.
Notably, the ratio between the running time of our approach com-
pared to plain Datalog evaluation (not tracking the provenance) is
experimentally bounded by a small constant factor. Moreover, in
case of large output DB size, the average number of output tuples
processed by seconds is up to a million, permitting a reasonable
running time in practice for large datasets.

The paper is organized as follows. We start by introducing in
Section 2 basic concepts on semirings and we recall the definition
of provenance for Datalog programs. We formulate and prove in
Section 3 the correspondence between weighted hypergraphs and
semiring-based provenance for Datalog programs. In Section 4, we
present the adapted version of Knuthâ€™s algorithm for the grammar
problem and discuss theoretical aspects of its optimization. We
then dive into the practical aspects of its implementation using
SoufflÃ©, and present in Section 5 experimental results witnessing
the efficiency of our approach for practical scenarios. We finally
discuss in Section 6 the related work. For space reasons, proofs are
deported to an appendix.

2 BACKGROUND
In the following, we recall basic concepts of semiring theory un-
derlying the optimization techniques we provide in this paper. For
more background on the theory and applications of semirings, ex-
amples of relevant semirings, as well as references to the literature
on advanced notions of semiring theory, see [19]. We mostly fol-
low the definitions from [19] and also highlight notions that occur
under different names depending on the application domain.

Definition 1 (Semiring). A semiring is an algebraic structure
(ğ‘†, âŠ•, âŠ—, Â¯0, Â¯1) where ğ‘† is some set, âŠ• and âŠ— are binary operators
over ğ‘†, and Â¯0 and Â¯1 are elements of ğ‘†, satisfying the following
axioms:

â€¢ (ğ‘†, âŠ•, Â¯0) is a commutative monoid: (ğ‘ âŠ• ğ‘) âŠ• ğ‘ = ğ‘ âŠ• (ğ‘ âŠ• ğ‘),

ğ‘ âŠ• ğ‘ = ğ‘ âŠ• ğ‘, ğ‘ âŠ• Â¯0 = Â¯0 âŠ• ğ‘ = ğ‘;

â€¢ (ğ‘†, âŠ—, Â¯1) is a monoid: (ğ‘ âŠ—ğ‘) âŠ—ğ‘ = ğ‘ âŠ— (ğ‘ âŠ—ğ‘), Â¯1âŠ—ğ‘ = ğ‘ âŠ—Â¯1 = ğ‘;
â€¢ âŠ— distributes over âŠ•: ğ‘ âŠ— (ğ‘ âŠ• ğ‘) = (ğ‘ âŠ— ğ‘) âŠ• (ğ‘ âŠ— ğ‘);
â€¢ Â¯0 is an annihilator for âŠ—: Â¯0 âŠ— ğ‘ = ğ‘ âŠ— Â¯0 = Â¯0.

A semiring is commutative if for all ğ‘, ğ‘ âˆˆ ğ‘†, ğ‘ âŠ— ğ‘ = ğ‘ âŠ— ğ‘. A
semiring is idempotent if for all ğ‘ âˆˆ ğ‘†, ğ‘ âŠ• ğ‘ = ğ‘. For an idempotent
semiring we can introduce the natural order defined by ğ‘ â©½ ğ‘
iff ğ‘ âŠ• ğ‘ = ğ‘.1 Note that this order is compatible with the two
binary operations of the semiring: for all ğ‘, ğ‘, ğ‘ âˆˆ ğ‘†, ğ‘ â©½ ğ‘ implies
ğ‘ âŠ• ğ‘ â©½ ğ‘ âŠ• ğ‘ and ğ‘ âŠ— ğ‘ â©½ ğ‘ âŠ— ğ‘. This is also called the monotonicity
property.

An important property is that of k-closedness [17], i.e., a semir-
ing is ğ‘˜-closed if: âˆ€ğ‘ âˆˆ ğ‘†, (cid:201)ğ‘˜+1
ğ‘ğ‘– . Here, by ğ‘ğ‘– we
ğ‘–=0
denote the repeated application of the âŠ— operation ğ‘– times, i.e.,
ğ‘ğ‘– = ğ‘ âŠ— ğ‘ âŠ— Â· Â· Â· âŠ— ğ‘
. 0-closed semirings (i.e., those in which âˆ€ğ‘ âˆˆ
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:125)

ğ‘ğ‘– = (cid:201)ğ‘˜

ğ‘–=0

(cid:124)

(cid:123)(cid:122)
ğ‘–

1There are unfortunately two definitions of natural order commonly found in the
literature; we use here that found in [10, 17] which matches the standard order on
the tropical semiring; other works [9, 15, 19] define it as the reverse order. Our choice
obviously has some impacts: in particular, when defining Datalog provenance, we
need greatest fixpoints in lieu of the least fixpoints used in [9, 15].

Yann Ramusat, Silviu Maniu, and Pierre Senellart

ğ‘†, Â¯1 âŠ• ğ‘ = Â¯1) have also been called absorptive, bounded, or simple
depending on the literature. Note that any 0-closed semiring is
idempotent (indeed, ğ‘ âŠ• ğ‘ = ğ‘ âŠ— (Â¯1 âŠ• Â¯1) = ğ‘ âŠ— Â¯1 = ğ‘) and therefore
admits a natural order.

Huang [10] introduces the notion of superiority of a semiring ğ‘†
with respect to a partial order â©½, defined by: âˆ€ğ‘, ğ‘ âˆˆ ğ‘† ğ‘ â©½ ğ‘ âŠ—ğ‘, ğ‘ â©½
ğ‘ âŠ— ğ‘. The natural order satisfies this notion for 0-closed semirings:
Lemma 2. Let ğ‘† be an idempotent semiring and â©½ the natural order
over ğ‘†. Then ğ‘† is superior with respect to â©½ if and only if ğ‘† is 0-closed.

An easier way of understanding natural order in 0-closed semir-
ings is to note that for any idempotent semiring ğ‘†, Â¯0 is the greatest
element (âˆ€ğ‘ âˆˆ ğ‘†, ğ‘ âŠ•0 = ğ‘ â©½ Â¯0) while, if the semiring is also 0-closed
(i.e., bounded), Â¯1 is the smallest (âˆ€ğ‘ âˆˆ ğ‘†, Â¯1 âŠ• ğ‘ = Â¯1 so Â¯1 â©½ ğ‘). Thus a
bounded semiring ğ‘† verifies Â¯1 â©½ ğ‘ â©½ Â¯0 for all ğ‘ âˆˆ ğ‘†.

Definition 3 (ğœ”-Continuous semiring). An idempotent semiring

(ğ‘†, âŠ•, âŠ—, Â¯0, Â¯1) is ğœ”-continuous if:

(1) (ğ‘†, â©¾) is an ğœ”-complete partial order, i.e., the infimum inf
ğ‘– âˆˆN

ğ‘ğ‘–

of any infinite chain ğ‘0 â©¾ ğ‘1 â©¾ . . . exists in ğ‘†.

(2) both addition and multiplication are ğœ”-continuous in both
arguments, i.e., for all ğ‘ âˆˆ ğ‘† and infinite chain ğ‘0 â©¾ ğ‘1 â©¾
(ğ‘ âŠ— ğ‘ğ‘– ),
. . . , (ğ‘ âŠ• inf
ğ‘– âˆˆN
ğ‘ğ‘– ) âŠ— ğ‘ = inf
( inf
ğ‘– âˆˆN
ğ‘– âˆˆN

ğ‘ğ‘– ) = inf
ğ‘– âˆˆN
(ğ‘ğ‘– âŠ— ğ‘).

(ğ‘ âŠ• ğ‘ğ‘– ), (ğ‘ âŠ— inf
ğ‘– âˆˆN

ğ‘ğ‘– ) = inf
ğ‘– âˆˆN

In such semirings we can define countable sums:

(cid:202)

ğ‘› âˆˆN

ğ‘ğ‘› = inf
ğ‘š âˆˆN

ğ‘š
(cid:202)

ğ‘–=0

ğ‘ğ‘– .

A system of fixpoint equations over an ğœ”-continuous semiring
ğ‘† is a finite set of equations: ğ‘‹1 = ğ‘“1 (ğ‘‹1, ğ‘‹2, . . . , ğ‘‹ğ‘›), . . . , ğ‘‹ğ‘› =
ğ‘“ğ‘› (ğ‘‹1, ğ‘‹2, . . . , ğ‘‹ğ‘›), where ğ‘‹1, . . . , ğ‘‹ğ‘› are variables and ğ‘“1, . . . ğ‘“ğ‘› are
polynomials with coefficients in ğ‘†. We extend the notion of natural
order from semiring elements to tuples of semiring elements by
simply considering the product order. We then have the follow-
ing on solutions of a system of equations over an ğœ”-continuous
semiring:

Theorem 4 (Theorem 3.1 of [15]). Every system of fixpoint equa-
tions X = ğ‘“ (X) over a commutative ğœ”-continuous semiring has a
greatest solution gfp(ğ‘“ ) w.r.t. â©½, and gfp(ğ‘“ ) is equal to the infimum
of the Kleene sequence: gfp(ğ‘“ ) = inf
ğ‘š âˆˆN

ğ‘“ ğ‘š (Â¯0).

We now recall some basics about the Datalog query language
and refer to [1] for more details. A Datalog rule is of the form
ğ‘…( (cid:174)ğ‘¥) :- ğ‘…1 ( (cid:174)ğ‘¥1),
. . . , ğ‘…ğ‘› ( (cid:174)ğ‘¥ğ‘›) with ğ‘…â€™s representing relations of a
given arity and the (cid:174)ğ‘¥â€™s tuples of variables of corresponding arities.
Variables occurring on the left-hand side, the head of the rule,
are required to occur in at least one of the atoms on the right-
hand side, the body of the rule. A Datalog program is a finite set of
Datalog rules. We call fact a rule with an empty body and variables
replaced by constants. We divide relations into extensional ones
(which can only occur as head of a fact, or in rule bodies) and
intensional ones (which may occur as heads of a non-fact rule). The
set of extensional facts is called the extensional database (EDB). We
distinguish one particular relation occurring in the head of a rule,
the output predicate of the Datalog program. We refer to [1] for the
semantics of such a program and the notion of derivation tree.

Efficient Provenance-Aware Querying of Graph Databases with Datalog

path(Paris, London) 1
ğ‘Ÿ2

path(Paris, London) 3

ğ‘Ÿ1

path(Paris, Brussels) 1

edge(Brussels, London) 0

edge(Paris, London) 3

ğ‘Ÿ1

edge(Paris, Brussels) 1

edge(Paris, London) :-

edge(Paris, Brussels) :-

edge(Brussels, London) :-

3
1
0

path(x, y) :- edge(x, y)

dummy

path(x, y) :- path(x, z),

edge(z, y)

ğ‘Ÿ1

ğ‘Ÿ2

Figure 1: Derivation trees along their weights for the fact
path(Paris, London) using the transitive closure Datalog pro-
gram over the tropical semiring with an EDB containing 3
facts.

There are two ways of defining the provenance of a Datalog
program ğ‘ with output predicate ğº over an ğœ”-continuous semiring.
We can first base this definition on the proof-theoretic definition of
standard Datalog:

Definition 5 (Proof-theoretic definition for Datalog provenance
[9]). Let (ğ‘†, âŠ•, âŠ—, Â¯0, Â¯1) be a commutative ğœ”-continuous semiring
and ğ‘ a Datalog program with output predicate ğ‘† and such that all
extensional facts ğ‘…(ğ‘¡ â€²) are annotated with an element of ğ‘†, denoted
ğ‘
ğ‘… (ğ‘¡ â€²). Then the provenance of ğº (ğ‘¡) for ğ‘, where ğº (ğ‘¡) is in
as prov
the output of ğ‘, is defined as:

ğ‘
ğº (ğ‘¡) =
prov

(cid:202)

ğœ yields ğ‘¡

(cid:204)

(cid:169)
(cid:173)
ğ‘¡ â€² âˆˆ leaves(ğœ)
(cid:171)

ğ‘
ğ‘… (ğ‘¡ â€²)(cid:170)
prov
(cid:174)
(cid:172)

.

The first sum ranges over all the derivation trees of the fact ğ‘¡
(see Figure 1 for examples of derivation trees), the second sum
ranges over all leaves of the tree (extensional facts). This definition
describes how the provenance propagates across the deduction
process given an initial assignment of provenance weights to the
ğ‘
extensional relations of ğ‘, prov
ğ‘….

Example 6. The tropical semiring is (R+ âˆª {âˆ}, min, +, âˆ, 0). It is
a 0-closed (and thus idempotent) ğœ”-continuous semiring. We show
in Figure 1 an example Datalog program (bottom right) with tropical
semiring annotations on extensional edge facts, as well as the (only)
two derivation trees of the fact path(Paris, London) along their
weight. This witnesses that the provenance of path(Paris, London)
is min(1 + 0, 3) = 1.

Since some tuples can have infinitely many derivations, the
Datalog semantics of Definition 5 cannot be used as an algorithm.
As pointed out in [9], it is possible instead to use a fixpoint-theoretic
definition of the provenance of a Datalog query ğ‘: introduce a fresh
variable for every possible intensional tuple (i.e., every possible
ground atom), and produce for this variable an equation that reflects
the immediate consequence operator Tğ‘ â€“ extensional facts appearing
as their semiring annotations in these equations. This yields a
system of fixpoint equation ğ‘“ğ‘. The provenance of ğº (ğ‘¡) for ğ‘ is now
simply the value of the variable corresponding to ğº (ğ‘¡) in gfp(ğ‘“ğ‘).
The fixpoint-theoretic definition directly yields an algorithm,
albeit a very inefficient one because of the need of generating a
rule for every intensional tuple.

3 DATALOG PROVENANCE AND DYNAMIC
PROGRAMMING OVER HYPERGRAPHS
We now show how to convert a Datalog program into a weighted
hypergraph (as introduced in [10]) and characterize the semirings
where the best-weight derivation in the hypergraph corresponds
to the provenance for the initial Datalog program, mimicking the
proof-theoretic definition. We first recall basic definitions and no-
tation related to hypergraphs.

Definition 7 (Weighted hypergraph [10]). Given a semiring ğ‘†, a
weighted hypergraph on ğ‘† is a pair ğ» = âŸ¨ğ‘‰ , ğ¸âŸ©, where ğ‘‰ is a finite
set of vertices and ğ¸ is a finite set of hyperedges, and each element
ğ‘’ âˆˆ ğ¸ is a triple ğ‘’ = âŸ¨â„(ğ‘’), T(ğ‘’), ğ‘“ğ‘’ âŸ© with â„(ğ‘’) âˆˆ ğ‘‰ its head vertex,
T(ğ‘’) âˆˆ ğ‘‰ an ordered list of tail vertices and ğ‘“ğ‘’ a weight function
from ğ‘† |T(ğ‘’) | to ğ‘†.

We note |ğ‘’ | = |T(ğ‘’)| the arity of a hyperedge. If |ğ‘’ | = 0, we say ğ‘’
is nullary and then ğ‘“ğ‘’ () is a constant, an element of the semiring;
we assume there exists at most one nullary edge for a given vertex.
In that case, ğ‘£ = â„(ğ‘’) is called a source vertex and we note ğ‘“ğ‘’ () as ğ‘“ğ‘£.
The arity of a hypergraph is the maximum arity of any hyperedge.
The backward-star BS(ğ‘£) of a vertex ğ‘£ is the set of incoming hy-
peredges {ğ‘’ âˆˆ ğ¸ | â„(ğ‘’) = ğ‘£ }. The graph projection of a hypergraph
ğ» = âŸ¨ğ‘‰ , ğ¸âŸ© is a directed graph ğº = (ğ‘‰ , ğ¸ â€²) where ğ¸ â€² = {(ğ‘¢, ğ‘£) |
âˆƒğ‘’ âˆˆ BS(ğ‘£), ğ‘¢ âˆˆ T(ğ‘’)}. A hypergraph ğ» is acyclic if its graph pro-
jection ğº is acyclic; then a topological ordering of ğ» is an ordering
of ğ‘‰ that is a topological ordering of ğº.

With these definitions in place, we can encode a Datalog pro-
gram with semiring annotations as a weighted hypergraph in a
straightforward manner:

Definition 8 (Hypergraph representation of a Datalog program).
Given a Datalog program ğ‘ described with a set of rules {ğ‘1, . . . , ğ‘ğ‘› }
and the semiring ğ‘† used for annotations, we define the weighted
hypergraph representation of ğ‘ as ğ»ğ‘ = âŸ¨ğ‘‰ğ‘, ğ¸ğ‘âŸ© with ğ‘‰ğ‘ being
all ground atoms and, for each instantiation of a rule ğ‘¡ ( (cid:174)ğ‘¥) â†
ğ‘Ÿ1 ( (cid:174)ğ‘¥1), . . . , ğ‘Ÿğ‘› ( (cid:174)ğ‘¥ğ‘›), a corresponding edge âŸ¨ğ‘¡ ( (cid:174)ğ‘¥), (ğ‘Ÿ1 ( (cid:174)ğ‘¥1), . . . , ğ‘Ÿğ‘› ( (cid:174)ğ‘¥ğ‘›)),
âŠ—âŸ©. For a fact ğ‘…( (cid:174)ğ‘¥) âˆˆ EDB(ğ‘) we add a nullary edge ğ‘’ with â„(ğ‘’) =
ğ‘
ğ‘… ( (cid:174)ğ‘¥).
ğ‘…( (cid:174)ğ‘¥) and ğ‘“ğ‘’ = prov

The notion of derivations is the hypergraph counterpart to paths
in graph. We recall the definition of derivations and we define it in
a way that is reminiscent of Datalog-related notions.

Definition 9 (Derivation in hypergraph [10]). We recursively de-
fine a derivation ğ· of a vertex ğ‘£ in a hypergraph ğ» (as a pair formed
of a hyperedge and a list of derivations), its size |ğ· | (a natural
integer) and its weight ğ‘¤ (ğ·) (a semiring element) as follows:

â€¢ If ğ‘’ âˆˆ BS(ğ‘£) with |ğ‘’ | = 0, then ğ· = âŸ¨ğ‘’, âŸ¨âŸ©âŸ© is a derivation of

ğ‘£, |ğ· | = 1, and ğ‘¤ (ğ·) = ğ‘“ğ‘’ ().

â€¢ If ğ‘’ âˆˆ BS(ğ‘£) with |ğ‘’ | â©¾ 0, ğ·ğ‘– is a derivation of ğ‘‡ğ‘– (ğ‘’) for
ğ‘– = 1 . . . |ğ‘’ |, then ğ· = âŸ¨ğ‘’, âŸ¨ğ·1 Â· Â· Â· ğ· |ğ‘’ |âŸ©âŸ© is a derivation of ğ‘£,
|ğ· | = 1 + (cid:205)|ğ‘’ |
ğ‘–=1

|ğ·ğ‘– |, ğ‘¤ (ğ·) = ğ‘“ğ‘’ (ğ‘¤ (ğ·1), . . . , ğ‘¤ (ğ· |ğ‘’ |)).

We note Dğ» (ğ‘£) the set of derivations of ğ‘£ in ğ» .

When modeling Datalog provenance in a semiring ğ‘† as weighted
hypergraphs on ğ‘†, all non-source weight functions are bound to
the âŠ— operation of the semiring. Note that, if ğ‘† is idempotent, the

natural order on ğ‘† induces an ordering on derivations: ğ· â©½ ğ· â€² if
ğ‘¤ (ğ·) â©½ ğ‘¤ (ğ· â€²).

We now show that in this formalism, the Datalog provenance of
an output predicate can be understood as the best-weight for the
corresponding vertex in the hypergraph.

Definition 10 (Best-weight [10]). The best-weight ğ›¿ğ» (ğ‘£) of a ver-
tex ğ‘£ of a hypergraph ğ» on a semiring (ğ‘†, âŠ•, âŠ—, Â¯0, Â¯1) is the weight
of the best derivation of ğ‘£:

ğ›¿ğ» (ğ‘£) =

(cid:26) ğ‘“ğ‘£
(cid:201)

ğ· âˆˆDğ» (ğ‘£)

ğ‘¤ (ğ·)

if v is a source vertex;
otherwise.

The best-weight generally requires additional properties of either
the hypergraph or the semiring to be well-defined. Acyclicity for
the hypergraph is a sufficient condition. Existence of an infinitary
summation operator in the semiring extending âŠ•, guaranteed in
ğœ”-continuous semirings, is also a sufficient condition. To guarantee
semantics compatible with the intuitive meaning of provenance,
a more restrictive sufficient condition is for the semiring to be a
ğ‘-complete star-semiring [14], see [19] for details.

We can now show that Datalog provenance can be computed
through the formalism of weighted hypergraphs. Let us start with
a lemma exhibiting a one-to-one mapping between derivations in
the hypergraph and proofs in Datalog.

Lemma 11. For any Datalog query ğ‘ and grounding of an atom ğ‘£

of ğ‘, there is a bijection between Dğ»ğ‘ (ğ‘£) and {ğœ | ğœ yields ğ‘£ }.

We then show that the weight of each derivation of a tuple is

equal to the corresponding proof tree weight in Datalog.

Lemma 12. For any Datalog query ğ‘ and grounding of an atom ğ‘£

of ğ‘, for any derivation ğ· of ğ‘£ in ğ»ğ‘ we have
ğ‘
ğ‘… (ğ‘¡ â€²)
prov

ğ‘¤ (ğ·) =

(cid:204)

ğ‘¡ â€² âˆˆ ğ‘™ğ‘’ğ‘ğ‘£ğ‘’ğ‘  (ğœğ· )
where ğœğ· is the proof tree corresponding to ğ· in the bijection given
by Lemma 11.

Finally, we obtain:

Theorem 13. Let ğ‘¡ be a tuple of a Datalog program ğ‘ with output
ğ‘
predicate ğº and ğ»ğ‘ its hypergraph representation, then prov
ğº (ğ‘¡) =
ğ›¿ğ»ğ‘ (ğº (ğ‘¡)).

4 BEST-FIRST METHOD
Knuth [13] generalized the Dijkstra algorithm to what he calls the
grammar problem (i.e., finding the best-weight derivation from a
given non-terminal, where each terminal has a specific weight and
each rule comes with an associated weight function). This has been
identified as corresponding to the search problem in a monotonic
superior hypergraph â€“ i.e., for each ğ‘’ âˆˆ ğ» , ğ‘“ğ‘’ is monotone and
superior in each argument (see Table 3 in [10]). We showed in
Lemma 2 that superiority corresponds to 0-closedness in semirings
with natural orders. The definition of the grammar problem assumes
a total order on weights as the weights are real numbers. In the
special case where all hyperedges are of arity 1 (and all weight
functions bound to âŠ—), we obtain the classical notion of semiring-
based provenance for graph databases [18]. Thus, Knuthâ€™s algorithm
can be seen as a generalization to hypergraphs (and therefore, by the

Yann Ramusat, Silviu Maniu, and Pierre Senellart

results of the previous section, to Datalog provenance computation)
of the modified Dijkstra algorithm from [18], working on 0-closed
totally-ordered semirings, which are generalizations of the tropical
semiring.

Optimized version of Best-First method. In the original paper of
Knuth [13], the question of efficient construction of the set of candi-
date facts for the extraction of the minimal-valued fact is not dealt
with. A lot of redundant work may be carried out if the implemen-
tation is not carefully designed.

In the following, we show how to obtain a ready-to-be-implemen-
ted version incorporating ideas from the semi-naÃ¯ve evaluation of
Datalog programs. Semi-naÃ¯ve evaluation of Datalog, as described
in [1, Chapter 13] introduces a number of ideas aiming at improving
the efficiency of the naÃ¯ve Datalog evaluation method; we show
how to leverage them in our setting.

The naÃ¯ve evaluation of a Datalog program ğ‘ processes iteratively,
applying at each step the consequence operator Tğ‘. Many redundant
derivations are computed, leading to practical inefficiency. The
semi-naÃ¯ve evaluation addresses this problem by considering only
facts derived using at least one new fact found at the previous step.
Note, however, that while many new facts can be found at one
step of the semi-naÃ¯ve evaluation, only one is to be added by the
Best-First method to respect the â©½-minimality ordering of added
facts.

Algorithm 1 Basic semi-naÃ¯ve version of Best-First method for
Datalog provenance
Require: Datalog query ğ‘, EDB ğ· with provenance indications over a

0-closed totally-ordered semiring ğ‘†.

Ensure: full Datalog provenance for the IDB of ğ‘.
1: function Relax(ğ‘Ÿ0 ( (cid:174)ğ‘¥0), ğ‘†)
2:

for each instantiation of a rule

ğ‘Ÿ ( (cid:174)ğ‘¥) â† ğ‘Ÿ1 ( (cid:174)ğ‘¥1), . . . , ğ‘Ÿğ‘š ( (cid:174)ğ‘¥ğ‘š), . . . , ğ‘Ÿğ‘› ( (cid:174)ğ‘¥ğ‘›)

where ğ‘Ÿğ‘– ( (cid:174)ğ‘¥ğ‘– ) âˆˆ ğ· âˆª ğ‘† âˆª {ğ‘Ÿ0 ( (cid:174)ğ‘¥0) }, 1 â©½ ğ‘– < ğ‘š, ğ‘Ÿğ‘š ( (cid:174)ğ‘¥ğ‘š) = ğ‘Ÿ0 ( (cid:174)ğ‘¥0) and
ğ‘Ÿğ‘– ( (cid:174)ğ‘¥ğ‘– ) âˆˆ ğ· âˆª ğ‘†, ğ‘š < ğ‘– â©½ ğ‘› do

ğœˆ (ğ‘Ÿ ( (cid:174)ğ‘¥)) âŠ•= (cid:203)
1â©½ğ‘– â©½ğ‘›

ğ‘Ÿğ‘– ( (cid:174)ğ‘¥ğ‘– )

3:

4:
5: ğ¼ â† âˆ…
6: Let ğœˆ be the function that maps all facts of ğ· to their annotation in ğ‘†

and all potential facts of the intensional schema of ğ‘ to Â¯0

7: for each intensional atom ğ‘Ÿ ( (cid:174)ğ‘¥) âˆ‰ğ¼ do
8:

for each instantiation of a rule ğ‘Ÿ ( (cid:174)ğ‘¥) â† ğ‘Ÿ1 ( (cid:174)ğ‘¥1), . . . , ğ‘Ÿğ‘› ( (cid:174)ğ‘¥ğ‘›) with

ğ‘Ÿğ‘– ( (cid:174)ğ‘¥ğ‘– ) âˆˆ ğ· do

ğ‘Ÿğ‘– ( (cid:174)ğ‘¥ğ‘– )

9:

ğœˆ (ğ‘Ÿ ( (cid:174)ğ‘¥)) âŠ•= (cid:203)
1â©½ğ‘– â©½ğ‘›
10: while minğœˆ\ğ¼ ğ‘Ÿ ( (cid:174)ğ‘¥) â‰  Â¯0 do
11:
12:
13: return ğœˆ

Add such minimal ğ‘Ÿ ( (cid:174)ğ‘¥) to ğ¼
Relax(ğ‘Ÿ ( (cid:174)ğ‘¥), ğ¼ \ ğ‘Ÿ ( (cid:174)ğ‘¥))

This algorithm starts by initializing the priority queue with IDB
facts that are derivable from EDB facts. Then, at each step, the
minimum valued-fact is added, and only derivations using this
new fact are computed to update the value of the facts in ğ¼ . This
algorithm stops whenever: 1. the maximal value is reached for a
candidate fact, or 2. the list is empty - the minimal value of the list
is by default the maximal value of the semiring.

Efficient Provenance-Aware Querying of Graph Databases with Datalog

Theorem 14. Algorithm 1 computes the full Datalog provenance

for 0-closed totally-ordered semirings.

Precedence graph. The structure of the Datalog program can be
analysed to provide clues about the predicates to focus on. Follow-
ing [1], we introduce the notion of precedence graph ğºğ‘ƒ of a Datalog
program ğ‘ƒ. The nodes are the IDB predicates and the edges are
pairs of IDB predicates (ğ‘…, ğ‘…â€²) where ğ‘…â€² occurs at the head of a rule
of ğ‘ƒ with ğ‘… belonging to the tail. ğ‘ƒ is a recursive program if ğºğ‘ƒ has
a directed cycle. Two predicates ğ‘… and ğ‘…â€² are mutually recursive
if ğ‘… = ğ‘…â€² or ğ‘… and ğ‘…â€² participate in the same cycle of ğºğ‘ƒ . This
defines equivalence classes. Following a topological ordering on the
equivalence classes, Algorithm 1 is sequentially applied to compute
the IDB predicates in the current equivalence class, considering
previous equivalence classes as EDB predicates. SoufflÃ© natively
supports this optimization.

Generalization to distributive lattices. In [19], a new algorithm
was introduced for single-source provenance in graph databases
over 0-closed multiplicatively idempotent semirings (equivalent to
distributive lattices). That method is relevant for semirings that are
0-closed but for which Dijkstraâ€™s algorithm is not directly applicable
as the semiring is not totally ordered. A similar gap also appears
when we consider provenance over Datalog queries (see Section 6).
Thus, we show how to apply the method from [19] for computing
provenance for Datalog queries over distributive lattices.

Algorithm 2 Generalized Best-first method for Datalog provenance
Require: ğ‘ a Datalog query with provenance indication over a 0-closed

multiplicatively idempotent semiring ğ‘†.
Ensure: full Datalog provenance for the IDB of ğ‘.
1: for each EDB fact ğ‘… ( (cid:174)ğ‘¥): Decompose(ğ‘… ( (cid:174)ğ‘¥))
2: for each dimension ğ‘– : ğœˆğ‘– â† Best-first(ğ‘, ğ‘–)
3: return Recompose(ğœˆ1, . . . , ğœˆğ‘›)

We provide a brief review of the key ideas presented in [19].
Any element of a distributive lattice is decomposable into a prod-
uct of join-irreducible elements of the lattice, and there exists an
embedding of the distributive lattice into a chain decomposition
of its join-irreducible elements. This ensures we can 1) work on
a totally ordered environment and apply algorithms that require
total ordering over the elements, 2) independently compute par-
tial provenance annotations for each dimension to form the final
provenance annotation. Given ğ‘š the number of dimensions in the
decomposition, our solution (described in Algorithm 2) performs
ğ‘š launches of the Best-First method and thus, roughly has a cost
increased by a factor ğ‘š.

5 IMPLEMENTATION AND EXPERIMENTS
In numerous application domains, Datalog is used as a domain
specific language (DSL) to express logical specifications for static
program analysis. A formal specification, written as a declarative
Datalog program is usually translated into an efficient imperative
implementation by a synthesizer. This process simplifies the devel-
opment of program analysis compared to hand-crafted solutions
(highly optimized C++ applications specialized in enforcing a fixed
set of specifications). SoufflÃ© [11, 20] has been introduced to pro-
vide efficient synthesis of Datalog specifications to executable C++

programs, competing with state-of-the-art handcrafted code for
program analysis. The inner workings of SoufflÃ© were of interest
to our work; the algorithm implementations are similar to the eval-
uation strategy followed by the Best-First method we introduced
here. We present a brief overview of the architecture of SoufflÃ©
and discuss how we extended it.

Architecture and implementation. Following what is described
in [11], an input datalog program ğ‘ goes through a staged specializa-
tion hierarchy. After parsing, the first stage of SoufflÃ© specializes
the semi-naÃ¯ve evaluation strategy applied to ğ‘, yielding a relational
algebra machine program (RAM). Such a program consists in ba-
sic relational algebra operations enriched with I/O operators and
fix-point computations. As a final step, the RAM program is finally
either interpreted or compiled into an executable. For this work,
we have only used the interpreter. Our code was inserted in two
different stages of SoufflÃ©: a new translation strategy from the
parsed program to the RAM program, a priority queue, replacing
the code in charge of adding at run-time the tuples to the relations.

Algorithm 3 Input Datalog program computing the transitive
closure (SoufflÃ© syntax)

.decl edge(s:number, t:number[, @prov:semiring value])
.decl path(s:number, t:number[, @prov:semiring value])
.input edge .output path

1:
2:
3:
4: path(x, y) :- edge(x, y).
5: path(x, y) :- path(x, z), edge(z, y).

Algorithm 4 Corresponding SoufflÃ© RAM program for Algo-
rithm 3

1: if Â¬(edge = âˆ…) then
for t0 in edge do
2:
3:
4:

add (t0.0, t0.1) in path
add (t0.0, t0.1) in ğ›¿path

5: loop
6:
7:
8:
9:
10:

if Â¬(ğ›¿path = âˆ…) âˆ§ Â¬(edge = âˆ…) then

for t0 in ğ›¿path do

for t1 in edge on index t1.0 = t0.1 do

if Â¬(t0.0, t0.1) âˆˆ path then
add (t0.0, t0.1) in pathâ€™

11:
12:
13:
14:

if pathâ€™ = âˆ… then exit
for t0 in pathâ€™: add (t0.0, t0.1) in path
swap ğ›¿path with pathâ€™
clear path

We showcase the result of our translation strategy in Algo-
rithms 4 and 5 for a Datalog query computing the transitive closure
of a graph; this program is given in Algorithm 3 in its SoufflÃ©
syntax. Algorithm 4 presents the corresponding SoufflÃ© RAM pro-
gram resulting from applying the semi-naÃ¯ve evaluation strategy
and Algorithm 5 our modification to the RAM program to pro-
vide provenance annotation via the Best-First strategy and use
the priority queue pq for provenance computation. The âŠ¥ nota-
tion corresponds to a wildcard. Importantly, modifying directly at
the RAM level of SoufflÃ© allows us to benefit of all implemented
optimizations.

Yann Ramusat, Silviu Maniu, and Pierre Senellart

)
s
(

e
m

i
t

100 000

10 000

1 000

100

10

1

0.1

)
s
(

e
m

i
t

Rome99

USPowerGrid

Yeast

Stif

SoufflÃ©

NodeElim-Id

NodeElim-Degree

SoufflÃ©-prov

Rome99

USPowerGrid

Yeast

Stif

BFS

SoufflÃ©

Dijkstra

Mohri

SoufflÃ©-prov

1

0.1

0.01

0.001

Figure 2: Comparison between algorithms for all-pairs
shortest-distances (tropical semiring). Values greater than
100 000 s are timeouts.

Figure 3: Comparison between algorithms for single-source
shortest-distances (tropical semiring).

Table 1: Computation times (in seconds), provenance overhead ratio, size of the output DB (million tuples), and throughput
(million tuples/second), for a selection of graph patterns.

Dataset

Rome99
PowerGrid
Yeast
Stif

ğ‘Ÿ

14.2
.079
.577
491

SoufflÃ©
ğ‘2
ğ‘1
6.45
.068
.028
.011
7.65
.131
oom
50.6

SoufflÃ©-prov

Ratio

Output DB size

ğ‘3
.556
.021
1.30
oom

ğ‘Ÿ

52.2
.202
1.88
2081

ğ‘1
.134
.019
.264
141

ğ‘2
20.1
.050
25.2
oom

ğ‘3
1.82
.035
3.73
oom

ğ‘Ÿ

3.68
2.56
3.26
4.24

ğ‘1
1.97
1.45
2.02
2.79

ğ‘2
3.11
1.78
3.56
n/a

ğ‘3
3.26
1.67
2.87
n/a

ğ‘Ÿ

1.12
.044
.487
313

ğ‘1
.005
0
ğœ–
.068

ğ‘2
16.5
.006
19.9
n/a

ğ‘3
1.31
.004
3.02
n/a

ğ‘Ÿ

.792
.556
.844
.151

Throughput
ğ‘2
ğ‘1
.820
.047
.130
n/a
.789
n/a
ğœ–
n/a

ğ‘3
.718
.119
.808
n/a

Algorithm 5 Modification of RAM program of Algorithm 4 to
implement Best-First strategy

1: if Â¬(edge = âˆ…) then
2:
3:

for t0 in edge: update (t0.0, t0.1, t0.prov) in path
for t0 in path: add (t0.0, t0.1, t0.prov) in ğ›¿path

4: loop
5:
6:
7:
8:
9:

if Â¬(ğ›¿path = âˆ…) âˆ§ Â¬(edge = âˆ…) then

for t0 in ğ›¿path do

for t1 in edge on index t1.0 = t0.1 do
if Â¬(t0.0, t1.1, âŠ¥) âˆˆ path then

update (t0.0, t0.1, t0.prov âŠ— t1.prov) in pq

10:
11:
12:

clear ğ›¿path
if pq is empty then exit
add pq.top() in pq.top().relation and in pq.top().ğ›¿relation

Experiments. Our implementation was tested on an Intel Xeon
E5-2650 computer with 176 GB of RAM. The source code will be
made available once anonymity requirements are removed.

To translate querying over graphs into Datalog query evaluation,
the graph structure has been encoded into an EDB with one binary
predicate edge encoding the edges, and with edge notations depend-
ing on the provenance semiring we chose. We run the transitive
closure Datalog program outlined in Algorithm 3. We use the same
datasets as those used in [19], see [16, 19] for their description and
where to download them.

We provide in Figure 2 a comparison between the Best-First
method introduced here (SoufflÃ©-prov), the plain SoufflÃ© with-
out provenance computation, and a previous provenance compu-
tation algorithm from [19] computing all-pairs shortest-distances
over graph databases (the NodeElimination algorithm, with a
choice of node to eliminate based on its id or its degree), in the
tropical semiring. Similarly, in Figure 3, we compare with previous
solutions for single-source shortest-distances, in the same semir-
ing, in particular the adaptation of the Dijkstra algorithm of [19],
and, for comparison purposes, a bread-first-search (Bfs) algorithm
that simply navigates the graph from the source node but does not
compute provenance.

The main focus of this work was to provide an effective Datalog
based solution for all-pairs provenance in graph databases. For
the all-pairs problem, depending on the dataset, (see, e.g., Yeast),
SoufflÃ©-Prov is significantly faster than the previous best known
algorithm, NodeElimination. Unsurprisingly, BFS and Dijkstra
perform respectively better than SoufflÃ© and SoufflÃ©-prov in the
single-source context. What favors both graph algorithms strongly
is the fact that they reduce redundant computation: the algorithms
abort whenever the target vertex has been reached. SoufflÃ©-prov
performs between 1 and 2 orders of magnitude faster than Mohri
[17] â€“ an algorithm designed for single-source provenance on ğ‘˜-
closed semirings. This fact highlights the potential of adapting the
best-first method to also handle ğ‘˜-closed semirings.

Previous work [19] addressing provenance computation for graph
databases was restricted to RPQs. We now turn to evaluating this
approach for more intricate graph patterns. Patterns considered are

Efficient Provenance-Aware Querying of Graph Databases with Datalog

combinations and/or unions of RPQs. The output is moreover not
restricted to pairs, but can be of any arbitrary arity. For instance, this
allows retrieval of intermediate nodes on a path when computing
graph reachability. On the same datasets, we label their edges with
two distinct labels, ğ‘ and ğ‘, in an uniform random manner. After
this process, some edges have disappeared (neither labeled with ğ‘
nor ğ‘), some appear two times (labeled with ğ‘ and ğ‘, with different
weights), or are only associated to one label. The final size of the
modified datasets did not change significantly. Table 1 provides a
summary of the experiments we conducted over three distinct pat-
terns ğ‘1, ğ‘2, and ğ‘3, described in the following. Pattern ğ‘1 (ğ‘¥, ğ‘¦, ğ‘§)
:- ğ‘…ğ‘ (ğ‘¥, ğ‘¦), ğ‘…ğ‘+ (ğ‘¦, ğ‘§), ğ‘…ğ‘ (ğ‘§, ğ‘¥) selects triplets of vertices that are tri-
angles in the graph, with one side being a ğ‘ path of arbitrary
length. Pattern ğ‘2 (ğ‘¤, ğ‘¥, ğ‘¦, ğ‘§) :- ğ‘…ğ‘+ (ğ‘¤, ğ‘¥), ğ‘…ğ‘+ (ğ‘¥, ğ‘¦), ğ‘…ğ‘+ (ğ‘¦, ğ‘§) selects
quadruplets of vertices with two hops, and pattern ğ‘3 (ğ‘¤, ğ‘¥, ğ‘¦, ğ‘§) :-
ğ‘…ğ‘+ (ğ‘¤, ğ‘¥), ğ‘…ğ‘ (ğ‘¥, ğ‘¦), ğ‘…ğ‘+ (ğ‘¦, ğ‘§) is a slight variation of ğ‘2. We perform
the same experiments as for the reachability queries before, and
we indicate the ratio between computation time with or without
provenance tracking. The results show that the overhead induced
by our provenance approach stays within a constant factor, roughly
between 2 and 4, depending on the dataset and pattern. Finally,
as observed in the Yeast dataset, the chosen pattern can strongly
impact the output DB size: almost negligible having around 100
tuples for pattern ğ‘1, or extremely large having 19 million tuples
for pattern ğ‘2. In order to provide a meaningful comparison, we
also measure the throughput, consisting in the average number of
output tuples processed per second. For smaller output DB sizes,
this measure is less relevant, as the fixed costs of running SoufflÃ©-
prov dominate the overall running time. Overall, these results are
promising, as our method has the potential to process 1M tuples
per second when the query output is large.

6 RELATED WORK
With respect to Datalog provenance, it has been shown in [6] that,
for a Datalog program having ğ‘› candidate IDB tuples, a circuit
for representing Datalog provenance in the semiring Sorp(ğ‘‹ ) (the
most general absorptive semiring) only needs ğ‘› + 1 layers. For
binary relations, e.g., representing the edge relation of a graph,
this construction is at least quadratic in the number of vertices,
thus not practically applicable for the graphs we analyzed in our
experiments. Similarly, in [7], absorptive semirings (i.e., 0-closed
semirings) have the property that derivation trees of size â©¾ ğ‘› are
â€œpumpableâ€ (they do not contribute to the final result). A concrete
implementation [8] computes the provenance for commutative and
idempotent semirings using ğ‘› Newton iterations.

Fairly recently, [12] introduced POPS (Partially Ordered, Pre-
Semiring), a structure decoupling the order on which the fixed-point
is computed from the semiring structure. Complex and recursive
computations over vectors, matrices, tensors are now expressible
using this framework. The study also generalized the semi-naÃ¯ve
method from plain Datalog evaluation to idempotent semirings (aka
dioids). In comparison, our method is restricted to semirings that
are totally ordered (a subclass of distributive dioids2), leveraging

2Distributive dioids are POPS structures over a distributive lattice being the natural
order of the dioid.

the invariant that once a fact is first labeled with a provenance
value, we are certain it is the correct one.

In cases where keeping the full provenance of a program (how-
provenance) is still prohibitively large, [4, 5] propose to select only
a relevant subset of such trees using selection criteria based on
tree patterns and ranking over rules and facts occurring in the
derivation. First, given a Datalog program ğ‘ƒ and a pattern ğ‘, an
offline instrumentation is performed, leading to an instrumented
program ğ‘ƒğ‘. Then, given any database ğ·, an efficient algorithm can
be used to retrieve only the top-ğ‘˜ best derivation trees for ğ‘ƒğ‘ (ğ·).
The top-1 algorithm of the study is closely related to our solution,
but does not mention the use of a priority queue nor does it take into
account the optimization provided by the semi-naÃ¯ve evaluation
strategy we describe in Section 4.

Our solution can be seen as a hybrid of the ideas introduced
in [12] and [5]. We generalize the semi-naÃ¯ve evaluation to a specific
class of semirings in order to achieve a more efficient algorithm,
one that can be used in practical real-world scenarios.

7 CONCLUSION
In this work, we developed a novel method for Datalog provenance
computation based on the link between dynamic programming
over hypergraphs and the proof structure of provenance of Dat-
alog programs. We introduced Knuthâ€™s algorithm for computing
the provenance, and optimized it for practical use. We showed its
feasibility by providing an implementation on top of SoufflÃ© and
tested it on several graph databases and matching patterns.

We proved in this paper that optimization methods for graph
provenance naturally extend to Datalog provenance, for certain
classes of semirings playing a major role in practical applications.
The previous work targeting provenance computations for graph
databases in the framework of [18] and [19] only considered RPQs,
which are a strict subset of the expressive capabilities of Datalog.
We thus have extended the supported set of queries for provenance-
aware interrogation of graph databases, maintaining the practical
efficiency of the approach. The theoretical complexity of the intro-
duced method is not fully understood yet; we plan to address this
in future work.

The internals of SoufflÃ©, targeting the inflationary computa-
tion of the fixed-point operator lack support for updating tuples.
We conjecture we could mitigate the overhead induced by prove-
nance computations within SoufflÃ©-prov by adding primitives in
their data structures. What remains to be established is to what
extent these data structures [11] could be extended to handle up-
dates, without reducing the efficiency of SoufflÃ©â€™s current set of
operators.

ACKNOWLEDGMENTS
This work has been funded by the French government under man-
agement of Agence Nationale de la Recherche as part of the â€œIn-
vestissements dâ€™avenirâ€ program, reference ANR-19-P3IA-0001 (PR-
AIRIE 3IA Institute).

REFERENCES
[1] Serge Abiteboul, Richard Hull, and Victor Vianu. Foundations of Databases.

Addison-Wesley, 1995.

[2] Pablo BarcelÃ³. Querying graph databases. In PODS, pages 175â€“188, New York,

[3]

2013. ACM.
James Cheney, Laura Chiticariu, and Wang Chiew Tan. Provenance in databases:
Why, how, and where. Found. Trends Databases, 1(4):379â€“474, 2009.

[4] Daniel Deutch, Amir Gilad, and Yuval Moskovitch. selP: selective tracking and

presentation of data provenance. In ICDE, pages 1484â€“1487, 2015.

[5] Daniel Deutch, Amir Gilad, and Yuval Moskovitch. Efficient provenance tracking

for datalog using top-k queries. The VLDB Journal, 27:245â€“269, 2018.

abs/2105.14435, 2021.

[13] Donald E. Knuth. A generalization of Dijkstraâ€™s algorithm. Information Processing

Letters, 6(1), 1977.

[14] Daniel Krob. Monoides et semi-anneaux complets. In Semigroup Forum, vol-

ume 36, pages 323â€“339. Springer, 1987.

[15] Werner Kuich. Semirings and formal power series: Their relevance to formal
languages and automata. In Handbook of Formal Languages, volume 1, chapter 9,
pages 609â€“677. Springer, 1997.

[6] Daniel Deutch, Tova Milo, Sudeepa Roy, and Val Tannen. Circuits for Datalog

[16] Silviu Maniu, Pierre Senellart, and Suraj Jog. An Experimental Study of the

Yann Ramusat, Silviu Maniu, and Pierre Senellart

[7]

Provenance. In ICDT, pages 201â€“212, 2014.
Javier Esparza and Michael Luttenberger. Solving fixed-point equations by
derivation tree analysis. In CALCO, pages 19â€“35, 2011.
Javier Esparza, Michael Luttenberger, and Maximilian Schlund. Fpsolve: A
generic solver for fixpoint equations over semirings. In CIAA, pages 1â€“15, 2014.
[9] Todd J. Green, Grigoris Karvounarakis, and Val Tannen. Provenance semirings.

[8]

In PODS, 2007.

Treewidth of Real-World Graph Data. In ICDT, pages 12:1â€“12:18, 2019.

[17] Mehryar Mohri. Semiring frameworks and algorithms for shortest-distance

problems. J. Autom. Lang. Comb., 7(3):321â€“350, 2002.

[18] Yann Ramusat, Silviu Maniu, and Pierre Senellart. Semiring provenance over

graph databases. In TaPP, 2018.

[19] Yann Ramusat, Silviu Maniu, and Pierre Senellart. Provenance-based algorithms

for rich queries over graph databases. In EDBT, pages 73â€“84, 2021.

[10] Liang Huang. Advanced dynamic programming in semiring and hypergraph

[20] Bernhard Scholz, Herbert Jordan, Pavle SubotiÄ‡, and Till Westmann. On fast

frameworks. In COLING, pages 1â€“18, 2008.

large-scale program analysis in datalog. In CC, page 196â€“206, 2016.

[11] Herbert Jordan, Bernhard Scholz, and Pavle SubotiÄ‡. SoufflÃ©: On synthesis of

[21] Pierre Senellart. Provenance in databases: Principles and applications. In Rea-

program analyzers. In CAV, pages 422â€“430, 2016.

soning Web, pages 104â€“109, 2019.

[12] Mahmoud Abo Khamis, Hung Q. Ngo, Reinhard Pichler, Dan Suciu, and
Yisu Remy Wang. Convergence of datalog over (pre-) semirings. CoRR,

Efficient Provenance-Aware Querying of Graph Databases with Datalog

A PROOFS FOR SECTION 2 (BACKGROUND)

Lemma 2. Let ğ‘† be an idempotent semiring and â©½ the natural order over ğ‘†. Then ğ‘† is superior with respect to â©½ if and only if ğ‘† is 0-closed.

Proof. First assume ğ‘† superior with respect to â©½. Then for any ğ‘, Â¯1 â©½ Â¯1 âŠ— ğ‘ = ğ‘, which means that Â¯1 + ğ‘ = Â¯1, i.e., ğ‘† is 0-closed.
Now assume ğ‘† 0-closed. Since ğ‘ âŠ• ğ‘ âŠ—ğ‘ = ğ‘ âŠ— (Â¯1 âŠ• ğ‘) = ğ‘, we have: ğ‘ â©½ ğ‘ âŠ— ğ‘, and similarly for ğ‘ â©½ ğ‘ âŠ— ğ‘. Thus ğ‘† is superior with respect
â–¡

to â©½.

B PROOFS FOR SECTION 3 (DATALOG PROVENANCE AND DYNAMIC PROGRAMMING OVER

HYPERGRAPHS)

Lemma 11. For any Datalog query ğ‘ and grounding of an atom ğ‘£ of ğ‘, there is a bijection between Dğ»ğ‘ (ğ‘£) and {ğœ | ğœ yields ğ‘£ }.

Proof. By definition of ğ»ğ‘ each instantiation of a rule corresponds to a unique hyperedge. Then, we can inductively construct for a

given derivation ğ· its associated (unique) Datalog proof tree ğœğ· :

â€¢ If |ğ· | = 1, then ğ‘£ is a source vertex and thus an extensional tuple, we get the empty proof.
â€¢ If |ğ· | â©¾ 1, then there exists ğ‘’ âˆˆ BS(ğ‘£) where |ğ‘’ | â©¾ 0 and ğ·ğ‘– a derivation of ğ‘‡ğ‘– (ğ‘’) for 1 â©½ ğ‘– â©½ |ğ‘’ |, where ğ· = âŸ¨ğ‘’, ğ·1 Â· Â· Â· ğ· |ğ‘’ |âŸ©. By
definition, this hyperedge corresponds to the grounding of a rule ğ‘¡ ( (cid:174)ğ‘¥) â† ğ‘Ÿ1 ( (cid:174)ğ‘¥1), . . . , ğ‘Ÿğ‘› ( (cid:174)ğ‘¥ğ‘›). By induction, for 1 â©½ ğ‘– â©½ |ğ‘’ |, ğœğ·ğ‘– is the
corresponding proof of the derivation ğ·ğ‘– . Then by composition we obtain ğœğ· the proof for ğ·.

â–¡

Lemma 12. For any Datalog query ğ‘ and grounding of an atom ğ‘£ of ğ‘, for any derivation ğ· of ğ‘£ in ğ»ğ‘ we have

ğ‘¤ (ğ·) =

(cid:204)

ğ‘
ğ‘… (ğ‘¡ â€²)
prov

ğ‘¡ â€² âˆˆ ğ‘™ğ‘’ğ‘ğ‘£ğ‘’ğ‘  (ğœğ· )

where ğœğ· is the proof tree corresponding to ğ· in the bijection given by Lemma 11.

Proof. By induction on the size of the derivation ğ·:

ğ‘
ğ‘… (ğ‘Ÿ ( (cid:174)ğ‘¥)) =
â€¢ If |ğ· | = 1 then, there exists a nullary edge ğ‘’ âˆˆ ğ¸ğ‘ with â„(ğ‘’) = ğ‘£ and ğ‘¤ (ğ·) = ğ‘“ğ‘£ = prov

(cid:206)
ğ‘¡ â€² âˆˆ ğ‘™ğ‘’ğ‘ğ‘£ğ‘’ğ‘  (ğœğ· )

ğ‘
ğ‘… (ğ‘¡ â€²).
prov

â€¢ If |ğ· | â©¾ 1 then there exists ğ‘’ âˆˆ ğ¸ğ‘ and ğ· is of the form âŸ¨ğ‘’, ğ·1 Â· Â· Â· ğ· |ğ‘’ |âŸ© with ğ·ğ‘– a derivation of ğ‘‡ğ‘– (ğ‘’) for 1 â©½ ğ‘– â©½ |ğ‘’ |. We have

ğ‘¤ (ğ·) = ğ‘“ğ‘’ (ğ‘¤ (ğ·1), . . . , ğ‘¤ (ğ· |ğ‘’ |)) and by definition of ğ‘“ğ‘’ = âŠ— and by IHP ğ‘¤ (ğ·) = (cid:203)

ğ‘
ğ‘… (ğ‘¡ â€²).
prov

ğ‘¡ â€² âˆˆ ğ‘™ğ‘’ğ‘ğ‘£ğ‘’ğ‘  (ğœğ· )

â–¡

ğ‘
ğº (ğ‘¡) =
Theorem 13. Let ğ‘¡ be a tuple of a Datalog program ğ‘ with output predicate ğº and ğ»ğ‘ its hypergraph representation, then prov

ğ›¿ğ»ğ‘ (ğº (ğ‘¡)).

Proof.

ğ›¿ğ»ğ‘ (ğ‘¡) =

(cid:201)
ğ· âˆˆDğ»ğ‘ (ğº (ğ‘¡ ))

ğ‘¤ (ğ·)

(cid:32)

(cid:203)
ğ‘¡ â€² âˆˆ ğ‘™ğ‘’ğ‘ğ‘£ğ‘’ğ‘  (ğœğ· )

(cid:33)

ğ‘
ğ‘… (ğ‘¡ â€²)
prov

and by Lemma 12,

and by Lemma 11,

=

(cid:201)
ğ· âˆˆDğ»ğ‘ (ğº (ğ‘¡ ))

(cid:32)

= (cid:201)

ğœ yields ğ‘¡

(cid:203)
ğ‘¡ â€² âˆˆ ğ‘™ğ‘’ğ‘ğ‘£ğ‘’ğ‘  (ğœ)

ğ‘
ğ‘… (ğ‘¡ â€²)
prov

(cid:33)

ğ‘
ğ‘‡ (ğ‘¡).
= prov

â–¡

C PROOFS FOR SECTION 4 (BEST-FIRST METHOD)

Theorem 14. Algorithm 1 computes the full Datalog provenance for 0-closed totally-ordered semirings.

Proof. We show the algorithm verifies the following invariant: whenever a tuple is added to ğ¼ in Line 11, it has optimal value. This
implies that ğ¼ is populated in increasing order: each new derivation computed in the Relax() procedure only updates the priority queues
with values greater than the value of the tuple relaxed (by superiority of âŠ—).

Assume by contradiction that some output tuples are not correctly labeled and take such a minimal tuple ğœˆ = ğ‘Ÿ ( (cid:174)ğ‘¥). At the moment where
ğœˆ is extracted with value ğ‘› let us consider an optimal derivation path of ğœˆ that leads to the optimum value ğ‘œğ‘ğ‘¡ < ğ‘›. By superiority each tuple
occurring in the tail of the rule has value less than ğ‘œğ‘ğ‘¡. Thus a tuple occurring in the tail is either wrong-valued or not present in ğ¼ at the
moment where ğœˆ is found. In both cases and because tuples are added to ğ¼ in increasing order we obtain a new minimal tuple incorrectly
â–¡
labeled by the algorithm, contradicting the hypothesis.

