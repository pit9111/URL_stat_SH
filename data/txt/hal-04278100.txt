Tractable Orders for Direct Access to Ranked Answers
of Conjunctive Queries
Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld,

Mirek Riedewald

To cite this version:

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, Mirek Riedewald.
Tractable Orders for Direct Access to Ranked Answers of Conjunctive Queries. ACM Transactions on
Database Systems, 2023, 48 (1), pp.1-45. ï¿¿10.1145/3578517ï¿¿. ï¿¿hal-04278100ï¿¿

HAL Id: hal-04278100

https://inria.hal.science/hal-04278100

Submitted on 9 Nov 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

Lâ€™archive ouverte pluridisciplinaire HAL, est
destinÃ©e au dÃ©pÃ´t et Ã  la diffusion de documents
scientifiques de niveau recherche, publiÃ©s ou non,
Ã©manant des Ã©tablissements dâ€™enseignement et de
recherche franÃ§ais ou Ã©trangers, des laboratoires
publics ou privÃ©s.

Distributed under a Creative Commons Attribution 4.0 International License

Tractable Orders for Direct Access to Ranked Answers of
Conjunctive Queries

NOFAR CARMELIâˆ—, Technion, Israel and DI ENS, ENS, CNRS, PSL University, Inria, France
NIKOLAOS TZIAVELISâˆ—, Northeastern University, USA
WOLFGANG GATTERBAUER, Northeastern University, USA
BENNY KIMELFELD, Technion - Israel Institute of Technology, Israel
MIREK RIEDEWALD, Northeastern University, USA

We study the question of when we can provide direct access to the ğ‘˜-th answer to a Conjunctive Query (CQ)
according to a specified order over the answers in time logarithmic in the size of the database, following
a preprocessing step that constructs a data structure in time quasilinear in database size. Specifically, we
embark on the challenge of identifying the tractable answer orderings, that is, those orders that allow for such
complexity guarantees. To better understand the computational challenge at hand, we also investigate the
more modest task of providing access to only a single answer (i.e., finding the answer at a given position), a
task that we refer to as the selection problem, and ask when it can be performed in quasilinear time. We also
explore the question of when selection is indeed easier than ranked direct access.

We begin with lexicographic orders. For each of the two problems, we give a decidable characterization
(under conventional complexity assumptions) of the class of tractable lexicographic orders for every CQ
without self-joins. We then continue to the more general orders by the sum of attribute weights and establish
the corresponding decidable characterizations, for each of the two problems, of the tractable CQs without
self-joins. Finally, we explore the question of when the satisfaction of Functional Dependencies (FDs) can be
utilized for tractability, and establish the corresponding generalizations of our characterizations for every set
of unary FDs.

CCS Concepts: â€¢ Theory of computation â†’ Database theory; Complexity classes; Database query languages
(principles); Database query processing and optimization (theory).

Additional Key Words and Phrases: conjunctive queries, direct access, ranking function, answer orderings,
query classification

1 INTRODUCTION
When can we support direct access to a ranked list of answers to a database query without (and
considerably faster than) materializing all answers? To illustrate the concrete instantiation of this
question, assume the following simple relational schema for information about activities of residents
in the context of pandemic spread:

Visits(person, age, city)

Cases(city, date, #cases)

Here, the relation Visits mentions, for each person in the database, the cities that the person visits
regularly (e.g., for work and for visiting relatives) and the age of the person (for risk assessment);
the relation Cases specifies the number of new infection cases in specific cities at specific dates
(a measure that is commonly used for spread assessment albeit being sensitive to the amount of
testing).

âˆ—Both authors contributed equally to the paper.

Authorsâ€™ addresses: Nofar Carmeli, Technion, Israel and DI ENS, ENS, CNRS, PSL University, Inria, France, Nofar.Carmeli@
inria.fr; Nikolaos Tziavelis, Northeastern University, USA, tziavelis.n@northeastern.edu; Wolfgang Gatterbauer, Northeast-
ern University, USA, w.gatterbauer@northeastern.edu; Benny Kimelfeld, Technion - Israel Institute of Technology, Israel,
bennyk@cs.technion.ac.il; Mirek Riedewald, Northeastern University, USA, m.riedewald@northeastern.edu.

2023. XXXX-XXXX/2023/11-ART $15.00
https://doi.org/10.1145/nnnnnnn.nnnnnnn

, Vol. 1, No. 1, Article . Publication date: November 2023.

2

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

Suppose that we wish to efficiently compute the natural join Visits (cid:90) Cases based on equality
of the city attribute, so that we have all combinations of people (with their age), the cities they
regularly visit, and the cityâ€™s daily new cases. For example,

(Anna, 72, Boston, 12/7/2020, 179) .

While the number of such answers could be quadratic in the size of the database, the seminal work
of Bagan, Durand, and Grandjean [4] has established that the answers can be enumerated with a
constant delay between consecutive answers, after a linear-time preprocessing phase. This is due
to the fact that this join is a special case of a free-connex Conjunctive Query (CQ). In the case of
CQs without self-joins, being free-connex is a sufficient and necessary condition for such efficient
evaluation [4, 11]. The necessity requires conventional assumptions in fine-grained complexity1
and it holds even if we multiply the preprocessing time and delay by a logarithmic factor in the
size of the database.2

To realize the constant (or logarithmic) delay, the preprocessing phase builds a data structure
that enables efficient iteration over the answers in the enumeration phase. Brault-Baron [11]
showed that in the quasilinear-time preprocessing phase, we can build a structure with better
guarantees: not only log-delay enumeration, but even log-time direct access: a structure that, given
ğ‘˜, allows to directly retrieve the ğ‘˜ th answer in the enumeration without needing to enumerate the
preceding ğ‘˜ âˆ’ 1 answers first.3 Later, Carmeli et al. [15] showed how such a structure can be used
for enumerating answers in a random order (random permutation)4 with the statistical guarantee
that the order is uniformly distributed. In particular, in the above example we can enumerate the
answers of Visits (cid:90) Cases in a provably uniform random permutation (hence, ensuring statistical
validity of each prefix) with logarithmic delay, after a quasilinear-time preprocessing phase. Their
direct-access structure also allows for inverted access: given an answer, return the index ğ‘˜ of that
answer (or determine that it is not a valid answer). Recently, Keppeler [32] proposed another
direct-access structure with the additional ability to allow efficient database updates, but at the
cost of only supporting a limited subset of free-connex CQs.

All known direct-access structures [11, 15, 32] allow the answers to be sorted by some lexico-
graphic order (even if the formal results do not explicitly state it). For instance, in our example
of Visits (cid:90) Cases, the structure could be such that the tuples are enumerated in the (descending
or ascending) order of #cases and then by date, or in the order of city and then by age. Hence,
in logarithmic time we can evaluate quantile queries, namely find the ğ‘˜ th answer in order, and
determine the position of a tuple inside the sorted list. From this we can also conclude (fairly easily)
that we can enumerate the answers ordered by age where ties are broken randomly, again provably
uniformly. Carmeli et al. [15] have also shown how the order of the answers can be useful for
generalizing direct-access algorithms from CQs to UCQs. Notice that direct access to the sorted
list of answers is a stronger requirement than ranked enumeration that has been studied in recent
work [10, 16, 41, 42, 44, 46].

Yet, the choice of lexicographic order is an artefact of the structure construction, e.g., the
elimination order [11], the join tree [15], or the ğ‘-tree [8]. If the application desires a specific
lexicographic order, we can only hope to find a matching construction. However, this is not
necessarily possible. For example, could we construct in quasilinear time a direct-access structure

1For the sake of simplicity, throughout this section we make all of these complexity assumptions. We give their formal
statements in Section 2.4.
2We refer to those as quasilinear preprocessing and logarithmic delay, respectively.
3â€œDirect accessâ€ is also widely known as â€œrandom access.â€ We prefer to use â€œdirect accessâ€ to avoid confusion with the
problem of answering â€œin random order.â€
4Not to be confused with â€œrandom access.â€

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

3

for Visits (cid:90) Cases ordered by #cases and then by age? Interestingly, we will show that the answer
is negative: it is impossible to build in quasilinear time a direct-access structure with logarithmic
access time for that lexicographic order.

Getting back to the question posed at the beginning of this section, in this paper we embark on
the challenge of identifying, for each CQ, the orders that allow for efficiently constructing a direct-
access structure. We adopt the tractability yardstick of quasilinear construction (preprocessing)
time and logarithmic access time. In addition, we focus on two types of orders: lexicographic orders,
and scoring by the sum of attribute weights.

As aforesaid, some of the orders that we study are intractable. To understand the root cause of
the hardness, we consider another task that allows us to narrow our question to a considerably
weaker guarantee. Our notion of tractability so far requires the construction of a structure in
quasilinear time that allows direct access in logarithmic time. In particular, if our goal is to compute
just a single quantile, say the ğ‘˜ th answer, then it should take quasilinear time. Computing a single
quantile is known as the selection problem [9]. The question we ask is to what extent selection is a
weaker requirement than direct access In other words, do we get more tractable cases if we lift the
requirement to construct a data structure and instead ask for quasilinear time per access?

In some situations, we might be able to avoid hardness through a more careful inspection of the
integrity constraints that the database guarantees on the source relations. For example, it turns out
that we can construct in quasilinear time a direct-access structure for Visits (cid:90) Cases ordered by
#cases and then by age if we assume that each city occurs at most once in Cases (i.e., for each city
we have a report for a single day). Hence, it may be the case that an ordered CQ is classified as
intractable (with respect to the guarantees that we seek), but it becomes tractable if we are allowed
to assume that the input database satisfies some integrity constraints such as key constraints or
more general Functional Dependencies (FDs). Moreover, FDs are so common that ignoring them
implies that we often miss opportunities of fast algorithms. This angle arises regardless of answer
ordering, and indeed, Carmeli and KrÃ¶ll [12] showed precisely how the class of (self-join-free)
CQs with tractable enumeration extends in the presence of FDs. Accordingly, we extend our study
on ranked direct access and the selection problem to incorporate FDs, and aim to classify every
combination of (a) CQ, (b) order over the answers, and (c) set of FDs.

Contributions. Before we describe the results that we establish in this manuscript, let us illustrate

them on an example.

Example 1.1. Figure 2 depicts an example database and different orderings of the answers to the
2-path CQ ğ‘„ (ğ‘¥, ğ‘¦, ğ‘§) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† (ğ‘¦, ğ‘§). The question we ask is whether the median (e.g., the 3rd
answer in the example) or in general, the answer in any index can be computed efficiently as the
database size ğ‘› grows. Tractable direct access requires O (polylog ğ‘›) per access after O (ğ‘› polylog ğ‘›)
preprocessing, while tractable selection requires O (ğ‘› polylog ğ‘›) for a single access. We compare
the impact of different orders, projections, and FDs on the example 2-path CQ.

â€¢ LEX âŸ¨ğ‘¥, ğ‘¦, ğ‘§âŸ©: Direct access is tractable.
â€¢ LEX âŸ¨ğ‘¥, ğ‘§, ğ‘¦âŸ©: Direct access is intractable because the lexicographic order â€œdoes not agreeâ€
with the query structure, which we capture through the concept of a disruptive trio that we
introduce later on. However, selection is tractable.

â€¢ LEX âŸ¨ğ‘¥, ğ‘§âŸ©: Direct access is intractable because the variables in the partial lexicographic
order are not â€œconnectedâ€ in a particular way. We will define this as not being ğ¿-connex for
a lexicographic order ğ¿. However, selection is again tractable.

â€¢ LEX âŸ¨ğ‘¥, ğ‘§âŸ© and ğ‘¦ projected away: Selection is now intractable because the query is not

free-connex.

, Vol. 1, No. 1, Article . Publication date: November 2023.

4

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

Fig. 1. Overview of our results for lexicographic (LEX) orders and sum-of-weights (SUM) orders. CQs without
self-joins (SJ-free) are classified based on the tractability of the direct access problem (left) and the selection
problem (right). The ğ¿-connex property applies only to lexicographic orders ğ¿ (the precise definitions are
given in Section 2). All tractable cases extend to CQs with self-joins. The sizes of the ellipses are arbitrary and
do not correspond to the size or importance of the classes.

R ğ‘¥ ğ‘¦
1 5
1 2
6 2

S ğ‘¦ ğ‘§
5 3
5 4
5 6
2 8

Q ğ‘¥ ğ‘¦ ğ‘§
#1 1 2 8
#2 1 5 3
#3 1 5 4
#4 1 5 6
#5 6 2 8

Q ğ‘¥ ğ‘§ ğ‘¦
#1 1 3 5
#2 1 4 5
#3 1 6 5
#4 1 8 2
#5 6 8 2

Q ğ‘¥ ğ‘¦ ğ‘§ ğ‘¥ + ğ‘¦ + ğ‘§
#1 1 5 3
#2 1 5 4
#3 1 2 8
#4 1 5 6
#5 6 2 8

9
10
11
12
16

(a) Example Database.

(b) LEX ordering âŸ¨ğ‘¥, ğ‘¦, ğ‘§âŸ©.

(c) LEX ordering âŸ¨ğ‘¥, ğ‘§, ğ‘¦âŸ©

(d) SUM ordering.

Fig. 2. Example 1.1: An example input database (a) and possible orderings of the answers to the query
ğ‘„ (ğ‘¥, ğ‘¦, ğ‘§) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† (ğ‘¦, ğ‘§). The orderings in (b) and (c) use two different lexicographic orders (LEX), while the
ordering in (d) uses a sum-of-weights order where the weights are assumed to be identical to the attribute
values.

â€¢ LEX âŸ¨ğ‘¥, ğ‘§, ğ‘¦âŸ©, with the FD ğ‘… : ğ‘¦ â†’ ğ‘¥ or the FD ğ‘† : ğ‘¦ â†’ ğ‘§: Direct access is tractable as a

consequence of earlier work on enumeration with FDs [12].

â€¢ LEX âŸ¨ğ‘¥, ğ‘§, ğ‘¦âŸ©, with the FD ğ‘… : ğ‘¥ â†’ ğ‘¦: Direct access is tractable with the techniques that we
develop in this paper. Intuitively, the FD implies that the order is equivalent to the tractable
order âŸ¨ğ‘¥, ğ‘¦, ğ‘§âŸ©.

â€¢ LEX âŸ¨ğ‘¥, ğ‘§, ğ‘¦âŸ©, with the FD ğ‘† : ğ‘§ â†’ ğ‘¦: Direct access is intractable since the FD does not help

in this case.

â€¢ SUM ğ‘¥ + ğ‘¦ + ğ‘§: Direct access is intractable because it would allow us to solve the 3SUM

problem in subquadratic time, yet selection is tractable.

â€¢ SUM ğ‘¥ + ğ‘¦ and ğ‘§ projected away: Direct access is tractable because all the free variables
are contained in ğ‘…. This means that we can produce the sorted list of answers during
preprocessing.

â€¢ SUM ğ‘¥ +ğ‘§ and ğ‘¦ projected away: Selection is intractable because the query is not free-connex.

, Vol. 1, No. 1, Article . Publication date: November 2023.

SelectionDirect AccessAcyclicSelf-join-freeCQsFree âŠ†1 atomL-connexand no disruptive trioNot L-connexor disruptive trioFree-connexTractableâ‰¡<ğ‘›polylogğ‘›,polylogğ‘›>Both intractableLEX tractable, SUM intractableBoth tractableMaximal free hyperdgesâ‰¤2AcyclicSelf-join-freeCQsFree âŠ†1 atomFree-connexTractableâ‰¡<1,ğ‘›polylogğ‘›>Tractable Orders for Direct Access to Ranked Answers of CQs

5

(1) Our first main result is an algorithm for direct access for lexicographic orders, including ones
that are not achievable by past structures. We further show that within the class of CQs without
self-joins, our algorithm covers all the tractable cases (in the sense adopted here), and we establish
a decidable and easy-to-test classification of the lexicographic orders over the free variables into
tractable and intractable ones. For instance, in the case of Visits (cid:90) Cases the lexicographic order
(#cases, age, city, date, person) is intractable. It is classified as such because #cases and age are
non-neighbours (i.e., do not co-occur in the same atom), but city, which comes after #cases and
age in the order, is a neighbour of both. This is what we call a disruptive trio. The lexicographic
order (#cases, age) is also intractable since the query Visits (cid:90) Cases is not {#cases, age}-connex
(a similar condition to being free-connex, but for the subset of the variables that appear in the
lexicographic order instead of the free ones). In contrast, the lexicographic order (#cases, city, age)
is tractable. We also show that within the tractable side, the structure we construct allows for
inverted access in constant time.

Our classification is proved in two steps. We begin by considering the complete lexicographic
orders (that involve all free variables). We show that for free-connex CQs without self-joins,
the absence of a disruptive trio is a sufficient and necessary condition for tractability. We then
generalize to partial lexicographic orders ğ¿ where the ordering is determined only by a subset of the
free variables. There, the condition is that there is no disruptive trio and that the query is ğ¿-connex.
Interestingly, it turns out that a partial lexicographic order is tractable if and only if it is the prefix
of a complete tractable lexicographic order.

(2) Next, we study the selection problem for lexicographic orders and show that being free-connex
is a sufficient and necessary condition for a linear-time solution in the case of CQs without self-joins.
In particular, there are ordered queries with tractable selection but intractable direct access, namely
free-connex CQs without self-joins where we have a disruptive trio or lack the property of being
ğ¿-connex.

(3) A lexicographic order is a special case of an ordering by the sum of attribute weights, where
every database value is mapped to some weight. Hence, a natural question is which CQs have a
tractable direct access by the order of sum. For example, what about Visits (cid:90) Cases with the order
(ğ›¼Â·#cases + ğ›½Â·age)? It is easy to see that this order is intractable because the lexicographic order
(#cases, age) is intractable. In fact, it is easy to show that an order by sum is intractable whenever
there exists an intractable lexicographic order (e.g., there is a disruptive trio). However, we will
show that the situation is worse: the only tractable case is the one where the CQ is free-connex and
there is an atom that contains all of the free variables. In particular, ranked direct access by sum
is intractable already for the Cartesian product ğ‘„ (ğ‘1, ğ‘‘, ğ‘¥, ğ‘, ğ‘, ğ‘2) :âˆ’ Visits(ğ‘, ğ‘, ğ‘1), Cases(ğ‘2, ğ‘‘, ğ‘¥),
even though every lexicographic order is tractable (according to our aforementioned classification).
This daunting hardness also emphasizes how ranked direct access is fundamentally harder than
ranked enumeration where, in the case of the sum of attributes, the answers of every free-connex
CQ can be enumerated with logarithmic delay after a linear preprocessing time [44].

(4) Next, we study the selection problem for the sum of weights, and establish the following
dichotomy in complexity (again assuming fine-grained hypotheses): the selection problem can be
solved in O (ğ‘› log ğ‘›) time, where ğ‘› is the size of the database, if and only if the hypergraph of the
CQ restricted to the free variables contains at most two maximal hyperedges (w.r.t. containment).
The tractable side is applicable even in the presence of self-joins, and it is achieved by adopting an
algorithm by Frederickson and Johnson [21] originally developed for selection on sorted matrices.
For illustration, the selection problem is solvable in quasilinear time for the query Visits (cid:90) Cases
ordered by sum.

(5) Lastly, we study the implication of FDs on our results, and generalize all of them to incorporate
a set of unary FDs (i.e., FDs with a single attribute on the left-hand side). Like previous works on

, Vol. 1, No. 1, Article . Publication date: November 2023.

6

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

FDs on enumeration [12], deletion propagation [33], resilience [22], and probabilistic inference [24],
we use the notion of an extended CQ to reason about the tractability of a CQ under the presence of
FDs. The idea is that by looking at the structure of the extended CQ (without FDs), then we are able
to classify the original CQ together with the FDs. While this works in a relatively straightforward
way for the case of sum, the case of lexicographic orders is more involved since the FDs may
interact with the order in non-trivial ways. To extend our dichotomy results for lexicographic
orders to incorporate FDs, we show how the extension of a CQ and order may also result in a
reordering of the variables. Then, tractability is decided by the extended CQ together with the
reordered lexicographic order.

Overview of results. We summarize our results (excluding the dichotomies under the presence
of FDs) in Figure 1 with different colors indicating the tractability of the studied orders, namely
lexicographic (LEX) and sum-of-weights (SUM) orders. For both direct access and selection, we
obtain the precise picture of the orders and CQs without self-joins that are tractable according to our
yardstick: O (ğ‘› polylog ğ‘›) preprocessing and O (polylog ğ‘›) per access for direct access (conveniently
denoted as âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ© for âŸ¨preprocessing, accessâŸ©) and O (ğ‘› polylog ğ‘›) for selection (or
âŸ¨1, ğ‘› log ğ‘›âŸ©). Finally, we show how the results are affected by every set of unary FDs (not depicted
in Figure 1); in other words, we extend our dichotomies to incorporate the FDs of the underlying
schema under the restriction that all FDs have a single attribute on the premise. We leave the case
of more general FDs open for future research.

Comparison to an earlier conference version. A preliminary version of this manuscript appeared
in a conference proceedings [13]. Compared to that version, this manuscript includes significant
extensions and improvements. First, we added an investigation on the complexity of the selection
problem with lexicographic orders, establishing a complete dichotomy result (Theorem 6.1 and all
of Section 6). Second, we extended a dichotomy from the conference version to include self-join-free
CQs beyond full CQs for the selection problem by SUM, so it now covers all self-join-free CQs
(with projections), thereby resolving the corresponding open question from the conference paper
(Section 7.4). Third, we extended our results to cover unary FDs (Section 8). Fourth, we have clarified
the relationship between the disruptive trio and the concept of an elimination order (Remark 1).
Fifth and last, we made considerable simplifications and improvements in previous components,
including the proof of hardness of direct access for lexicographic orders (Lemma 3.13) and several
proofs for the SUM selection (Section 7).

Applicability. It is important to note that while our positive results are stated over a limited
class of queries (a fragment of acyclic CQs), there are some implications beyond this class that are
immediate yet significant. In particular, we can use known techniques that reduce other CQs to a
tractable form and then apply our direct-access or selection algorithms. As an example, a hypertree
decomposition can be used to transform a cyclic CQ to an acyclic form by paying a non-linear
overhead during preprocessing [27]. As another example, a CQ with inequality (<) predicates can
be reduced to a CQ without inequalities by paying only a polylogarithmic-factor increase in the
size of the database [43].

Outline. The remainder of the manuscript is organized as follows. Section 2 gives the necessary
background. In Section 3, we consider direct access by lexicographic orders that include all the
free variables, and Section 4 extends the results to partial ones. We move on to the (for the most
part) negative results for direct access by sum orders in Section 5. We study the selection problem
for lexicographic orders and sum in Section 6 and Section 7, respectively. We extend our results to
incorporate unary FDs in Section 8 and, lastly, conclude and give future directions in Section 9.

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

7

2 PRELIMINARIES

2.1 Basic Notions
Database. A schema S is a set of relational symbols {ğ‘…1, . . . , ğ‘…ğ‘š }. We use ar(ğ‘…) for the arity of a
relational symbol ğ‘…. A database instance ğ¼ contains a finite relation ğ‘…ğ¼ âŠ† domar(ğ‘…) for each ğ‘… âˆˆ S,
where dom is a set of constant values called the domain. When ğ¼ is clear, we simply use ğ‘… instead of
ğ‘…ğ¼ . We use ğ‘› for the size of the database, i.e., the total number of tuples.

Queries. A conjunctive query (CQ) ğ‘„ over schema S is an expression of the form
ğ‘„ (Xğ‘“ ) :âˆ’ ğ‘…1(X1), . . . , ğ‘…â„“ (Xâ„“ ), where the tuples Xğ‘“ , X1, . . . , Xâ„“ hold variables, every variable in Xğ‘“
appears in some X1, . . . , Xâ„“ , and {ğ‘…1, . . . , ğ‘…â„“ } âŠ† S. Each ğ‘…ğ‘– (Xğ‘– ) is called an atom of the query ğ‘„,
and the set of all atoms is denoted by atoms(ğ‘„). We use var(ğ‘’) or var(ğ‘„) for the set of variables
that appear in an atom ğ‘’ or query ğ‘„, respectively.5 The variables Xğ‘“ are called free and are denoted
by free(ğ‘„). A CQ is full if free(ğ‘„) = var(ğ‘„) and Boolean if free(ğ‘„) = âˆ…. Sometimes, we say that
CQs that are not full have projections. A repeated occurrence of a relational symbol is a self-join
and if no self-joins exist, a CQ is called self-join-free. A homomorphism from a CQ ğ‘„ to a database
ğ¼ is a mapping of var(ğ‘„) to constants from dom, such that every atom of ğ‘„ maps to a tuple in the
database ğ¼ . A query answer is such a homomorphism followed by a projection on the free variables.
The answer to a Boolean CQ is whether such a homomorphism exists. The set of query answers is
ğ‘„ (ğ¼ ) and we use ğ‘ âˆˆ ğ‘„ (ğ¼ ) for a query answer. For an atom ğ‘…(X) of a CQ, we say that a tuple ğ‘¡ âˆˆ ğ‘…
assigns a value ğ‘ to a variable ğ‘¥ and denote it as ğ‘¡ [ğ‘¥] = ğ‘ if for every index ğ‘– such that X[ğ‘–] = ğ‘¥
we have that ğ‘¡ [ğ‘–] = ğ‘. The active domain of a variable ğ‘¥ is the subset of dom that ğ‘¥ can be assigned
from the database ğ¼ .

Hypergraphs. A hypergraph H = (ğ‘‰ , ğ¸) is a set ğ‘‰ of vertices and a set ğ¸ of subsets of ğ‘‰ called
hyperedges. Two vertices in a hypergraph are neighbors if they appear in the same edge. A path of
H is a sequence of vertices such that every two succeeding vertices are neighbors. A chordless path
is a path in which no two non-succeeding vertices appear in the same hyperedge (in particular,
no vertex appears twice). A join tree of a hypergraph H = (ğ‘‰ , ğ¸) is a tree ğ‘‡ where the nodes6 are
the hyperedges of H and the running intersection property holds, namely: for all ğ‘¢ âˆˆ ğ‘‰ the set
{ğ‘’ âˆˆ ğ¸ | ğ‘¢ âˆˆ ğ‘’} forms a (connected) subtree in ğ‘‡ . An equivalent phrasing of the running intersection
property is that given two nodes ğ‘’1, ğ‘’2 of the tree, for any node ğ‘’3 on the simple path between them,
we have that ğ‘’1 âˆ© ğ‘’2 âŠ† ğ‘’3. A hypergraph H is acyclic if there exists a join tree for H . We associate
a hypergraph H (ğ‘„) = (ğ‘‰ , ğ¸) to a CQ ğ‘„ where the vertices are the variables of ğ‘„, and every atom
of ğ‘„ corresponds to a hyperedge with the same set of variables. Stated differently, ğ‘‰ = var(ğ‘„)
and ğ¸ = {var(ğ‘’)|ğ‘’ âˆˆ atoms(ğ‘„)}. With a slight abuse of notation, we identify atoms of ğ‘„ with
hyperedges of H (ğ‘„). A CQ ğ‘„ is acyclic if H (ğ‘„) is acyclic, otherwise it is cyclic. The free-restricted
hypergraph Hfree (ğ‘„) is the restriction of H (ğ‘„) = (ğ‘‰ , ğ¸) on the nodes that correspond to free
variables, i.e., Hfree(ğ‘„) = (free(ğ‘„), {ğ‘’ âˆ© free(ğ‘„)|ğ‘’ âˆˆ ğ¸}).

Free-connex CQs. A hypergraph H â€² is an inclusive extension of H if every edge of H appears
in H â€², and every edge of H â€² is a subset of some edge in H . Given a subset X of the vertices of H ,
a tree ğ‘‡ is an ext-X-connex tree (i.e., extension-X-connex tree) for a hypergraph H if: (1) ğ‘‡ is a join
tree of an inclusive extension of H , and (2) there is a subtree7 ğ‘‡ â€² of ğ‘‡ that contains exactly the
vertices X [4]. As an example, Figure 3b depicts an ext-{ğ‘£1, ğ‘£2}-connex tree for a query ğ‘„3. We say
that a hypergraph is X-connex if it has an ext-X-connex tree [4]. A hypergraph is X-connex iff
it is acyclic and it remains acyclic after the addition of a hyperedge containing exactly X [7, 11].
Given a hypergraph H and a subset X of its vertices, an X-path is a chordless path (ğ‘¥, ğ‘§1, . . . , ğ‘§ğ‘˜, ğ‘¦)

5We use ğ‘’ for atoms because of the natural analogy to hyperedges in hypergraphs associated with a query ğ‘„.
6To make a clear distinction between the vertices of a hypergraph and those of its join tree, we call the latter nodes.
7By subtree, we mean any connected subgraph of the tree.

, Vol. 1, No. 1, Article . Publication date: November 2023.

8

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

in H with ğ‘˜ â‰¥ 1, such that ğ‘¥, ğ‘¦ âˆˆ X, and ğ‘§1, . . . , ğ‘§ğ‘˜ âˆ‰ X. A hypergraph is X-connex iff it has no
X-path [4]. A CQ ğ‘„ is free-connex if H (ğ‘„) is free(ğ‘„)-connex [4]. Note that a free-connex CQ is
necessarily acyclic.8 An implication of the characterization given above is that it suffices to find a
join-tree for an inclusive extension of a hypergraph H to infer that H is acyclic.

To simplify notation, we also say that a CQ is ğ¿-connex for a (partial) lexicographic order ğ¿
if the CQ is X-connex for the set of variables X that appear in ğ¿. Generalizing the notion of an
inclusive extension, we say that a hypergraph H â€² is inclusion equivalent to H if every hyperedge
of H is a subset of some hyperedge of H â€² and vice versa. For example, the two hypergraphs with
hyperedges ğ¸1 = {{ğ‘¥, ğ‘¦}, {ğ‘¦, ğ‘§}} and ğ¸2 = {{ğ‘¥, ğ‘¦}, {ğ‘¦, ğ‘§}, {ğ‘§}} are inclusion equivalent because {ğ‘§}
is a subset of {ğ‘¦, ğ‘§} and every hyperedge is trivially a subset of itself.

2.2 Problem Definitions
Orders over Answers. For a CQ ğ‘„ and database instance ğ¼ , we assume a total order âª¯ over the
query answers ğ‘„ (ğ¼ ). We consider two types of orders in this paper:

(1) LEX: Assuming that the domain values are ordered, a lexicographic order ğ¿ is an ordering of
free(ğ‘„) such that âª¯ compares two query answers ğ‘1, ğ‘2 on the value of the first variable in
ğ¿, then on the second (if they are equal on the first), and so on [29]. A lexicographic order is
called partial if the variables in ğ¿ are a subset of free(ğ‘„).

(2) SUM: The second type of order assumes given weight functions that assign real-valued
weights to the domain values of each variable. More precisely, for each variable ğ‘¥, we define
a function ğ‘¤ğ‘¥ : dom â†’ R. Then, the query answers are ordered by a weight which is
computed by aggregating the weights of the assigned values of free variables. In a sum-of-
weights order, denoted by SUM, we have the weight of each query answer ğ‘ âˆˆ ğ‘„ (ğ¼ ) to be
ğ‘¤ğ‘„ (ğ‘) = (cid:205)ğ‘¥ âˆˆfree(ğ‘„) ğ‘¤ğ‘¥ (ğ‘(ğ‘¥)) and ğ‘1 âª¯ ğ‘2 implies that ğ‘¤ğ‘„ (ğ‘1) â‰¤ ğ‘¤ğ‘„ (ğ‘2). We emphasize
that we allow only free variables to have weights, otherwise different semantics for the query
answers are possible [44]. To simplify notation, we sometimes refer to all ğ‘¤ğ‘¥, ğ‘¥ âˆˆ free(ğ‘„)
and ğ‘¤ğ‘„ together as one weight function ğ‘¤.

Attribute Weights vs. Tuple Weights for SUM. Notice that in the definition above, we assume
that the input weights are assigned to the domain values of the attributes. Alternatively, the input
weights could be assigned to the relation tuples, a convention that has been used in past work on
ranked enumeration [41]. Since there are several reasonable semantics for interpreting a tuple-
weight ranking for CQs with projections and/or self-joins [44], we elect to present our results for
the case of attribute weights. We note that our results directly extend to the case of tuple weights
for full self-join-free CQs where the semantics are clear. On the one hand, attribute weights can
easily be transformed to tuple weights in linear time such that the weights of the query answers
remain the same. This works by assigning each variable to one of the atoms that it appears in,
and computing the weight of a tuple by aggregating the weights of the assigned attribute values.
Therefore, our hardness results for SUM orders directly extend to the case of tuple weights. On
the other hand, our positive results on direct access (Section 5), selection (Section 7.2) and their
extension to the case of FDs (Section 8.1) rely on algorithms that innately operate on tuple weights,
thus we cover those cases too.

Direct Access vs. Selection. We now define two problems that both directly access ordered
query answers. Since our goal is to classify the combination of CQs and orders by their tractability,
we let those two define the problem. Specifically, a problem is defined by a CQ ğ‘„ and a family of

8Free-connex CQs are sometimes called in the literature free-connex acyclic CQs [4]. For cyclic CQs, the free-connex property
is only defined with respect to a particular hypertree decomposition [4], and not for the CQs themselves. Thus, we choose
to omit the word acyclic when referring to free-connex acyclic CQs.

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

9

orders Î . The reason that we use a family of orders in the problem definition is that for the case of
SUM, we do not distinguish between different weight functions in our classification. For LEX, we
always consider the family of orders to contain only one specific (partial) lexicographic order.

Definition 2.1 (Direct Access). Let ğ‘„ be a CQ and Î  a family of total orders. The problem of direct
access by Î  takes as an input a database ğ¼ and an order â‰º from Î  and constructs a data structure
(called the preprocessing phase) which then allows access to a query answer ğ‘ âˆˆ ğ‘„ (ğ¼ ) at any index
ğ‘˜ of the (implicit) array of query answers sorted by â‰º.

The essence of direct access is that after the preprocessing phase, we need to be able to support
multiple such accesses. Notably, the values of ğ‘˜ that are going to be requested afterward are not
known during preprocessing.

Definition 2.2 (Selection). Let ğ‘„ be a CQ and Î  a family of total orders. The problem of selection
by Î  takes as an input a database ğ¼ , an order â‰º from Î , and asks for the query answer ğ‘ âˆˆ ğ‘„ (ğ¼ ) at
index ğ‘˜ of the (implicit) array of query answers sorted by â‰º.

The problem of selection [9, 19, 20] is a computationally easier task that requires only a single
direct access, hence does not make a distinction between preprocessing and access phases. A special
case of the problem is finding the median query answer.

For both problems, if the index ğ‘˜ exceeds the total number of answers, the returned answer is

â€œout-of-boundâ€.

2.3 Complexity Framework and Sorting
We measure asymptotic complexity in terms of the size of the database ğ‘›, while the size of the
query is considered a constant. If the time for preprocessing is O (cid:0)ğ‘“ (ğ‘›)(cid:1) and the time for each
access is O (cid:0)ğ‘”(ğ‘›)(cid:1), we denote that as âŸ¨ğ‘“ (ğ‘›), ğ‘”(ğ‘›)âŸ©, where ğ‘“ , ğ‘” are functions from N to R. Note that
by definition, the problem of selection asks for a âŸ¨1, ğ‘”(ğ‘›)âŸ© solution.

Our goal for both problems is to achieve efficient access in time significantly smaller than (the
worst case) |ğ‘„ (ğ¼ )|. For direct access, we consider the problem tractable if âŸ¨ğ‘› log ğ‘›, log ğ‘›âŸ© is possible,
and for selection âŸ¨1, ğ‘› log ğ‘›âŸ©.

The model of computation is the standard RAM model with uniform cost measure. In particular,
it allows for linear time construction of lookup tables, which can be accessed in constant time. We
would like to point out that some past works [4, 15] have assumed that in certain variants of the
model, sorting can be done in linear time [28]. Since we consider problems related to summation
and sorting [21] where a linear-time sort would improve otherwise optimal bounds, we adopt a
more standard assumption that sorting is comparison-based and possible only in quasilinear time.
As a consequence, some upper bounds mentioned in this paper are weaker than the original sources
which assumed linear-time sorting [11, 15].

2.4 Hardness Hypotheses
All the lower bounds we prove are conditional on one or multiple of the following four hypotheses.

Hypothesis 1 (sparseBMM). Two Boolean matrices ğ´ and ğµ, represented as lists of their non-zero
entries, cannot be multiplied in time ğ‘š1+ğ‘œ (1) , where ğ‘š is the number of non-zero entries in ğ´, ğµ, and
ğ´ğµ.

, Vol. 1, No. 1, Article . Publication date: November 2023.

10

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

A consequence of this hypothesis is that we cannot answer the query ğ‘„ (ğ‘¥, ğ‘§) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† (ğ‘¦, ğ‘§)
with quasilinear preprocessing and polylogarithmic delay. In more general terms, any self-join-
free acyclic non-free-connex CQ cannot be enumerated with quasilinear9 preprocessing time and
polylogarithmic delay assuming the sparseBMM hypothesis [4, 7].

Hypothesis 2 (Hypercliqe [1, 34]). For every ğ‘˜ â‰¥ 2, there is no ğ‘‚ (ğ‘š polylog ğ‘š) algorithm for
deciding the existence of a (ğ‘˜+1, ğ‘˜)-hyperclique in a ğ‘˜-uniform hypergraph with ğ‘š hyperedges, where
a (ğ‘˜+1, ğ‘˜)-hyperclique is a set of ğ‘˜+1 vertices such that every subset of ğ‘˜ elements is a hyperedge.

When ğ‘˜ = 2, this follows from the â€œğ›¿-Triangleâ€ hypothesis [1]. This is the hypothesis that we
cannot detect a triangle in a graph in linear time [3]. When ğ‘˜ â‰¥ 3, this is a special case of the
â€œ(â„“, ğ‘˜)-Hypercliqueâ€ hypothesis [34]. A known consequence is that Boolean cyclic and self-join-free
CQs cannot be answered in quasilinear9 time [11]. As a result, cyclic and self-join-free CQs do not
admit enumeration with quasilinear preprocessing time and polylogarithmic delay assuming the
Hypercliqe hypothesis [11].

Hypothesis 3 (3sum [6, 39]). Deciding whether there exist ğ‘ âˆˆ ğ´, ğ‘ âˆˆ ğµ, ğ‘ âˆˆ ğ¶ from three sets of
integers ğ´, ğµ, ğ¶, each of size Î©(ğ‘š), such that ğ‘ + ğ‘ + ğ‘ = 0 cannot be done in time ğ‘‚ (ğ‘š2âˆ’ğœ– ) for any
ğœ– > 0.

In its simplest form, the 3sum problem asks for three distinct real numbers ğ‘, ğ‘, ğ‘ from a set ğ‘†
with ğ‘š elements that satisfy ğ‘ + ğ‘ + ğ‘ = 0. There is a simple ğ‘‚ (ğ‘š2) algorithm for the problem, but
it is conjectured that in general, no truly subquadratic solution exists [39]. The significance of this
conjecture has been highlighted by many conditional lower bounds for problems in computational
geometry [23] and within the class P in general [45]. Note that the problem remains hard even for
integers provided that they are sufficiently large (i.e., in the order of ğ‘‚ (ğ‘›3)) [39]. The hypothesis
we use here has three different sets of numbers, but it is equivalent [6]. This lower bound has been
confirmed in some restricted models of computation [2, 18].

Hypothesis 4 (Seth [30]). For the satisfiability problem with ğ‘š variables and ğ‘˜ variables per
clause (ğ‘˜-SAT), if ğ‘ ğ‘˜ is the infimum of the real numbers ğ›¿ for which ğ‘˜-SAT admits an O (2ğ›¿ğ‘š) algorithm,
then limğ‘˜â†’âˆ ğ‘ ğ‘˜ = 1

Intuitively, the Strong Exponential Time Hypothesis (Seth) states that the best possible algorithms
for ğ‘˜-SAT approach O (2ğ‘š) running time when ğ‘˜ goes to infinity. Seth implies that the ğ‘˜-Dominating
Set problem on a graph with ğ‘š vertices cannot be solved in O (ğ‘š2âˆ’ğœ– ) for ğ‘˜ â‰¥ 3 and any constant ğœ–
[40]. Based on that, it can be shown that counting the answers to a self-join-free acyclic CQ that is
not free-connex cannot be done in O (ğ‘›2âˆ’ğœ–â€²) for any constant ğœ– â€² [35].

2.5 Known Results for CQs
Eliminating Projection. We now provide some background that relates to the efficient handling
of CQs. For a query with projections, a standard strategy is to reduce it to an equivalent one where
techniques for acyclic full CQs can be leveraged. The following proposition, which is widely known
and used [7], shows that this is possible for free-connex CQs.

Proposition 2.3 (Folklore). Given a database instance ğ¼ , a CQ ğ‘„, a join tree ğ‘‡ of an inclusive
extension of ğ‘„, and a subtree ğ‘‡ â€² of ğ‘‡ that contains all the free variables, we can compute in linear
time a database instance ğ¼ â€² over the schema of a CQ ğ‘„ â€² that consists of the nodes of ğ‘‡ â€² such that
ğ‘„ (ğ¼ ) = ğ‘„ â€²(ğ¼ â€²) and |ğ¼ â€²| â‰¤ |ğ¼ |.

9 Works in the literature [5, 7, 15] typically phrase this as linear, yet any logarithmic factor increase is still covered by the
hypotheses.

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

11

This reduction is done by first creating a relation for every node in ğ‘‡ using projections of existing
relations, then performing the classic semi-join reduction by Yannakakis [47] to filter the relations
of ğ‘‡ â€² according to the relations of ğ‘‡ , and then we can simply ignore all relations that do not appear
in ğ‘‡ â€² and obtain the same answers. Afterward, they can be handled efficiently, e.g. their answers
can be enumerated with constant delay [4]. We refer the reader to recent tutorials [7, 17] for an
intuitive illustration of the idea.

Ranked enumeration. Enumerating the answers to a CQ in ranked order is a special case of
direct access where the accessed indexes are consecutive integers starting from 0. As it was recently
shown [42], ranked enumeration for CQs is intimately connected to classic algorithms on finding
the ğ‘˜ th shortest path in a graph. In contrast to direct access, ranked enumeration by SUM orders
(which also includes lexicographic orderings as a special case) is possible with logarithmic delay
after a linear-time preprocessing phase for all free-connex CQs [41]. In contrast, as we will show,
that is not the case for direct access. Existing ranked-enumeration algorithms rely on priority queue
structures that compare a minimal number of candidate answers to produce the ranked answers
one-by-one in order. There is no straightforward way to extend them to the task of direct access
where we may skip over a large number of answers to get to an arbitrary index ğ‘˜.

Direct Access. Carmeli et al. [15] devise a direct access structure (called â€œrandom accessâ€) and
use it to uniformly sample CQ answers (called â€œrandom-order enumerationâ€). While it leverages the
idea of using count statistics on the input tuples to navigate the space of query answers that had
also been used in prior work on sampling [48], it decouples it from the random order requirement
and advances it into direct access. The separation into a direct access component and a random
permutation (of indices) generated externally also allows sampling without replacement which was
not possible before. This direct access algorithm is also a significant simplification over a prior one
by Brault-Baron [11]. We emphasize that even though these algorithms do not explicitly discuss the
order of the answers, a closer look shows that they internally use and produce some lexicographic
order.

Theorem 2.4 ([11, 15]). Let ğ‘„ be a CQ. If ğ‘„ is free-connex, then direct access (in some order) is
possible in âŸ¨ğ‘› log ğ‘›, log ğ‘›âŸ©. Otherwise, if it is also self-join-free, then direct access (in any order) is not
possible in âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ©, assuming sparseBMM and Hyperclique.

Recent work by Keppeler [32] suggests another direct-access solution by lexicographic order,
which also supports efficient insertion and deletion of input tuples. Given these additional re-
quirements, the supported CQs are more limited, and are only a subset of free-connex CQs called
ğ‘-hierarchical [8]. This is a subclass of the well-known hierarchical queries with an additional
restriction on the existential variables. As an example, the following CQs are not ğ‘-hierarchical
even though they are free-connex: ğ‘„1(ğ‘¥, ğ‘¦) :âˆ’ ğ‘…1(ğ‘¥), ğ‘…2 (ğ‘¥, ğ‘¦), ğ‘…3(ğ‘¦) and ğ‘„2(ğ‘¥) :âˆ’ ğ‘…1(ğ‘¥, ğ‘¦), ğ‘…2(ğ‘¦). For
these queries, direct access is not supported by the solution of Keppeler [32], even though it is
possible without the update requirements (as we show in Section 3).

All previous direct-access solutions of which we are aware have two gaps compared to this work:
(1) they do not discuss which lexicographic orders (given by orderings of the free variables) are
supported; (2) they do not support all possible lexicographic orders. We conclude this section with
a short survey of existing solutions and their supported orders.

All prior direct-access solutions use some component that depends on the query structure and
constrains the supported orders. The algorithm of Carmeli et al. [15, Algorithm 3] assumes that a
join tree is given with the CQ, and the lexicographic order is imposed by the join tree. Specifically, it
is an ordering of the variables achieved by a preorder depth-first traversal of the tree. As a result, it
does not support any order that requires jumping back-and-forth between different branches of the
tree. In particular, it does not support ğ‘„3(ğ‘£1, ğ‘£2, ğ‘£3, ğ‘£4) :âˆ’ ğ‘…(ğ‘£1, ğ‘£3), ğ‘† (ğ‘£2, ğ‘£4) with the lexicographic

, Vol. 1, No. 1, Article . Publication date: November 2023.

12

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

order given by the increasing variable indices (we adopt this convention for all the examples
below). We show how to handle this CQ and order in detail in Example 3.5. The algorithm of
Brault-Baron [11, Algorithm 4.3] assumes that an elimination order is given along with the CQ.
The resulting lexicographic order is affected by that elimination order, but is not exactly the same.
This solution suffers from similar restrictions, and it does not support ğ‘„3 either. The algorithm of
Keppeler [32] assumes that a ğ‘-tree is given with the CQ, and the possible lexicographic orders are
affected by this tree. Unlike the two earlier mentioned approaches, this algorithm can interleave
variables from different atoms, yet cannot support some orders that are possible for the previous
algorithms. As an example, it does not support ğ‘„4(ğ‘£1, ğ‘£2, ğ‘£3) :âˆ’ ğ‘…1(ğ‘£1, ğ‘£2), ğ‘…2(ğ‘£2, ğ‘£3) as ğ‘£2 is highest
in the hierarchy (the atoms containing it strictly subsume the atoms containing any other variable)
and so it is necessarily the first variable in the q-tree and in the ordering produced.

than any hierarchy. As a result,

Finally, we should mention that

there exist queries and orders that require both
jumping back-and-forth in the join tree and visiting the variables in an order dif-
these are not supported by any previous so-
ferent
and
lution. Two such examples
ğ‘„6(ğ‘£1, ğ‘£2, ğ‘£3, ğ‘£4, ğ‘£5) :âˆ’ ğ‘…1(ğ‘£1, ğ‘£2, ğ‘£4), ğ‘…2(ğ‘£2, ğ‘£3, ğ‘£5).
In Section 3, we provide an algorithm that
supports both of these CQs.

are ğ‘„5(ğ‘£1, ğ‘£2, ğ‘£3, ğ‘£4, ğ‘£5) :âˆ’ ğ‘…1(ğ‘£1, ğ‘£3), ğ‘…2(ğ‘£3, ğ‘£4), ğ‘…3(ğ‘£2, ğ‘£5)

3 DIRECT ACCESS BY LEXICOGRAPHIC ORDERS
In this section, we answer the following question: for which underlying lexicographic orders can
we achieve â€œtractableâ€ direct access to ranked CQ answers, i.e. with quasilinear preprocessing and
polylogarithmic time per answer?

Example 3.1 (No direct access). Consider the lexicographic order ğ¿ = âŸ¨ğ‘£1, ğ‘£2, ğ‘£3âŸ© for the query
ğ‘„ (ğ‘£1, ğ‘£2, ğ‘£3) :âˆ’ ğ‘…(ğ‘£1, ğ‘£3), ğ‘† (ğ‘£3, ğ‘£2). Direct access to the query answers according to that order would
allow us to â€œjump overâ€ the ğ‘£3 values via binary search and essentially enumerate the answers to
ğ‘„ â€²(ğ‘£1, ğ‘£2) :âˆ’ ğ‘…(ğ‘£1, ğ‘£3), ğ‘† (ğ‘£3, ğ‘£2). However, we know that ğ‘„ â€² is not free-connex and that is impossible
to achieve enumeration with quasilinear preprocessing and polylogarithmic delay (if sparseBMM
holds). Therefore, the bounds we are hoping for are out of reach for the given query and order.
The core difficulty is that the joining variable ğ‘£3 appears after the other two in the lexicographic
order.

We formalize this notion of â€œvariable in the middleâ€ in order to detect similar situations in more

complex queries.

Definition 3.2 (Disruptive Trio). Let ğ‘„ be a CQ and ğ¿ a lexicographic order of its free variables.
We say that three free variables ğ‘£1, ğ‘£2, ğ‘£3 are a disruptive trio in ğ‘„ with respect to ğ¿ if ğ‘£1 and ğ‘£2 are
not neighbors (i.e. they do not appear together in an atom), ğ‘£3 is a neighbor of both ğ‘£1 and ğ‘£2, and
ğ‘£3 appears after ğ‘£1 and ğ‘£2 in ğ¿.

As it turns out, for free-connex and self-join-free CQs, the tractable CQs are precisely captured
by this simple criterion. Regarding self-join-free CQs that are not free-connex, their known in-
tractability of enumeration implies that direct access is also intractable. This leads to the following
dichotomy:

Theorem 3.3 (Direct Access by LEX). Let ğ‘„ be a CQ and ğ¿ be a lexicographic order.
â€¢ If ğ‘„ is free-connex and does not have a disruptive trio with respect to ğ¿, then direct access by ğ¿

is possible in âŸ¨ğ‘› log ğ‘›, log ğ‘›âŸ©.

â€¢ Otherwise,

if ğ‘„ is also self-join-free,

then direct access by ğ¿ is not possible in

âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ© assuming sparseBMM and Hyperclique.

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

13

Remark 1. Assume we are given a full CQ, and the lexicographic order we want to achieve is
âŸ¨ğ‘£1, . . . , ğ‘£ğ‘šâŸ©. It was shown (in the context of ranked enumeration by lexicographic orders) that the
absence of disruptive trios is equivalent to the existence of a reverse (ğ›¼-)elimination order of the
variables [11, Theorem 15]. That is, we need there to exist an atom that contains ğ‘£ğ‘š and all of its
neighbors (variables that share an atom with ğ‘£ğ‘š), and if we remove ğ‘£ğ‘š from the query, ğ‘£1, . . . , ğ‘£ğ‘šâˆ’1
should recursively be a reverse elimination order. For the base case, when ğ‘š = 1, ğ‘£1 constitutes a
reverse-elimination order.

Remark 2. On the positive side of Theorem 3.3, the preprocessing time is dominated by sorting the
input relations, which we assume requires O (ğ‘› log ğ‘›) time. If we assume instead that sorting takes
linear time (as assumed in some related work [11, 15, 28]), then the time required for preprocessing is
only O (ğ‘›) instead of O (ğ‘› log ğ‘›).

In Section 3.1, we provide an algorithm for this problem for full acyclic CQs that have a particular
join tree that we call layered. Then, we show how to find such a layered join tree whenever there
is no disruptive trio in Section 3.2. In Section 3.3, we explain how to adapt our solution for CQs
with projections, and in Section 3.4 we prove a lower bound which establishes that our algorithm
applies to all cases where direct access is tractable.

3.1 Layer-Based Algorithm
Before we explain the algorithm, we first define one of its main components. A layered join tree is a
join tree where each node belongs to a layer. The layer number is the last position of any of its
variables in the lexicographic order. Intuitively, â€œpeelingâ€ off the outermost (largest) layers must
result in a valid join tree (for a hypergraph with fewer variables). To find such a join tree for a CQ
ğ‘„, we may have to introduce hyperedges that are contained in those of H (ğ‘„) (this corresponds to
taking the projection of a relation) or remove hyperedges of H (ğ‘„) that are contained in others
(this corresponds to filtering relations that contain a superset of the variables). Thus, we define the
layered join tree with respect to a hypergraph that is inclusion equivalent (recall the definition of
an inclusion equivalent hypergraph from Section 2.1).

Definition 3.4 (Layered Join Tree). Let ğ‘„ be a full acyclic CQ, and let ğ¿ = âŸ¨ğ‘£1, . . . , ğ‘£ ğ‘“ âŸ© be a
lexicographic order. A layered join tree for ğ‘„ with respect to ğ¿ is a join tree of a hypergraph that is
inclusion equivalent to H (ğ‘„) where (1) every node ğ‘‰ of the tree is assigned to layer max{ğ‘– | ğ‘£ğ‘– âˆˆ ğ‘‰ },
(2) there is exactly one node for each layer, and (3) for all ğ‘— â‰¤ ğ‘“ the induced subgraph with only
the nodes that belong to the first ğ‘— layers is a tree.

Example 3.5. Consider the CQ ğ‘„3(ğ‘£1, ğ‘£2, ğ‘£3, ğ‘£4) :âˆ’ ğ‘…(ğ‘£1, ğ‘£3), ğ‘† (ğ‘£2, ğ‘£4) and the lexicographic order
âŸ¨ğ‘£1, ğ‘£2, ğ‘£3, ğ‘£4âŸ©. To support that order, we first find an inclusion equivalent hypergraph, shown in
Figure 3a. Notice that we added two hyperedges that are strictly contained in the existing ones,
and obtained a hypergraph corresponding to ğ‘…(ğ‘£1, ğ‘£3), ğ‘… â€²(ğ‘£1), ğ‘† (ğ‘£2, ğ‘£4), ğ‘† â€²(ğ‘£2). A layered join tree
constructed from that hypergraph is depicted in Figure 3b. There are four layers, one for each
node of the join tree. The layer of the node containing {ğ‘£1, ğ‘£3} is 3 because ğ‘£3 appears after ğ‘£1 in
the order and it is the third variable. If we remove the last layer, then we obtain a layered join
tree for the induced hypergraph where the last variable ğ‘£4 is removed.

We now describe an algorithm that takes as an input a CQ ğ‘„, a lexicographic order ğ¿, and a
corresponding layered join tree and provides direct access to the query answers after a preprocessing
phase. For preprocessing, we leverage a construction from Carmeli et al. [15, Algorithm 2] and apply
it to our layered join tree. For completeness, we briefly explain how it works below. Subsequently,
we describe the access phase that takes into account the layers of the tree to accommodate the

, Vol. 1, No. 1, Article . Publication date: November 2023.

14

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

(a) A hypergraph that is inclusion equivalent to
H (ğ‘„3).

(b) A layered join tree for ğ‘„3 w.r.t. the lexicographic
order.

Fig. 3. Constructing a layered join tree for the query ğ‘„3 (ğ‘£1, ğ‘£2, ğ‘£3, ğ‘£4) :âˆ’ ğ‘…(ğ‘£1, ğ‘£3), ğ‘† (ğ‘£2, ğ‘£4) and order
âŸ¨ğ‘£1, ğ‘£2, ğ‘£3, ğ‘£4âŸ©.

provided lexicographic order. We emphasize that the way we access the structure is different than
that of the past work [15], and that this allows support of lexicographic orders that were impossible
for the previous access routine (e.g. the order in Example 3.5).

Preprocessing. The preprocessing phase (1) creates a relation for every node of the tree, (2)
removes dangling tuples, (3) sorts the relations, (4) partitions the relations into buckets, and (5)
uses dynamic programming on the tree to compute and store certain counts10. After preprocessing,
we are guaranteed that for all ğ‘–, the node of layer ğ‘– has a corresponding relation where each tuple
participates in at least one query answer; this relation is partitioned into buckets by the assignment
of the variables preceding ğ‘–. In each bucket, we sort the tuples lexicographically by ğ‘£ğ‘– . Each tuple is
given a weight that indicates the number of different answers this tuple agrees with when only
joining its subtree. The weight of each bucket is the sum of its tuple weights. We denote both by
the function weight. Moreover, for every tuple ğ‘¡, we compute the sum of weights of the preceding
tuples in the bucket, denoted by start(ğ‘¡). We use end(ğ‘¡) for the sum that corresponds to the tuple
following ğ‘¡ in the same bucket; if ğ‘¡ is last, we set this to be the bucket weight. If we think of the
query answers in the subtree sorted in the order of ğ‘£ğ‘– values, then start and end distribute the
indices between 0 and the bucket weight to tuples. The number of indices within the range of each
tuple corresponds to its weight.

Example 3.6 (Continued). The result of the preprocessing phase on an example database for our
query ğ‘„3 is shown in Figure 4. Notice that ğ‘… has been split into two buckets according to the values
of its parent ğ‘… â€², one for value ğ‘1 and one for ğ‘2. For tuple (ğ‘1) âˆˆ ğ‘… â€², we have weight((ğ‘1)) = 8
because this is the number of answers that agree on that value in its subtree: the left subtree
has 2 such answers which can be combined with any of the 4 possible answers of the right
subtree. The start index of tuple (ğ‘1, ğ‘‘3) âˆˆ ğ‘† is the sum of the previous weights within the bucket:
start((ğ‘1, ğ‘‘3)) = weight((ğ‘1, ğ‘‘1)) + weight((ğ‘1, ğ‘‘2)) = 1 + 1 = 2. Not shown in the figure is that
every bucket stores the sum of weights it contains.

Access. The access phase works by going through the tree layer by layer. When resolving a
layer ğ‘–, we select a tuple from its corresponding relation, which sets a value for the ğ‘–th variable in ğ¿,
and also determines a bucket for each child. Then, we conceptually erase the node of layer ğ‘– and its
outgoing edges.

10The same count statistics are also leveraged in [48, Sect. 4.2] in the context of sampling.

, Vol. 1, No. 1, Article . Publication date: November 2023.

ğ‘£1ğ‘£3ğ‘£2ğ‘£4ğ‘†ğ‘…â€²ğ‘†â€²ğ‘…ğ‘£1ğ‘…â€²ğ‘£2,ğ‘£4ğ‘£1,ğ‘£3ğ‘£2ğ‘†â€²ğ‘†ğ‘…1234Tractable Orders for Direct Access to Ranked Answers of CQs

15

Fig. 4. Example 3.6: The result of the preprocessing phase on ğ‘„3, the layered join tree (Figure 3b) and an
example database. The weight, start index, and end index for each tuple are abbreviated in the figure as ğ‘¤, ğ‘ ,
and ğ‘’ respectively.

The access algorithm maintains a directed forest and an assignment to a prefix of the variables.
Each tree in the forest represents the answers obtained by joining its relations. Each root contains a
single bucket that agrees with the already assigned values, thus every answer agrees on the prefix.
Due to the running intersection property, different trees cannot share unassigned variables. As a
consequence, any combination of answers from different trees can be added to the prefix assignment
to form an answer to ğ‘„. The answers obtained this way are exactly the answers to ğ‘„ that agree
with the already set assignment. Since we start with a layered join tree, we are guaranteed that at
each step, the next layer (which corresponds to the variable following the prefix for which we have
an assignment) appears as a root in the forest.

Recall that from the preprocessing phase, the weight of each root is the number of answers in
its tree. When we are at layer ğ‘–, we have to take into account the weights of all the other roots
in order to compute the number of query answers for a particular tuple. More specifically, the
number of answers to ğ‘„ containing the already selected attributes (smaller than ğ‘–) and some ğ‘£ğ‘–
value contained in a tuple is found by multiplying the tuple weight with the weights of all other
roots. That is because the answers from all trees can be combined into a query answer. Let ğ‘¡ be the
selected tuple when resolving the ğ‘–th layer. The number of answers to ğ‘„ that have a value of ğ¿[ğ‘–]
smaller than that of ğ‘¡ and a value of ğ¿[ ğ‘—] equal to that of ğ‘¡ for all ğ‘— < ğ‘– is then:

(cid:32)

(cid:213)

ğ‘¡ â€²

weight(ğ‘¡ â€²)

(cid:214)

ğ‘Ÿ âˆˆroots

(cid:33)

weight(ğ‘Ÿ )

where ğ‘¡ â€² ranges over tuples preceding ğ‘¡ in its bucket. Denote by factor the product of all root
weights. Then we can rewrite as:

(cid:32)

(cid:213)

ğ‘¡ â€²

weight(ğ‘¡ â€²)

(cid:33) (cid:32)

(cid:214)

ğ‘Ÿ âˆˆroots

(cid:33)

weight(ğ‘Ÿ )

= start(ğ‘¡) Â· factor .

Therefore, when resolving layer ğ‘– we select the last tuple ğ‘¡ such that the index we want to access is
at least start(ğ‘¡) Â· factor.

Algorithm 1 summarizes the process we described where ğ‘˜ is the index to be accessed and ğ‘“ is
the number of variables. Iteration ğ‘– resolves layer ğ‘–. Pointers to the selected buckets from the roots
are kept in a bucket array. The product of the weights of all roots is kept in a factor variable. In
each iteration, the variable ğ‘˜ is updated to the index that should be accessed among the answers
that agree with the already selected attribute values. Note that bucket[ğ‘–] is always initialized when
accessed since layer ğ‘– is guaranteed to be a child of a smaller layer.

Example 3.7 (Continued). We demonstrate how the access algorithm works for index ğ‘˜ = 12.
When resolving ğ‘… â€², the tuple (ğ‘2) is chosen since 8 Â· 1 â‰¤ 12 < 16 Â· 1; then, the single bucket in ğ‘† â€²
and the bucket containing ğ‘2 in ğ‘… are selected. The next iteration resolves ğ‘† â€². When it reaches

, Vol. 1, No. 1, Article . Publication date: November 2023.

ğ‘…â€²ğ‘¤ğ‘ ğ‘’ğ‘1808ğ‘28816ğ‘†â€²ğ‘¤ğ‘ eğ‘1303ğ‘2134ğ‘…ğ‘¤ğ‘ eğ‘1ğ‘1101ğ‘1ğ‘2112ğ‘2ğ‘2101ğ‘2ğ‘3112ğ‘†ğ‘¤ğ‘ eğ‘1ğ‘‘1101ğ‘1ğ‘‘2112ğ‘1ğ‘‘3123ğ‘2ğ‘‘410116

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

Algorithm 1: Lexicographic Direct-Access

1 if ğ‘˜ â‰¥ weight(root) then
return â€œout-of-boundâ€
2
3 bucket[1] = root
4 factor = weight(root)
5 for i=1,. . . ,f do
6

7

8

9

10

11

factor = factor/weight(bucket[ğ‘–])
pick ğ‘¡ âˆˆ bucket[ğ‘–] s.t. start(ğ‘¡) Â· factor â‰¤ ğ‘˜ < end(ğ‘¡) Â· factor
ğ‘˜ = ğ‘˜ âˆ’ start(ğ‘¡) Â· factor
for child ğ‘‰ of layer ğ‘– do

get the bucket ğ‘ âˆˆ ğ‘‰ agreeing with the selected tuples
bucket[layer(ğ‘‰ )] = ğ‘
factor = factor Â· weight(ğ‘)

12
13 return the answer agreeing with the selected tuples

line 7, ğ‘˜ = 12 âˆ’ 8 = 4 and factor = 2. As 0 Â· 2 â‰¤ 4 < 3 Â· 2, the tuple (ğ‘1) is selected. Next, ğ‘… is
resolved, which we depict in Figure 5. The current index is ğ‘˜ = 4 âˆ’ 0 = 4. The weights of the
other roots (only ğ‘† here) gives us factor = 3. To make our choice in ğ‘…, we multiply the weights of
the tuples by factor = 3. Then, we find that the index ğ‘˜ we are looking for falls into the range
of (ğ‘2, ğ‘3) because 1 Â· 3 â‰¤ 4 < 2 Â· 3. Next, ğ‘† is resolved, ğ‘˜ = 4 âˆ’ 1 Â· 3 = 1, and factor = 1. As
1 Â· 1 â‰¤ 1 < 2 Â· 1, the tuple (ğ‘1, ğ‘‘2) is selected. Overall, answer number 12 (the 13th answer) is
(ğ‘2, ğ‘1, ğ‘3, ğ‘‘2).

Lemma 3.8. Let ğ‘„ be a full acyclic CQ, and ğ¿ = âŸ¨ğ‘£1, . . . , ğ‘£ ğ‘“ âŸ© be a lexicographic order. If there is a

layered join tree for ğ‘„ with respect to ğ¿, then direct access is possible in âŸ¨ğ‘› log ğ‘›, log ğ‘›âŸ©.

Proof. The correctness of Algorithm 1 follows from the discussion above. For the time complex-
ity, note that it contains a constant number of operations (assuming the number of attributes ğ‘“ is
fixed). Line 7 can be done in logarithmic time using binary search, while all other operations only
require constant time in the RAM model. Thus, we obtain direct access in logarithmic time per
â–¡
answer after the quasilinear preprocessing (dominated by sorting).

Remark 3 (Inverted access). A straightforward adaptation of Algorithm 1 can be used to achieve
inverted access: given a query result as the input, we return its index according to the lexicographic
order. Algorithm 2 is almost the same as Algorithm 1 except that the choices in each iteration are made
according to the given answer and the corresponding index is constructed (instead of the opposite). The
algorithm runs in constant time per answer since every operation can be done within that time (unlike
Algorithm 1, there is no need for binary search here).

Another adaptation of Algorithm 2 can give us a form of inverted access for the cases when the given
answer does not exist. That is, instead of returning â€œnot-an-answerâ€, we want to return the next answer
in the lexicographic order. The first time a tuple ğ‘¡ is not found in Line 7 of Algorithm 2, we select the
first tuple in the bucket that is larger than ğ‘¡, and in all following iterations, we always select the first
tuple in the bucket. If there is no tuple larger than ğ‘¡, we revert the previous iteration and select the next
tuple there (compared to what we selected before). If no such tuple exists, we again revert the previous
iteration and so on. If there are no previous iterations, we were asked to access a tuple larger than the
last answer, so we return an appropriate message. The algorithm described here takes logarithmic time,
as we can use binary search to find the tuple following our target tuple in each bucket.

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

17

Fig. 5. Example 3.7: Illustration of an iteration of the access phase where layer 3 corresponding to ğ‘… is resolved.

Algorithm 2: Lexicographic Inverted-Access
1 ğ‘˜ = 0
2 bucket[1] = root
3 factor = weight(root)
4 for i=1,. . . ,f do
5

factor = factor/weight(bucket[ğ‘–])
select ğ‘¡ âˆˆ bucket[ğ‘–] agreeing with the answer
if no such ğ‘¡ exists then

return â€œnot-an-answerâ€

ğ‘˜ = ğ‘˜ + start(ğ‘¡) Â· factor
for child ğ‘‰ of layer ğ‘– do

get the bucket ğ‘ âˆˆ ğ‘‰ agreeing with the answer
bucket[layer(ğ‘‰ )] = ğ‘
factor = factor Â· weight(ğ‘)

6

7

8

9

10

11

12

13
14 return ğ‘˜

3.2 Finding Layered Join Trees
We now have an algorithm that can be applied whenever we have a layered join tree. We next show
that the existence of such a join tree relies on the disruptive trio condition we introduced earlier. In
particular, if no disruptive trio exists, we are able to construct a layered join tree for full acyclic
CQs.

Lemma 3.9. Let ğ‘„ be a full acyclic CQ, and ğ¿ be a lexicographic order. If ğ‘„ does not have a disruptive

trio with respect to ğ¿, then there is a layered join tree for ğ‘„ with respect to ğ¿.

Proof. We show by induction on ğ‘– that there exists a layered join tree for the hypergraph
containing the hyperedges {ğ‘‰ âˆ© {ğ‘£1, . . . , ğ‘£ğ‘– } | ğ‘‰ âˆˆ atoms(ğ‘„)} with respect to the prefix of ğ¿
containing its first ğ‘– elements. The induction base is the tree that contains the node {ğ‘£1} and no
edges.

, Vol. 1, No. 1, Article . Publication date: November 2023.

ğ‘…â€²ğ‘¤ğ‘ ğ‘180ğ‘288ğ‘†â€²ğ‘¤ğ‘ ğ‘130ğ‘213ğ‘…ğ‘¤ğ‘ ğ‘1ğ‘110ğ‘1ğ‘211ğ‘2ğ‘210ğ‘2ğ‘311ğ‘†ğ‘¤ğ‘ ğ‘1ğ‘‘110ğ‘1ğ‘‘211ğ‘1ğ‘‘312ğ‘2ğ‘‘410Weight of bucket=1+1+1=31âˆ—3answers1âˆ—3answersğ‘˜=418

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

In the inductive step, we assume a layered join tree with ğ‘– âˆ’ 1 layers for {ğ‘‰ âˆ© {ğ‘£1, . . . , ğ‘£ğ‘–âˆ’1} |
ğ‘‰ âˆˆ atoms(ğ‘„)}, and we build a layer on top of it. Denote by V the sets of {ğ‘‰ âˆ© {ğ‘£1, . . . , ğ‘£ğ‘– } | ğ‘‰ âˆˆ
atoms(ğ‘„)} that contain ğ‘£ğ‘– (these are the sets that need to be included in the new layer). First note
that V is acyclic. Indeed, by the running intersection property, the join tree for H (ğ‘„) has a subtree
with all the nodes that contain ğ‘£ğ‘– . By taking this subtree and projecting out all variables that occur
after ğ‘£ğ‘– in ğ¿, we get a join tree for an inclusion equivalent hypergraph to V, and its existence
proves that V is acyclic.

We next claim that some set in V contains all the others; that is, there exists ğ‘‰ğ‘š âˆˆ V such that
for all ğ‘‰ âˆˆ V, we have that ğ‘‰ âŠ† ğ‘‰ğ‘š. Consider a join tree for V. Every variable ğ‘£ âˆˆ V defines a
subtree ğ‘‡ğ‘£ induced by the nodes that contain this variable. If two variables ğ‘¥, ğ‘¦ are neighbors, their
subtrees ğ‘‡ğ‘¥,ğ‘‡ğ‘¦ share a node. It is known that every collection of subtrees of a tree satisfies the
Helly property [26]: if every two subtrees share a node, then some node is shared by all subtrees.
In particular, since V is acyclic, if every two variables of V are neighbors, then some element of
V contains all variables that appear in (elements of) V. Thus, if, by way of contradiction, there
is no such ğ‘‰ğ‘š, there exist two non-neighboring variables ğ‘£ğ‘ and ğ‘£ğ‘ that appear in (elements of)
V. Since ğ‘£ğ‘– appears in all elements of V, this means that there exist ğ‘‰ğ‘, ğ‘‰ğ‘ âˆˆ V with {ğ‘£ğ‘, ğ‘£ğ‘– } âŠ† ğ‘‰ğ‘
and {ğ‘£ğ‘, ğ‘£ğ‘– } âŠ† ğ‘‰ğ‘. Since ğ‘£ğ‘ and ğ‘£ğ‘ are not neighbors, these three variables are a disruptive trio with
respect to ğ¿: ğ‘£ğ‘ and ğ‘£ğ‘ are both neighbors of the later variable ğ‘£ğ‘– . The existence of a disruptive trio
contradicts the assumption of the lemma we are proving, and so we conclude that there is ğ‘‰ğ‘š âˆˆ V
such that for all ğ‘‰ âˆˆ V, we have that ğ‘‰ âŠ† ğ‘‰ğ‘š.

With ğ‘‰ğ‘š at hand, we can now add the additional layer to the tree given by the inductive
hypothesis. By the inductive hypothesis, the layered join tree with ğ‘– âˆ’1 layers contains the hyperedge
ğ‘‰ğ‘š âˆ© {ğ‘£1, . . . , ğ‘£ğ‘–âˆ’1} = ğ‘‰ğ‘š \ {ğ‘£ğ‘– }. We insert ğ‘‰ğ‘š with an edge to the node containing ğ‘‰ğ‘š \ {ğ‘£ğ‘– }. This
results in the join tree we need: (1) the hyperedges {ğ‘‰ âˆ© {ğ‘£1, . . . , ğ‘£ğ‘– } | ğ‘‰ âˆˆ atoms(ğ‘„)} are all
contained in nodes, since the ones that do not appear in the tree from the inductive hypothesis
are contained in the new node; (2) it is a tree since we add one leaf to an existing tree; and (3) the
running intersection property holds since the added node is connected to all of its variables that
â–¡
already appear in the tree.

Lemmas 3.8 and 3.9 give a direct-access algorithm for full acyclic CQs and lexicographic orders

without disruptive trios.

3.3 Supporting Projection
Next, we show how to support CQs that have projections. A free-connex CQ can be efficiently
reduced to a full acyclic CQ using Proposition 2.3. We next show that the resulting CQ contains no
disruptive trio if the original CQ does not.

Lemma 3.10. Given a database instance ğ¼ , a free-connex CQ ğ‘„, and a lexicographic order ğ¿ with
no disruptive trio with respect to ğ¿, we can compute in linear time a database instance ğ¼ â€² and a full
acyclic CQ ğ‘„ â€² with no disruptive trio with respect to ğ¿ such that ğ‘„ â€²(ğ¼ â€²) = ğ‘„ (ğ¼ ), |ğ¼ â€²| â‰¤ |ğ¼ |, and ğ‘„ â€² does
not depend on ğ¼ or ğ¼ â€².

Proof. Let ğ‘„ be a free-connex CQ, and let ğ‘‡ be an ext-free(ğ‘„)-connex tree for ğ‘„ where ğ‘‡ â€² is

the subtree of ğ‘‡ that contains exactly the free variables.

First, we claim that two free variables are neighbors in ğ‘‡ iff they are neighbors in ğ‘‡ â€². The â€œifâ€
direction is immediate since ğ‘‡ â€² is contained in ğ‘‡ . We show the other direction. Let ğ‘¢ and ğ‘£ be free
variables of ğ‘„ that are neighbors in ğ‘‡ . That is, there is a node ğ‘‰ğ‘‡ in ğ‘‡ that contains them both.
Consider the unique path from ğ‘‰ to any node in ğ‘‡ â€² such that only the last node on the path, which

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

19

we denote ğ‘‰ğ‘‡ â€², is in ğ‘‡ â€². Since both variables appear in ğ‘‡ â€² and in ğ‘‰ , by the running intersection
property, both variables appear in ğ‘‰ğ‘‡ â€². Thus, ğ‘¢ and ğ‘£ are also neighbors in ğ‘‡ â€².

Since the definition of disruptive trios depends only on neighboring pairs of free variables, an
immediate consequence of the claim from the previous paragraph is that there is a disruptive trio
in ğ‘‡ iff there is a disruptive trio in ğ‘‡ â€². Next, we can simply use Proposition 2.3 to reduce ğ‘„ to the
â–¡
full acyclic CQ where the atoms are exactly the nodes of ğ‘‡ â€².

By combining Lemmas 3.8 to 3.10, we conclude an efficient algorithm for free-connex CQs and

orders with no disruptive trios. The next lemma summarizes our results so far.

Lemma 3.11. Let ğ‘„ be a free-connex CQ, and ğ¿ be a lexicographic order. If ğ‘„ does not have a

disruptive trio with respect to ğ¿, direct access by ğ¿ is possible in âŸ¨ğ‘› log ğ‘›, log ğ‘›âŸ©.

3.4 Lower Bound for Conjunctive Queries
Next, we show that our algorithm supports all tractable cases (for self-join-free CQs); we prove
that all unsupported cases are intractable. We base our hardness results on the known hardness
of enumeration for non-free-connex CQs [5, 11] through a reduction that uses direct access to
enumerate the answers projected on a prefix of the variables. Adapting our notation to enumeration,
we say that an enumeration problem is in âŸ¨ğ‘ (ğ‘›), ğ‘“ (ğ‘›)âŸ© if there is an algorithm that solves this
problem with ğ‘ (ğ‘›) time before the first answer and ğ‘“ (ğ‘›) time between consecutive answers.

Lemma 3.12. Let ğ‘„ be a self-join-free CQ, ğ¿ be a lexicographic order, and ğ‘„ â€² be the same as ğ‘„ but
with free variables ğ¿â€² for some prefix ğ¿â€² of ğ¿. If direct access for ğ‘„ by ğ¿ is possible in âŸ¨ğ‘ (ğ‘›), ğ‘“ (ğ‘›)âŸ© for
some functions ğ‘, ğ‘“ , then enumeration of the answers to ğ‘„ â€² is possible in âŸ¨ğ‘ (ğ‘›), ğ‘“ (ğ‘›) log ğ‘›âŸ©.

Proof. We show how to enumerate the unique assignments of the free variables of ğ‘„ â€² given
the direct access algorithm for ğ‘„. First we perform the preprocessing step in O (ğ‘ (ğ‘›)). Then, we
perform the following starting with ğ‘– = 0 and until there are no more answers. We access the
answer at index ğ‘– and print its assignment to the variables ğ¿â€². Then, we set ğ‘– to be the index of the
next answer which assigns different values to ğ¿â€² and repeat. Finding the next index can be done
â–¡
with a logarithmic number of direct access calls using binary search.

We now exploit that for CQs with disruptive trios, we can always find a prefix that is not connex.
Therefore, enumerating the query answers projected on that prefix via direct access leads to the
enumeration of a non-free-connex CQ, where existing lower bounds apply.

Lemma 3.13. Let ğ‘„ be a self-join-free acyclic CQ, and ğ¿ be a lexicographic order. If ğ‘„ has a
disruptive trio with respect to ğ¿, then direct access by ğ¿ is not possible in âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ©,
assuming sparseBMM.11

Proof. Let ğ‘£1, ğ‘£2, ğ‘£3 be a disruptive trio in ğ¿. We take ğ¿â€² to be the prefix of ğ¿ that ends in ğ‘£2. Then,
ğ‘£1, ğ‘£3, ğ‘£2 is an ğ¿â€²-path or in other words, the hypergraph of ğ‘„ is not ğ¿â€²-connex. Now, we define
a new CQ ğ‘„ â€² so that it has the same body as ğ‘„ but its free variables are ğ¿â€². Thus, ğ‘„ â€² is acyclic
but not free-connex. Assuming that direct access for ğ‘„ is possible in âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ©, we
use Lemma 3.12 to enumerate the answers of ğ‘„ â€² in âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ©, which is known to
â–¡
contradict sparseBMM [5] .

11In fact, this lemma holds also for cyclic CQs, as it can be shown that Boolean matrix multiplication can be encoded in
any CQ that contains a free-path regardless of its acyclicity. However, this is not formally stated in previous work, and we
prefer not to complicate the proof with the technical details of the reduction. We chose here to limit the statement to acyclic
CQs as cyclic CQs are already known to be hard if we assume Hypercliqe. The direct reduction that applies also to cyclic
CQs can be found in the conference version of this article [14].

, Vol. 1, No. 1, Article . Publication date: November 2023.

20

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

By combining Lemma 3.11 and Lemma 3.13 together with the known hardness results for non-
free-connex CQs (Theorem 2.4), we prove the dichotomy given in Theorem 3.3: direct access
by a lexicographic order for a self-join-free CQ is possible with quasilinear preprocessing and
polylogarithmic time per answer if and only if the query is free-connex and does not have a
disruptive trio with respect to the required order.

4 DIRECT ACCESS BY PARTIAL LEXICOGRAPHIC ORDERS
We now investigate the case where the desired lexicographic order is partial, i.e., it contains only
some of the free variables. This means that there is no particular order requirement for the rest
of the variables. One way to achieve direct access to a partial order is to complete it into a full
lexicographic order and then leverage the results of the previous section. If such completion is
impossible, we have to consider cases where tie-breaking between the non-ordered variables is
done in an arbitrary way. However, we will show in this section that the tractable partial orders are
precisely those that can be completed into a full lexicographic order. In particular, we will prove
the following dichotomy which also gives an easy-to-detect criterion for the tractability of direct
access.

Theorem 4.1. Let ğ‘„ be a CQ and ğ¿ be a partial lexicographic order.
â€¢ If ğ‘„ is free-connex and ğ¿-connex and does not have a disruptive trio with respect to ğ¿, then direct

access by ğ¿ is possible in âŸ¨ğ‘› log ğ‘›, log ğ‘›âŸ©.

â€¢ Otherwise,

if ğ‘„ is also self-join-free,

then direct access by ğ¿ is not possible in

âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ©, assuming sparseBMM and Hyperclique.

Example 4.2. Consider the CQ ğ‘„ :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† (ğ‘¦, ğ‘§). If the free variables are exactly ğ‘¥ and ğ‘§, then
the query is not free-connex, and so it is intractable. Next assume that all variables are free. If
ğ¿ = âŸ¨ğ‘¥, ğ‘§âŸ©, then the query is not ğ¿-connex, and so it is intractable. If ğ¿ = âŸ¨ğ‘¥, ğ‘§, ğ‘¦âŸ©, then ğ‘¥, ğ‘§, ğ‘¦ is a
disruptive trio, thus the query is intractable. However, if ğ¿ = âŸ¨ğ‘¥, ğ‘¦, ğ‘§âŸ© or ğ¿ = âŸ¨ğ‘§, ğ‘¦âŸ©, then the query
is free-connex, ğ¿-connex and has no disruptive trio, so it is tractable.

4.1 Tractable Cases
For the positive side, we can solve our problem efficiently if the CQ is free-connex and there is
a completion of the lexicographic order to all free variables with no disruptive trio. Lemma 4.4
identifies these cases with a connexity criterion. To prove it, we first need a way to combine two
different connexity properties. The proof of the following proposition uses ideas from a proof of
the characterization of free-connex CQs in terms of the acyclicity of the hypergraph obtained by
including a hyperedge with the free variables [7].

Proposition 4.3. If a CQ ğ‘„ is both ğ¿1-connex and ğ¿2-connex where ğ¿2 âŠ† ğ¿1, then there exists a
join tree ğ‘‡ of an inclusive extension of ğ‘„ with a subtree ğ‘‡1 containing exactly the variables ğ¿1 and a
subtree ğ‘‡2 of ğ‘‡1 contains exactly the variables ğ¿2.

Proof. We describe a construction of the required tree. Figure 6 demonstrates our construction.
We use two different characterizations of connexity. Since ğ‘„ is ğ¿2-connex, it has an ext-ğ¿2-connex
tree ğ‘‡2. Since ğ‘„ is ğ¿1-connex, there is a join-tree ğ‘‡1 for the atoms of ğ‘„ and its head. Let ğ‘‡2 [ğ¿1] be ğ‘‡2
where the variables that are not in ğ¿1 are deleted from all nodes. That is, for every node ğ‘‰ âˆˆ ğ‘‡2, its
variables are replaced with var(ğ‘‰ ) âˆ© ğ¿1. Denote by V all neighbors of the head in ğ‘‡1, and denote
by ğ‘‡ âˆ’
1 and connecting
every node ğ‘‰1 âˆˆ V with a node ğ‘‰2 of ğ‘‡2 [ğ¿1] such that var(ğ‘‰1) âˆ© ğ¿1 = var(ğ‘‰2) gives us the tree we

1 the graph ğ‘‡1 after the deletion of the head node. Taking both ğ‘‡2 [ğ¿1] and ğ‘‡ âˆ’

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

21

ğ‘‡1:

ğ‘¥ğ‘¦ğ‘§

ğ‘‡2:

ğ‘¦

ğ‘¥ğ‘¦ğ‘

ğ‘¦ğ‘§ğ‘

ğ‘¥ğ‘¦ğ‘

ğ¿2

ğ‘¦ğ‘§ğ‘

ğ‘¦ğ‘§ğ‘‘

ğ‘ğ‘

ğ‘¦ğ‘§ğ‘‘

ğ‘ğ‘

ğ‘¥ğ‘¦ğ‘

ğ‘¦ğ‘§ğ‘

ğ‘¥ğ‘¦

ğ‘¦ğ‘§ğ‘‘

ğ‘ğ‘

ğ¿2

ğ‘¦ğ‘§

ğ‘¦

ğ‘¦ğ‘§

ğ¿1

6. Example

Fig.
4.3
ğ‘„ (ğ‘¥, ğ‘¦, ğ‘§) :âˆ’ ğ‘…1 (ğ‘¥, ğ‘¦, ğ‘), ğ‘…2 (ğ‘¦, ğ‘§, ğ‘), ğ‘…3 (ğ‘, ğ‘), ğ‘…4 (ğ‘¦, ğ‘§, ğ‘‘) with ğ¿1 = {ğ‘¥, ğ‘¦, ğ‘§} and ğ¿2 = {ğ‘¦}.

construction

Proposition

from

the

for

for

the

CQ

1 represents an atom of ğ‘„, and every atom
want. Such a node exists in ğ‘‡2 [ğ¿1] since every node of ğ‘‡ âˆ’
of ğ‘„ is contained in some node of ğ‘‡2. The subtree ğ‘‡2 [ğ¿1] contains exactly ğ‘‰1, and since this subtree
comes from an ext-ğ¿2-connex tree, it has a subtree containing exactly ğ¿1. It is easy to verify that
the result is a tree, and we can show that the running intersection property holds in the united
â–¡
graph since it holds for ğ‘‡1 and ğ‘‡2.

We are now in a position to show the following:

Lemma 4.4. Let ğ‘„ be a CQ and ğ¿ be a partial lexicographic order. If ğ‘„ is free-connex and ğ¿-connex
and does not have a disruptive trio with respect to ğ¿, then there is an ordering ğ¿+ of free(ğ‘„) that
starts with ğ¿ such that ğ‘„ has no disruptive trio with respect to ğ¿+.

Proof. According to Proposition 4.3, there is a join tree ğ‘‡ (of an inclusive extension of ğ‘„) with
a subtree ğ‘‡free containing exactly the free variables, and a subtree ğ‘‡ğ¿ of ğ‘‡free containing exactly
the ğ¿ variables. We assume that ğ‘‡ğ¿ contains at least one node; otherwise (this can only happen in
case ğ¿ is empty), we can introduce a node with no variables to all of ğ‘‡ , ğ‘‡free and ğ‘‡ğ¿ and connect it
to any one node of ğ‘‡free. We describe a process of extending ğ¿ while traversing ğ‘‡free. Consider the
nodes of ğ‘‡ğ¿ as handled, and initialize ğ¿+ = ğ¿. Then, repeatedly handle a neighbor of a handled node
until all nodes are handled. When handling a node, append to ğ¿+ all of its free variables that are not
already there. Since the join tree is connected and includes all query variables, ğ¿+ will necessarily
contain free(ğ‘„) at the end of the process. We prove by induction that ğ‘„ has no disruptive trio
w.r.t any prefix of ğ¿+. The base case is guaranteed by the premises of this lemma since ğ¿ (hence all
of its prefixes) has no disruptive trio.

Let ğ‘£ğ‘ be a new variable added to a prefix ğ‘£1, . . . , ğ‘£ğ‘âˆ’1 of ğ¿+. Let ğ‘‡ + be the subtree of ğ‘‡free with
the handled nodes when adding ğ‘£ğ‘ to ğ¿+ and let ğ‘‰ âˆ‰ ğ‘‡ + be the node being handled. Note that, since
ğ‘£ğ‘ is being added, ğ‘£ğ‘ âˆˆ ğ‘‰ but ğ‘£ğ‘ is not in any node of ğ‘‡ +.

We first claim that every neighbor ğ‘£ğ‘– of ğ‘£ğ‘ with ğ‘– < ğ‘ is in ğ‘‰ . Our arguments are illustrated in
Figure 7. Since ğ‘£ğ‘– and ğ‘£ğ‘ are neighbors, they appear together in a node ğ‘‰ğ‘–,ğ‘ outside of ğ‘‡ +. Let ğ‘‰ğ‘– be
a node in ğ‘‡ + containing ğ‘£ğ‘– (such a node exists since ğ‘£ğ‘– appears before ğ‘£ğ‘ in ğ¿+). Consider the path
from ğ‘‰ğ‘–,ğ‘ to ğ‘‰ğ‘– . Let ğ‘‰â„“ be the last node of this path not in ğ‘‡ +. If ğ‘‰â„“ â‰  ğ‘‰ , the path between ğ‘‰â„“ and
ğ‘‰ goes only through nodes of ğ‘‡ + (except for the end-points). Thus, concatenating the path from

, Vol. 1, No. 1, Article . Publication date: November 2023.

22

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

ğ‘‡ +

ğ‘‰ğ‘–

ğ‘£ğ‘–

ğ‘£ğ‘

ğ‘‰ğ‘–

ğ‘£ğ‘–

ğ‘‡ +

ğ‘‰

ğ‘£ğ‘

ğ‘‰â„“

ğ‘£ğ‘

ğ‘‰ = ğ‘‰â„“

ğ‘£ğ‘, ğ‘£ğ‘–

ğ‘‰ğ‘–,ğ‘

ğ‘£ğ‘–, ğ‘£ğ‘

ğ‘£ğ‘–, ğ‘£ğ‘

ğ‘‰ğ‘–,ğ‘

We get a contradiction in
the case where ğ‘‰ â‰  ğ‘‰â„“ .

If ğ‘£ğ‘– is a neighbor of ğ‘£ğ‘ with
ğ‘– < ğ‘›, then ğ‘£ğ‘– âˆˆ ğ‘‰ .

Fig. 7. The induction step in Lemma 4.4

ğ‘‰ğ‘–,ğ‘ to ğ‘‰â„“ with the path from ğ‘‰â„“ to ğ‘‰ results in a simple path. By the running intersection property,
all nodes on this path contain ğ‘£ğ‘ . In particular, the node following ğ‘‰â„“ contains ğ‘£ğ‘ in contradiction
to the fact that ğ‘£ğ‘ does not appear in ğ‘‡ +. Therefore, ğ‘‰â„“ = ğ‘‰ . By the running intersection property,
since ğ‘‰ is on the path between ğ‘‰ğ‘– and ğ‘‰ğ‘–,ğ‘ , we have that ğ‘‰ contains ğ‘£ğ‘– .

We now prove the induction step. We know by the inductive hypothesis that ğ‘£1, . . . , ğ‘£ğ‘âˆ’1 have
no disruptive trio. Assume by way of contradiction that appending ğ‘£ğ‘ introduces a disruptive trio.
Then, there are two variables ğ‘£ğ‘–, ğ‘£ ğ‘— with ğ‘– < ğ‘— < ğ‘ such that ğ‘£ğ‘–, ğ‘£ğ‘ are neighbors, ğ‘£ ğ‘—, ğ‘£ğ‘ are neighbors,
but ğ‘£ğ‘–, ğ‘£ ğ‘— are not neighbors. As we proved, since ğ‘£ğ‘– and ğ‘£ ğ‘— are neighbors of ğ‘£ğ‘ preceding it, we have
that all three of them appear in the handled node ğ‘‰ . This is a contradiction to the fact that ğ‘£ğ‘– and
â–¡
ğ‘£ ğ‘— are not neighbors.

The positive side of Theorem 4.1 is obtained by combining Lemma 4.4 with Theorem 3.3.

4.2 Intractable Cases
For the negative part, we prove a generalization of Lemma 3.13. Recall that according to Lemma 3.12,
we can use lexicographic direct access to enumerate the answers to a CQ with a prefix of the ordered
free variables. Similarly to Section 3.4, our goal is to find a â€œbadâ€ prefix that does not allow efficient
enumeration. For non-ğ¿-connex CQs, this is easy since ğ¿ itself is such a prefix.

Lemma 4.5. Let ğ‘„ be an acyclic self-join free CQ and ğ¿ be a partial lexicographic order. If ğ‘„ has
a disruptive trio or ğ‘„ is not ğ¿-connex, then there exists a self-join-free acyclic non-free-connex CQ
ğ‘„ â€² such that: if direct access for ğ‘„ is possible in âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ©, then enumeration for ğ‘„ â€² is
possible in âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ©.

Proof. If ğ‘„ is not ğ¿-connex, we use Lemma 3.12 with ğ¿â€² = ğ¿. If ğ¿ has a disruptive trio ğ‘£1, ğ‘£2, ğ‘£3,
we take ğ¿â€² to be the prefix of ğ¿ that ends in ğ‘£2. Then, ğ‘£1, ğ‘£3, ğ‘£2 is an ğ¿â€²-path, meaning that the body
â–¡
of ğ‘„ is not ğ¿â€²-connex. Thus, we can use Lemma 3.12 in that case too.

It is known that, assuming sparseBMM, self-join-free non-free-connex CQs cannot be answered
with polylogarithmic time per answer after quasilinear preprocessing time. Thus, we conclude from
Lemma 4.5 that self-join-free acyclic CQs with disruptive trios or that are not ğ¿-connex do not have

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

23

partial lexicographic direct access within these time bounds either. The case that ğ‘„ is cyclic is hard
since even finding any answer for cyclic CQs is not possible efficiently assuming Hypercliqe.

5 DIRECT ACCESS BY SUM OF WEIGHTS
We now consider direct access for the more general orderings based on SUM (the sum of free-
variable weights). As with lexicographic orderings, we are able to exhaustively classify tractability
for the self-join-free CQs, even those with projections. We will show that direct access for SUM is
significantly harder and tractable only for a small class of queries.

5.1 Overview of Results
The main result of this section is a dichotomy for direct access by SUM orders:

Theorem 5.1 (Direct Access by SUM). Let ğ‘„ be a CQ.
â€¢ If ğ‘„ is acyclic and an atom of ğ‘„ contains all the free variables, then direct access by SUM is

possible in âŸ¨ğ‘› log ğ‘›, 1âŸ©.

â€¢ Otherwise,

if ğ‘„ is also self-join-free, direct access by SUM is not possible in

âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ©, assuming 3sum and Hyperclique.

For the positive part of the above theorem, we will see that we are able to materialize the query
answers and keep them in a sorted array that supports direct access in constant time. The proof of
the negative part requires the query answers to express certain combinations of weights. If the
query contains independent free variables, then its answers may contain all possible combinations
of their corresponding attribute weights. We will thus rely on this independence measure to identify
hard cases.

Definition 5.2 (Independent free variables). A set of vertices ğ‘‰ğ‘– âŠ† ğ‘‰ of a hypergraph H (ğ‘‰ , ğ¸) is
called independent iff no pair of these vertices appears in the same hyperedge, i.e., |ğ‘‰ğ‘– âˆ© ğ‘’ | â‰¤ 1 for
all ğ‘’ âˆˆ ğ¸. For a CQ ğ‘„, we denote by ğ›¼free (ğ‘„) the maximum number of variables among free(ğ‘„)
that are independent in H (ğ‘„).

Intuitively, we can construct a database instance where each independent free variable is assigned
to ğ‘› different domain values with ğ‘› different weights. By appropriately choosing the assignment of
the other variables, all possible ğ‘›ğ›¼free (ğ‘„) combinations of these weights will appear in the query
answers. Providing direct access then implies that we can retrieve these sums in ranked order. We
later use this to show that direct access on certain CQs allows us to solve 3sum efficiently.

Example 5.3. For ğ‘„ (ğ‘¥, ğ‘¦, ğ‘§) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† (ğ‘¦, ğ‘§),ğ‘‡ (ğ‘§, ğ‘¢), we have ğ›¼free (ğ‘„) = 2, namely for variables
{ğ‘¥, ğ‘§}. Let the binary relation ğ‘… be [1, ğ‘›] Ã— {0}, i.e., the cross product between the set of values
from 1 to ğ‘› with the single value 0. If we also set ğ‘† = {0} Ã— [1, ğ‘›] and ğ‘‡ = [1, ğ‘›] Ã— {0}, then the
query answers are the ğ‘›2 assignments of (ğ‘¥, ğ‘¦, ğ‘§) to [1, ğ‘›] Ã— [1, ğ‘›] Ã— {0}. The ğ‘› values of ğ‘¥ and ğ‘§
can be respectively assigned to any real-valued weights such that direct access on ğ‘„ retrieves
their ğ‘–th sum in ranked order.

Our independence measure ğ›¼free (ğ‘„) is related to the classification of Theorem 5.1 in the following

way:

Lemma 5.4. For an acyclic CQ ğ‘„, an atom contains all the free variables iff ğ›¼free (ğ‘„) â‰¤ 1.

Proof. The â€œonly ifâ€ part of ğ›¼free(ğ‘„) > 1 follows immediately from Definition 5.2.
For ğ›¼free (ğ‘„) = 1 and acyclic query ğ‘„, we prove that there is an atom ğ‘…ğ‘“ (Xğ‘“ ) which contains all
the free variables. First note that for |free(ğ‘„)| = 1 this is trivially true. For |free(ğ‘„)| > 1, let ğ‘‰ be
a node in the join tree (corresponding to some atom of ğ‘„) that contains the maximum number of

, Vol. 1, No. 1, Article . Publication date: November 2023.

24

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

Query condition
Direct access
acyclic ğ›¼free (ğ‘„) = 1
possible in
not possible in
acyclic ğ›¼free (ğ‘„) = 2
acyclic ğ›¼free (ğ‘„) â‰¥ 3 not possible in

Complexity
âŸ¨ğ‘› log ğ‘›, 1âŸ©
âŸ¨ğ‘›2âˆ’ğœ–, ğ‘›1âˆ’ğœ– âŸ©
âŸ¨ğ‘›2âˆ’ğœ–, ğ‘›2âˆ’ğœ– âŸ©
not possible in âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ© Hypercliqe

Reason
Lemma 5.9
3sum
3sum

cyclic

Fig. 8. Possibility of direct access by sum of weights for acyclic self-join-free conjunctive queries.

free variables and assume for the sake of contradiction that there exists a free variable ğ‘¦ with ğ‘¦ âˆ‰ ğ‘‰ .
We use Vğ‘¦ to denote the set of nodes in the join tree that contain variable ğ‘¦; thus ğ‘‰ âˆ‰ Vğ‘¦. From ğ‘„
being acyclic follows that the nodes in Vğ‘¦ form a connected graph and there exists a node ğ‘‰ â€² that
lies on every path from ğ‘‰ to a node in Vğ‘¦. Since ğ›¼free (ğ‘„) = 1, each variable ğ‘¥ âˆˆ ğ‘‰ must appear
together with ğ‘¦ in some query atom, implying that ğ‘¥ appears in some node ğ‘‰ â€²â€² âˆˆ Vğ‘¦. From that
and the running intersection property follows that ğ‘¥ must also appear in ğ‘‰ â€² since ğ‘‰ â€² lies on the
path from ğ‘‰ to any such ğ‘‰ â€²â€². Hence ğ‘‰ â€² contains ğ‘¦ and all the ğ‘‰ variables, violating the maximality
assumption for ğ‘‰ .

For ğ›¼free (ğ‘„) = 0, ğ‘„ is a Boolean query and any atom trivially contains the empty set.

â–¡

Therefore, the dichotomy of Theorem 5.1 can equivalently be stated using ğ›¼free(ğ‘„) â‰¤ 1 as a
criterion. We chose to use the other criterion (all free variables contained in one atom) in the
statement of our theorem statement as it is more straightforward to check. In the next section, we
proceed to prove our theorem by showing intractability for all queries with ğ›¼free (ğ‘„) > 1 and a
straight-forward algorithm for ğ›¼free (ğ‘„) â‰¤ 1.

5.2 Proofs
For the hardness results, we rely mainly on the 3sum hypothesis. To more easily relate our direct-
access problem to 3sum, which asks for the existence of a particular sum of weights, it is useful to
define an auxiliary problem:

Definition 5.5 (weight lookup). Given a CQ ğ‘„ and a weight function ğ‘¤ over its possible answers,
weight lookup takes as an input a database ğ¼ and ğœ† âˆˆ R, and returns the first index of a query answer
ğ‘ âˆˆ ğ‘„ (ğ¼ ) with ğ‘¤ (ğ‘) = ğœ† in the array of answers sorted by ğ‘¤ or â€œnoneâ€ if no such answer exists.

The following lemma associates direct access with weight lookup via binary search on the query

answers:

Lemma 5.6. For a CQ ğ‘„, if the ğ‘˜ th query answer ordered by a weight function ğ‘¤ can be directly ac-
cessed in O (ğ‘”(ğ‘›)) time for every ğ‘˜, then weight lookup for ğ‘„ and ğ‘¤ can be performed in O (ğ‘”(ğ‘›) log ğ‘›).

Proof. We use binary search on the sorted array of query answers. Each direct access returns a
query answer whose weight can be computed in O (1). Thus, in a logarithmic number of accesses
we can find the first occurrence of the desired weight. Since the number of answers is polynomial
â–¡
in ğ‘›, the number of accesses is O (log ğ‘›) and each one takes O (ğ‘”(ğ‘›)) time.

Lemma 5.6 implies that whenever we are able to support efficient direct access on the sorted
array of query answers, weight lookup increases time complexity only by a logarithmic factor,
i.e., it is also efficient. The main idea behind our reductions is that via weight lookups on a CQ
with an appropriately constructed database, we can decide the existence of a zero-sum triplet over
three distinct sets of numbers, thus hardness follows from 3sum. First, we consider the case of
three independent variables that are free. These three variables are able to simulate a three-way

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

25

Cartesian product in the query answers. This allows us to directly encode the 3sum triplets using
attribute weights, obtaining a lower bound for direct access.

Lemma 5.7. If a CQ ğ‘„ is self-join-free and ğ›¼free (ğ‘„) â‰¥ 3, then direct access by SUM is not possible in

âŸ¨ğ‘›2âˆ’ğœ–, ğ‘›2âˆ’ğœ– âŸ© for any ğœ– > 0 assuming 3sum.

Proof. Assume for the sake of contradiction that the lemma does not hold. We show that
this would imply an ğ‘‚ (ğ‘›2âˆ’ğœ– )-time algorithm for 3sum. To this end, consider an instance of 3sum
with integer sets ğ´, ğµ, and ğ¶ of size ğ‘›, given as arrays. We reduce 3sum to direct access over the
appropriate query and input instance by using a construction similar to Example 5.3. Let ğ‘¥, ğ‘¦, and
ğ‘§ be free and independent variables of ğ‘„, which exist because ğ›¼free (ğ‘„) â‰¥ 3. We create a database
instance where ğ‘¥, ğ‘¦, and ğ‘§ take on each value in [1, ğ‘›], while all the other attributes have value
0. This ensures that ğ‘„ has exactly ğ‘›3 answersâ€”one for each (ğ‘¥, ğ‘¦, ğ‘§) combination in [1, ğ‘›]3, no
matter the number of atoms and the variables they contain. To see this, note that since ğ‘¥, ğ‘¦, and ğ‘§
are independent, no pair of them appears together in an atom. Also, since ğ‘„ is self-join-free, each
relation appears once in the query, hence contains at most one of ğ‘¥, ğ‘¦, and ğ‘§. Thus each relation
either contains 1 tuple (if neither ğ‘¥, ğ‘¦, nor ğ‘§ is present) or ğ‘› tuples (if one of ğ‘¥, ğ‘¦, or ğ‘§ is present).
No matter on which attributes these relations are joined (including Cartesian products), the output
result is always the â€œsameâ€ set [1, ğ‘›]3 Ã— {0}ğ‘“ of size ğ‘›3, where ğ‘“ is the number of free variables
other than ğ‘¥, ğ‘¦, and ğ‘§. (We use the term â€œsameâ€ loosely for the sake of simplicity. Clearly, for
different values of ğ‘“ the query-result schema changes, e.g., consider Example 5.3 with ğ‘§ removed
from the head. However, this only affects the number of additional 0s in each of the ğ‘›3 answer
tuples, therefore it does not impact our construction.)

For the reduction from 3sum, weights are assigned to the attribute values as ğ‘¤ğ‘¥ (ğ‘–) = ğ´[ğ‘–],
ğ‘¤ğ‘¦ (ğ‘–) = ğµ [ğ‘–], ğ‘¤ğ‘§ (ğ‘–) = ğ¶ [ğ‘–], ğ‘– âˆˆ [1, ğ‘›], and ğ‘¤ğ‘¢ (0) = 0 for all other attributes ğ‘¢. By our weight
assignment, the weights of the answers are ğ´[ğ‘–] + ğµ [ ğ‘—] +ğ¶ [ğ‘˜], ğ‘–, ğ‘—, ğ‘˜ âˆˆ [1, ğ‘›], and thus in one-to-one
correspondence with the possible value combinations in the 3sum problem. We first perform the
preprocessing for direct access in ğ‘‚ (ğ‘›2âˆ’ğœ– ), which enables direct access to any position in the sorted
array of query answers in ğ‘‚ (ğ‘›2âˆ’ğœ– ). By Lemma 5.6, weight lookup for a query result with zero
weight is possible in ğ‘‚ (ğ‘›2âˆ’ğœ– log ğ‘›). Thus, we answer the original 3sum problem in ğ‘‚ (ğ‘›2âˆ’ğœ–â€²) for any
â–¡
0 < ğœ– â€² < ğœ–, violating the 3sum hypothesis.

For queries that do not have three independent free variables, we need a slightly different
construction. We show next that two variables are sufficient to encode partial 3sum solutions (i.e.,
pairs of elements), enabling a full solution of 3sum via weight lookups. This yields a weaker lower
bound than Lemma 5.7, but still is sufficient to prove intractability according to our yardstick.

Lemma 5.8. If a CQ ğ‘„ is self-join-free and ğ›¼free (ğ‘„) = 2, then direct access by SUM is not possible in

âŸ¨ğ‘›2âˆ’ğœ–, ğ‘›1âˆ’ğœ– âŸ© for any ğœ– > 0 assuming 3sum.

Proof. We show that a counterexample query would violate the 3sum hypothesis. Let ğ´, ğµ, and ğ¶
be three integer arrays of a 3sum instance of size ğ‘›. We construct a database instance with attribute
weights like in the proof of Lemma 5.7, but now with only 2 free and independent variables ğ‘¥ and ğ‘¦.
Hence the weights of the ğ‘›2 query results are in one-to-one correspondence with the corresponding
sums ğ´[ğ‘–] + ğµ [ ğ‘—], ğ‘–, ğ‘— âˆˆ [1, ğ‘›]. We run the preprocessing phase for direct access in ğ‘‚ (ğ‘›2âˆ’ğœ– ), which
allows us to access the sorted array of query results in ğ‘‚ (ğ‘›1âˆ’ğœ– ). For each value ğ¶ [ğ‘˜] in ğ¶, we
perform a weight lookup on ğ‘„ for weight âˆ’ğ¶ [ğ‘˜], which takes time ğ‘‚ (ğ‘›1âˆ’ğœ– log ğ‘›) (Lemma 5.6). If
that returns a valid index, then there exists a pair (ğ‘–, ğ‘—) of ğ´ and ğµ with sum ğ´[ğ‘–] + ğµ [ ğ‘—] = âˆ’ğ¶ [ğ‘˜],
which implies ğ´[ğ‘–] + ğµ [ ğ‘—] + ğ¶ [ğ‘˜] = 0; otherwise no such pair exists. Since there are ğ‘› values in ğ¶,
total time complexity is O (ğ‘› Â· ğ‘›1âˆ’ğœ– log ğ‘›) = O (ğ‘›2âˆ’ğœ– log ğ‘›). This procedure solves 3sum in ğ‘‚ (ğ‘›2âˆ’ğœ–â€²)
â–¡
for any 0 < ğœ– â€² < ğœ–, violating the 3sum hypothesis.

, Vol. 1, No. 1, Article . Publication date: November 2023.

26

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

A special case of Lemma 5.8 is closely related to the problem of selection in ğ‘‹ + ğ‘Œ [31], where
we want to access the ğ‘˜ th smallest sum of pairs between two sets ğ‘‹ and ğ‘Œ . This is equivalent to
accessing the answers to ğ‘„ğ‘‹ğ‘Œ (ğ‘¥, ğ‘¦) :âˆ’ ğ‘…(ğ‘¥), ğ‘† (ğ‘¦) by a SUM order. It has been shown that if ğ‘‹ and ğ‘Œ
are given sorted, then selection (single access) is possible even in linear time [21, 36]. Thus, for ğ‘„ğ‘‹ğ‘Œ
direct access by SUM is possible in âŸ¨ğ‘› log ğ‘›, ğ‘›âŸ© if we sort the relations during the preprocessing
phase. Compared to our âŸ¨ğ‘›2âˆ’ğœ–, 1 âˆ’ ğœ–âŸ© lower bound (see also Figure 8), notice that even though
the preprocessing of this algorithm is lower (asymptotically), the access time is not sublinear
(ğ‘’ğ‘ğ‘ ğ‘–ğ‘™ğ‘œğ‘› = 0).

So far, we have covered all self-join-free CQs with ğ›¼free (ğ‘„) > 1, which, by Lemma 5.4, proves
the negative part of Theorem 5.1. Next, we show that the remaining acyclic CQs (those with
ğ›¼free (ğ‘„) â‰¤ 1 or equivalently, an atom containing all the free variables) are tractable. For these
queries, a single relation contains all the answers, so direct access can easily be supported by
reducing, projecting, and sorting that relation.

Lemma 5.9. If a CQ ğ‘„ is acyclic and an atom contains all the free variables, then direct access by

SUM is possible in âŸ¨ğ‘› log ğ‘›, 1âŸ©.

Proof. Since all free variables appear in one atom ğ‘…ğ‘“ (Xğ‘“ ), we can apply a linear-time semi-join
reduction as in the Yannakakis algorithm [47] to remove the dangling tuples, and then compute the
query answers by projecting ğ‘… on the free variables. Then, we sort the query answers by the sum
of weights, which takes total time O (ğ‘› log ğ‘›) for preprocessing. We maintain the sorted answers in
â–¡
an array, which enables constant-time direct access to individual answers in ranked order.

We now combine these lemmas with the fact that Boolean self-join-free cyclic CQs cannot be

answered in O (ğ‘› polylog ğ‘›) time assuming Hypercliqe, completing the proof of Theorem 5.1.

6 SELECTION BY LEXICOGRAPHIC ORDERS
We next investigate the tractability of a simpler version of the problem: When is selection, i.e.,
direct access to a single query answer, possible in quasilinear time? In this section, we answer this
question for lexicographic orders and in Section 7 we move to the case of SUM. Unlike direct-access,
we show that selection can be efficiently achieved for any lexicographic order, as long as the query
is free-connex. Our main result in this setting is summarized below:

Theorem 6.1 (Selection by LEX). Let ğ‘„ be a CQ and ğ¿ be a partial lexicographic order.
â€¢ If ğ‘„ is free-connex, then selection by ğ¿ is possible in âŸ¨1, ğ‘›âŸ©.
â€¢ Otherwise, if ğ‘„ is also self-join-free, then selection by ğ¿ is not possible in âŸ¨1, ğ‘› polylog ğ‘›âŸ©,

assuming Seth and Hyperclique.

Our theorem shows that when we limit ourselves to the problem of selection, the tractability of

the problem depends only on the query structure and is independent of the lexicographic order.

Example 6.2. Recall that direct access by ğ¿ is intractable for ğ‘„ (ğ‘£1, ğ‘£2, ğ‘£3) :âˆ’ ğ‘…(ğ‘£1, ğ‘£3), ğ‘† (ğ‘£3, ğ‘£2)
with ğ¿ being the lexicographic order âŸ¨ğ‘£1, ğ‘£2, ğ‘£3âŸ© or the partial lexicographic order âŸ¨ğ‘£1, ğ‘£2âŸ©. The
former contains a disruptive trio while the latter is not ğ¿-connex. However, selection is tractable
in both cases. Still, if we project out the middle variable ğ‘£3 and the head of the CQ is ğ‘„ (ğ‘£1, ğ‘£2),
then the CQ is not free-connex and thus, selection becomes intractable for any lexicographic
order.

For the negative part of Theorem 6.1, we reduce the problem of selection to that of counting

query answers.

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

27

Lemma 6.3. For a CQ ğ‘„, if selection by some ranking function is possible in âŸ¨1, ğ‘“ (ğ‘›)âŸ© for a function

ğ‘“ , then counting the answers to the CQ ğ‘„ is possible in O (ğ‘“ (ğ‘›) log ğ‘›).

Proof. We reduce the counting problem to the selection problem under any ranking function.
If the number of relations in the query is â„“, then an upper bound on the number of answers is ğ‘›â„“ .
We use selection to determine whether any index contains an answer. With binary search on the
range of indices [0, ğ‘›â„“ ), we can find the smallest index that does not correspond to an answer. This
process requires only O (log ğ‘›â„“ ) = O (log ğ‘›) selections since â„“ is constant.
â–¡

We can now exploit lower bounds based on Seth. The proof does not rely on the properties of

lexicographic orders and thus captures any possible ordering of the query answers.

Lemma 6.4. If a self-join-free CQ ğ‘„ is not free-connex, then selection by any ranking function is not

possible in âŸ¨1, ğ‘› polylog ğ‘›âŸ© assuming Seth and Hyperclique.

Proof. We use the fact that, assuming Seth, the answers to a self-join-free and acyclic non-free-
connex CQ cannot be counted in O (ğ‘›2âˆ’ğœ– ) for any constant ğœ– [35]. By Lemma 6.3, if selection is
possible in O (ğ‘› polylog ğ‘›), then we can also count the number of query answers in O (ğ‘› polylog ğ‘›),
contradicting our hypothesis. Cyclic CQs are covered by the hardness of Boolean self-join-free
â–¡
cyclic CQs based on Hypercliqe, completing the proof.

For the remainder of this section, we give a selection algorithm that together with Lemma 6.4

completes the proof of Theorem 6.1

6.1 Lexicographic Selection Algorithm
We first claim that, for any free variable in a free-connex CQ, we can efficiently compute the
histogram of its assignments in the query answers. This is essentially equivalent to a group-by
query that groups the query answers based on a single variable, and then counts how many answers
fall within each group.

Lemma 6.5. Let ğ‘„ be a free-connex CQ and ğ‘£ âˆˆ free(ğ‘„). Given an input database ğ¼ , we can compute

in linear time how many answers in ğ‘„ (ğ¼ ) assign ğ‘ to ğ‘£ for each value ğ‘ in the active domain of ğ‘£.

Proof. Following Proposition 2.3, we can transform the problem to an equivalent problem with
a full acyclic CQ ğ‘„ â€². We then take a join-tree for ğ‘„ â€², identify a node ğ‘‰ğ‘ containing ğ‘£, and introduce
a new node ğ‘‰ğ‘Ÿ as a neighbor of ğ‘‰ğ‘ . We associate ğ‘‰ğ‘Ÿ with the single variable ğ‘£, assign ğ‘‰ğ‘Ÿ with a
unary relation that contains the active domain of ğ‘£, and set ğ‘‰ğ‘Ÿ to be the root of the tree. Then, we
follow the preprocessing explained in Section 3.1 over this tree. By the end of this preprocessing,
each tuple is given a weight that indicates the number of different answers that this tuple agrees
â–¡
with when only joining its subtree. Thus, the weights for ğ‘‰ğ‘Ÿ will contain the desired values.

This count guides our selection algorithm as it iteratively chooses an assignment for the next
variable in the lexicographic order. Comparing the desired index with the count, it chooses an
appropriate value for the next variable, filters the remaining relations according to the chosen
value, and continues with the next variable.

Lemma 6.6. Let ğ‘„ be a free-connex CQ and ğ¿ be a partial lexicographic order. Then, selection by ğ¿

is possible in âŸ¨1, ğ‘›âŸ©.

Proof. Let âŸ¨ğ‘£1, . . . , ğ‘£ğ‘šâŸ© be a completion of ğ¿ to a full lexicographic order, and let ğ‘˜ be the index
we want to access. We perform the following starting with ğ‘– = 1. Let ğ‘1, . . . , ğ‘ğ‘š be the ordered
values in the active domain of ğ‘£ğ‘– (the algorithm does not sort them because that would already
take O (ğ‘› log ğ‘›)). We use Lemma 6.5 to count, for each ğ‘ğ‘Ÿ , the number of answers that assign ğ‘ğ‘Ÿ

, Vol. 1, No. 1, Article . Publication date: November 2023.

28

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

ğ‘Ÿ =1 weight(ğ‘ğ‘Ÿ ) â‰¤ ğ‘˜ < (cid:205)ğ‘—

to ğ‘£ğ‘– , denoted by weight(ğ‘ğ‘Ÿ ). Then, we find ğ‘— such that (cid:205)ğ‘—âˆ’1
ğ‘Ÿ =1 weight(ğ‘ğ‘Ÿ )
and select the value ğ‘ ğ‘— for ğ‘£ğ‘– . This computation can be done in O (ğ‘›) without sorting if we use
a weighted selection algorithm [31]. We proceed to filter all relations according to the ğ‘£ğ‘– = ğ‘ ğ‘—
assignment, update ğ‘˜ to ğ‘˜ âˆ’ (cid:205)ğ‘—âˆ’1
ğ‘Ÿ =1 weight(ğ‘ğ‘Ÿ ), and continue iteratively with ğ‘– + 1. In each iteration,
the value for another variable is determined, where (cid:205)ğ‘—âˆ’1
ğ‘Ÿ =1 weight(ğ‘ğ‘Ÿ ) answers contain a strictly
smaller value for the variable, and the next iterations break the tie between the weight(ğ‘ ğ‘— ) answers
that have this value. For the running time, each iteration takes linear time and we have a constant
â–¡
number of iterations (one iteration for every free variable).

7 SELECTION BY SUM OF WEIGHTS
We now move on to the problem of selection by SUM order. Given that direct access by this order
with quasilinear preprocessing and polylogarithmic delay is possible only in very few cases, it is a
natural question to ask how the tractability landscape changes when considering the simpler task
of selection.

7.1 Overview of Results
We show that the simplifications move only a narrow class of queries to the tractable side. For
example, the 2-path query ğ‘„2(ğ‘¥, ğ‘¦, ğ‘§) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† (ğ‘¦, ğ‘§) is tractable for selection, even though it is
not for direct access. On the other hand, the 3-path query ğ‘„3(ğ‘¥, ğ‘¦, ğ‘§, ğ‘¢) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† (ğ‘¦, ğ‘§),ğ‘‡ (ğ‘§, ğ‘¢)
remains intractable. Given that ğ‘„2 and ğ‘„3 both have two free and independent variables, a different
criterion than that of Section 5 (ğ›¼free (ğ‘„) or number of atoms containing the free variables) is needed
for classification. To this end, we use hypergraph Hfree (ğ‘„). Recall that it is the restriction of the
query hypergraph H (ğ‘„) to the free variables, i.e., all the other variables are removed.

Definition 7.1 (Maximal Hyperedges). For a hypergraph H = (ğ‘‰ , ğ¸), we denote the number of
maximal hyperedges w.r.t. containment by mh(H ), i.e., mh(H ) = |{ğ‘’ âˆˆ ğ¸ | (cid:154)ğ‘’ â€² âˆˆ ğ¸ : ğ‘’ âŠ‚ ğ‘’ â€²}|.
The number of maximal hyperedges of a query ğ‘„ is mh(ğ‘„) = mh(H (ğ‘„)) and the number of
free-maximal hyperedges of ğ‘„ is fmh(ğ‘„) = mh(Hfree (ğ‘„)).

Example 7.2. For ğ‘„ (ğ‘¥, ğ‘§, ğ‘¤) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† (ğ‘¦, ğ‘§),ğ‘‡ (ğ‘§, ğ‘¤), ğ‘ˆ (ğ‘¥), we have mh(ğ‘„) = 3 because ğ‘ˆ
is contained in ğ‘… and fmh(ğ‘„) = 2 because after removing the existentially-quantified ğ‘¦, the
remainder of the ğ‘†-hyperedge is contained in ğ‘‡ .

Remark 4. For any CQ ğ‘„ we have ğ›¼free(ğ‘„) â‰¤ fmh(ğ‘„). This follows from the fact that each
independent variable must appear in a maximal hyperedge and that each hyperedge cannot contain
more than 1 independent variable by definition. Note also that the condition ğ›¼free (ğ‘„) â‰¤ 1 is equivalent
to fmh(ğ‘„) â‰¤ 1, giving us a third possible way to express the criterion of Theorem 5.1 for direct access.
We summarize the results of this section in the following theorem, which classifies CQs ğ‘„ based

on fmh(ğ‘„):

Theorem 7.3 (Selection by SUM). Let ğ‘„ be a CQ.
â€¢ If ğ‘„ is free-connex and fmh(ğ‘„) â‰¤ 2, then selection by SUM is possible in âŸ¨1, ğ‘› log ğ‘›âŸ©.
â€¢ Otherwise, if ğ‘„ is also self-join-free, then selection by SUM is not possible in âŸ¨1, ğ‘› polylog ğ‘›âŸ©.

assuming 3sum, Hyperclique, and Seth.

Example 7.4. For the query ğ‘„2(ğ‘¥, ğ‘¦, ğ‘§) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† (ğ‘¦, ğ‘§) we have already shown in Section 5
that direct access by SUM is intractable. However, given that it has two maximal hyperedges, only
one access (or a constant number of them) is in fact possible in O (ğ‘› log ğ‘›). The situation does not

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

29

change for ğ‘„ â€²
3(ğ‘¥, ğ‘¦, ğ‘§) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† (ğ‘¦, ğ‘§),ğ‘‡ (ğ‘§, ğ‘¢) because the hyperedge of ğ‘‡ is contained in ğ‘† in
the free-restricted hypergraph. However, ğ‘„3(ğ‘¥, ğ‘¦, ğ‘§, ğ‘¢) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† (ğ‘¦, ğ‘§),ğ‘‡ (ğ‘§, ğ‘¢) which keeps the
variable ğ‘¢ in the answers is intractable for selection because now ğ‘‡ corresponds to a free-maximal
hyperedge.

Before proving Theorem 7.3, we first introduce some necessary concepts and prove a useful

lemma.

Absorbed atoms and variables. We say that an atom ğ‘’ is absorbed by an atom ğ‘’ â€² â‰  ğ‘’ if ğ‘‰ âŠ† ğ‘‰ â€²
where ğ‘‰ and ğ‘‰ â€² are their sets of variables respectively. Additionally, we say that a variable ğ‘£ is
absorbed by a variable ğ‘¢ â‰  ğ‘£ if (1) they appear in exactly the same atoms and (2) it is not the
case that ğ‘£ is free and ğ‘¢ is not free. As evident from Theorem 7.3, adding to a query atoms or
variables that are absorbed by existing ones does not affect the complexity of selection. We prove
this claim first and use it later in our analysis in order to treat queries that contain absorbed atoms
or variables.

Definition 7.5 (Maximal Contraction). A query ğ‘„ â€² is a contraction of ğ‘„ if we can obtain ğ‘„ â€² by
iteratively removing absorbed atoms and variables, one at a time. ğ‘„ğ‘š is a maximal contraction of ğ‘„
if it is a contraction and there is no contraction of ğ‘„ğ‘š.

Note that the number of atoms of a maximal contraction ğ‘„ğ‘š of ğ‘„ is mh(ğ‘„).

Example 7.6. Consider ğ‘„ (ğ‘¥, ğ‘¦, ğ‘§) :âˆ’ ğ‘…(ğ‘¥, ğ‘¢, ğ‘¦), ğ‘† (ğ‘¦),ğ‘‡ (ğ‘¦, ğ‘§), ğ‘ˆ (ğ‘¥, ğ‘¢, ğ‘¦). Here, ğ‘† (ğ‘¦) is absorbed by
ğ‘…(ğ‘¥, ğ‘¢, ğ‘¦) and ğ‘ˆ (ğ‘¥, ğ‘¢, ğ‘¦), and the latter two absorb each other. Additionally, the free variable ğ‘¥
absorbs ğ‘¢ since these two variables appear together in ğ‘… and ğ‘ˆ . Thus, a maximal contraction
of ğ‘„ is ğ‘„ğ‘š (ğ‘¥, ğ‘¦, ğ‘§) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦),ğ‘‡ (ğ‘¦, ğ‘§), which is unique up to renaming. The number of maximal
hyperdges of ğ‘„ is mh(ğ‘„) = 2.

Lemma 7.7. Selection for a CQ ğ‘„ by SUM is possible in âŸ¨1, ğ‘”(ğ‘›)âŸ© if selection for a maximal contraction

ğ‘„ğ‘š of ğ‘„ by SUM is possible in âŸ¨1, ğ‘”(ğ‘›)âŸ©. The converse is also true if ğ‘„ is self-join-free.

Proof. For the â€œifâ€ direction, we use selection on ğ‘„ğ‘š to solve selection on ğ‘„. We can remove
absorbed atoms from ğ‘„ after making sure that the tuples in the database satisfy those atoms. Thus,
to remove an atom ğ‘† (Y) which is absorbed by ğ‘…(X), we filter the relation ğ‘… based on the tuples of
ğ‘†. To remove a variable ğ‘£ that is absorbed by ğ‘¢, in all relations that contain both ğ‘¢ and ğ‘£ we â€œpackâ€
them together: We remove ğ‘£ and replace the ğ‘¢-values by values that represent the pair (ğ‘¢, ğ‘£) and
assign to it the weight ğ‘¤ (ğ‘¢) + ğ‘¤ (ğ‘£). (Note that we assign ğ‘¤ (ğ‘§) = 0 for all variables ğ‘§ that are not
free.) After separating any packed variables, ğ‘„ğ‘š over the modified database has the same answers
as ğ‘„ over the original one and the weights are preserved.

For the â€œonly ifâ€ direction, we create an extended database where the answers to ğ‘„ are the same
as those of ğ‘„ğ‘š over the original database. For each step of the contraction, we make a modification
of the database. If an atom ğ‘† (Y) was removed because it was absorbed by another atom ğ‘…(X), then
we create the relation ğ‘† by copying ğœ‹Y (ğ‘…). Note that we are allowed to create ğ‘† without restrictions
because ğ‘„ has no self-joins, hence the database does not already contain the relation. If a variable ğ‘£
was removed because it was absorbed by another variable ğ‘¢, then we extend all the relations that ğ‘¢
appears in with another attribute ğ‘£ that takes the constant âŠ¥ value everywhere and has weight
ğ‘¤ğ‘£ (âŠ¥) = 0. After projecting away the new variable, this construction does not change the query
answers or their weights.

The above reductions take linear time, which is dominated by ğ‘”(ğ‘›) since ğ‘”(ğ‘›) is trivially in Î©(ğ‘›)
â–¡

for the selection problem.

, Vol. 1, No. 1, Article . Publication date: November 2023.

30

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

To prove Theorem 7.3 we first limit our attention to the class of full CQs (for them mh(ğ‘„) =
fmh(ğ‘„)) and prove the positive part in Section 7.2 and the negative part in Section 7.3. We then
extend those results to more general CQs with projections in Section 7.4.

7.2 Tractability Proofs for Full CQs
In this section, we provide tractability results for full CQs with mh(ğ‘„) â‰¤ 2. First, we consider the
trivial case of mh(ğ‘„) = 1 where the maximal contraction of ğ‘„ has only one atom. The lemma
below is a direct consequence of the linear-time array selection algorithm of Blum et al. [9].

Lemma 7.8. For a full CQ ğ‘„ with mh(ğ‘„) = 1, selection by SUM is possible in âŸ¨1, ğ‘›âŸ©.

Proof. By Lemma 7.7, it suffices to solve selection on the query ğ‘„ (ğ‘¥) :âˆ’ ğ‘…(ğ‘¥), which is a maximal
contraction of all queries with mh(ğ‘„) = 1, up to renaming. Trivially, the weights of the single
attribute can also be viewed as tuple weights. Thus, applying linear-time selection [9] on the tuples
of ğ‘… gives us the ğ‘˜ th smallest query answer.
â–¡

For the mh(ğ‘„) = 2 case, we rely on an algorithm by Frederickson and Johnson [21], which
generalizes selection on the X+Y problem. If the two sets ğ‘‹ and ğ‘Œ are given sorted, then the
pairwise sums can be represented as a sorted matrix. A sorted matrix ğ‘€ contains a sequence of
non-decreasing elements in every row and every column. For the ğ‘‹ + ğ‘Œ problem, a cell ğ‘€ [ğ‘–, ğ‘—]
contains the sum ğ‘‹ [ğ‘–] + ğ‘Œ [ ğ‘—]. Even though the matrix ğ‘€ has quadratically many cells, there is no
need to construct it in advance given that we can compute each cell in constant time. Selection
on a union of such matrices {ğ‘€1, . . . , ğ‘€â„“ } asks for the ğ‘˜ th smallest element among the cells of all
matrices.

Theorem 7.9 ([21]). Selection on a union of sorted matrices {ğ‘€1, . . . , ğ‘€â„“ }, where ğ‘€ğ‘š has dimension

ğ‘ğ‘š Ã— ğ‘ğ‘š with ğ‘ğ‘š â‰¥ ğ‘ğ‘š, is possible in time O ((cid:205)â„“

ğ‘š=1 ğ‘ğ‘š log(2ğ‘ğ‘š/ğ‘ğ‘š)).

Leveraging this algorithm, we provide our next positive result:

Lemma 7.10. For a full CQ ğ‘„ with mh(ğ‘„) = 2, selection by SUM is possible in âŸ¨1, ğ‘› log ğ‘›âŸ©.

Proof. The maximal contraction of full CQs with mh(ğ‘„) = 2 is ğ‘„1 (ğ‘¥, ğ‘§) :âˆ’ ğ‘…(ğ‘¥), ğ‘† (ğ‘§) or
ğ‘„2(ğ‘¥, ğ‘¦, ğ‘§) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† (ğ‘¦, ğ‘§), up to renaming. Thus by Lemma 7.7, it is enough to prove an O (ğ‘› log ğ‘›)
bound for these two queries. As before, we turn the attribute weights into tuple weights. For ğ‘„1,
the attribute weights are trivially tuple weights and for ğ‘„2, we assign each attribute weight to only
one relation to avoid double-counting. Thus, for ğ‘„2 we compute ğ‘¤ (ğ‘Ÿ ) = ğ‘¤ğ‘¥ (ğ‘Ÿ [ğ‘¥]) + ğ‘¤ğ‘¦ (ğ‘Ÿ [ğ‘¦]) and
ğ‘¤ (ğ‘ ) = ğ‘¤ğ‘§ (ğ‘  [ğ‘§]) for all ğ‘Ÿ âˆˆ ğ‘… and ğ‘  âˆˆ ğ‘†, respectively. Since the query is full, the weights of the
query answers are in one-to-one correspondence with the pairwise sums of weights of tuples from
ğ‘… and ğ‘†.

For ğ‘„2, we group the ğ‘… and ğ‘† tuples by their ğ‘¦ values: we create â„“ buckets of tuples where
all tuples ğ‘¡ within a bucket have equal ğ‘¡ [ğ‘¦] values. This can be done in linear time. For ğ‘„1, we
place all tuples in a single bucket. For each assignment of a ğ‘¦ value (no assignment for the case
of ğ‘„1), the query answers with those values are formed by the Cartesian product of ğ‘… and ğ‘†
tuples inside that bucket. Also, if the size of bucket ğ‘š is ğ‘›ğ‘š, then ğ‘›1 + Â· Â· Â· + ğ‘›â„“ = |ğ‘…| + |ğ‘† | = O (ğ‘›).
We sort the tuples in each bucket (separately for each relation) according to their weight in
O (ğ‘› log ğ‘›) time. Assume ğ‘…ğ‘š and ğ‘†ğ‘š are the partitions of ğ‘… and ğ‘† in bucket ğ‘š and ğ‘…ğ‘š [ğ‘–] denotes
the ğ‘–th tuple of ğ‘…ğ‘š in sorted order (equivalently for ğ‘†ğ‘š [ ğ‘—]). We define a union of sorted matrices
{ğ‘€1, . . . , ğ‘€â„“ } by setting for each bucket ğ‘š: ğ‘€ğ‘š [ğ‘–, ğ‘—] = ğ‘¤ (ğ‘…ğ‘š [ğ‘–]) + ğ‘¤ (ğ‘†ğ‘š [ ğ‘—]) if |ğ‘…ğ‘š | â‰¥ |ğ‘†ğ‘š | or
ğ‘€ğ‘š [ğ‘–, ğ‘—] = ğ‘¤ (ğ‘†ğ‘š [ğ‘–]) + ğ‘¤ (ğ‘…ğ‘š [ ğ‘—]) otherwise (this distinction is needed simply to conform with the
way Theorem 7.9 is stated). Selection on these matrices is equivalent to selection on the query

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

31

answers of ğ‘„. By Theorem 7.9, if matrix ğ‘€ğ‘š has dimension ğ‘ğ‘š Ã— ğ‘ğ‘š with ğ‘ğ‘š â‰¥ ğ‘ğ‘š, we can achieve
ğ‘š=1 ğ‘ğ‘š log(2ğ‘ğ‘š/ğ‘ğ‘š)) âŠ† O ((cid:205)â„“
selection in O ((cid:205)â„“
ğ‘š=1 ğ‘›ğ‘š) =
â–¡
O (ğ‘›). Overall, the time spent is O (ğ‘› log ğ‘›) because of sorting.

ğ‘š=1 ğ‘ğ‘š Â· 2ğ‘ğ‘š/ğ‘ğ‘š) = O ((cid:205)â„“

ğ‘š=1 ğ‘ğ‘š) = O ((cid:205)â„“

7.3 Intractability Proofs for Full CQs
Though selection is a special case of direct access, we show that for most full CQs, time
O (ğ‘› polylog ğ‘›) is still unattainable. We start from the cases covered by Lemma 5.7. To extend
that result to the selection problem, note that a selection algorithm can be repeatedly applied for
solving direct access. For queries with three free and independent variables, an O (ğ‘›2âˆ’ğœ– ) selection
algorithm would imply a âŸ¨1, ğ‘›2âˆ’ğœ– âŸ© direct-access algorithm, which we showed to be impossible.
Therefore, the following immediately follows from Lemma 5.7:

Corollary 7.11. If a full CQ ğ‘„ is self-join-free and ğ›¼free (ğ‘„) â‰¥ 3, then selection by SUM is not

possible in âŸ¨1, ğ‘›2âˆ’ğœ– âŸ© for any ğœ– > 0 assuming 3sum.

This leaves only a small fraction of full acyclic CQs to be covered: queries with two or fewer
independent variables and three or more maximal hyperedges. We next show that these queries all
contain a length-3 chordless path12, a property that we will use in order to prove a lower bound.

Lemma 7.12. The hypergraph of the maximal contraction of any full acyclic CQ with ğ›¼free (ğ‘„) < 3

and mh(ğ‘„) > 2 contains a chordless path of four variables.

Proof. First, for ğ›¼free (ğ‘„) = 1, we have by Lemma 5.4 that an atom contains all free variables,
thus mh(ğ‘„) = 1. For the case of ğ›¼free(ğ‘„) = 2, let ğ‘¥, ğ‘¦ be independent variables. We distinguish two
cases.

The first case is that each of ğ‘¥ and ğ‘¦ appear in exactly one maximal hyperedge. Denote the
maximal hyperedge containing ğ‘¦ by ğ‘’ğ‘¦ and the maximal hyperedge containing ğ‘¥ by ğ‘’ğ‘¥ . Since there
are at least 3 maximal edges, there is a hyperedge ğ‘’0 such that ğ‘¥, ğ‘¦ âˆ‰ ğ‘’0. Since ğ‘’0 is not absorbed
by ğ‘’ğ‘¦, there exists ğ‘ âˆˆ ğ‘’0 and ğ‘ âˆ‰ ğ‘’ğ‘¦. Thus, ğ‘ and ğ‘¦ are not neighbors. Since {ğ‘, ğ‘¥, ğ‘¦} is not an
independent set, we conclude that ğ‘ and ğ‘¥ are neighbors, and because only one maximal hyperedge
can contain ğ‘¥, we get that ğ‘ âˆˆ ğ‘’ğ‘¥ . Similarly, since ğ‘’0 is not absorbed by ğ‘’ğ‘¥ , we conclude that there
exists a neighbor ğ‘ of ğ‘¦ such that ğ‘ âˆˆ ğ‘’0, ğ‘ âˆ‰ ğ‘’ğ‘¥ . Overall, we have a chordless path ğ‘¥ âˆ’ ğ‘ âˆ’ ğ‘ âˆ’ ğ‘¦.

The second case is that ğ‘¥ or ğ‘¦ (or both) appear in at least two hyperedges. Assume WLOG
that two maximal hyperedges contain ğ‘¥. According to the claim we shall prove next, this means
that there exist non-neighbors ğ‘,ğ‘ that are both neighbors of ğ‘¥. Then, since {ğ‘, ğ‘, ğ‘¦} is not an
independent set, we have that ğ‘¦ is a neighbor of ğ‘ or ğ‘. Assume WLOG it is ğ‘. Then, we have a path
ğ‘¦ âˆ’ ğ‘ âˆ’ ğ‘¥ âˆ’ ğ‘ such that ğ‘¦ and ğ‘¥ are not neighbors and ğ‘ and ğ‘ are not neighbors. We conclude that
also ğ‘¦ and ğ‘ are not neighbors, otherwise this path is a chordless cycle contradicting acyclicity.

We now prove the claim that if two maximal hyperedges in an acyclic hypergraph both contain
a node ğ‘¥, then there exists a chordless path ğ‘ âˆ’ ğ‘¥ âˆ’ ğ‘ for some vertices ğ‘, ğ‘. If there are two non-
neighboring neighbors of ğ‘¥, then we are done. For the sake of contradiction, assume that there are
no such neighbors. We prove with induction on the number of neighbors that for every ğ‘˜ neighbors
of ğ‘¥, there exists a hyperedge that contains all of them and ğ‘¥. For the base of the induction, consider
2 neighbors of ğ‘¥. By our assumption, they must necessarily be neighbors. Since the graph is acyclic,
every triangle must be covered by a hyperedge, so there exists a hyperedge containing both of them
and ğ‘¥. For the inductive step, consider ğ‘˜ neighbors of ğ‘¥. By the induction hypothesis, every subset

12The conference version of
these
CQs is the 3-path query ğ‘„ (ğ‘¥, ğ‘¦, ğ‘§, ğ‘¢) :âˆ’ ğ‘… (ğ‘¥, ğ‘¦), ğ‘† (ğ‘¦, ğ‘§),ğ‘‡ (ğ‘§, ğ‘¢). This is not correct because for example,
ğ‘„â€² (ğ‘¥, ğ‘¦, ğ‘§, ğ‘¢, ğ‘) :âˆ’ ğ‘… (ğ‘¥, ğ‘, ğ‘¦), ğ‘† (ğ‘¦, ğ‘, ğ‘§),ğ‘‡ (ğ‘§, ğ‘, ğ‘¢) also satisfies ğ›¼free (ğ‘„â€²) < 3 and mh(ğ‘„â€²) > 2. However, as we
show here, the same reduction that was used for the 3-path query ğ‘„ can also work for any of these CQs.

[14] erroneously claims that

the maximal contraction of

this paper

, Vol. 1, No. 1, Article . Publication date: November 2023.

32

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

of these neighbors of size ğ‘˜ âˆ’ 1 appears in a hyperedge together with ğ‘¥. If there is no hyperedge that
contains all ğ‘˜ of them, then these neighbors (without ğ‘¥) form a (ğ‘˜, ğ‘˜ âˆ’ 1)-hyperclique contradicting
acyclicity. If there is, then these ğ‘˜ neighbors along with ğ‘¥ form a (ğ‘˜ + 1, ğ‘˜)-hyperclique. This
contradicts acyclicity unless there is a hyperedge containing all ğ‘˜ variables and ğ‘¥. This concludes
the induction. Now consider all neighbors of ğ‘¥. By the induction, one edge contains all of them and
ğ‘¥. This contradicts the fact that ğ‘¥ appears in two maximal hyperedges.

â–¡

Now that we established the precise form of the queries we want to classify, we proceed to prove
their intractability. We approach this in a different way than the other hardness proofs: instead of
relying on the 3sum hypothesis, we instead show that tractable selection would lead to unattainable
bounds for Boolean cyclic queries.

Lemma 7.13. If a full CQ ğ‘„ is self-join-free and the hypergraph of its maximal contraction contains
a chordless path of four variables, then selection by SUM is not possible in âŸ¨1, ğ‘› polylog ğ‘›âŸ© assuming
Hyperclique.

Proof. We will show that if selection for ğ‘„ can be done in O (ğ‘› polylog ğ‘›), then the Boolean
triangle query can be evaluated in the same time bound, which contradicts the Hypercliqe
hypothesis. Let ğ‘„ â–³ () :âˆ’ ğ‘… â€²(ğ‘¥ â€², ğ‘¦ â€²), ğ‘† â€²(ğ‘¦ â€², ğ‘§ â€²),ğ‘‡ â€²(ğ‘§ â€², ğ‘¥ â€²) be a query over a database ğ¼ â€² of size O (ğ‘›). We
will construct a database ğ¼ for ğ‘„ so that weight lookup (see Definition 5.5) for ğ‘„ over ğ¼ will allow
us to answer ğ‘„ â–³ over ğ¼ â€².

Let ğ‘¥ âˆ’ ğ‘¦ âˆ’ ğ‘§ âˆ’ ğ‘¢ be the chordless path in the hypergraph of the maximal contraction of ğ‘„.
This implies that there are atoms ğ‘…(ğ‘¥, ğ‘¦, Xğ‘…), ğ‘† (ğ‘¦, ğ‘§, Xğ‘† ),ğ‘‡ (ğ‘§, ğ‘¢, Xğ‘‡ ) in ğ‘„. We construct a database
ğ¼ where in all relations, we let ğ‘¥ and ğ‘¢ respectively take all the values that ğ‘¥ â€² can take in ğ¼ â€². We
repeat the same for ğ‘¦ with ğ‘¦ â€² and ğ‘§ with ğ‘§ â€². The values that all the other variables can take in ğ¼ are
set to a fixed domain value âŠ¥. Because the ğ‘¥ âˆ’ ğ‘¦ âˆ’ ğ‘§ âˆ’ ğ‘¢ path is chordless, we know that the pair
ğ‘¥ âˆ’ ğ‘§ never appears in a single atom, and so is the case for ğ‘¥ âˆ’ ğ‘¢ and ğ‘¦ âˆ’ ğ‘¢. Therefore, the size of
each relation in ğ¼ is bounded by |ğ‘… â€²| or |ğ‘† â€²| or |ğ‘‡ â€²| and the size of ğ¼ is thus O (ğ‘›). Now consider a
query answer ğ‘ âˆˆ ğ‘„ (ğ¼ ). If ğœ‹ğ‘¢ (ğ‘) = ğœ‹ğ‘¥ (ğ‘), then ğœ‹ğ‘¥ ğ‘¦ğ‘§ (ğ‘) has to satisfy all three atoms of ğ‘„ â–³. This is
because an (ğ‘¥, ğ‘¦) pair of values has to satisfy ğœ‹ğ‘¥ ğ‘¦ (ğ‘…) which contains precisely the tuples of ğ‘… â€², and
similarly for (ğ‘¦, ğ‘§) with ğœ‹ğ‘¦ğ‘§ (ğ‘†). For a (ğ‘§, ğ‘¥) pair of values, these are the same as (ğ‘§, ğ‘¢) and satisfy
ğœ‹ğ‘§ğ‘¢ (ğ‘‡ ) contains precisely the tuples of ğ‘‡ â€².

We now assign weights as follows: If dom âŠ† R, then ğ‘¤ğ‘¥ (ğ‘–) = ğ‘–, ğ‘¤ğ‘¢ (ğ‘–) = âˆ’ğ‘–, and for all other
variables ğ‘¡, ğ‘¤ğ‘¡ (ğ‘–) = 0. Otherwise, it is also easy to assign ğ‘¤ğ‘¥ and ğ‘¤ğ‘¢ in a way s.t. ğ‘¤ğ‘¥ (ğ‘–) = ğ‘¤ğ‘¥ ( ğ‘—) if and
only if ğ‘– = ğ‘— and ğ‘¤ğ‘¢ (ğ‘–) = âˆ’ğ‘¤ğ‘¥ (ğ‘–). This is done by maintaining a lookup table for all the domain values
that we map to some arbitrary real number. Then, we perform weight lookup for ğ‘„ to identify if a
query result with zero weight exists. If it does for some result ğ‘, then ğ‘¤ğ‘¥ (ğœ‹ğ‘¥ (ğ‘))+. . .+ğ‘¤ğ‘¢ (ğœ‹ğ‘¢ (ğ‘¢)) = 0
hence ğœ‹ğ‘¥ (ğ‘) = ğœ‹ğ‘¢ (ğ‘) and ğ‘„ â–³ is true, otherwise it is false. If the time to access the sorted array
of ğ‘„-answers takes O (ğ‘› polylog ğ‘›), then by Lemma 5.6 weight lookup also takes O (ğ‘› polylog ğ‘›),
â–¡
contradicting Hypercliqe.

For full CQs, the negative part of Theorem 7.3 for acyclic queries is proved by combining
Corollary 7.11 and Lemma 7.13 together with Lemma 7.12 and Lemma 7.7 which show that we
cover all queries. For self-join-free cyclic CQs, we once again resort to the hardness of their Boolean
version based on Hypercliqe.

So far we have proved the restriction of Theorem 7.3 to full CQs as summarized below.

Lemma 7.14. Let ğ‘„ be a full CQ.
â€¢ If mh(ğ‘„) â‰¤ 2, then selection by SUM is possible in âŸ¨1, ğ‘› log ğ‘›âŸ©.

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

33

â€¢ Otherwise, if ğ‘„ is also self-join-free, then selection by SUM is not possible in âŸ¨1, ğ‘› polylog ğ‘›âŸ©.

assuming 3sum and Hyperclique.

7.4 CQs with Projections
To complete the proof of Theorem 7.3, we now show how the results from Sections 7.2 and 7.3
generalize to free-connex CQs. For that purpose, we mainly rely on Proposition 2.3, which allows
us to reduce a free-connex CQ to a full CQ. One difficulty that we encounter is that the full CQ that
we obtain by this reduction may not necessarily be unique, as it depends on the join tree of the
inclusion extension that we choose to use. For instance, the inclusion extension allows us to include
unary hyperedges {ğ‘¥ } for all query variables ğ‘¥, if these do not exist already. Thus, the following
definition will be useful:

Definition 7.15 (Reduced Full CQs). For a free-connex CQ ğ‘„, RF(ğ‘„) is the set of all possible full

CQs we can obtain by the reduction of Proposition 2.3.

We now show that for our purposes, the tractability of a free-connex CQ ğ‘„ coincides with that

of any of the CQs in RF(ğ‘„).

Lemma 7.16. Let ğ‘„ be a free-connex CQ and ğ‘„ â€² âˆˆ RF(ğ‘„). Selection for ğ‘„ by SUM is possible in
âŸ¨1, ğ‘”(ğ‘›)âŸ© if selection for ğ‘„ â€² by SUM is possible in âŸ¨1, ğ‘”(ğ‘›)âŸ©. The converse is also true if ğ‘„ is self-join-free.

Proof. The â€œifâ€ direction is trivial from Proposition 2.3: If ğ‘„ is over a database ğ¼ , we can use ğ‘„ â€²

over a modified database ğ¼ â€² to obtain exactly the same answers.

For the â€œonly ifâ€ direction, we use selection on ğ‘„ to answer selection on ğ‘„ â€². If ğ‘„ â€² is over a
database ğ¼ â€², then we construct a modified database ğ¼ for ğ‘„ as follows. We copy all the relations of
ğ¼ â€² into ğ¼ and for every existential variable of ğ‘„, we add an attribute to the corresponding relations
that takes the same âŠ¥ value in all tuples. The weight of all the new attributes is set to 0 for âŠ¥. Now,
the answers to ğ‘„ over ğ¼ are the same as those of ğ‘„ â€² over ğ¼ â€² if we ignore all the âŠ¥ values from the
answers.

The above reductions take linear time, which is dominated by ğ‘”(ğ‘›) since ğ‘”(ğ‘›) is trivially in Î©(ğ‘›)
â–¡

for the selection problem.

From Lemma 7.14, we can decide the tractability of any (self-join-free) full CQ in RF(ğ‘„) by the
number of its maximal hyperedges. We now connect this measure to the free-maximal-hyperedges
fmh(ğ‘„), which is a measure easily computable from the original query ğ‘„.

Lemma 7.17. For a free-connex CQ ğ‘„, fmh(ğ‘„) = mh(ğ‘„ â€²) for any ğ‘„ â€² âˆˆ RF(ğ‘„).

Proof. Let ğ‘‡ be the ext-free(ğ‘„)-connex tree used to derive ğ‘„ â€² and ğ‘‡ â€² be the connected subtree
containing exactly the free variables of ğ‘„ (which are also the free variables of ğ‘„ â€²). Recall that the
nodes of ğ‘‡ â€² correspond to the atoms of ğ‘„ â€².

First, we prove that every node of ğ‘‡ â€² is a subset of some hyperedge of Hfree (ğ‘„) and as a result
fmh(ğ‘„) â‰¤ mh(ğ‘„ â€²). Consider a node of ğ‘‡ â€² and let ğ‘‰ be the corresponding set of variables. Note that
ğ‘‰ are all free variables since they appear in ğ‘‡ â€². Since ğ‘‡ â€² is a subtree of ğ‘‡ , which in turn is a join-tree
of an inclusive extension of H (ğ‘„), there must exist an atom in ğ‘„ that contains ğ‘‰ . Let the set of
variables of that atom be ğ‘‰ âˆª ğ‘‰1 âˆª ğ‘‹ , for some disjoint sets ğ‘‰ , ğ‘‰1, ğ‘‹ , where ğ‘‰1 are free variables and
ğ‘‹ are existential. By the definition of Hfree (ğ‘„), there must exist a hyperedge ğ‘‰ âˆª ğ‘‰1 in Hfree (ğ‘„).
Second, we prove that every maximal hyperedge in Hfree (ğ‘„) is a subset of some node of ğ‘‡ â€² and
as a result mh(ğ‘„ â€²) â‰¤ fmh(ğ‘„). Let ğ‘‰ be the (free) variables of a hyperedge of Hfree (ğ‘„). Then, there
must exist an atom ğ‘’ in ğ‘„ that contains the ğ‘‰ variables. If ğ‘’ corresponds to a node in ğ‘‡ â€², then we
are done. Otherwise, ğ‘’ corresponds to a node in ğ‘‡ \ ğ‘‡ â€². Let ğ‘‰ â€² be the first node of ğ‘‡ â€² on the path

, Vol. 1, No. 1, Article . Publication date: November 2023.

34

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

from ğ‘‰ to some node in ğ‘‡ â€². A path between ğ‘‰ and any node of ğ‘‡ â€² must necessarily pass through
ğ‘‰ â€², otherwise ğ‘‡ would contain a cycle. Since ğ‘‰ contains only free variables, each one of them has
to appear in some node of ğ‘‡ â€² and by the running intersection property, in all the nodes on the path
â–¡
to ğ‘‰ . Therefore, ğ‘‰ â€² contains all the variables of ğ‘‰ .

Lemmas 7.16 and 7.17 allow us to generalize the positive part of Lemma 7.14 from full CQs to
free-connex CQs by simply replacing the mh(ğ‘„) measure with fmh(ğ‘„). For the negative part, we
need three ingredients to cover the class of self-join-free CQs: The case of free-connex CQs with
fmh(ğ‘„) > 2 is also covered by the lemmas above. For acyclic CQs that are not free-connex, we
use Lemma 6.4 which applies to any ranking function, including SUM. Finally, the intractability of
cyclic CQs follows from Hypercliqe.

8 FUNCTIONAL DEPENDENCIES
In this section, we extend our results to apply to databases that are constrained by Functional
Dependencies (FDs). From the point of view of a CQ, if the allowed input databases are restricted
to satisfy an FD, an assignment to some of the variables uniquely determines the assignment to
another variable. Our positive results are not affected by this, since an algorithm can simply ignore
the FDs. However, certain CQs that were previously intractable may now become tractable in
the presence of FDs. Our goal is to investigate how the tractability landscape changes for all four
variants we have investigated so far: direct access and selection by LEX or SUM orders.

Concepts and Notation for FDs. In this section, we assume that the database schema S is
extended with FDs of the form ğ‘… : ğ´ â†’ ğµ, where ğ´ and ğµ are sets of integers. This means that if
the tuples of relation ğ‘… agree on the attributes indexed by ğ´, then they also agree on those indexed
by ğµ. Though FDs are usually defined directly on the schema of the database, we express them from
now on using the query variables for convenience. More specifically, we assume that an FD has the
form ğ‘… : X â†’ Y for some atom ğ‘…(Z) where X, Y âŠ† Z. We now briefly explain why this assumption
can be done without loss of generality. There are two factors that can render such a notation not
well-defined. The first is self-joins. However, our negative results apply only to self-join-free CQs
regardless of this issue, and positive results for self-join-free CQs naturally extend to CQs with self
joins: Self-joins can be reduced in linear time to a self-join-free form by replacing the ğ‘–th occurrence
of a relational symbol ğ‘… with a fresh relational symbol ğ‘…ğ‘– and then copying relation ğ‘… into ğ‘…ğ‘– . The
second factor is repeated appearances of a variable in an atom (e.g., ğ‘…(ğ‘¥, ğ‘¥)). Such an appearance
can be eliminated in a linear-time preprocessing step that performs the selection on the relation
and then removes the duplicate variable. For the other direction of the equivalence, the projected
relation can be transformed to one with the repeated variable by duplicating the relevant column in
the relation. We say that an FD X â†’ Y is satisfied by an input database ğ¼ if for all tuples ğ‘¡1, ğ‘¡2 âˆˆ ğ‘…ğ¼
we have that if ğ‘¡1 [ğ‘¥] = ğ‘¡2 [ğ‘¥], âˆ€ğ‘¥ âˆˆ X, then ğ‘¡1 [ğ‘¦] = ğ‘¡2 [ğ‘¦], âˆ€ğ‘¦ âˆˆ Y. For such an FD, we sometimes
say that X implies Y. WLOG, we assume that all FDs are of the form ğ‘… : X â†’ ğ‘¦ where ğ‘¦ is a single
variable because we can replace an FD of the form ğ‘… : X â†’ Y with a set of FDs {ğ‘… : X â†’ ğ‘¦ | ğ‘¦ âˆˆ Y}.
If |X| = 1, we say that the FD is unary. In this paper, we focus only on unary FDs.

Complexity and Reductions. In all previous sections, the computational problem we were
considering was defined by a CQ and we were interested in the worst-case complexity over all
possible input databases. Now, the problem is defined by a CQ ğ‘„ and a set of FDs Î”. Thus the input
is limited to databases that satisfy all the FDs Î”. Therefore, to determine the hardness of a problem,
we need to consider the complexity of the combination of CQ and FDs. In particular, the results in
the previous sections apply when the given FD set is empty. Our reductions from now on are from
a certain CQ and FD set to another CQ and another FD set.

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

35

Definition 8.1 (Exact Reduction). We say that there is an exact reduction from a CQ ğ‘„ with FDs Î”

to a CQ ğ‘„ â€² with FDs Î”â€² if for every database ğ¼ that satisfies Î”:

(1) We can construct a database ğ¼ â€² in O (|ğ¼ |) that satisfies the FDs Î”â€².
(2) There is a bijection ğœ from ğ‘„ â€²(ğ¼ â€²) to ğ‘„ (ğ¼ ) that is computable in O (1).

Additionally, we say that an exact reduction is weight-preserving if for every weight function ğ‘¤
given for ğ‘„, there is a weight function ğ‘¤ â€² for ğ‘„ â€² such that ğ‘¤ (ğœ (ğ‘â€²)) = ğ‘¤ â€²(ğ‘â€²), âˆ€ğ‘â€² âˆˆ ğ‘„ â€²(ğ¼ â€²).

Known Results. Carmeli and KrÃ¶ll [12] reasoned about the complexity of enumerating the
answers to a CQ by looking at an equivalent extended CQ over an extended schema and FDs. We
recall the definition of this extension here13 and then proceed to use it for our classification.

Definition 8.2 (FD-extension [12]). Given a self-join free CQ ğ‘„ and a set of FDs Î”, we define two

types of extension steps. For an FD ğ‘… : X â†’ ğ‘¦:

(1) If X âŠ† Z for some atom ğ‘† (Z) and ğ‘¦ âˆ‰ Z, then increase the arity of ğ‘† by one, replace ğ‘† (Z)

with ğ‘† (Z, ğ‘¦), and add ğ‘† : X â†’ ğ‘¦ to the FD set.

(2) If X âŠ† free(ğ‘„) and ğ‘¦ âˆ‰ free(ğ‘„), then add ğ‘¦ to free(ğ‘„).

The FD-extension of ğ‘„ and Î” is a CQ ğ‘„ + and a set of FDs Î”+ that are obtained as the fixpoint of
the above two extension steps.

Example 8.3. Consider the CQ ğ‘„2ğ‘ƒ (ğ‘¥, ğ‘§) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† (ğ‘¦, ğ‘§). This CQ is not free-connex, therefore
selection (or direct access) is not possible by any order (Lemma 6.4). Now, if we know that the
database satisfies the FD ğ‘† : ğ‘¦ â†’ ğ‘§, we can take the unique ğ‘§-value for every ğ‘¦ from ğ‘† and
add it to every tuple of ğ‘…, while preserving the same query answers. Thus, we can extend the
2ğ‘ƒ (ğ‘¥, ğ‘§) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦, ğ‘§), ğ‘† (ğ‘¦, ğ‘§) and add the FD ğ‘… : ğ‘¦ â†’ ğ‘§. While the original CQ was not
CQ to ğ‘„ +
free-connex, notice that ğ‘„ +
2ğ‘ƒ now is. This makes it tractable for all the tasks that we consider in
this article since it is acyclic and ğ‘… contains all the free variables (see Section 5).

Similarly,

the FD-extension may transform a cyclic CQ into an acyclic one. For
: ğ‘¦ â†’ ğ‘§, we get the FD-extension
ğ‘„ â–³ (ğ‘¥, ğ‘¦, ğ‘§) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† (ğ‘¦, ğ‘§),ğ‘‡ (ğ‘§, ğ‘¥) with the FD ğ‘†
â–³ (ğ‘¥, ğ‘¦, ğ‘§) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦, ğ‘§), ğ‘† (ğ‘¦, ğ‘§),ğ‘‡ (ğ‘§, ğ‘¥) with the additional FD ğ‘… : ğ‘¦ â†’ ğ‘§ which is acyclic be-
ğ‘„ +
cause ğ‘… contains all the variables. Like ğ‘„ +
â–³ is tractable for all the tasks
that we consider. This is despite the fact that the cyclic ğ‘„ â–³ without FDs is intractable for all of
these tasks.

2ğ‘ƒ (ğ‘¥, ğ‘§), we have that ğ‘„ +

Previous work [12] showed exact reductions between the original CQ (with the original FDs) and
its extension (with the extended FDs) in both directions, proving that the two tasks are essentially
equivalent for the task of enumeration.

Theorem 8.4 ([12]). Let ğ‘„ be a self-join free CQ with FDs Î”. There are exact reductions between ğ‘„

with Î” and ğ‘„ + with Î”+ in both directions.

This theorem alone implies that, if ğ‘„ + has a tractable structure (free-connex for enumeration),
then the original CQ ğ‘„ is tractable too. That is because according to the definition of an exact
reduction, an instance for the extended schema can be built in linear time, and answers to the
extension can be translated back to answers of the original CQ in constant time per answer.

We restate this result below in a slightly more general way, adding the fact that these reductions
are actually weight-preserving. Intuitively, this means that any SUM ordering of the answers in
one problem can be preserved through the reduction.

13The original definition is more involved since it also applies to self-joins. We only give the restriction of the definition
required for our purposes. We also state it for general FDs instead of unary FDs, which is useful for our discussion in
Section 8.3

, Vol. 1, No. 1, Article . Publication date: November 2023.

36

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

Lemma 8.5. Let ğ‘„ be a self-join free CQ with FDs Î”. There are weight-preserving exact reductions

between ğ‘„ with Î” and ğ‘„ + with Î”+ in both directions.

Proof. The bijections between the answers in the exact reductions do not change the values of
the free variables of ğ‘„. For the reduction from the query to its extension, we set the weights of
the new free variables to zero. For the reduction from the extension to the original query, if the
extension has a free variable ğ‘¦ that is existential in the original query, then some free variable ğ‘¥ in
the original query implies ğ‘¦. To maintain the contribution of the ğ‘¦-weight in the query answers, we
simply increase the weight of every domain value of ğ‘¥ by adding the weight of the corresponding
â–¡
domain value of ğ‘¦ (i.e., the one that is implied by the FD).

Proving lower bounds using the extension is more tricky. If the extension has a structure that is
known to make a CQ intractable (e.g. not free-connex for enumeration), it is not necessarily the
case that it is intractable together with the FDs. Still, Carmeli and KrÃ¶ll [12] were able to prove
lower bounds for the cases where the extension is not free-connex. We proceed to use the same
technique that they used in order to prove a more general statement.

Eliminating FDs. Our goal is to show that for the extension of a self-join-free CQ, unary FDs
essentially do not affect our classification. This result is similar in spirit to other results in database
theory where the complexities of problems with FDs were also identified to be the complexity of
the original complexity criterion applied to the FD extension after removing the FDs [22, 25, 33]. To
achieve that, we reduce a CQ without FDs to the same CQ with FDs, under the condition that the
CQ and the FDs we reduce to are the extension of some CQ.

Lemma 8.6. Let ğ‘„ be a self-join free CQ with unary FDs Î”. There is a weight-preserving exact

reduction from ğ‘„ + without FDs to ğ‘„ + over Î”+.

Proof. We are given a database instance ğ¼ for ğ‘„ + that does not necessarily satisfy any FDs and
we construct another database instance ğ¼ â€² with roughly the same answers (there is a bijection ğœ
such that ğ‘„ +(ğ¼ ) = ğœ (ğ‘„ +(ğ¼ â€²))) that satisfies the extended FDs Î”+. Given a variable ğ‘£, denote by Xğ‘£
the set of all variables that are transitively implied by ğ‘£. By the definition of the extension, for
every variable ğ‘£, every atom of ğ‘„ + that contains ğ‘£ also contains all Xğ‘£ variables. For every tuple in
the relation that corresponds to such an atom, we replace the ğ‘£-value with the concatenation of
Xğ‘£-values. We set the weight of a concatenated value to be equal to the weight of the ğ‘£ variable as
it was in the original database ğ¼ . This construction can be done in linear time, and the resulting
database satisfies the FDs.

We now claim that this construction preserves the answers through a bijection. Note that for
every free variable ğ‘£, by the definition of the extension, the variables in Xğ‘£ are all free. Every answer
to the original problem gives an answer to our construction by assigning every free variable ğ‘£ to
the concatenation of the assignments of Xğ‘£. Every answer to our construction gives an answer to
the original problem by keeping only the value that corresponds to the original variable for every
free variable. In both cases, the weights of the query answers are the same in the two instances. â–¡

Example 8.7. We illustrate the reduction above through the CQ ğ‘„ (ğ‘¥, ğ‘§, ğ‘¢) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦),
ğ‘† (ğ‘¦, ğ‘§),ğ‘‡ (ğ‘§, ğ‘¢) with FD ğ‘‡ : ğ‘§ â†’ ğ‘¢. The FD-extension is ğ‘„ +(ğ‘¥, ğ‘§, ğ‘¢) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† â€²(ğ‘¦, ğ‘§, ğ‘¢),ğ‘‡ (ğ‘§, ğ‘¢)
with extended FDs ğ‘‡ : ğ‘§ â†’ ğ‘¢ and ğ‘† â€² : ğ‘§ â†’ ğ‘¢. Notice that ğ‘„ +, like ğ‘„, is not free-connex. From
that structural property of ğ‘„ +, we know that without any FDs it is intractable, e.g., for the task
of selection by Lemma 7.16. The reduction shows that this is still the case, even if we take the
extended FDs into account.

Concretely, the reduction takes a database that does not satisfy the extended FDs and constructs
another database that does. For example, ğ‘† â€² could contain tuples (1, 1, 1) and (1, 1, 2) where the

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

37

middle attribute (corresponding to ğ‘§) does not imply the third attribute (corresponding to ğ‘¢).
To modify this database, we replace the ğ‘§-values by values that pack ğ‘§ and ğ‘¢ together as (ğ‘§, ğ‘¢).
Conceptually, and abusing the notation a little, ğ‘† â€²(ğ‘¦, ğ‘§, ğ‘¢) is further replaced with ğ‘† â€²â€²(ğ‘¦, (ğ‘§, ğ‘¢), ğ‘¢)
and the whole query with ğ‘„ + â€²(ğ‘¥, (ğ‘§, ğ‘¢), ğ‘¢) :âˆ’ ğ‘…(ğ‘¥, ğ‘¦), ğ‘† â€²â€²(ğ‘¦, (ğ‘§, ğ‘¢), ğ‘¢),ğ‘‡ â€²((ğ‘§, ğ‘¢), ğ‘¢). The aforemen-
tioned two tuples of ğ‘† â€² are thus replaced by (1, (1, 1), 1) and (1, (1, 2), 2). Now, the third attribute
is trivially dependent on the middle one because it is contained in the latter. This reduction is
only possible because, being an FD-extension of ğ‘„, ğ‘„ + always contains ğ‘¢ in all of its atoms that
contain ğ‘§. The weights of the query answers are preserved if we only keep the weight of ğ‘§ in the
concatenated (ğ‘§, ğ‘¢) values, i.e., ğ‘¤ğ‘§ ((1, 1)) = ğ‘¤ğ‘§ (1) and ğ‘¤ğ‘§ ((1, 2)) = ğ‘¤ğ‘§ (1).

Note that a reduction in the opposite direction is trivial since, given an instance that satisfies
the FDs, it is also a valid instance for the instance without the FDs. Thus, this lemma proves that
the two problems are equivalent. By combining this fact with the equivalence of CQs and their
FD-extensions (Lemma 8.5), we obtain the following result that is also useful for lower bounds and
allows us to classify queries based on the structure of their extension.

Theorem 8.8. Let ğ‘„ be a self-join free CQ with unary FDs Î”. There are weight-preserving exact

reductions between ğ‘„ over Î” and ğ‘„ + without FDs in both directions.

8.1 Sum of Weights
For a sum-of-weights order, applying a weight-preserving exact reduction cannot reorder the query
answers since their weight is preserved. More formally, the classes of self-join-free CQs that are
tractable for selection and direct access are both closed under weight-preserving exact reductions.
Therefore, Theorem 8.8 immediately proves that for both problems, we can classify self-join-free
CQs by their FD-extension.

Theorem 8.9. Let ğ‘„ be a CQ with unary FDs Î”.
â€¢ If ğ‘„ + is acyclic and an atom of ğ‘„ + contains all the free variables, then direct access for ğ‘„ by

SUM is possible in âŸ¨ğ‘› log ğ‘›, 1âŸ©.

â€¢ Otherwise,

if ğ‘„ is also self-join-free, direct access for ğ‘„ by SUM is not possible in

âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ©, assuming 3sum and Hyperclique.

Theorem 8.10. Let ğ‘„ be a CQ with unary FDs Î”.
â€¢ If ğ‘„ + is free-connex and fmh(ğ‘„ +) â‰¤ 2, then selection for ğ‘„ by SUM is possible in âŸ¨1, ğ‘› log ğ‘›âŸ©.
â€¢ Otherwise, if ğ‘„ is also self-join-free, then selection for ğ‘„ by SUM is not possible in âŸ¨1, ğ‘› polylog ğ‘›âŸ©,

assuming 3sum, Hyperclique, and Seth.

8.2 Lexicographic Orders
We now move on to lexicographic orders, where we also provide dichotomies for unary FDs.
The analysis gets more intriguing compared to SUM since the FDs may interact with the given
lexicographic order in non-trivial ways that have not been explored by any previous work we know
of. Like before, we use as our main tool an extension of the query according to the FDs and show
an equivalence between the extension and the original problem with respect to tractability. The
key difference now is that the extension may also reorder the variables in the lexicographic order
according to the FDs.

8.2.1 Tractability Results. Our positive results rely on two ingredients. The first ingredient is to
have a reduction that preserves precisely the same lexicographic order that we begin with. This is
necessary because if the query answers after the reduction follow a different lexicographic order,

, Vol. 1, No. 1, Article . Publication date: November 2023.

38

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

then we cannot conclude anything about the position of a query answer in the original problem.
Thus, we define a stricter notion of an exact reduction.

Definition 8.11 (Lex-preserving exact reduction). Consider a CQ ğ‘„ and FDs Î”, and a CQ ğ‘„ â€² and
FDs Î”â€² such that the free variables of ğ‘„ are also free variables in ğ‘„ â€². An exact reduction via a
bijection ğœ from ğ‘„ and Î” to ğ‘„ â€² and Î”â€² is called lex-preserving if, for every partial lexicographic
order ğ¿ for ğ‘„ and for all query answers ğ‘1, ğ‘2 of ğ‘„ â€², we have that ğ‘1 â‰ºâ€² ğ‘2 iff ğœ (ğ‘1) âª¯ ğœ (ğ‘2) where
âª¯ and âª¯â€² are orders implied by ğ¿.

In a lex-preserving exact reduction, we have the guarantee that even though the query answers
might not be exactly the same, those that are in a 1-1 correspondence will be placed in the same
position when ordered. Thus, such a reduction allows us to solve direct access or selection on a
different problem and translate the answers back to the original problem. Analogously to weight-
preserving exact reductions for SUM, our notions of tractability for lexicographic orders are
preserved under lex-preserving exact reductions.

Now notice that the forward reduction from ğ‘„ with Î” to ğ‘„ + with Î”+ in Lemma 8.5 is a lex-
preserving exact reduction. This is because as we argued before, the reduction to the extension does
not change the values of any of the free variables. The following lemma is, similarly to Lemma 8.5,
a slight generalization of the result of Carmeli and KrÃ¶ll [12], this time suited to lexicographic
orders.

Lemma 8.12. Let ğ‘„ be a self-join free CQ with FDs Î”. There is a lex-preserving exact reduction from

ğ‘„ with Î” to ğ‘„ + with Î”+.

Importantly, the other direction of Lemma 8.12 is not true in general, since the FD-extension
may contain additional free variables that do not appear in the original query ğ‘„. Similarly, the
reduction in Lemma 8.6 is also not lex-preserving. As an example, consider the simple example of
ğ‘„ (ğ‘£1, ğ‘£2, ğ‘£3) :âˆ’ ğ‘…(ğ‘£1, ğ‘£2, ğ‘£3) with the FD ğ‘… : ğ‘£1 â†’ ğ‘£3. Sorting the constructed instance by âŸ¨ğ‘£1, ğ‘£2, ğ‘£3âŸ©
will actually result in an ordering according to âŸ¨(ğ‘£1, ğ‘£3), ğ‘£2, ğ‘£3âŸ© which is the same as âŸ¨ğ‘£1, ğ‘£3, ğ‘£2âŸ©. That
is precisely the reason why proving lower bounds for the case of lexicographic orders is not as
straightforward as the SUM case.

Going back to the positive side, we can now use Lemma 8.12 to reduce our problem to its
extension. But in order to cover all tractable cases, we need to modify the FD-extension so that the
FDs are also taken into account in the lexicographic order. In particular, if a variable ğ‘¢ is implied by
a variable ğ‘£ and ğ‘¢ comes after ğ‘£ in the order, then ğ‘¢ is placed right after ğ‘£ in the reordering.

Definition 8.13 (FD-reordered extension). Given a self-join-free CQ ğ‘„, a set of unary FDs Î” and a
partial lexicographic order ğ¿, their FD-reordered extension is a CQ ğ‘„ +, a set of unary FDs Î”+ and
a partial lexicographic order ğ¿+. We take ğ‘„ + and Î”+ to be as defined in Definition 8.2, and ğ¿+ is
obtained from ğ¿ by applying the following reordering step iteratively from index ğ‘– = 0 until we
reach the end of the list ğ¿: Find all variables Xğ¿ [ğ‘– ] that are transitively implied by ğ¿[ğ‘–] and place
them in consecutive indexes starting from ğ‘– + 1. Note that ğ¿ may grow in this process to contain
variables that are free in ğ‘„ + though they are not free in ğ‘„.

Example 8.14. Consider the CQ ğ‘„ (ğ‘£1, ğ‘£2, ğ‘£3, ğ‘£4) :âˆ’ ğ‘…(ğ‘£1, ğ‘£3), ğ‘† (ğ‘£3, ğ‘£2),ğ‘‡ (ğ‘£2, ğ‘£4) with the FD ğ‘… :
ğ‘£1 â†’ ğ‘£3 and the lexicographic order ğ¿ = âŸ¨ğ‘£1, ğ‘£2, ğ‘£3, ğ‘£4âŸ©. This order contains the disruptive trio
ğ‘£1, ğ‘£2, ğ‘£3 and is intractable for direct access according to the results of Section 3. When applying the
FD-extension, we get that ğ‘„ + = ğ‘„ because ğ‘£1 already appears with ğ‘£3 in ğ‘…. For the FD-reordered
extension, we reorder the lexicographic order into ğ¿ = âŸ¨ğ‘£1, ğ‘£3, ğ‘£2, ğ‘£4âŸ©, which contains no disruptive
trio and is tractable for direct access.

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

39

We next prove two important properties for the FD-reordered extension:

Lemma 8.15. For every variable ğ‘£ of an order ğ¿+ of an FD-reordered extension, all variables transi-

tively implied by ğ‘£ that appear after ğ‘£ in ğ¿+ have to appear consecutively after ğ‘£ in ğ¿+.

Proof. The property holds at the end of the process due to the transitivity of implication.
Consider a variable ğ‘¦ implied by ğ‘£ that appears after ğ‘£ in ğ¿+ and assume there is a variable ğ‘¥ that is
in-between ğ‘£ and ğ‘¦ but is not implied by ğ‘£. We can further assume that ğ‘¥ is the first variable in the
order with that property. Now, ğ‘¥ must have been inserted at that position when handling another
variable ğ‘§ that is in-between ğ‘£ and ğ‘¥ in ğ¿+ and that ğ‘§ â†’ ğ‘¥. Since ğ‘¥ is the first one not implied by ğ‘£,
we have that ğ‘£ â†’ ğ‘§ which gives us ğ‘£ â†’ ğ‘¥, contradicting our assumption.

â–¡

We next show that the reordering of the variables gives the same result because of the extended

FDs Î”+. As a consequence, we can study the complexity of the query with the FD-reordering.

Lemma 8.16. Given a self-join-free CQ ğ‘„, a set of unary FDs Î” and a partial lexicographic order ğ¿,

for every database ğ¼ that satisfies Î”+, ordering ğ‘„ +(ğ¼ ) by ğ¿ is the same as ordering it by ğ¿+.

Proof. Once the value for a variable ğ‘£ is set, a variable implied by ğ‘£ can have at most one possible
value, so as long as it comes after ğ‘£ in the order, its exact position or whether it is free cannot
influence the answer ordering. Therefore, the reordered extension is equivalent to the original
â–¡
extension.

We now have what we need in order to show that if the reordered extension has a tractable
structure, then we can conclude tractability for the original problem. Specifically, if the CQ ğ‘„ + of
the FD-reordered extension is free-connex, ğ¿+-connex and has no disruptive trio, then we know it
is tractable with respect to direct access by Theorem 4.1. Lemma 8.16 shows that direct access to
the extension by ğ¿+ is the same as direct access by ğ¿, which is the order that we want. Finally, we
use the fact that the reduction given in Lemma 8.5 preserves lexicographic orders to conclude that,
given an input to ğ‘„, we can construct an FD-reordered extension where tractable direct access for
ğ‘„ + by ğ¿+ will give us tractable direct access for ğ‘„ by ğ¿. Following the same process for selection
and using Theorem 6.1, we conclude that if the CQ ğ‘„ + is free-connex, then selection for ğ‘„ by ğ¿ is
tractable.

Intractability Results. We begin by some negative results that can easily be inferred from the

8.2.2
results we have already proved in this paper or by past work.

Lemma 8.17. Let ğ‘„ be a self-join-free CQ with unary FDs Î”. If ğ‘„ + is not free-connex then for any
ranking function, direct access for ğ‘„ is not possible in âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ© assuming sparseBMM
and Hyperclique, and selection for ğ‘„ is not possible in âŸ¨1, ğ‘› polylog ğ‘›âŸ© assuming Seth and Hyper-
clique.

Proof. For direct access, the impossibility is implied by the hardness of enumeration. If we
could have direct access for ğ‘„, then we can also have enumeration with the same time bounds.
Then, by the exact reduction of Theorem 8.8, we would be able to enumerate the answers to the
non-free-connex CQ ğ‘„ + with no FDs with quasilinear preprocessing and polylogarithmic delay,
which is known to contradict sparseBMM or Hypercliqe [5, 11].

For selection, we use Lemma 6.3 together with the simple observation that an exact reduction
preserves the number of query answers. Irrespective of the order, Theorem 8.8 tells us that counting
the answers to ğ‘„ with Î” gives us the count of query answers of ğ‘„ + with no FDs. Since a logarithmic
number of selections can be used to find the latter, the count of answers of the non-free-connex

, Vol. 1, No. 1, Article . Publication date: November 2023.

40

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

CQ ğ‘„ + can be found in quasilinear time, contradicting Seth (if ğ‘„ + is acyclic) or Hypercliqe (if
â–¡
ğ‘„ + is cyclic).

It is left to handle the cases that the reordering of the extension is free-connex acyclic but has a
disruptive trio or is not ğ¿+-connex. The case that the extension is not ğ¿+-connex can be shown using
a reduction from enumeration for a non-free-connex CQ (Lemma 3.12) as we did in Section 4.2.

Lemma 8.18. Let ğ‘„ be a self-join-free CQ with unary FDs Î”, and let ğ¿ be a partial lexicographic order.
If ğ‘„ + is acyclic but not ğ¿+-connex, then direct access for ğ‘„ by ğ¿ is not possible in âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ©
assuming sparseBMM.

Proof. Using Lemma 3.12, it is enough to find a prefix ğ¿â€² of ğ¿+ that is closed under implication
such that the extension ğ‘„ + is not ğ¿â€²-connex. We simply take ğ¿â€² = ğ¿+. Then, we conclude that there
is efficient enumeration for the acyclic but not free-connex ğ‘„ + with ğ¿â€² as free variables. Since ğ¿â€²
is closed under implication, ğ‘„ + is an extension of itself, so we can use Lemma 8.6 to conclude
that there exists efficient enumeration to ğ‘„ + with ğ¿â€² as free variables even without FDs. This is a
â–¡
contradiction as it is not free-connex.

The case where the reordered extension has a disruptive trio ğ‘£1, ğ‘£2, ğ‘£3 is slightly more intricate
as we cannot directly use Lemma 8.6. One might hope that, as we did in the proof of Lemma 3.13,
we would be able to take a prefix of ğ¿+ that ends in ğ‘£2 and then apply Lemma 8.6. However, that is
not always possible here because we have the additional restriction that the prefix we pick has to
be closed under implication. This is required so that the CQ we obtain when we restrict the free
variables to the prefix is a valid FD-extension. Unfortunately, a prefix that includes ğ‘£2 but not ğ‘£3
and is closed under implication does not necessarily exist. That is the case when some variable
implies both ğ‘£2 and ğ‘£3.

Example 8.19. Consider the CQ ğ‘„ (ğ‘£1, ğ‘£2) :âˆ’ ğ‘…(ğ‘£1, ğ‘£3), ğ‘† (ğ‘£3, ğ‘£2) with the FD ğ‘† : ğ‘£2 â†’ ğ‘£3 and
the lexicographic order ğ¿ = âŸ¨ğ‘£1, ğ‘£2âŸ©. The extended reordering is ğ¿+ = âŸ¨ğ‘£1, ğ‘£2, ğ‘£3âŸ© which contains
the disruptive trio ğ‘£1, ğ‘£2, ğ‘£3. To reuse our previous approach, we would want to claim that using
lexicographic direct access to ğ‘„ +, we can enumerate the CQ with only ğ‘£1, ğ‘£2 as free variables
(which happens to be in this case the same as ğ‘„ that we started with). However, this is not a
contradiction because ğ‘„ is not known to be hard for enumeration as it has FDs and it is not an
extension (ğ‘£2 implies ğ‘£3 while ğ‘£2 is free and ğ‘£3 is existential). In fact, we cannot find any prefix ğ¿â€²
of ğ¿+ that is closed under implication such that ğ‘„ + is not ğ¿â€²-connex. To circumvent this issue, we
encode the enumeration of ğ‘„ without FDs into the extension by combining the binary search
approach from Lemma 3.12 with the concatenation reduction from Lemma 8.6. The difference is
that before we used binary search to enumerate a prefix of the free variables, and now this prefix
might stop in the middle of a variable with concatenated values. Thus, ğ‘£2 will be assigned the
values (ğ‘£2, ğ‘£3), and we will use binary search to skip over the ğ‘£3 values.

Lemma 8.20. Let ğ‘„ be a self-join-free CQ with unary FDs Î”, and let ğ¿ be a partial lexicographic
order. If ğ‘„ + is acyclic and ğ¿+ contains a disruptive trio in ğ‘„ +, then direct access for ğ‘„ by ğ¿ is not
possible in âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ© assuming sparseBMM.

Proof. Consider a disruptive trio ğ‘£1, ğ‘£2, ğ‘£3 in ğ‘„ + with respect to ğ¿+. Let ğ¿â€² be the prefix of ğ¿+
ending in ğ‘£2, and let ğ‘„ â€² be the query with the body of ğ‘„ + and the free variables ğ¿â€². As ğ‘£1, ğ‘£3, ğ‘£2 is an
ğ¿â€²-path, we know that ğ‘„ â€² is acyclic but not free-connex, and so it cannot be enumerated efficiently
without FDs assuming sparseBMM.

We first claim that the reordering ğ¿+ is stable with respect to the first occurrences of implying
variables. More precisely, let ğ‘ and ğ‘ be variables in ğ¿+ such that ğ‘ appears before ğ‘ in ğ¿+. We

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

41

claim that the first variable implying ğ‘ does not appear before the first variable implying ğ‘. Indeed,
consider the first variable ğ‘£ğ‘ implying ğ‘. If ğ‘£ğ‘ appears before ğ‘, by Lemma 8.15, ğ‘£ğ‘ also implies ğ‘. So,
the first variable that implies ğ‘ is ğ‘£ğ‘ or a variable before it. As a consequence, due to the reordering,
the first variable implying a value that appears after ğ‘£2 appears after all first variables implying
values before (and including) ğ‘£2.

We can now claim that we can enumerate the answers to ğ‘„ â€² without FDs using lexicographic
direct access to ğ‘„ + with FDs. We use the same construction as we did in Lemma 8.6 by assigning
each variable a concatenation of the variables it implies, except that now we need to be careful
about the order in which we concatenate: we start with any variables in ğ¿+, ordered by ğ¿+. The
constructed database satisfies the FDs. It is only left to use binary search, similarly to Lemma 3.12,
in order to enumerate the distinct values of the variables of ğ¿â€². Due to the previous paragraph, we
â–¡
know that these appear as a prefix, before the first value of a variable after ğ‘£2.

The results of this section regarding lexicographic orders are summarized as follows.

Theorem 8.21. Let ğ‘„ be a CQ with unary FDs Î” and ğ¿ be a partial lexicographic order.
â€¢ If ğ‘„ + is free-connex and ğ¿+-connex and does not have a disruptive trio with respect to ğ¿+, then

direct access for ğ‘„ by ğ¿ is possible in âŸ¨ğ‘› log ğ‘›, log ğ‘›âŸ©.

â€¢ Otherwise, if ğ‘„ is also self-join-free, then direct access for ğ‘„ by ğ¿ is not possible in

âŸ¨ğ‘› polylog ğ‘›, polylog ğ‘›âŸ©, assuming sparseBMM and Hyperclique.

Theorem 8.22. Let ğ‘„ be a CQ with unary FDs Î” and ğ¿ be a partial lexicographic order.
â€¢ If ğ‘„ + is free-connex, then selection for ğ‘„ by ğ¿ is possible in âŸ¨1, ğ‘›âŸ©.
â€¢ Otherwise, if ğ‘„ is also self-join-free, then selection for ğ‘„ by ğ¿ is not possible in âŸ¨1, ğ‘› polylog ğ‘›âŸ©,

assuming Seth and Hyperclique.

8.3 A Note on General FDs
We discussed only unary FDs, where a single variable implies another. The positive side of our
results also holds for general FDs where a combination of variables may imply a variable. We
simply need to take the general form of the extension (given an FD ğ‘¥1, . . . , ğ‘¥ğ‘š â†’ ğ‘¦, we add ğ‘¦
wherever all of ğ‘¥1, . . . , ğ‘¥ğ‘š appear). If the extension has a tractable form, Lemma 8.5 and Lemma 8.12
show that the original query is tractable too. However, extending the negative results requires a
much more intricate analysis that goes beyond the scope of this work. Already for enumeration,
even though Carmeli and KrÃ¶ll [12] showed a classificiation for general FDs when the extension is
acyclic, the cyclic case is not resolved, and they provide a specific example of a CQ and FDs where
the complexity is unknown.

9 CONCLUSIONS
We investigated the task of constructing a direct-access data structure to the output of a query
with an ordering over the answers, as well as the restriction of the problem to accessing a single
answer (the selection problem). We presented algorithms for fragments of the class of CQs for
lexicographic and sum-of-weights orders. The direct access algorithms take quasilinear construction
time in the size of the database, and logarithmic time for access. For selection, our algorithms
take quasilinear or even linear time. We further showed that within the class of CQs without self-
joins, our algorithms cover all the cases where these complexity guarantees are feasible, assuming
conventional hypotheses in the theory of fine-grained complexity. We were also able to precisely
capture how the frontier of tractability changes under the presence of unary FDs.

This work opens up several directions for future work, including the generalization to more
expressive queries (CQs with self-joins, union of CQs, negation, etc.), other kinds of orders (e.g.,

, Vol. 1, No. 1, Article . Publication date: November 2023.

42

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

min/max over the tuple entries), and a continuum of complexity guarantees (beyond âŸ¨quasilinear,
logarithmic timeâŸ©).

Generalizing the question posed at the beginning of the Introduction, we view this work as
part of a bigger challenge that continues the line of research on factorized representations in
databases [37, 38]: how can we represent the output of a query in a way that, compared to the
explicit representation, is fundamentally more compact and efficiently computable, yet equally
useful to downstream operations?

ACKNOWLEDGMENTS
We thank the anonymous reviewers for their constructive comments and Florent Capelli for
his input on simplifying the proof of Lemma 6.6. Nofar Carmeli and Nikolaos Tziavelis were
supported by Google PhD Fellowships. Nofar Carmeli and Benny Kimelfeld were supported by the
German Research Foundation (DFG) Project 412400621 (DIP program). Nikolaos Tziavelis, Wolfgang
Gatterbauer, and Mirek Riedewald were supported by the National Science Foundation (NSF) under
award number IIS-1956096. Wolfgang Gatterbauer was supported by NSF under award number
CAREER IIS-1762268. Nofar Carmeli was supported by the French government under management
of Agence Nationale de la Recherche as part of the â€œInvestissements dâ€™avenirâ€ program, reference
ANR-19-P3IA-0001 (PRAIRIE 3IA Institute).

REFERENCES
[1] Amir Abboud and Virginia Vassilevska Williams. 2014. Popular Conjectures Imply Strong Lower Bounds for Dynamic

Problems. In FOCS. 434â€“443. https://doi.org/10.1109/FOCS.2014.53

[2] Nir Ailon and Bernard Chazelle. 2005. Lower Bounds for Linear Degeneracy Testing. J. ACM 52, 2 (2005), 157â€“171.

https://doi.org/10.1145/1059513.1059515

[3] Noga Alon, Raphael Yuster, and Uri Zwick. 1997. Finding and Counting Given Length Cycles. Algorithmica 17, 3

(1997), 209â€“223. https://doi.org/10.1007/BF02523189

[4] Guillaume Bagan, Arnaud Durand, and Etienne Grandjean. 2007. On Acyclic Conjunctive Queries and Constant Delay

Enumeration. In CSL. 208â€“222. https://doi.org/10.1007/978-3-540-74915-8_18

[5] Guillaume Bagan, Arnaud Durand, Etienne Grandjean, and FrÃ©dÃ©ric Olive. 2008. Computing the jth solution of a first-
order query. RAIRO-Theoretical Informatics and Applications 42, 1 (2008), 147â€“164. https://doi.org/10.1051/ita:2007046
[6] Ilya Baran, Erik D. Demaine, and Mihai PË‡atraÅŸcu. 2005. Subquadratic Algorithms for 3SUM. In Algorithms and Data

Structures. 409â€“421. https://doi.org/10.1007/11534273_36

[7] Christoph Berkholz, Fabian Gerhardt, and Nicole Schweikardt. 2020. Constant delay enumeration for conjunctive

queries: a tutorial. SIGLOG 7, 1 (2020), 4â€“33. https://doi.org/10.1145/3385634.3385636

[8] Christoph Berkholz, Jens Keppeler, and Nicole Schweikardt. 2017. Answering Conjunctive Queries under Updates. In

PODS (PODS â€™17). 303â€“318. https://doi.org/10.1145/3034786.3034789

[9] Manuel Blum, Robert W. Floyd, Vaughan Pratt, Ronald L. Rivest, and Robert E. Tarjan. 1973. Time bounds for selection.

JCSS 7, 4 (1973), 448 â€“ 461. https://doi.org/10.1016/S0022-0000(73)80033-9

[10] Pierre Bourhis, Alejandro Grez, Louis Jachiet, and Cristian Riveros. 2021. Ranked Enumeration of MSO Logic on Words.

In ICDT, Vol. 186. 20:1â€“20:19. https://doi.org/10.4230/LIPIcs.ICDT.2021.20

[11] Johann Brault-Baron. 2013. De la pertinence de lâ€™Ã©numÃ©ration: complexitÃ© en logiques propositionnelle et du premier ordre.

Ph.D. Dissertation. U. de Caen. https://hal.archives-ouvertes.fr/tel-01081392

[12] Nofar Carmeli and Markus KrÃ¶ll. 2020. Enumeration Complexity of Conjunctive Queries with Functional Dependencies.

TCS 64, 5 (2020), 828â€“860. https://doi.org/10.1007/s00224-019-09937-9

[13] Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald. 2021. Tractable
Orders for Direct Access to Ranked Answers of Conjunctive Queries. , 325â€“341 pages. https://doi.org/10.1145/3452021.
3458331

[14] Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald. 2021. Tractable
Orders for Direct Access to Ranked Answers of Conjunctive Queries. In PODS. 325â€“341. https://doi.org/10.1145/
3452021.3458331

[15] Nofar Carmeli, Shai Zeevi, Christoph Berkholz, Benny Kimelfeld, and Nicole Schweikardt. 2020. Answering (Unions
of) Conjunctive Queries Using Random Access and Random-Order Enumeration. In PODS. 393â€“409. https://doi.org/
10.1145/3375395.3387662

, Vol. 1, No. 1, Article . Publication date: November 2023.

Tractable Orders for Direct Access to Ranked Answers of CQs

43

[16] Shaleen Deep and Paraschos Koutris. 2021. Ranked Enumeration of Conjunctive Query Results. In ICDT, Vol. 186.

5:1â€“5:19. https://doi.org/10.4230/LIPIcs.ICDT.2021.5

[17] Arnaud Durand. 2020. Fine-Grained Complexity Analysis of Queries: From Decision to Counting and Enumeration. In

PODS (PODSâ€™20). 331â€“346. https://doi.org/10.1145/3375395.3389130

[18] Jeff Erickson. 1995. Lower Bounds for Linear Satisfiability Problems. In SODA. 388â€“395. https://dl.acm.org/doi/10.

5555/313651.313772

[19] Robert W. Floyd and Ronald L. Rivest. 1975. Expected Time Bounds for Selection. Commun. ACM 18, 3 (1975), 165â€“172.

https://doi.org/10.1145/360680.360691

[20] Greg N. Frederickson. 1993. An Optimal Algorithm for Selection in a Min-Heap. Inf. Comput. 104, 2 (1993), 197â€“214.

https://doi.org/10.1006/inco.1993.1030

[21] Greg N. Frederickson and Donald B. Johnson. 1984. Generalized Selection and Ranking: Sorted Matrices. SIAM J.

Comput. 13, 1 (1984), 14â€“30. https://doi.org/10.1137/0213002

[22] Cibele Freire, Wolfgang Gatterbauer, Neil Immerman, and Alexandra Meliou. 2015. The Complexity of Resilience and
Responsibility for Self-Join-Free Conjunctive Queries. PVLDB 9, 3 (2015), 180â€“191. https://doi.org/10.14778/2850583.
2850592

[23] Anka Gajentaan and Mark H Overmars. 1995. On a class of O(n2) problems in computational geometry. Computational

Geometry 5, 3 (1995), 165 â€“ 185. https://doi.org/10.1016/0925-7721(95)00022-2

[24] Wolfgang Gatterbauer and Dan Suciu. 2015. Approximate Lifted Inference with Probabilistic Databases. PVLDB 8, 5

(2015), 629â€“640. https://doi.org/10.14778/2735479.2735494

[25] Wolfgang Gatterbauer and Dan Suciu. 2017. Dissociation and propagation for approximate lifted inference with standard
relational database management systems. VLDB J. 26, 1 (2017), 5â€“30. https://doi.org/10.1007/s00778-016-0434-5
[26] Martin Charles Golumbic. 1980. Algorithmic Graph Theory and Perfect Graphs. Academic Press, Chapter 4, 81 â€“ 104.

https://doi.org/10.1016/C2013-0-10739-8

[27] Georg Gottlob, Gianluigi Greco, Nicola Leone, and Francesco Scarcello. 2016. Hypertree Decompositions: Questions

and Answers. In PODS. 57â€“74. https://doi.org/10.1145/2902251.2902309

[28] Etienne Grandjean. 1996. Sorting, linear time and the satisfiability problem. Annals of Mathematics and Artificial

Intelligence 16, 1 (1996), 183â€“236. https://doi.org/10.1007/BF02127798

[29] Egbert Harzheim. 2006. Ordered sets. Vol. 7. Springer Science & Business Media. https://doi.org/10.1007/b104891
[30] Russell Impagliazzo and Ramamohan Paturi. 2001. On the Complexity of K-SAT. J. Comput. Syst. Sci. 62, 2 (2001),

367â€“375. https://doi.org/10.1006/jcss.2000.1727

[31] Donald B Johnson and Tetsuo Mizoguchi. 1978. Selecting the Kth element in ğ‘‹ + ğ‘Œ and ğ‘‹1 + ğ‘‹2 + Â· Â· Â· + ğ‘‹ğ‘š. SIAM J.

Comput. 7, 2 (1978), 147â€“153. https://doi.org/10.1137/0207013

[32] Jens Keppeler. 2020. Answering Conjunctive Queries and FO+MOD Queries under Updates. Ph.D. Dissertation. Humboldt-

UniversitÃ¤t zu Berlin, Mathematisch-Naturwissenschaftliche FakultÃ¤t. https://doi.org/10.18452/21483

[33] Benny Kimelfeld. 2012. A dichotomy in the complexity of deletion propagation with functional dependencies. In PODS.

191â€“202. https://doi.org/10.1145/2213556.2213584

[34] Andrea Lincoln, Virginia Vassilevska Williams, and R. Ryan Williams. 2018. Tight Hardness for Shortest Cycles and

Paths in Sparse Graphs. In SODA. 1236â€“1252. https://doi.org/10.1137/1.9781611975031.80

[35] Stefan Mengel. 2021. A short note on the counting complexity of conjunctive queries. CoRR abs/2112.01108 (2021).

https://arxiv.org/abs/2112.01108

[36] A. Mirzaian and E. Arjomandi. 1985. Selection in X + Y and matrices with sorted rows and columns. Inform. Process.

Lett. 20, 1 (1985), 13 â€“ 17. https://doi.org/10.1016/0020-0190(85)90123-1

[37] Dan Olteanu and Maximilian Schleich. 2016. Factorized Databases. SIGMOD Rec. 45, 2 (2016), 5â€“16. https://doi.org/10.

1145/3003665.3003667

[38] Dan Olteanu and Jakub Zavodny. 2012. Factorised representations of query results: size bounds and readability. In

ICDT. 285â€“298. https://doi.org/10.1145/2274576.2274607

[39] Mihai Patrascu. 2010. Towards polynomial lower bounds for dynamic problems. In STOC. 603. https://doi.org/10.

1145/1806689.1806772

[40] Mihai PÄƒtraÅŸcu and Ryan Williams. 2010. On the Possibility of Faster SAT Algorithms. In SODA. 1065â€“1075. https:

//doi.org/10.1137/1.9781611973075.86

[41] Nikolaos Tziavelis, Deepak Ajwani, Wolfgang Gatterbauer, Mirek Riedewald, and Xiaofeng Yang. 2020. Optimal
Algorithms for Ranked Enumeration of Answers to Full Conjunctive Queries. PVLDB 13, 9 (2020), 1582â€“1597. https:
//doi.org/10.14778/3397230.3397250

[42] Nikolaos Tziavelis, Wolfgang Gatterbauer, and Mirek Riedewald. 2020. Optimal Join Algorithms Meet Top-k. In

SIGMOD. 2659â€“2665. https://doi.org/10.1145/3318464.3383132

[43] Nikolaos Tziavelis, Wolfgang Gatterbauer, and Mirek Riedewald. 2021. Beyond Equi-joins: Ranking, Enumeration and

Factorization. PVLDB 14, 11 (2021), 2599â€“2612. https://doi.org/10.14778/3476249.3476306

, Vol. 1, No. 1, Article . Publication date: November 2023.

44

Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald

[44] Nikolaos Tziavelis, Wolfgang Gatterbauer, and Mirek Riedewald. 2022. Any-k Algorithms for Enumerating Ranked

Answers to Conjunctive Queries. CoRR abs/2205.05649 (2022). https://doi.org/10.48550/arXiv.2205.05649

[45] Virginia Vassilevska Williams. 2015. Hardness of Easy Problems: Basing Hardness on Popular Conjectures such as the
Strong Exponential Time Hypothesis (Invited Talk). In IPEC, Vol. 43. 17â€“29. https://doi.org/10.4230/LIPIcs.IPEC.2015.17
[46] Xiaofeng Yang, Mirek Riedewald, Rundong Li, and Wolfgang Gatterbauer. 2018. Any-ğ‘˜ Algorithms for Exploratory

Analysis with Conjunctive Queries. In ExploreDB. 1â€“3. https://doi.org/doi.org/10.1145/3214708.3214711

[47] Mihalis Yannakakis. 1981. Algorithms for Acyclic Database Schemes. In VLDB. 82â€“94. https://dl.acm.org/doi/10.5555/

1286831.1286840

[48] Zhuoyue Zhao, Robert Christensen, Feifei Li, Xiao Hu, and Ke Yi. 2018. Random Sampling over Joins Revisited. In

SIGMOD. 1525â€“1539. https://doi.org/10.1145/3183713.3183739

A NOMENCLATURE

Definition
relation
atom/hyperedge/node of join tree
schema
database (instance)
size of ğ¼ (number of tuples)
domain
list of variables/attributes
tuple
variable
CQ
query answer of CQ ğ‘„ over database ğ¼
set of answers of ğ‘„ over ğ¼
projection of ğ‘… on X
free variables of query ğ‘„
variables of query or atom
set of query atoms
hypergraph associated with query ğ‘„

Symbol
ğ‘…, ğ‘†,ğ‘‡ , ğ‘ˆ , ğ‘…1, ğ‘…2
ğ‘’, ğ‘‰ , ğ‘‰1, ğ‘‰2
S
ğ¼
ğ‘›
dom
X, Y, Z
ğ‘¡
ğ‘¥, ğ‘¦, ğ‘§, ğ‘¢, ğ‘£1, ğ‘£2
ğ‘„
ğ‘ âˆˆ ğ‘„ (ğ¼ )
ğ‘„ (ğ¼ )
ğœ‹X (ğ‘…)
Xğ‘“ , free(ğ‘„)
var(ğ‘„), var(ğ‘’)
atoms(ğ‘„)
H (ğ‘„) = (ğ‘‰ , ğ¸)
Hfree (ğ‘„) = (ğ‘‰ , ğ¸) restriction of H (ğ‘„) to free variables only
ğ‘‡
V
ğ›¼free (ğ‘„)
mh(ğ‘„)
fmh(ğ‘„)
ğ¿ = âŸ¨ğ‘£1, . . . , ğ‘£ğ‘šâŸ©
ğ‘¤ğ‘¥
ğ‘¤ğ‘„
ğ‘¤
Î£ğ‘¤
ğœ†
âª¯
Î 
order
ordering
ğ‘… : X â†’ Y
Î”
âŸ¨ğ‘› log ğ‘›, log ğ‘›âŸ©
âŸ¨1, ğ‘› log ğ‘›âŸ©

join tree
set of join tree nodes
maximum number of independent free variables of ğ‘„
number of maximal hyperedges (with respect to containment) in H (ğ‘„)
number of free-maximal hyperedges = maximal hyperedges in Hfree (ğ‘„)
lexicographic order of variables
weight function for variable ğ‘¥: dom â†’ R
weight function for query answers
short form for all ğ‘¤ğ‘¥ and ğ‘¤ğ‘„
sum-of-weights order
a real-valued weight
total order over query answers
family of orders
a binary relation as in partial/total order
a sorted list according to an order
FD where X implies Y in ğ‘…
set of FDs
direct access with O (ğ‘› log ğ‘›) preprocessing and O (log ğ‘›) per access
selection in O (ğ‘› log ğ‘›)

, Vol. 1, No. 1, Article . Publication date: November 2023.

