Bounded Treewidth and the Infinite Core Chase:
Complications and Workarounds toward Decidable
Querying
Jean-FranÃ§ois Baget, Marie-Laure Mugnier, Sebastian Rudolph

To cite this version:

Jean-FranÃ§ois Baget, Marie-Laure Mugnier, Sebastian Rudolph. Bounded Treewidth and the Infinite
Core Chase: Complications and Workarounds toward Decidable Querying. SIGMOD/PODS 2023 -
International Conference on Management of Data, Jul 2023, Seattle, WA, United States. pp.291-302,
ï¿¿10.1145/3584372.3588659ï¿¿. ï¿¿lirmm-04320944ï¿¿

HAL Id: lirmm-04320944

https://hal-lirmm.ccsd.cnrs.fr/lirmm-04320944

Submitted on 4 Dec 2023

HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in France or
abroad, or from public or private research centers.

Lâ€™archive ouverte pluridisciplinaire HAL, est
destinÃ©e au dÃ©pÃ´t et Ã  la diffusion de documents
scientifiques de niveau recherche, publiÃ©s ou non,
Ã©manant des Ã©tablissements dâ€™enseignement et de
recherche franÃ§ais ou Ã©trangers, des laboratoires
publics ou privÃ©s.

Bounded Treewidth and the Infinite Core Chase
Complications and Workarounds toward Decidable Querying

Jean-FranÃ§ois Baget
Marie-Laure Mugnier
jfbaget@inria.fr
mugnier@lirmm.fr
LIRMM, Inria, University of Montpellier, CNRS
Montpellier, France

ABSTRACT
The core chase, a popular algorithm for answering conjunctive
queries (CQs) over existential rules, is guaranteed to terminate and
compute a finite universal model whenever one exists, leading to
the equivalence of the universal-model-based and the chase-based
definitions of finite expansion sets (fes) â€“ a class of rulesets featuring
decidable CQ entailment. In case of non-termination, however, it is
non-trivial to define a â€œresultâ€ of the core chase, due to its non-mo-
notonicity. This causes complications when dealing with advanced
decidability criteria based on the existence of (universal) models of
finite treewidth. For these, sufficient chase-based conditions have
only been established for weaker, monotonic chase variants.

This paper investigates the â€“ prima facie plausible â€“ hypothesis
that the existence of a treewidth-bounded universal model and the
existence of a treewidth-bounded core-chase sequence coincide â€“
which would conveniently entail decidable CQ entailment when-
ever the latter holds. Perhaps surprisingly, carefully crafted exam-
ples show that both directions of this hypothesized correspondence
fail. On a positive note, we are still able to define an aggregation
scheme for the infinite core chase that preserves treewidth bounds
and produces a finitely universal model, i.e., one that satisfies ex-
actly the entailed CQs. This allows us to prove that the existence of
a treewidth-bounded core-chase sequence does warrant decidability
of CQ entailment (yet, on other grounds than expected). Hence, for
the first time, we are able to define a chase-based notion of bounded
treewidth sets of rules that subsumes fes.

CCS CONCEPTS
â€¢ Theory of computation â†’ Automated reasoning; â€¢ Comput-
ing methodologies â†’ Knowledge representation and reason-
ing.

KEYWORDS
existential rules, tuple-generating dependencies, chase, treewidth,
universal models

Publication rights licensed to ACM. ACM acknowledges that this contribution was
authored or co-authored by an employee, contractor or affiliate of a national govern-
ment. As such, the Government retains a nonexclusive, royalty-free right to publish or
reproduce this article, or to allow others to do so, for Government purposes only.
PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA
Â© 2023 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0127-6/23/06. . . $15.00
https://doi.org/10.1145/3584372.3588659

Sebastian Rudolph
sebastian.rudolph@tu-dresden.de
Computational Logic Group, TU Dresden
Dresden, Germany

ACM Reference Format:
Jean-FranÃ§ois Baget, Marie-Laure Mugnier, and Sebastian Rudolph. 2023.
Bounded Treewidth and the Infinite Core Chase: Complications and Work-
arounds toward Decidable Querying. In Proceedings of the 42nd ACM SIGMOD-
SIGACT-SIGAI Symposium on Principles of Database Systems (PODS â€™23),
June 18â€“23, 2023, Seattle, WA, USA. ACM, New York, NY, USA, 12 pages.
https://doi.org/10.1145/3584372.3588659

1 INTRODUCTION
The chase is a fundamental tool for the popular formalism of exis-
tential rules, also known as tuple-generating dependencies. Given a
knowledge base (KB) composed of a finite set ğ¹ of facts (the data-
base) and a set Î£ of (existential) rules, the chase repeatedly applies
rules, giving rise to a sequence ğ¹ =ğ¹0, ğ¹1, ğ¹2, . . . If, in the course of
this, a fixpoint is reached after a finite number of steps, one speaks
of chase termination. Then, the final fact set obtained, seen as a
structure, constitutes a finite model of the given KB, which is also
universal, meaning that it can be homomorphically mapped to any
model of the KB. This pleasant property allows one to consider this
single model (instead of all models) to answer all queries preserved
under homomorphisms, ranging from conjunctive queries (CQs) to
datalog and other second-order queries.

In fact, there are different chase variants with differing behavior
regarding redundancy treatment and termination. The simplest,
most lavish, known as the oblivious chase, performs all possible
rule applications, without checking for any redundancies [6]. The
most frugal, known as the core chase, prunes all redundancies at
each step, retaining a minimal set of atoms, which is called a core [9].
Between these two extremes, the semi-oblivious (aka skolem) and
restricted (aka standard) chase avoid the creation of some redundan-
cies, but not all [10, 17]. The core chase is the only chase variant
that terminates exactly when the KB has a finite universal model,
and produces the unique (up to isomorphism) smallest such model.
Thus, the core chase is the best choice for a decision procedure that
aims at chase termination. This motivates the definition of the fes
(finite expansion sets) class containing all rule sets Î£ for which the
core chase for K = (ğ¹, Î£) terminates for all ğ¹ [3]. For such Î£, the
entailment K |= ğ‘„ for any CQ ğ‘„ can be decided by computing the
core chase and evaluating ğ‘„ against the resulting structure.

Yet, finite universal models may not exist. In such cases, no chase
reaches a fixpoint, and there is no last chase sequence element to
pick as a result. As a remedy, one may define the â€œresultâ€ of the chase
as the infinite union over all the fact sets of the infinite sequence,
obtaining an infinite structure. This will still yield a universal model
for monotonic chase variants, where ğ¹ğ‘– âŠ† ğ¹ğ‘–+1 holds for all ğ‘–, such

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Jean-FranÃ§ois Baget, Marie-Laure Mugnier, and Sebastian Rudolph

Figure 1: Venn diagram displaying the (non-)inclusion of decidable classes of existential rule sets discussed in the paper. We
abbreviate treewidth by tw, and restricted and core chase by rc and cc, respectively. The rulesets entitled "steepening staircase"
and "inflating elevator" demonstrate that existence of treewidth-finite universal models and treewidth-bounded core-chase
sequences are independent properties. The tw-bounded cc class actually comes in two flavors, referred to as uniform and
recurring boundedness. The latter is more general, but the distinction is irrelevant for this overview.

as the oblivious, semi-oblivious and restricted chases. However, this
does not work well for non-monotonic chase variants such as the
core chase, where one cannot even be certain to obtain a model.

One could argue that these issues are of theoretical interest only,
given that the non-terminating chase cannot actually be computed
and cannot serve as a decision procedure. However, fortunately,
decidability of CQ entailment can be established by other means,
even when the chase does not terminate. In particular, it is ensured
whenever an infinite universal model exists that is still reasonably
â€œstructurally well-behavedâ€ by virtue of having a bounded treewidth
[1, 7]. This insight gave rise to many existential rule fragments of
high practical relevance, mostly based on varying notions of guard-
edness, which impose syntactic restrictions ensuring treewidth-
boundedness for all chase sequences [1, 2, 7, 16]. Yet, these classes
all have in common that the existence of a treewidth-bounded uni-
versal model can be established only via chase variants that are
necessarily monotonic: the union over all ğ¹ğ‘– in a monotonic chase
sequence is known to inherit the treewidth bound. Regrettably, for
the core chase, which produces â€œsmallerâ€ intermediate structures
and hence ensures treewidth-boundedness of the produced facts
more often, no adequate model-producing â€œaggregationâ€ strategy
is known, let alone a treewidth-preserving one.

To overcome this issue, we provide a decidability guarantee, but
also bring some unpleasant truths to light. We propose a treewidth-
preserving aggregation scheme for the core chase that produces
a model, but not a universal one. Luckily, we can still guarantee
that the resulting model is finitely universal (that is, any of its finite
substructures is universal) and thus sufficient for our purpose of
decidable CQ entailment. Also, we show that the failure to construct
a treewidth-bounded universal model out of a treewidth-bounded
chase sequence is not a flaw of our approach, but unavoidable, by
exhibiting the steepening staircase example: a uniformly treewidth-
bounded core-chase sequence for a KB whose every universal model
has infinite treewidth. Conversely, the inflating elevator example
presents a KB with a universal model of finite treewidth, yet each
of its core-chase sequences consists of structures of ever-growing
treewidth, refuting the plausible hypothesis that any universal
model of bounded treewidth can be obtained from a treewidth-
bounded core-chase sequence. Figure 1 summarizes our findings.

2 PRELIMINARIES
We use countably infinite disjoint sets Î”ğ‘‰ of variables (denoted by
uppercase letters) and Î”ğ¶ of constants (denoted by lowercase letters).
A schema S is a finite set of relation symbols (or predicates); each
p âˆˆ S is given an arity ar (p) â‰¥ 0. The set of terms is Î”ğ‘‡ = Î”ğ¶ âˆª Î”ğ‘‰ .
A list ğ‘¡1, . . . , ğ‘¡ğ‘˜ of terms is also denoted by (cid:174)ğ‘¡ with |(cid:174)ğ‘¡ | = ğ‘˜.

Atomsets and Homomorphisms. An atom over a schema S is an
expression of the form p((cid:174)ğ‘¡), p âˆˆ S and (cid:174)ğ‘¡ âˆˆ (Î”ğ‘‡ )ğ‘˜ with ğ‘˜ = ar (p).
An atomset over S is a countable set of atoms over S. For an atom
or atomset ğ´, we let terms(ğ´) and vars(ğ´) denote the set of terms
and variables in ğ´, respectively.

A substitution of a set of variables Y âŠ† Î”ğ‘‰ is a mapping ğœ
from Y to Î”ğ‘‡ . For an atom at = p(ğ‘¡1, . . . , ğ‘¡ğ‘˜ ) and a substitution
ğœ of Y, let ğœ (at) = p(ğœ+ (ğ‘¡1), . . . , ğœ+ (ğ‘¡ğ‘˜ )) where ğœ+ (ğ‘¡ğ‘– ) = ğœ (ğ‘¡ğ‘– )
whenever ğ‘¡ğ‘– âˆˆ Y and ğœ+ (ğ‘¡ğ‘– ) = ğ‘¡ğ‘– otherwise. If ğ´ is an atomset, then
ğœ (ğ´) = {ğœ (at) | at âˆˆ ğ´}. For two substitutions ğœ and ğœ â€² of variable
sets Y and Yâ€², respectively, we let ğœ â€² â—¦ ğœ denote the substitution
of Yâ€² âˆª Y defined by ğ‘Œ â†¦â†’ ğœ â€²+ (ğœ+ (ğ‘Œ )). Two substitutions are
compatible if they map the same variables to the same terms.

A homomorphism from an atomset ğ´ to an atomset ğµ is a substi-
tution ğœ‹ with ğœ‹ (ğ´) âŠ† ğµ. Given such a homomorphism ğœ‹, we also
say that ğœ‹ maps ğ´ to ğµ, or that ğ´ maps to ğµ (via ğœ‹). An isomorphism
from ğ´ to ğµ is a bijective homomorphism ğœ‹ such that ğœ‹ âˆ’1 is a
homomorphism from ğµ to ğ´ (then ğ´ and ğµ are called isomorphic).
An endomorphism (automorphism) of ğ´ is a homomorphism (iso-
morphism) from ğ´ to itself. A retraction of ğ´ is an endomorphism
ğœ‹ where the restriction of ğœ‹ to terms(ğœ‹ (ğ´)) (the retract) is the id-
entity. Note that the classes of homomorphisms, endomorphisms,
isomorphisms, and retractions are all closed under composition.
A finite atomset ğ´ is called a core if every retraction of ğ´ is the
identity. Any finite atomset ğ´ admits a retract that is a core; this
retract is unique up to isomorphism and called the core of ğ´.

We identify an atomset with the (possibly infinite) formula ob-
tained from the existential closure of the conjunction of its atoms.
Finite or infinite atomsets also naturally correspond to first-order
interpretations;1 if we want to emphasize this aspect, we also re-
fer to them as instances. A (Boolean) conjunctive query (CQ) is a

1Note that we operate under the unique name assumption.

terminatingcc= finite universal modeltw-boundedrctw-finite universal modelinflatingelevatortw-boundedcctw-finite finitelyuniversal modelsteepeningstaircaseBounded Treewidth and the Infinite Core Chase

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

finite atomset. Note that we conflate labeled nulls usually used in
instances with variables usually used in queries, as they correspond
to the same logical notion. We rely on the standard notions of model
and semantic entailment, denoted by |=. An instance ğ¼ is a model
of a (possibly infinite) atomset ğ´ iff ğ´ maps to ğ¼ ; for ğ´ and ğµ two
(possibly infinite) atomsets, ğ´ |= ğµ iff ğµ maps to ğ´.

Existential Rules. An (existential) rule ğ‘… is of the form ğµ â†’ ğ» ,
where the body ğµ = body(ğ‘…) and the head ğ» = head (ğ‘…) are
nonempty finite atomsets. The variables in ğµ are called univer-
sal, those both in ğµ and ğ» are called frontier, and those only in ğ»
are called existential. We identify a rule with the first-order sentence
âˆ€ (cid:174)ğ‘‹ (cid:174)ğ‘Œ.(cid:211)ğµ [ (cid:174)ğ‘‹, (cid:174)ğ‘Œ ] â†’ âˆƒ (cid:174)ğ‘.(cid:211)ğ» [ (cid:174)ğ‘‹, (cid:174)ğ‘ ] where (cid:174)ğ‘‹, (cid:174)ğ‘Œ , (cid:174)ğ‘ are the frontier, non-
frontier universal, and existential variables of ğ‘…, respectively. In
examples, we use the logical notation but omit universal quantifiers.
Given an instance ğ¼ and a rule ğµ â†’ ğ» , a trigger for ğ¼ is a pair
tr = (ğµ â†’ ğ», ğœ‹) such that ğœ‹ maps ğµ to ğ¼ ; tr is satisfied in ğ¼ if ğœ‹ can
be extended to a homomorphism from ğµ âˆª ğ» to ğ¼ . Note that an
instance ğ¼ is a model of a rule ğ‘… iff it satisfies every trigger for ğ¼ of
the form (ğ‘…, ğœ‹). Given a rule ğ‘… = ğµ â†’ ğ» , an instance ğ¼ and a trigger
tr = (ğ‘…, ğœ‹) for ğ¼ , the application of tr on ğ¼ produces the instance
ğ›¼ (ğ¼, tr) = ğ¼ âˆª ğœ‹ safe (ğ» ), where ğœ‹ safe maps every frontier-variable
ğ‘‹ of ğ‘… to ğœ‹ (ğ‘‹ ) and any existential variable in vars(ğ» ) to a fresh
variable (usually called a labeled null).2

Universal Models. A knowledge base (KB) is a pair K = (ğ¹, Î£),
where ğ¹ is a finite instance and Î£ is a finite set of rules. An instance ğ¼
is a model of K if it is a model of ğ¹ and of each rule in Î£. An instance
ğ¼ is universal for K if it (homomorphically) maps to every model
of K; note that this does not necessarily mean that ğ¼ is a model
of K. An instance ğ¼ is a universal model of K if it is a model of K
and is universal for K. We consider the following CQ entailment
problem: given a KB K and a Boolean CQ ğ‘„, does K |= ğ‘„ hold? For
any universal model ğ¼ of K, K |= ğ‘„ holds iff ğ‘„ (homomorphically)
maps to ğ¼ , hence, a universal model of K is sufficient to decide CQ
entailment.

3 DERIVATIONS AND THEIR RESULTS
In this paper, we focus on the restricted and the core chase variants.
We now introduce a convenient notion of derivation to define these
two variants. Actually, it would allow to define other variants that
fall between these two variants in terms of redundancy removal,
like e.g., the frugal chase [15]. Our type of derivation is not only
a sequence of rule applications, but also incorporates a retraction
that removes (some) redundancies after each rule application. In
the following, â„‘ denotes either the set N of natural integers (for
infinite derivations) or the interval {0, . . . , ğ‘˜ } âŠ† N (for finite ones).

Definition 1 (Derivation). A derivation from a KB K = (ğ¹, Î£)
is a (possibly infinite) sequence D = ((trğ‘–, ğœğ‘–, ğ¹ğ‘– ))ğ‘– âˆˆâ„‘, where the trğ‘–
are triggers (except tr0 = âˆ…), the ğœğ‘– are retractions called simplifica-
tions, and the ğ¹ğ‘– are finite instances such that: ğ¹0 = ğœ0 (ğ¹ ); and, for
all ğ‘– âˆˆ â„‘\{0}, ğ¹ğ‘– = ğœğ‘– (ğ›¼ (ğ¹ğ‘– âˆ’1, trğ‘– )), where trğ‘– = (ğ‘…ğ‘–, ğœ‹ğ‘– ) with ğ‘…ğ‘– âˆˆ Î£
is a trigger for ğ¹ğ‘– âˆ’1 not satisfied in ğ¹ğ‘– âˆ’1.

2The notion of fresh variable refers to the underlying assumption that the referred
variable is not already present in ğ¹ , but also, that it has not occurred at any potential
previous computation step (which is particularly relevant when rule applications are
iterated and/or intertwined with other operations).

For the sake of brevity, we often denote a derivation simply by
D = (ğ¹ğ‘– )ğ‘– âˆˆâ„‘, leaving the trğ‘– and ğœğ‘– implicit. A derivation is called
monotonic if ğ¹ğ‘– âˆ’1 âŠ† ğ¹ğ‘– holds for all ğ‘– âˆˆ â„‘\{0}. In a monotonic
derivation, the restriction of ğœğ‘– to the terms of ğ¹ğ‘– âˆ’1 is the identity.
When a derivation D = (ğ¹ğ‘– )0â‰¤ğ‘– â‰¤ğ‘˜ is finite, its result can be
defined by just taking its last instance: D+ = ğ¹ğ‘˜ . However, for
infinite derivations of the form D = (ğ¹ğ‘– )ğ‘– âˆˆN, the â€œresultâ€ of D
is usually defined as the (infinite) union of all instances along D.
We denote this union by Dâˆ— = (cid:208)ğ‘– âˆˆâ„‘ ğ¹ğ‘– and call it the natural
aggregation of D (to distinguish it from the robust aggregation
defined in Section 8). Note that if D is a finite monotonic derivation,
then Dâˆ— = D+.

As stated in the next proposition, Dâˆ— is universal for K. Yet, to
ensure that a model of K is obtained, we need to require fairness,
which intuitively means that every trigger for some ğ¹ğ‘– has to be
satisfied in some ğ¹ ğ‘— with ğ‘— â‰¥ ğ‘–. To formalize this notion, a difficulty
with our derivation notion (which arises for any non-monotonic
type of chase) is that a trigger (ğ‘…, ğœ‹) for some ğ¹ğ‘– may not remain a
trigger for some ğ¹ ğ‘— with ğ‘— > ğ‘–: this is because ğœ‹ (body(R)) may be
â€œtransformed awayâ€ by successive simplifications. To address this
issue, we need to â€œtraceâ€ how a set of atoms is transformed along a
derivation.

ğ‘– (ğ‘‹ ) = ğœğ‘— â—¦ Â· Â· Â· â—¦ ğœğ‘–+1 (ğ‘‹ ) when ğ‘— > ğ‘–.

Definition 2. Let D = (ğ¹ğ‘– )ğ‘– âˆˆâ„‘ be a derivation, and ğ‘‹ be a
variable occurring in some ğ¹ğ‘– . For any ğ‘— âˆˆ â„‘ with ğ‘— â‰¥ ğ‘–, we define
ğ‘– (ğ‘‹ ) = ğ‘‹ and Ëœğœ ğ‘—
Ëœğœğ‘–
It is immediate that Ëœğœ ğ‘—

ğ‘– (which is either the identity when ğ‘– = ğ‘—
or ğœğ‘— â—¦ Â· Â· Â· â—¦ ğœğ‘–+1 otherwise) is a homomorphism from ğ¹ğ‘– to ğ¹ ğ‘— . Note
also that for a monotonic derivation, Ëœğœ ğ‘—
ğ‘– is the identity for any ğ‘—. In
the following, if tr = (ğ‘…, ğœ‹) is a trigger for ğ´ and ğœ is a substitution,
we note ğœ (tr) = (ğ‘…, ğœ â—¦ ğœ‹) the trigger for ğœ (ğ´).

Definition 3 (Fair derivation). A derivation D = (ğ¹ğ‘– )ğ‘– âˆˆâ„‘ is
fair if, for any ğ‘– âˆˆ â„‘ and trigger tr for ğ¹ğ‘– , there is some ğ‘— âˆˆ â„‘ with
ğ‘— â‰¥ ğ‘–, such that Ëœğœ ğ‘—
ğ‘– (tr) is a satisfied trigger for ğ¹ ğ‘— .

In classical chase procedures, only active triggers (a notion spe-
cific to each chase variant) are applied. In the restricted chase, a
trigger for ğ¹ğ‘– is active if it is not already satisfied in ğ¹ğ‘– . The core
chase furthermore computes a retraction to a core after each (or
a finite number of) rule application. For both variants, the clas-
sical definition of a chase sequence coincides with our notion of
a fair derivation. A restricted chase sequence can be seen as a fair
derivation ((trğ‘–, ğœğ‘–, ğ¹ğ‘– ))ğ‘– âˆˆâ„‘ in which ğœğ‘– is the identity. Since this
derivation is monotonic, it allows for a simpler expression of fair-
ness: any trigger for an ğ¹ğ‘– has to be satisfied in some ğ¹ ğ‘— , with
ğ‘– â‰¤ ğ‘—. A core chase sequence can be seen as a (non-monotonic) fair
derivation in which each ğœğ‘– produces a core.

Finally, we adapt to our general framework some well-known
properties of these chase variants [9, 10, 14]. Albeit Dâˆ— is not always
a model, modelhood is guaranteed for monotonic derivations, as
already known for the restricted chase.

Proposition 1. Let D be a derivation from K. Then:

(1) Dâˆ— is universal for K;
(2) if D is monotonic and fair, Dâˆ— is a model of K;
(3) if D is fair, for all CQ ğ‘„, K |= ğ‘„ iff Dâˆ— |= ğ‘„.

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Jean-FranÃ§ois Baget, Marie-Laure Mugnier, and Sebastian Rudolph

4 ADDING TREEWIDTH TO THE PICTURE
We now recall the popular notion of the treewidth of an atomset as
well as some well-known facts about it, which will be useful later.

Definition 4. Given an atomset ğ´, a tree decomposition of ğ´ is
a (possibly infinite) tree ğ‘‡ = (ğ‘‰, ğ¸), with vertices ğ‘‰ âŠ† 2terms (ğ´) and
edges ğ¸ âˆˆ ğ‘‰ Ã— ğ‘‰ , where:
â€¢ for each at âˆˆ ğ´ exists some ğ‘£ âˆˆ ğ‘‰ with terms(at) âŠ† ğ‘£;
â€¢ for each ğ‘¡ âˆˆ terms(ğ´), letting ğ‘‰ğ‘¡ = {ğ‘£ âˆˆ ğ‘‰ | ğ‘¡ âˆˆ ğ‘£ }, the subgraph

of ğ‘‡ induced by ğ‘‰ğ‘¡ is connected.

The width of ğ‘‡ = (ğ‘‰ , ğ¸) is the size of its largest vertex, minus 1. The
treewidth of an atomset ğ´, denoted by ğ‘¡ğ‘¤ (ğ´), is the minimal width
among all its tree decompositions.

Fact 1. ğ´ âŠ† ğµ implies tw(ğ´) â‰¤ tw(ğµ).

Definition 5. Given a natural number ğ‘›, we say that an atomset
ğ´ contains an ğ‘› Ã— ğ‘›-grid, if terms(ğ´) contains ğ‘›2 distinct terms,
denoted ğ‘¡ğ‘–
ğ‘— for ğ‘–, ğ‘— âˆˆ {1, . . . , ğ‘›}, such that for all ğ‘˜ âˆˆ {1, . . . , ğ‘› âˆ’ 1}
and â„“ âˆˆ {1, . . . , ğ‘›}:
â„“ , ğ‘¡ğ‘˜+1
â€¢ there is some at âˆˆ ğ´ with {ğ‘¡ğ‘˜
â„“
, ğ‘¡ â„“
â€¢ there is some atâ€² âˆˆ ğ´ with {ğ‘¡ â„“
ğ‘˜+1} âŠ† terms(atâ€²).
ğ‘˜

} âŠ† terms(at), and

Fact 2. If ğ´ contains an ğ‘› Ã— ğ‘›-grid then tw(ğ´) â‰¥ ğ‘›.

Treewidth is an important notion in the context of existential
rules, as the existence of universal models with finite treewidth im-
plies decidability of CQ entailment [3, 7]. In fact, many concrete and
practically relevant classes of existential rule sets enjoy this prop-
erty. One generic way to guarantee the existence of such models
is by imposing conditions on the corresponding derivations. This
approach underlies all definitions of so-called bounded treewidth
sets of rules from the literature, but there is a certain disagreement
and diversity as to certain details and the type of chase employed (cf.
Footnote 4). Here, we will provide the most general such definition
that is known to guarantee finite-treewidth universal models along
the lines of previously established proofs.

Definition 6. A ruleset Î£ is called a bounded treewidth set (bts)
if for any finite instance ğ¹ , there exist some ğ‘ âˆˆ N and a restricted
chase sequence (ğ¹ğ‘– )ğ‘– âˆˆâ„‘ such that tw(ğ¹ğ‘– ) â‰¤ ğ‘ for all ğ‘– âˆˆ â„‘.
Proposition 2. CQ entailment for bts is decidable.

5 CORE CHASE & STRUCTURAL MEASURES
In what follows, we will use the term structural measure to gener-
ically denote any function ğœ‡ that maps instances to elements of
N âˆª {âˆ}. An easy example would be the size of an instance defined
by size : ğ¼ â†¦â†’ |ğ¼ |. An instance ğ¼ is then called ğœ‡-finite, if ğœ‡ (ğ¼ ) â‰  âˆ.
Moreover, we say that a sequence (ğ¹ğ‘– )ğ‘– âˆˆâ„‘ of atomsets is uniformly ğœ‡-
bounded, if there exists some ğ‘˜ âˆˆ N such that ğœ‡ (ğ¹ğ‘– ) â‰¤ ğ‘˜ for all ğ‘– âˆˆ â„‘.
(ğ¹ğ‘– )ğ‘– âˆˆâ„‘ will be called recurringly ğœ‡-bounded if there exists some
ğ‘˜ âˆˆ N such that for any ğ‘— âˆˆ â„‘ there exists some ğ‘– â‰¥ ğ‘— from â„‘ for
which ğœ‡ (ğ¹ğ‘– ) â‰¤ ğ‘˜ holds. It is easy to see that uniform ğœ‡-boundedness
implies recurring ğœ‡-boundedness, but not vice versa.

Since â€“ on an intuitive level â€“ universal models can be seen as
â€œlimitsâ€ of appropriate chase sequences, it is a natural question to
ask to what extent this limit process preserves structural measures.
More specifically, one may ask oneself, given a particular type of

chase and structural measure ğœ‡, if the existence of a (uniformly
or recurringly) ğœ‡-bounded chase sequence for a KB is a necessary
and/or sufficient condition for the existence of a ğœ‡-finite universal
model. As mentioned before, for the structural measure of size, this
question can be answered positively: A knowledge base K has a
(size-)finite universal model iff it has a size-bounded core chase
sequence [9].

Turning to the structural measure of treewidth, however, we
found that, surprisingly, both directions fail, witnessed by coun-
terexamples for either direction: The â€œsteepening staircaseâ€ KB
(Section 6) allows for a (even uniformly) treewidth-bounded chase
sequence while lacking a treewidth-finite universal model, whereas
the â€œinflating elevatorâ€ KB (Section 7) has a universal model of finite
treewidth while not exhibiting a (even just recurringly) treewidth-
bounded core-chase sequence.

Irrespective of the fact that our presentation focuses on treewidth
as the arguably most prominent structural measure, it should be
noted that our counterexamples are based on grid structures and
therefore also immediately work for other measures, such as clique-
width [11] or (generalized) hypertreewidth [13].

(ğ¹ h, Î£h) where Î£h = {ğ‘…h

6 THE STEEPENING STAIRCASE
For the KB below, the core chase sequence is uniformly treewidth-
bounded by 2, but none of its universal models has finite treewidth.
Definition 7 (The Steepening Staircase KB). We let Kh =
3 , ğ‘…h
We now describe the instance ğ¼ h, which is a universal model of
Kh that we can obtain via both the restricted and the core chase.
Definition 8. We define ğ¼ h as the infinite instance using the terms
ğ‘— | (ğ‘–, ğ‘—) âˆˆ N2, ğ‘– + 1 â‰¥ ğ‘— } and consisting of the atoms

4 }, as given in Figure 2.

terms(ğ¼ h) = {ğ‘‹ ğ‘–

2 , ğ‘…h

1 , ğ‘…h

ğ‘—+1)

ğ‘— , ğ‘‹ ğ‘–

v(ğ‘‹ ğ‘–

h(ğ‘‹ ğ‘–
h(ğ‘‹ ğ‘–

for ğ‘– â‰¥ ğ‘— â‰¥ 1

ğ‘˜+1}. Let ğ‘ƒ h

)
for ğ‘– â‰¤ ğ‘— .

ğ‘— , ğ‘‹ ğ‘–+1
f(ğ‘‹ ğ‘–
0)
ğ‘—
c(ğ‘‹ ğ‘–
ğ‘— , ğ‘‹ ğ‘–
ğ‘— )
ğ‘— )
The instance ğ¼ h is depicted in Figure 2; the names ğ‘‹ ğ‘–

ğ‘— of the
variables of ğ¼ h are in correspondence to their cartesian coordi-
nates (ğ‘–, ğ‘—) in the picture. We now consider some particular subsets
of terms(ğ¼ h). For any ğ‘˜ âˆˆ N, let ğ‘ƒğ‘˜ = {ğ‘‹ ğ‘–
ğ‘— }ğ‘– â‰¤ğ‘˜ , ğ¶ğ‘˜ = {ğ‘‹ ğ‘˜
ğ‘— } ğ‘— â‰¤ğ‘˜ , and
ğ‘˜ , ğ‘†h
ğ‘˜ (resp. ğ¶h
ğ‘†ğ‘˜ = ğ¶ğ‘˜ âˆª ğ¶ğ‘˜+1 âˆª {ğ‘‹ ğ‘˜
ğ‘˜ ) denote the subset of
ğ¼ h induced by ğ‘ƒğ‘˜ (resp. ğ¶ğ‘˜ , ğ‘†ğ‘˜ ). Intuitively, ğ‘ƒ h
ğ‘˜ is the finite part until
ğ‘˜ is the ğ‘˜th column of ğ¼ h (minus its top element) and
column ğ‘˜, ğ¶h
ğ‘˜ is a step â€“ a rectangle containing the two columns ğ¶h
ğ‘†h
ğ‘˜+1.
We first point out that there is a sequence of rule applications
from any ğ¶h
1 on the top of
ğ‘˜ to â€œcompleteâ€ ğ¶h
ğ¶h
ğ‘˜ and obtain the two highest variables of ğ¶h
ğ‘˜+1.
Then we apply ğ‘…h
2 ğ‘˜ times (from top to bottom) to obtain the other
variables of ğ¶h
ğ‘˜+1. Once ğ‘‹ ğ‘˜+1
has been generated, we can apply ğ‘…h
3
to generate the h-loop on ğ‘‹ ğ‘˜+1
, then ğ‘˜ successive applications of
0
4 propagate the loops on ğ¶h
ğ‘…h
ğ‘˜+1, from bottom to top. There is thus
a monotonic infinite derivation Dr = (ğ¹ğ‘– )ğ‘– âˆˆN from Kh, the natural
aggregation of which yields ğ¼ h. We successively apply ğ‘…h
3 , and
ğ‘…h
4 on ğ¹ h to obtain ğ‘†h
0 , we apply the rules
on ğ¶h
2 , and so on. The
r = ğ¼ h.
infinite union of all atomsets along this derivation is Dâˆ—
Proposition 3. ğ¼ h is a result of the restricted chase on Kh.

1 . Since ğ¶h
1 as seen previously to obtain ğ‘…h

ğ‘˜ . Indeed, we can apply ğ‘…h

1 âŠ† ğ‘†h
1 and thus ğ‘†h

ğ‘˜ producing ğ‘†h

ğ‘˜ and ğ¶h

0 = ğ‘ƒ h

1 , ğ‘…h

0

Bounded Treewidth and the Infinite Core Chase

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

(ğ‘…h
1 )
(ğ‘…h
2 )
(ğ‘…h
3 )
(ğ‘…h
4 )

(ğ¹ h)

ğ¹ h

]
Ã—
[

h(ğ‘‹ , ğ‘‹ ) â†’ âˆƒğ‘‹ â€²ğ‘Œğ‘Œ â€².h(ğ‘‹ , ğ‘Œ ) âˆ§ v(ğ‘‹ , ğ‘‹ â€² ) âˆ§ h(ğ‘‹ â€², ğ‘Œ â€² ) âˆ§ v(ğ‘Œ , ğ‘Œ â€² ) âˆ§ c(ğ‘Œ â€² )

h(ğ‘‹ , ğ‘‹ ) âˆ§ v(ğ‘‹ , ğ‘‹ â€² ) âˆ§ h(ğ‘‹ â€², ğ‘‹ â€² ) âˆ§ h(ğ‘‹ â€², ğ‘Œ â€² ) â†’ âˆƒğ‘Œ .c(ğ‘Œ â€² ) âˆ§ h(ğ‘‹ , ğ‘Œ ) âˆ§ v(ğ‘Œ , ğ‘Œ â€² )
f(ğ‘‹ ) âˆ§ h(ğ‘‹ , ğ‘‹ ) âˆ§ h(ğ‘‹ , ğ‘Œ ) â†’ f(ğ‘Œ ) âˆ§ h(ğ‘Œ , ğ‘Œ )

h(ğ‘‹ , ğ‘‹ ) âˆ§ v(ğ‘‹ , ğ‘‹ â€² ) âˆ§ c(ğ‘‹ â€² ) â†’ h(ğ‘‹ â€², ğ‘‹ â€² )

{f(ğ‘‹ 0

0 ), h(ğ‘‹ 0

0 , ğ‘‹ 0

0 ) }

ğ‘…h
1

ğ‘…h
2

ğ‘…h
3

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

ğ‘…h
4

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
]
Ã—
Ã—
[
[

]
]
]
Ã—
Ã—
Ã—
[
[
[

]
Ã—
[

]
]
]
Ã—
Ã—
Ã—
[
[
[

ğ¼ h

]
Ã—
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
]
Ã—
Ã—
Ã—
[
[
[

]
Ã—
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
]
Ã—
Ã—
Ã—
[
[
[

]
Ã—
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
]
Ã—
Ã—
Ã—
[
[
[

]
Ã—
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
]
Ã—
Ã—
Ã—
[
[
[

Ëœğ¼ h

]
Ã—
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
]
Ã—
Ã—
Ã—
[
[
[

]
Ã—
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
Ã—
Ã—
[
[

]
]
]
Ã—
Ã—
Ã—
[
[
[

Figure 2: Left: rules of Î£h, fact set ğ¹ h, and a graphical representation thereof. Orange (grey) elements represent the rule body,
]
denotes v (â€œverticalâ€); we write[
denotes h (â€œhorizontalâ€) and
black elements the rule head. Visualization of atoms:
Ã—
] for f (â€œfloorâ€). Right: Atomset ğ¼ h from Definition 8 â€“ an infinite universal model of Kh. Atomset Ëœğ¼ h at
for c (â€œceilingâ€) and[
Ã—
the very right is another infinite model of Kh, which is not universal but satisfies exactly the same CQs.

Sketch of proof. The derivation Dr given above is a restric-
ted chase sequence. Clearly, no ğ›¼ (ğ¹, ğ‘…, ğœ‹) in Dr retracts to ğ¹, so it
remains to check that Dr is fair. Indeed, if (ğ‘…, ğœ‹) is a trigger for
some ğ¹ğ‘– , then it is a trigger wrt some ğ‘…h
ğ‘˜ that is necessarily satisfied
(at most in ğ‘ƒ h
â–¡

). Thus (ğ‘…, ğœ‹) is satisfied in some ğ¹ ğ‘— âŠ‡ ğ‘ƒ h

.

ğ‘˜+2

ğ‘˜+2

ğ‘˜+1 is a retract of ğ‘†h

As a result of the restricted chase, ğ¼ h is a universal model of Kh.
Now, we point out that for any ğ‘˜, ğ¶h
ğ‘˜ that is
a core. Then we can use Dr to build a derivation Dc that relies
upon those retractions. Dc starts out like Dr, but as soon as ğ‘†h
0 is
obtained, we retract it to its core ğ¶h
1 . Then, following Drâ€™s course,
Dc proceeds to build ğ‘†h
2 . . . As for Dr,
we note that Dc is fair. Moreover, each retraction to a core is done
a finite number of rule applications after the previous one: Dc is
thus a core chase sequence. Finally, we point out that every atomset
in Dc is a subset of some ğ‘†h

1 that retracts to its core ğ¶h

ğ‘˜ , and has thus treewidth at most 2.

Proposition 4. There is a core chase sequence for Kh that is

uniformly treewidth-bounded by 2.

c = Dâˆ—

However, all the core computations done in Dc with the goal of
producing a â€œleanerâ€ result turn out to be futile when it comes to
r = ğ¼ h contains an ğ‘› Ã—ğ‘› grid for any ğ‘›, and
the aggregation: Dâˆ—
has thus unbounded treewidth. The next proposition even shows
that Kh admits no universal model of finite treewidth. For instance,
the atomset Ëœğ¼ h pictured in Figure 2 is a model of Kh but it is not
universal: it does not map to ğ¼ h, since it features an infinite v-path,
while all v-paths contained in ğ¼ h are of finite length.

Proposition 5. No universal model of Kh has finite treewidth.
Sketch of proof. Any universal model ğ‘ˆ of Kh is homomor-
phically equivalent to ğ¼ h. This allows to show that, for any ğ‘› â‰¥ 1,
â–¡
ğ‘ˆ contains an ğ‘› Ã— ğ‘›-grid, hence tw(ğ‘ˆ ) â‰¥ ğ‘›.

7 THE INFLATING ELEVATOR
We now present a knowledge base Kv which does have a universal
model with a treewidth of 1, while any (fair) core chase sequence

for Kv contains atomsets whose associated treewidths grow mono-
tonically beyond any given bound.

Definition 9 (The Inflating Elevator KB). We let Kv =
7 } and ğ¹ v are as given
4, ğ‘…v

6, ğ‘…v

3, ğ‘…v

5, ğ‘…v

2, ğ‘…v

(ğ¹ v, Î£v) where Î£v = {ğ‘…v
1, ğ‘…v
in the upper part of Figure 3.

We describe an atomset (shown on the left in Figure 4) repre-
senting a universal model that can be obtained via the natural
aggregation over the restricted chase or a core chase. We use the
same naming convention for nulls as before.

Definition 10. Let terms(ğ¼ h) = {ğ‘‹ ğ‘–

ğ‘— | (ğ‘–, ğ‘—) âˆˆ N, ğ‘– âˆ’ 1 â‰¤ ğ‘— â‰¤ 2ğ‘–}.
Then ğ¼ v consists of the following atoms for all ğ‘–, ğ‘— where all mentioned
nulls are in terms(ğ¼ v):
d(ğ‘‹ ğ‘–
ğ‘— )
f(ğ‘‹ ğ‘–
ğ‘— )
c(ğ‘‹ ğ‘–
2ğ‘– )

ğ‘— , ğ‘‹ ğ‘–+1
)
ğ‘—
2ğ‘–, ğ‘‹ ğ‘–+1
2ğ‘–+1)
2ğ‘–, ğ‘‹ ğ‘–+1
2ğ‘–+2)

ğ‘— , ğ‘‹ ğ‘–
ğ‘—+1)
ğ‘— , ğ‘‹ ğ‘–
ğ‘— )

h(ğ‘‹ ğ‘–
h(ğ‘‹ ğ‘–
h(ğ‘‹ ğ‘–

v(ğ‘‹ ğ‘–
v(ğ‘‹ ğ‘–

for ğ‘– â‰¤ ğ‘—

Proposition 6. ğ¼ v is a result of the restricted chase on Kv.

Sketch of proof. The claim can be shown inductively by as-
suming that rules without existential variables are prioritized and
new nulls are created according to the following scheme:
â€¢ for every ğ‘– â‰¥ 1, ğ‘‹ ğ‘–

2ğ‘– âˆ’1 and ğ‘‹ ğ‘–

2ğ‘– are introduced as instances of ğ‘Œ â€²
2ğ‘– âˆ’2 and

1 with ğ‘‹ â†¦â†’ ğ‘‹ ğ‘– âˆ’1

and ğ‘Œ â€²â€² through an application of Rule ğ‘…v
ğ‘Œ â†¦â†’ ğ‘‹ ğ‘–

2ğ‘– âˆ’2.
â€¢ for every ğ‘– â‰¥ 1, ğ‘‹ ğ‘–+1
application of Rule ğ‘…v

ğ‘–

â€¢ every remaining ğ‘‹ ğ‘–

is introduced as instance of ğ‘Œ â€² through an
ğ‘– âˆ’1 and ğ‘‹ â€² â†¦â†’ ğ‘‹ ğ‘–
2 with ğ‘‹ â†¦â†’ ğ‘‹ ğ‘–
ğ‘– .
ğ‘— âˆˆ terms(ğ¼ v) with ğ‘– â‰¥ 1 is introduced as
3 with ğ‘‹ â†¦â†’ ğ‘‹ ğ‘– âˆ’1
ğ‘— âˆ’1,

instance of ğ‘Œ â€² through an application of Rule ğ‘…v
ğ‘‹ â€² â†¦â†’ ğ‘‹ ğ‘– âˆ’1

, and ğ‘Œ â†¦â†’ ğ‘‹ ğ‘–

ğ‘—

ğ‘— âˆ’1.

Fairness follows from the fact that ğ¼ v satisfies all its triggers, as can
â–¡
be checked easily.

As a result of the restricted chase, ğ¼ v is a universal model of Kv.
As it turns out, it even contains another universal model of finite

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Jean-FranÃ§ois Baget, Marie-Laure Mugnier, and Sebastian Rudolph

(ğ¹ v)
(ğ‘…v
1 )
(ğ‘…v
3 )
(ğ‘…v
2 )

0 ), d(ğ‘‹ 0

{c(ğ‘‹ 0
0 ), f(ğ‘‹ 1
c(ğ‘‹ ) âˆ§ h(ğ‘‹ , ğ‘Œ ) â†’ âˆƒğ‘Œ â€²ğ‘Œ â€²â€².v(ğ‘Œ , ğ‘Œ â€² ) âˆ§ v(ğ‘Œ â€², ğ‘Œ â€²â€² ) âˆ§ c(ğ‘Œ â€²â€² )

0 ), h(ğ‘‹ 0

0 , ğ‘‹ 1

0 ) }

v(ğ‘‹ , ğ‘‹ â€² ) âˆ§ h(ğ‘‹ , ğ‘Œ ) â†’ âˆƒğ‘Œ â€².v(ğ‘Œ , ğ‘Œ â€² ) âˆ§ h(ğ‘‹ â€², ğ‘Œ â€² )

d(ğ‘‹ ) âˆ§ f(ğ‘‹ ) âˆ§ v(ğ‘‹ , ğ‘‹ â€² ) â†’ âˆƒğ‘Œ â€².h(ğ‘‹ â€², ğ‘Œ â€² ) âˆ§ f(ğ‘Œ â€² )

ğ¹ v

ğ‘…v
1

ğ‘…v
2

]
Ã—
[

]
Ã—
[

A

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

A

ğ‘…v
3

]
Ã—
[

]
Ã—
[

]
Ã—
[

A

(ğ‘…v
4 )
(ğ‘…v
5 )
(ğ‘…v
6 )
(ğ‘…v
7 )

ğ‘…v
4

]
Ã—
[

A

c(ğ‘‹ ) â†’ d(ğ‘‹ )
v(ğ‘‹ , ğ‘‹ â€² ) âˆ§ d(ğ‘‹ â€² ) â†’ d(ğ‘‹ )

h(ğ‘‹ , ğ‘Œ ) âˆ§ d(ğ‘Œ ) âˆ§ f(ğ‘Œ ) â†’ f(ğ‘‹ ) âˆ§ v(ğ‘‹ , ğ‘‹ )

c(ğ‘‹ ) âˆ§ h(ğ‘‹ , ğ‘Œ ) âˆ§ v(ğ‘Œ , ğ‘Œ â€² ) âˆ§ f(ğ‘Œ â€² ) â†’ h(ğ‘‹ , ğ‘Œ â€² )

ğ‘…v
5

]
Ã—
[

]
Ã—
[

A

ğ‘…v
6

ğ‘…v
7

]
Ã—
[

]
Ã—
[

A

]
Ã—
[

]
Ã—
[

]
Ã—
[

A

Figure 3: ğ¹ v and rules of Î£v (top) and their graphical depictions (bottom). Orange (grey) elements represent the rule body and
denotes v (â€œverticalâ€); we
black elements the rule head. Atoms are encoded as follows:
] for f (â€œfloorâ€), and[
] for d (â€œdoneâ€).
] for c (â€œceilingâ€),[
write[
Ã—
Ã—
Ã—

denotes h (â€œhorizontalâ€) and

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
Ã—
[

]
]
]
]
]
Ã—
Ã—
Ã—
Ã—
Ã—
[
[
[
[
[

]
]
Ã—
Ã—
[
[

]
]
]
Ã—
Ã—
Ã—
[
[
[

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
]
]
]
]
]
]
]
]
Ã—
Ã—
Ã—
Ã—
Ã—
Ã—
Ã—
Ã—
Ã—
[
[
[
[
[
[
[
[
[

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
]
]
]
]
]
]
Ã—
Ã—
Ã—
Ã—
Ã—
Ã—
Ã—
[
[
[
[
[
[
[

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
Ã—
[

]
]
]
]
]
Ã—
Ã—
Ã—
Ã—
Ã—
[
[
[
[
[

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
]
]
]
]
]
]
]
Ã—
Ã—
Ã—
Ã—
Ã—
Ã—
Ã—
Ã—
[
[
[
[
[
[
[
[

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
]
]
]
]
]
Ã—
Ã—
Ã—
Ã—
Ã—
Ã—
[
[
[
[
[
[

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
]
]
]
Ã—
Ã—
Ã—
Ã—
[
[
[
[

]
]
]
]
Ã—
Ã—
Ã—
Ã—
[
[
[
[

]
]
Ã—
Ã—
[
[

]
]
]
Ã—
Ã—
Ã—
[
[
[

]
]
]
Ã—
Ã—
Ã—
[
[
[

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
]
]
]
]
]
]
Ã—
Ã—
Ã—
Ã—
Ã—
Ã—
Ã—
[
[
[
[
[
[
[

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
Ã—
[

]
]
]
]
]
Ã—
Ã—
Ã—
Ã—
Ã—
[
[
[
[
[

]
]
Ã—
Ã—
[
[

]
]
]
Ã—
Ã—
Ã—
[
[
[

]
]
]
Ã—
Ã—
Ã—
[
[
[

]
]
]
Ã—
Ã—
Ã—
[
[
[

]
]
]
Ã—
Ã—
Ã—
[
[
[

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
]
]
]
]
]
Ã—
Ã—
Ã—
Ã—
Ã—
Ã—
[
[
[
[
[
[

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
]
]
]
Ã—
Ã—
Ã—
Ã—
[
[
[
[

]
]
]
]
Ã—
Ã—
Ã—
Ã—
[
[
[
[

]
Ã—
[

ğ¼ v
âˆ—

]
]
]
Ã—
Ã—
Ã—
[
[
[

ğ¼ v
1

]
]
]
Ã—
Ã—
Ã—
[
[
[

ğ¼ v
2

]
]
]
Ã—
Ã—
Ã—
[
[
[

ğ¼ v
3

]
]
]
Ã—
Ã—
Ã—
[
[
[

ğ¼ v
4

]
]
]
Ã—
Ã—
Ã—
[
[
[

ğ¼ v
5

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
Ã—
[

]
Ã—
[

ğ¼ v

]
]
Ã—
Ã—
[
[

]
Ã—
[

]
Ã—
[

]
]
Ã—
Ã—
[
[

Figure 4: Two infinite universal models of Kv (ğ¼ v from Definition 10 and ğ¼ v
the sequence (ğ¼ v

ğ‘› )ğ‘›âˆˆN from Definition 12 (recall that ğ¼ v

0 = ğ¹ v).

âˆ— from Definition 11), and finite atomsets ğ¼ v

1 â€“ ğ¼ v

5 of

treewidth. This second universal model ğ¼ v
is given in the next definition.

âˆ— , also shown in Figure 4,

Definition 11. We define the atomset ğ¼ v
from ğ¼ v only containing variables of the form ğ‘‹ ğ‘–
2ğ‘– .
âˆ— is a universal model of Kv.

Proposition 7. ğ¼ v

âˆ— as the set of those atoms

Proof. ğ¼ v

âˆ— is a model of Kv: it receives a homomorphism from ğ¹ v
and satisfies all rules from Î£v. It is universal, since the identity is a
âˆ— to ğ¼ v which is itself a universal model. â–¡
homomorphism from ğ¼ v
This implies that no finite universal model of Kv can exist (as
any such model would receive a homomorphism from ğ¼ v
âˆ— and thus
contain a h-cycle, thus not be homomorphically equivalent to ğ¼ v
âˆ— ).
1 , . . . of subsets of ğ¼ v that ex-
hibit increasing treewidths and will later be shown to occur as
substructures in any core chase sequence of Kv. Figure 4 depicts
the first elements of that sequence.

We next describe a sequence ğ¼ v

0 , ğ¼ v

Definition 12. We define the sequence (ğ¼ v
ğ‘› )ğ‘›âˆˆN of atomsets by
0 = ğ¹ v and, for any ğ‘› > 0, obtaining ğ¼ v
ğ‘› as the substructure of
2 } âˆª {ğ‘‹ ğ‘–
ğ‘› ) = {ğ‘‹ ğ‘–
ğ‘— | ğ‘– â‰¤ ğ‘›+1 and ğ‘— â‰¥ ğ‘›}
ğ‘— , ğ‘‹ ğ‘–
ğ‘— ) with ğ‘— > ğ‘› as well as all

letting ğ¼ v
ğ¼ v induced by terms(ğ¼ v
removing all atoms v(ğ‘‹ ğ‘–
ğ‘— , ğ‘‹ ğ‘–+1
atoms h(ğ‘‹ ğ‘–
ğ‘˜

2ğ‘– | ğ‘– â‰¤ ğ‘›
ğ‘— ) and f(ğ‘‹ ğ‘–
) with ğ‘˜ > ğ‘— and ğ‘˜ > ğ‘›.

Proposition 8. The following hold:

ğ‘› is a core.

ğ‘› has a treewidth of at least âŒˆğ‘›/3âŒ‰ + 1.

(1) Every ğ¼ v
(2) ğ¼ v
(3) For every core chase sequence (ğ¹ğ‘– )ğ‘– âˆˆN for Kv, there is an un-
: N â†’ N such that, for every

bounded monotonic function ğ‘“
ğ‘› âˆˆ N, ğ¼ v

ğ‘“ (ğ‘›) is isomorphic to a subset of ğ¹ğ‘›.

(4) For every core chase sequence (ğ¹ğ‘– )ğ‘– âˆˆN for Kv and any ğ‘š âˆˆ N

exists a ğ‘˜ âˆˆ N such that tw(ğ¹ğ‘– ) â‰¥ ğ‘š for all ğ‘– â‰¥ ğ‘˜.
From these technical insights, we obtain the strong guarantee

regarding the growth of the treewidth:

Corollary 1. No core chase sequence for Kv is recurringly or

uniformly treewidth-bounded.

Bounded Treewidth and the Infinite Core Chase

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

8 ROBUST AGGREGATIONS SAVE THE DAY
Recall that the steepening staircase example demonstrates that a
bounded-treewidth chase sequence does not warrant the existence
of a universal model of finite treewidth. This blocks the traditional
approach for showing decidability of CQ entailment. However, we
are still able to establish this desired result by other means, as
demonstrated in the course of the next two sections.

More specifically, we show that CQ entailment is decidable for
the class of KBs having a recurringly treewidth-bounded core chase
sequence (forthcoming Theorem 2). To do so, we go through the
following steps. Firstly, we resort to a weaker notion than universal-
ity, namely finite universality (Definition 13). We show that finitely
universal models can play the same role as universal models when it
comes to CQ entailment (Proposition 9). Secondly, we define a novel
way to compute the result of a derivation, namely the robust aggre-
gation of a derivation, and show that the robust aggregation of any
fair derivation is a finitely universal model (Proposition 11). Finally,
in Section 9, we show that the robust aggregation of a derivation
having recurringly bounded treewidth has finite treewidth (Propo-
sition 12), and conclude by adapting Courcelleâ€™s theorem to show
that CQ entailment is decidable for KBs admitting a finitely uni-
versal model of finite treewidth (Theorem 1). In the following, we
detail the employed notions and arguments laid out above.

Definition 13 (Finite universality). An atomset ğ¼ is finitely

universal for K if each finite subset of ğ¼ is universal for K.

Proposition 9. Let ğ‘€ be a finitely universal model of a KB K,

and let ğ‘„ be a CQ. Then K |= ğ‘„ iff ğ‘€ |= ğ‘„.

Proof. (â‡) Let ğœ be a homomorphism from ğ‘„ to ğ‘€. As ğ‘€ is
finitely universal, the finite subset ğœ (ğ‘„) of ğ‘€ maps to any model ğ¼
of K by some ğœ â€², thus ğœ â€² â—¦ ğœ maps ğ‘„ to ğ¼ . (â‡’) Since K |= ğ‘„ and
â–¡
ğ‘€ is a model of K, ğ‘€ |= ğ‘„.

Defining Robust Aggregations. For non-monotonic derivations
D = (ğ¹ğ‘– )ğ‘– âˆˆâ„‘, it may happen that an atom at is in some ğ¹ğ‘– , but
â€œdisappearsâ€ at some later step ğ‘—. Yet, at will still belong to the nat-
ural aggregation Dâˆ—. Intuitively, the natural aggregation generates
atomsets that are â€œtoo bigâ€ (this is why they may not be models). We
thus introduce a new type of aggregation, called robust aggregation,
that, instead of merely combining all atomsets ğ¹ğ‘– along the deriva-
tion, combines their collapsed versions obtained via preemptive
applications of future simplifications ğœ ğ‘— along the derivation. Defin-
ing this result is not immediate, however, since a variable could be
indefinitely re-mapped through simplifications along a derivation.
Observe that, in the staircase example, the core chase maps ğ‘‹ 0
0 to
ğ‘‹ 1
0 to ğ‘‹ 2
0 , then ğ‘‹ 1
0 , etc., and there is no way we can define the ulti-
mate image of ğ‘‹ 0
0 unless we can force the simplification to stabilize
at some point. This is the goal of the robust renaming, for which we
assume a bijection rank of the variables X with N, and use the total
ordering <X on X defined by ğ‘‹ <X ğ‘Œ iff rank(ğ‘‹ ) < rank(ğ‘Œ ).

Definition 14 (Robust renaming). Let ğ´ be an atomset and let
ğœ be a retraction of ğ´. The robust renaming associated with ğœ is the
substitution ğœŒğœ of vars(ğœ (ğ´)) that maps any variable ğ‘‹ of ğœ (ğ´) to
the <X-smallest variable of ğœ âˆ’1 (ğ‘‹ ). We let ğœğœ = ğœŒğœ â—¦ ğœ.

ğ´ğ‘– âˆ’1

ğœğ‘– âˆ’1

ğ¹ğ‘– âˆ’1

homomorphism

isomorphism

rule application

ğœŒğ‘– âˆ’1

ğºğ‘– âˆ’1

ğ´ğ‘–
ğœŒğ‘– âˆ’1

ğ´â€²
ğ‘–

ğœğ‘–

ğœğ‘–

ğœ â€²
ğ‘–

ğœğ‘–

ğœŒğ‘– âˆ’1
ğ¹ â€²
ğ‘–
ğœŒğœ â€²
ğ‘–

ğ¹ğ‘–

ğœŒğ‘–

ğºğ‘–

Figure 5: Building the robust sequence associated with D.

It is immediate that ğœŒğœ is an isomorphism from ğœ (ğ´) to ğœğœ (ğ´),
and, for any variable ğ‘‹ in ğ´, ğœğœ (ğ‘‹ ) is a constant or ğœŒğœ (ğ‘‹ ) â‰¤X ğ‘‹ . Let
us now inductively apply those robust renamings along a derivation.

Definition 15 (Robust seqence). Let D = (ğ¹ğ‘– )ğ‘– âˆˆâ„‘ be a deriva-
tion. The robust sequence associated with D is the sequence of atom-
sets (ğºğ‘– )ğ‘– âˆˆâ„‘ defined inductively by (see Figure 5 for induction step):
â€¢ With ğ´0 = ğ¹ , ğ¹0 = ğœ0 (ğ´0), and ğœŒ0 = ğœŒğœ0 , we define ğº0 = ğœŒ0 (ğ¹0);
â€¢ âˆ€ğ‘– âˆˆ â„‘ with ğ‘– > 0, if ğ¹ğ‘– âˆ’1 = ğœğ‘– âˆ’1 (ğ´ğ‘– âˆ’1), ğ´ğ‘– = ğ›¼ (ğ¹ğ‘– âˆ’1, tr), ğ¹ğ‘– =
ğœğ‘– (ğ´ğ‘– ) and ğºğ‘– âˆ’1 = ğœŒğ‘– âˆ’1 (ğ¹ğ‘– âˆ’1) (ğ¹ğ‘– âˆ’1 and ğºğ‘– âˆ’1 being isomorphic),
we build ğºğ‘– and an isomorphism ğœŒğ‘– from ğ¹ğ‘– to ğºğ‘– as follows:
â€“ let ğ´â€²

ğ‘– = ğ›¼ (ğºğ‘– âˆ’1, ğœŒğ‘– âˆ’1 (tr))), with the

ğ‘– = ğœŒğ‘– âˆ’1 (ğ´ğ‘– ) (see that ğ´â€²

same fresh variables as in ğ›¼ (ğ¹ğ‘– âˆ’1, tr)) and ğ¹ â€²

ğ‘– = ğœŒğ‘– âˆ’1 â—¦ ğœğ‘– â—¦ ğœŒ âˆ’1

â€“ then ğœ â€²
â€“ we define ğºğ‘– = ğœŒğœ â€²

(ğ¹ â€²
ğ‘– and ğœŒğ‘– = ğœŒğœ â€²

with ğœ â€²

ğ‘–

ğ‘–

ğ‘– âˆ’1 is a retraction such that ğœ â€²

ğ‘– ) = ğ¹ â€²
ğ‘– ;
ğ‘– the robust renaming associated

ğ‘– ), with ğœŒğœ â€²
â—¦ ğœŒğ‘– âˆ’1 an isomorphism from ğ¹ğ‘– to ğºğ‘– ;
â—¦ğœ â€²

ğ‘– the homomorphism

= ğœŒğœ â€²
ğ‘–

ğ‘–

â€“ furthermore, we denote by ğœğ‘– = ğœğœ â€²

from ğ´â€²

ğ‘– to ğºğ‘– . See that ğœğ‘– also maps ğºğ‘– âˆ’1 âŠ† ğ´â€²
ğ‘– to ğºğ‘– .
Note that (ğºğ‘– ) is not a derivation, since the ğœğ‘– from ğ´â€²

ğ‘– to ğºğ‘– are
not endomorphisms. However, every ğºğ‘– is isomorphic to ğ¹ğ‘– , and
we show that variables are finitely renamed along this sequence.

ğ‘– = ğœŒğ‘– âˆ’1 (ğ¹ğ‘– );
ğ‘– (ğ´â€²

Proposition 10. Let (ğºğ‘– )ğ‘– âˆˆâ„‘ be an associated robust sequence.
For ğ‘–, ğ‘— âˆˆ â„‘ with ğ‘– < ğ‘—, let Â¯ğœ ğ‘—
ğ‘– = ğœ ğ‘— â—¦ Â· Â· Â· â—¦ ğœğ‘–+1 denote the composition
of all ğœâ„“ between ğºğ‘– and ğº ğ‘— . Then, for any ğ‘‹ âˆˆ vars(ğºğ‘– ), there is ğ‘— âˆˆ â„‘
with ğ‘— > ğ‘– such that Â¯ğœ ğ‘—
ğ‘– (ğ‘‹ ) = ğ‘Œ âˆˆ terms(ğº ğ‘— ) and for all ğ‘˜ âˆˆ â„‘ with
ğ‘˜ > ğ‘—, Â¯ğœğ‘˜

ğ‘— (ğ‘Œ ) = ğ‘Œ (i.e., ğ‘Œ is stable from ğº ğ‘— on). We let Â¯ğœ (ğ‘‹ ) = ğ‘Œ .

Proof. Let ğ‘‹ âˆˆ vars(ğºğ‘– ), then ğœğ‘–+1 (ğ‘‹ ) = ğœğœ â€²
ğ‘–+1

(ğ‘‹ ) â‰¤X ğ‘‹. Con-
sider some arbitrary ğ‘— âˆˆ â„‘ with ğ‘— > ğ‘–. Among the homomorphisms ğœâ„“
that Â¯ğœ ğ‘—
ğ‘– is composed of, there can be at most rank X (ğ‘‹ ) many of them
that are effectively decreasing (causing Â¯ğœ â„“ âˆ’1
â–¡

(ğ‘‹ ) <X Â¯ğœ â„“

ğ‘– (ğ‘‹ )).

ğ‘–

We now use the Â¯ğœ (ğºğ‘– ) to define the robust aggregation. Note that,

contrary to (ğ¹ğ‘– ) or (ğºğ‘– ), the sequence ( Â¯ğœ (ğºğ‘– )) is monotonic.

Definition 16 (Robust aggregation). Given a derivation D =
(ğ¹ğ‘– )ğ‘– âˆˆâ„‘ and its associated robust sequence (ğºğ‘– )ğ‘– âˆˆâ„‘, the robust aggre-
gation of D is the (possibly infinite) atomset D âŠ› = (cid:208)ğ‘– âˆˆâ„‘ Â¯ğœ (ğºğ‘– ).

Semantic Properties of Robust Aggregations. The steepening stair-
case shows that the robust aggregation of a derivation is not always
universal. Indeed, consider the KB Kh (from Definition 7) and let
<X be an order on the variables with ğ‘— < ğ‘˜ â‡’ ğ‘‹ ğ‘–
ğ‘˜ . The core
chase on Kh begins building the first step ğ‘†h
0 of ğ¼ h, and all simplifi-
cations are the identity until done. Now, the first proper retraction
maps ğ‘‹ 0
1 , so the robust renaming generates
ğºğ‘–1 , which is isomorphic to the column ğ¶h
1 , but its variables are

0 and ğ‘‹ 0

ğ‘— <X ğ‘‹ ğ‘–

1 to ğ‘‹ 1

0 to ğ‘‹ 1

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Jean-FranÃ§ois Baget, Marie-Laure Mugnier, and Sebastian Rudolph

1 , ğ‘‹ 1

0 , ğ‘‹ 0

0 and ğ‘‹ 0

named (from bottom to top) ğ‘‹ 0
1 . Likewise, from successive
proper retraction steps, we obtain ğºğ‘– ğ‘— isomorphic to ğ¶h
ğ‘— but with
variables named ğ‘‹ 0
2 , . . . , ğ‘‹ ğ‘—
ğ‘—+1. Note that Â¯ğœ (ğºğ‘– ğ‘— ) = ğºğ‘– ğ‘— holds:
every variable is stable since subsequent re-mappings would have
to be within the same row, yet all variables therein are <X-greater.
Then, the robust aggregation D âŠ› is isomorphic to the infinite col-
umn Ëœğ¼ h, with variables named ğ‘‹ 0
ğ‘—+1, . . . , which is
not universal, but is a finitely universal model, as stated below.

2 , . . . , ğ‘‹ ğ‘—

1 , ğ‘‹ 1

0 , ğ‘‹ 0

Proposition 11. Let D be a derivation from K. Then (1) D âŠ›
is a model of K.

finitely universal for K; and (2) if D is fair, D âŠ›

is

To prove this proposition, we rely on the next lemma, which
states that any finite part of D âŠ› is â€œstably presentâ€ from a certain
element on in the robust sequence associated with D.

Lemma 1. Let D be a derivation and let (ğºğ‘– )ğ‘– âˆˆâ„‘ be the robust
, there is

sequence associated with D. For any finite subset ğ´ of D âŠ›
some ğ‘˜ âˆˆ â„‘ such that ğ´ âŠ† ğºğ‘Ÿ for every ğ‘Ÿ âˆˆ â„‘ with ğ‘Ÿ â‰¥ ğ‘˜.

Sketch of proof. See that (i) the Â¯ğœ (ğºğ‘– ) form a monotonic se-
quence and then, thanks to Proposition 10, that (ii) for every Â¯ğœ (ğºğ‘– ),
there exists ğ‘˜ âˆˆ â„‘ such that Â¯ğœ (ğºğ‘– ) âŠ† ğºğ‘Ÿ for every ğ‘Ÿ â‰¥ ğ‘˜. Thanks to
(i), there is some ğ‘– with ğ´ âŠ† Â¯ğœ (ğºğ‘– ) and we conclude with (ii).
â–¡

Proof of Proposition 11. (1) Let ğ‘€ be an arbitrary model of
K, and let ğ¼ be be any finite subset of D âŠ›. By Lemma 1, there is
some ğ‘˜ such that ğ¼ âŠ† ğºğ‘˜ . Now ğºğ‘˜ is isomorphic to ğ¹ğ‘˜ , which is
universal (from Proposition 1), so ğºğ‘˜ (hence also ğ¼ ) maps to ğ‘€.

(2) Let D = (ğ¹ğ‘– )ğ‘– âˆˆâ„‘ be a fair derivation from (ğ¹, Î£) and (ğºğ‘– )ğ‘– âˆˆâ„‘
be its associated robust sequence. Since ğœ0 maps ğ¹ to ğº0, Â¯ğœ â—¦ğœ0 maps
ğ¹ to D âŠ›, thus D âŠ› is a model of ğ¹ . Consider now any trigger tr for
D âŠ›. By Lemma 1, there exists some ğ‘— âˆˆ â„‘ such that tr is a trigger for
ğºğ‘Ÿ for any ğ‘Ÿ âˆˆ â„‘ with ğ‘Ÿ â‰¥ ğ‘—. Since ğœŒğ‘Ÿ is an isomorphism from ğ¹ğ‘Ÿ to
ğºğ‘Ÿ , we obtain that ğœŒ âˆ’1
(tr) is a trigger for ğ¹ğ‘Ÿ . Since D is fair, there
exists some ğ‘  âˆˆ â„‘ with ğ‘  â‰¥ ğ‘Ÿ such that the trigger Ëœğœğ‘ 
(tr) for ğ¹ğ‘ 
is satisfied in ğ¹ğ‘  . Now since ğœŒğ‘  is an isomorphism from ğ¹ğ‘  to ğºğ‘  , it
follows that ğœŒğ‘  â—¦ Ëœğœğ‘ 
(tr) is a satisfied trigger for ğºğ‘  . We first see
that ğœğ‘Ÿ +1 â—¦ ğœŒ âˆ’1
ğ‘Ÿ +1 â—¦ ğœğ‘Ÿ +1. By applying this property iteratively,
ğ‘Ÿ â—¦ğœŒ âˆ’1
we show that ğœŒğ‘  â—¦ Ëœğœğ‘ 
(tr) = Â¯ğœğ‘ 
ğ‘Ÿ (tr) = tr
is a trigger for ğºğ‘  satisfied in ğºğ‘  , and thus satisfied in D âŠ›.
â–¡

ğ‘Ÿ â—¦ğœŒ âˆ’1
ğ‘Ÿ
ğ‘Ÿ = ğœŒ âˆ’1

ğ‘Ÿ . Then ğœŒğ‘  â—¦ Ëœğœğ‘ 

ğ‘Ÿ = Â¯ğœğ‘ 

ğ‘Ÿ â—¦ ğœŒ âˆ’1
ğ‘Ÿ

ğ‘Ÿ â—¦ğœŒ âˆ’1
ğ‘Ÿ

ğ‘Ÿ

Hence, both natural and robust aggregations indicate whether a
CQ is entailed by a KB. Yet, natural aggregation provides an instance
that is universal but not always a model, while the more complex
robust aggregation provides a model which might be only finitely
universal. We show next how the latter case can still be utilized
towards proving Theorem 2.

9 DECIDABILITY THROUGH TREEWIDTH
The steepening staircase example shows that the natural aggre-
gation of the core chase may have infinite treewidth even if the
chase sequence is uniformly treewidth-bounded. The next proposi-
tion provides two results: Firstly, the natural aggregation is indeed
treewidth-preserving for monotonic derivations, generalizing a re-
sult by Baget et al. [3] for the restricted chase. Secondly (and more
importantly), robust aggregation is superior to natural aggrega-
tion in that treewidth preservation can be shown to hold even for
non-monotonic chases. Both results rely upon the compactness of

treewidth [18]: if ğ¹ is an atomset where tw(ğ¹ â€²) â‰¤ ğ‘˜ holds for every
finite subset ğ¹ â€² âŠ† ğ¹ , then tw(ğ¹ ) â‰¤ ğ‘˜.

Proposition 12. For any derivation D that is recurringly tree-

width-bounded by some integer ğ‘˜, the following hold:
(1) Dâ€™s natural aggregation Dâˆ— has treewidth â‰¤ğ‘˜, if D is monotonic.
(2) Dâ€™s robust aggregation D âŠ›

has treewidth â‰¤ğ‘˜.

Proof. Let ğ¼ be a finite subset of Dâˆ— (for proof of (1)) or D âŠ›
(for proof of (2)). There is some ğ‘ âˆˆ â„‘ such that, âˆ€ğ‘Ÿ â‰¥ ğ‘ âˆˆ â„‘,
we can exhibit some ğ¼ğ‘Ÿ isomorphic to ğ¹ğ‘Ÿ with ğ¼ âŠ† ğ¼ğ‘Ÿ . To prove
(1), D being monotonic, we can define ğ¼ğ‘Ÿ = ğ¹ğ‘Ÿ . To prove (2), we
rely upon Lemma 1 and define ğ¼ğ‘Ÿ = ğºğ‘Ÿ . Since D is recurrently
treewidth-bounded, there is some ğ‘  â‰¥ ğ‘ âˆˆ â„‘ such that tw(ğ¹ğ‘  ) â‰¤ ğ‘˜.
Thus tw(ğ¼ ) â‰¤ tw(ğ¼ğ‘  ) = tw(ğ¹ğ‘  ) â‰¤ ğ‘˜, and we conclude, thanks to
compactness of treewidth, that Dâˆ— or D âŠ› has treewidth â‰¤ ğ‘˜. â–¡

The last missing insight is that the existence of treewidth-bounded
finitely universal models suffices to establish decidability of CQ
entailment.3 We obtain this result via a mild generalization of re-
spective statements for universal models [3, 7, 11].

Theorem 1. Let â„­ be a class of knowledge bases for which every
K = (ğ¹, Î£) âˆˆ â„­ has a model ğ¼ that is finitely universal for K and
that satisfies ğ‘¡ğ‘¤ (ğ¼ ) âˆˆ N. Then CQ entailment for â„­ is decidable.

Sketch of proof. K |= ğ‘„ can be detected in finite time due to
the completeness of first-order logic. K Ì¸|= ğ‘„ can be detected by
incrementing ğ‘˜ stepwise and checking if K âˆ§ (Â¬ğ‘„) has a model of
â–¡
treewidth ğ‘˜, which is decidable.

We finally obtain our main result, which follows from Proposi-

tions 11 and 12, and Theorem 1:

Theorem 2. CQ entailment is decidable for the class of KBs having

a recurringly treewidth-bounded core chase sequence.

We end this section by using this decidability result to define a
new class of rulesets and discussing its relationship with existing
abstract decidable classes. As usual in the existential rule setting,
the considered property can be abstracted from the underlying
database, obtaining a new fragment of existential rules that â€“ thanks
to Theorem 2 â€“ warrants decidable CQ entailment and properly
subsumes and reconciles other classes with that property.4

Definition 17. A ruleset Î£ is called core-bts, if for every finite
atomset ğ¹ , there exists a core chase sequence for the KB (ğ¹, Î£), whose
treewidth is recurringly bounded by some ğ‘˜ âˆˆ N.

Proposition 13. CQ entailment is decidable for any ruleset that
is core-bts. Moreover, core-bts subsumes both finite expansion sets (fes)
and bounded treewidth sets (bts), which are mutually incomparable.

3However, no upper complexity bounds are entailed. This holds even for the more
restricted class of KBs with finite, â€œproperlyâ€ universal models [5].
4Notably, this corrects inaccurate statements in prior work by Baget et al. [3], where
bts was claimed to subsume fes. The reason for this misconception was a definition
of bts using cores, whereas the proof of decidability of CQ entailment for this class
was flawed, as it erroneously assumed that the natural aggregation over a (treewidth-
bounded) core chase sequence produces a (treewidth-bounded) universal model. The
current paper also corrects this earlier work, showing that the decidability claim made
therein can be salvaged by other means.

Bounded Treewidth and the Infinite Core Chase

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

10 CONCLUSION AND FUTURE WORK
In this paper, we have investigated ways of exploiting properties of
the core chase in non-terminating settings, with the main goal of en-
suring decidability of CQ entailment based on treewidth guarantees
for the atomsets occurring in chase sequence.

On the negative side, we found that, contrary to plausible expec-
tations, the existence of a treewidth-bounded core-chase sequence
does not coincide with the existence of a treewidth-bounded univer-
sal model, nor is there a subsumption in one of the two directions:
On one hand, we exhibited a KB Kh admitting a core-chase se-
quence the treewidth of which is uniformly bounded by 2, while
all its universal models are of unbounded treewidth. On the other
hand, we described a KB Kv admitting an infinite universal model
of treewidth 1, while all corresponding core chase sequences consist
of structures of ever increasing treewidth.

On the positive side, we showed how a given core chase sequence
can be robustly aggregated into a (potentially infinite) atomset that
is a model of the underlying knowledge base, while satisfying ex-
actly those CQs entailed by it. We also showed that for any such
core chase sequence that is recurringly treewidth-bounded, the
aggregated atomset will be of finite treewidth. Together, these find-
ings establish decidability of CQ entailment for all knowledge bases
with a recurringly treewidth-bounded core chase. Abstracting from
concrete databases, this yields a novel, very general abstract class
of recurringly treewidth-bounded rulesets, ensuring decidability of
CQ entailment and subsuming the two previously known incompa-
rable classes fes and bts.

Future work on the topic will clarify under what circumstances
the robust aggregation produces cores (according to some of the
many existing non-equivalent definitions of cores in the infinite [4]).
Also, we will investigate the relationship of our approach to the
stable chase introduced by Carral et al. [8], which also produces
(not necessarily universal) models satisfying exactly the entailed
CQs. Note that the stable chase is quite elaborate and not subsumed
by our current generic definition of derivation: the computation
occasionally â€œjumps backâ€ to earlier sequence elements and starts
rebuilding the sequence from there.

ACKNOWLEDGMENTS
The authors thank the anonymous reviewers for their helpful com-
ments. Jean-FranÃ§ois Baget and Marie-Laure Mugnier were partially
supported by the ANR project CQFD (ANR-18-CE23-0003). Sebas-
tian Rudolph has received funding from the European Research
Council (Consolidator Grant Agreement no. 771779, DeciGUT).

REFERENCES
[1] Jean-FranÃ§ois Baget, Michel LeclÃ¨re, and Marie-Laure Mugnier. 2010. Walking the
Decidability Line for Rules with Existential Variables. In Proceedings of the 12th
International Conference on Principles of Knowledge Representation and Reasoning
(KRâ€™10), Fangzhen Lin, Ulrike Sattler, and Miroslaw Truszczynski (Eds.). AAAI
Press. http://aaai.org/ocs/index.php/KR/KR2010/paper/view/1216

[2] Jean-FranÃ§ois Baget, Marie-Laure Mugnier, Sebastian Rudolph, and MichaÃ«l
Thomazo. 2011. Walking the Complexity Lines for Generalized Guarded Ex-
istential Rules. In Proceedings of the 22nd International Joint Conference on Ar-
tificial Intelligence (IJCAIâ€™11), Toby Walsh (Ed.). IJCAI/AAAI, 712â€“717. https:
//doi.org/10.5591/978-1-57735-516-8/IJCAI11-126

[3] Jean-FranÃ§ois Baget, Michel LeclÃ¨re, Marie-Laure Mugnier, and Eric Salvat. 2011.
On rules with existential variables: Walking the decidability line. Artificial
Intelligence 175, 9 (2011), 1620â€“1654. https://doi.org/10.1016/j.artint.2011.03.002
[4] Bruce L. Bauslaugh. 1995. Core-like properties of infinite graphs and structures.

Discrete Mathematics 138, 1-3 (1995), 101â€“111.

[5] Camille Bourgaux, David Carral, Markus KrÃ¶tzsch, Sebastian Rudolph, and
MichaÃ«l Thomazo. 2021. Capturing Homomorphism-Closed Decidable Queries
with Existential Rules. In Proceedings of the 18th International Conference on Prin-
ciples of Knowledge Representation and Reasoning, KR 2021, Meghyn Bienvenu,
Gerhard Lakemeyer, and Esra Erdem (Eds.). 141â€“150. https://doi.org/10.24963/kr.
2021/14

[6] A. CalÃ¬, G. Gottlob, and M. Kifer. 2008. Taming the Infinite Chase: Query An-
swering under Expressive Relational Constraints. In Proceedings of the 11th In-
ternational Conference on Principles of Knowledge Representation and Reasoning
(KRâ€™08). AAAI Press, 70â€“80.

[7] Andrea CalÃ¬, Georg Gottlob, and Michael Kifer. 2013. Taming the Infinite Chase:
Query Answering under Expressive Relational Constraints. Journal of Artificial
Intelligence Research 48 (2013), 115â€“174. https://doi.org/10.1613/jair.3873
[8] David Carral, Markus KrÃ¶tzsch, Maximilian Marx, Ana Ozaki, and Sebastian
Rudolph. 2018. Preserving Constraints with the Stable Chase. In Proceedings of the
21st International Conference on Database Theory (ICDTâ€™18) (LIPIcs, Vol. 98), Benny
Kimelfeld and Yael Amsterdamer (Eds.). Schloss Dagstuhl - Leibniz-Zentrum fÃ¼r
Informatik, 12:1â€“12:19. https://doi.org/10.4230/LIPIcs.ICDT.2018.12

[9] Alin Deutsch, Alan Nash, and Jeffrey B. Remmel. 2008. The chase revisited. In
Proceedings of the 27th ACM SIGMOD-SIGACT-SIGART Symposium on Principles
of Database Systems (PODSâ€™08), Maurizio Lenzerini and Domenico Lembo (Eds.).
ACM, 149â€“158. https://doi.org/10.1145/1376916.1376938

[10] R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa. 2005. Data Exchange: Semantics
and Query Answering. Theoretical Computer Science 336, 1 (2005), 89â€“124.
[11] Thomas Feller, Tim S. Lyon, Piotr Ostropolski-Nalewaja, and Sebastian Rudolph.
2023. Finite-Cliquewidth Sets of Existential Rules: Toward a General Criterion for
Decidable yet Highly Expressive Querying. In Proceedings of the 26th International
Conference on Database Theory (ICDT 2023) (LIPIcs). Schloss Dagstuhl - Leibniz-
Zentrum fÃ¼r Informatik. To appear. Preprint available via https://arxiv.org/abs/
2209.02464.

[12] Kurt GÃ¶del. 1929. Ãœber die VollstÃ¤ndigkeit des LogikkalkÃ¼ls. Ph. D. Dissertation.

UniversitÃ¤t Wien.

[13] Georg Gottlob, Nicola Leone, and Francesco Scarcello. 2003. Robbers, Marshals,
and Guards: Game Theoretic and Logical Characterizations of Hypertree Width.
J. Comput. Syst. Sci. 66, 4 (jun 2003), 775â€“808. https://doi.org/10.1016/S0022-
0000(03)00030-8

[14] GÃ¶sta Grahne and Adrian Onet. 2018. Anatomy of the Chase. Fundamenta
Informaticae 157, 3 (2018), 221â€“270. https://doi.org/10.3233/FI-2018-1627
[15] George Konstantinidis and JosÃ© Luis Ambite. 2014. Optimizing the Chase: Scalable
Data Integration under Constraints. Proc. VLDB Endow. 7, 14 (2014), 1869â€“1880.
https://doi.org/10.14778/2733085.2733093

[16] Markus KrÃ¶tzsch and Sebastian Rudolph. 2011. Extending Decidable Existential
Rules by Joining Acyclicity and Guardedness. In Proceedings of the 22nd Inter-
national Joint Conference on Artificial Intelligence (IJCAIâ€™11), Toby Walsh (Ed.).
IJCAI/AAAI, 963â€“968. https://doi.org/10.5591/978-1-57735-516-8/IJCAI11-166
[17] B. Marnette. 2009. Generalized schema-mappings: from termination to tractability.
In Proceedings of the 28th ACM SIGMOD-SIGACT-SIGART Symposium on Principles
of Database Systems (PODSâ€™09), J. Paredaens and J. Su (Eds.). ACM, 13â€“22.
[18] Robin Thomas. 1988. The Tree-Width Compactness Theorem for Hypergraphs.

Available via https://people.math.gatech.edu/~thomas/PAP/twcpt.pdf.

A PROOFS OF SECTION 3
The following appendices are devoted to the complete proofs that
are missing or only sketched in the paper.

Fact 3. If tr is a trigger for ğ¹ , ğœ‡ maps ğ¹ to ğ¼ and ğ¼ satisfies ğœ‡ (tr),

then there is ğœ‡â€² (compatible with ğœ‡) that maps ğ›¼ (ğ¹, tr) to ğ¼ .

Lemma 2. For every fair derivation D = (ğ¹ğ‘– )ğ‘– âˆˆâ„‘, there exists a
fair monotonic derivation Dğ‘šğ‘œğ‘› = (ğºğ‘– )ğ‘– âˆˆâ„‘ such that for every ğ‘– âˆˆ â„‘,
there is a retraction from ğºğ‘– to ğ¹ğ‘– .

Proof. From D = (ğ¹ğ‘– )ğ‘– âˆˆâ„‘, let us first build inductively a deriva-
tion Dğ‘šğ‘œğ‘› = (ğºğ‘– )ğ‘– âˆˆâ„‘ such that ğº0 = ğ´0 = ğ¹ , ğ¹0 = ğœ0 (ğ¹0) and
âˆ€ğ‘– > 0 âˆˆ â„‘, ğ¹ğ‘– = ğœğ‘– (ğ´ğ‘– ) with ğ´ğ‘– = ğ›¼ (ğ¹ğ‘– âˆ’1, trğ‘– ), we can define
ğºğ‘– = ğ›¼ (ğºğ‘– âˆ’1, trğ‘– ). See that ğœ0 is a retraction from ğº0 to ğ¹0, and so
the trigger tr1 is also a trigger in ğº0, allowing us to build ğº1. Now
we claim that ğœ0 is a retraction from ğº1 to ğ´1, and thus ğœ1 â—¦ ğœ0 is a
retraction from ğº1 to ğ¹1. An induction based upon these remarks
shows that for ğ‘– âˆˆ â„‘, Ëœğœğ‘– = ğœğ‘– â—¦ Â· Â· Â· â—¦ ğœ0 is a retraction from ğºğ‘– to
ğ¹ğ‘– that allows us to build ğºğ‘–+1. The derivation Dğ‘šğ‘œğ‘› we obtain is

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Jean-FranÃ§ois Baget, Marie-Laure Mugnier, and Sebastian Rudolph

ğ‘˜+1, ğ‘‹ ğ‘˜+1

ğ‘˜+1 ), c(ğ‘‹ ğ‘˜+1

ğ‘˜ , ğ‘‹ ğ‘˜+1
,

ğ‘˜), v(ğ‘‹ ğ‘˜+1

ğ‘˜

, ğ‘‹ ğ‘˜+1
ğ‘˜+1 )

ğ‘˜ âˆ’1), v(ğ‘‹ ğ‘˜+1

ğ‘˜ âˆ’1, ğ‘‹ ğ‘˜+1
ğ‘˜

ğ‘˜+1 ), h(ğ‘‹ ğ‘˜
)

), c(ğ‘‹ ğ‘˜+1
ğ‘˜

Rule
ğ‘…â„
1
ğ‘…â„
2
...
ğ‘…â„
2
ğ‘…â„
3
ğ‘…â„
4
...
ğ‘…â„
4

Homomorphism
ğ‘‹ â†¦â†’ ğ‘‹ ğ‘˜
ğ‘˜
ğ‘˜ , ğ‘Œ â€² â†¦â†’ ğ‘‹ ğ‘˜+1
ğ‘˜ âˆ’1, ğ‘‹ â€² â†¦â†’ ğ‘‹ ğ‘˜

ğ‘˜

ğ‘‹ â†¦â†’ ğ‘‹ ğ‘˜

...

1 , ğ‘Œ â€² â†¦â†’ ğ‘‹ ğ‘˜+1

1

ğ‘‹ â†¦â†’ ğ‘‹ ğ‘˜

0 , ğ‘‹ â€² â†¦â†’ ğ‘‹ ğ‘˜
ğ‘‹ â†¦â†’ ğ‘‹ ğ‘˜
ğ‘‹ â†¦â†’ ğ‘‹ ğ‘˜+1

0

1

0 ğ‘Œ â†¦â†’ ğ‘‹ ğ‘˜+1
0
, ğ‘‹ â€² â†¦â†’ ğ‘‹ ğ‘˜+1
...
, ğ‘‹ â€² â†¦â†’ ğ‘‹ ğ‘˜+1
ğ‘˜+1

ğ‘‹ â†¦â†’ ğ‘‹ ğ‘˜+1

ğ‘˜

ğ‘˜ , ğ‘‹ ğ‘˜
ğ‘˜ âˆ’1, ğ‘‹ ğ‘˜+1

Atoms produced
v(ğ‘‹ ğ‘˜
ğ‘˜+1), h(ğ‘‹ ğ‘˜
h(ğ‘‹ ğ‘˜
...
h(ğ‘‹ ğ‘˜
c(ğ‘‹ ğ‘˜+1
0
h(ğ‘‹ ğ‘˜+1
1
...
h(ğ‘‹ ğ‘˜+1

0 , ğ‘‹ ğ‘˜+1
0
), h(ğ‘‹ ğ‘˜+1
0
, ğ‘‹ ğ‘˜+1
1

ğ‘˜+1 , ğ‘‹ ğ‘˜+1
ğ‘˜+1 )

)

, ğ‘‹ ğ‘˜+1
1

), c(ğ‘‹ ğ‘˜+1
1

)

), v(ğ‘‹ ğ‘˜+1
0
, ğ‘‹ ğ‘˜+1
0

)

Table 1: Steepening staircase: from column to step.

monotonic, but it remains to check that it is fair. Given any trigger
tr for some ğºğ‘– , Ëœğœğ‘– (tr) is a trigger for ğ¹ğ‘– and thus (fairness of D)
there exists ğ‘— âˆˆ â„‘ such that Ëœğœ ğ‘— (tr) is a trigger for ğ¹ ğ‘— satisfied in
ğ¹ ğ‘— , and the trigger tr for ğº ğ‘— for which Ëœğœ ğ‘— is a retraction into ğ¹ ğ‘— is
â–¡
satisfied in ğº ğ‘— .

Proposition 1 (Extended version) Let D be a derivation from K.

Then:
(1) Dâˆ— is universal for K;
(2) if D is finite, D+ is universal for K;
(3) if D is monotonic and fair, Dâˆ— is a model of K;
(4) if D is finite and fair, D+ is a model of K;
(5) if D is fair and ğ‘„ is a CQ, K |= ğ‘„ iff Dâˆ— |= ğ‘„.

Proof. Let ğ‘€ be an arbitrary model of K. We first prove the
existence of homomorphisms ğ¹ğ‘– â†’ ğ‘€ by induction over ğ‘–. The
existence of some homomorphism ğ¹0 â†’ ğ‘€ is immediate by as-
sumption. Then, if there is a homomorphism ğœ‡ ğ‘— from some ğ¹ ğ‘— of D
to ğ‘€, then there is a homomorphism ğœ‡ ğ‘—+1 of ğ¹ ğ‘—+1 to ğ‘€ such that
ğœ‡ ğ‘—+1 is compatible with ğœ‡ ğ‘— . We have ğ¹ ğ‘—+1 = ğœ ğ‘—+1 (ğ›¼ (ğ¹ ğ‘— , trğ‘–+1)). See
that ğœ‡ ğ‘— (trğ‘–+1) is a trigger for ğ‘€, satisfied in ğ‘€ since it is a model
of K. Then (Fact 3) there is a homomorphism ğœ‡ from ğ›¼ (ğ¹ ğ‘— , tr ğ‘—+1)
to ğ‘€ compatible with ğœ‡ ğ‘— and its restriction ğœ‡ ğ‘—+1 to the variables of
ğœ ğ‘—+1 (ğ›¼ (ğ¹ ğ‘— , tr ğ‘—+1)) is a homomorphism from ğ¹ ğ‘—+1 to ğ‘€ compatible
with ğœ‡ ğ‘— .
(2) Hence, ğ‘€ is a model of every ğ¹ğ‘– in D: each instance ğ¹ğ‘– is univer-
sal and, if D is finite, then the final result D+ = ğ¹ğ‘˜ is universal. â–¡
(1) Now we claim that since a variable present both in ğ¹ğ‘– and ğ¹ ğ‘—
must appear in all atomsets between ğ¹ğ‘– and ğ¹ ğ‘— (a consequence of
the usage of fresh variables), the pairwise compatibility of the ğœ‡ğ‘–
between succsessive atomsets implies global compatibility of all
ğœ‡ğ‘– . We conclude by pointing out that (cid:208)ğ‘– âˆˆâ„‘ ğœ‡ğ‘– is a homomorphism
from Dâˆ— to ğ‘€, and thus that Dâˆ— is universal.
â–¡
(4) The final result D+ = ğ¹ğ‘˜ of a finite derivation is a model of ğ¹
( Ëœğœ ğ‘—
0 â—¦ ğœ0 is a homomorphism from ğ¹ to any ğ¹ ğ‘— in the derivation)
and, by Definition 3, for any trigger tr for ğ¹ğ‘˜ , there is some ğ‘— â‰¥ ğ‘˜
(thus ğ‘— = ğ‘˜) such that Ëœğœğ‘˜
â–¡
(3) In the case of an infinite fair derivation, we first point out that
Dâˆ— contains ğ¹0 = ğœ0 (ğ¹ ), so it is a model of ğ¹ . Then consider any

ğ‘˜ (tr) = tr is a satisfied trigger for ğ¹ğ‘˜ .

trigger tr for Dâˆ—: it is also a trigger for some ğ¹ğ‘– in D. By Definition 3,
there exists some ğ‘— âˆˆ â„‘ with ğ‘— â‰¥ ğ‘– such that Ëœğœ ğ‘—
ğ‘– (tr) is a satisfied
trigger for ğ¹ ğ‘— . Since D is monotonic, ğœ ğ‘—
is the identity and thus
ğ‘–
Ëœğœ ğ‘—
ğ‘– (tr) = tr is satisfied in Dâˆ—.
â–¡
(5, â‡) Let ğœ‹ be a homomorphism from ğ‘„ to Dâˆ—. Since Dâˆ— is uni-
versal (by (1)), it maps to any model ğ‘€ of K. Let ğœğ‘€ be a homo-
morphism from Dâˆ— to ğ‘€, then ğœğ‘€ â—¦ ğœ‹ maps ğ‘„ to ğ‘€.
â–¡
(5, â‡’) Let us now consider the fair monotonic derivation Dğ‘šğ‘œğ‘›
from Lemma 2. We now that Dâˆ—
ğ‘šğ‘œğ‘› is a model of K, and then
if K |= ğ‘„, then there is a homomorphism ğœ‹ from ğ‘„ to Dâˆ—
ğ‘šğ‘œğ‘›.
Since ğœ‹ (ğ‘„) is finite, there is some atomset ğºğ‘– in Dğ‘šğ‘œğ‘› such that
ğœ‹ (ğ‘„) âŠ† ğºğ‘– . We know there is a retract Ëœğœğ‘– from ğºğ‘– to ğ¹ğ‘– , so Ëœğœğ‘– â—¦ ğœ‹
is a homomorphism from ğ‘„ to ğ¹ğ‘– and so from ğ‘„ to Dâˆ—.
â–¡

B PROOFS OF SECTION 6
We first prove the following claim (see the explanations before
Proposition 5.).

Claim. There is a sequence of rule applications from any column
ğ‘˜ producing step ğ‘†h
ğ¶h
ğ‘˜ .
Proof. Let us consider ğ¶â„
ğ‘˜

1 , . . . , ğ‘‹ ğ‘˜
from bottom to top. Let us apply rules as shown in Table 1. The
obtained result is indeed ğ‘†â„
â–¡
ğ‘˜

with variables named (ğ‘‹ ğ‘˜

0 , ğ‘‹ ğ‘˜

.

ğ‘˜ ),

Proposition 5. No universal model of Kh has finite treewidth.
Proof. We call v-path (resp. h-path) in an atomset a non-empty
sequence of nulls such that, for any two consecutive nulls ğ‘‹ğ‘– and
ğ‘‹ğ‘–+1, the atomset contains the atom v(ğ‘‹ğ‘–, ğ‘‹ğ‘–+1) (resp. h(ğ‘‹ğ‘–, ğ‘‹ğ‘–+1)).
By analogy to graphs, the length of a path is ğ‘› âˆ’ 1 if it is a sequence
of ğ‘› nulls.

Let ğ‘ˆ be an arbitrary universal model of Kh. We first point out
that ğ¼ h and ğ‘ˆ being both universal models, they homomorphically
map to each other. We let â„1 denote the homomorphism from ğ¼ h
to ğ‘ˆ and let â„2 denote the homomorphism from ğ‘ˆ to ğ¼ h. Then
â„ = â„2 â—¦ â„1 is an endomorphism on ğ¼ h, the properties of which we
will now inspect further. We make use of the following notation: for
â„(ğ‘‹ ğ‘–
â„“ , we denote ğ‘˜ by â„ğ‘¥ (ğ‘–, ğ‘—) and â„“ by â„ğ‘¦ (ğ‘–, ğ‘—), that is, we

ğ‘— ) = ğ‘‹ ğ‘˜

Bounded Treewidth and the Infinite Core Chase

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

ğ‘— ) = ğ‘‹ â„ğ‘¥ (ğ‘–,ğ‘— )

â„ğ‘¦ (ğ‘–,ğ‘— ) . We make the following observations (which

let â„(ğ‘‹ ğ‘–
hold for all endomorphisms on ğ¼ h):
(1) â„ğ‘¦ (ğ‘–, 0) = 0 since f holds precisely for all nulls ğ‘‹ ğ‘–
0.
(2) â„ğ‘¦ (ğ‘–, ğ‘—) = ğ‘—, inductively with (1) as base case and the observa-
tion that â„ must preserve the length of incoming v-paths rooted
in some f.

(3) â„ğ‘¥ (ğ‘–, ğ‘—) = â„ğ‘¥ (ğ‘–, ğ‘— +1), since this is the only way for â„ to preserve

the v-atoms.

(4) â„ğ‘¥ (ğ‘–, ğ‘—) = â„ğ‘¥ (ğ‘–, ğ‘˜), via iteration of (3).
(5) â„ğ‘¥ (ğ‘–, ğ‘—) â‰¥ ğ‘–, due to (2) and the fact that ğ‘‹ ğ‘–

ğ‘— does not exist for

ğ‘— > ğ‘– + 1.

(6) â„ğ‘¥ (ğ‘– + 1, ğ‘—) = â„ğ‘¥ (ğ‘–, ğ‘—) or â„ğ‘¥ (ğ‘– + 1, ğ‘—) = â„ğ‘¥ (ğ‘–, ğ‘—) + 1, since this is

the only way for â„ to preserve the h-atoms.

(7) â„ğ‘¦ (ğ‘– + 1, ğ‘—) = â„ğ‘¦ (ğ‘–, ğ‘—) since this is the only way for â„ to preserve

the h-atoms.

(8) There are ğ‘˜, â„“ âˆˆ N such that â„ğ‘¥ (ğ‘–, ğ‘—) = ğ‘– + â„“ for all ğ‘– > ğ‘˜. This is

a consequence of (5) and (6).

(9) There is a ğ‘˜ âˆˆ N such that the restriction of â„ to the ğ‘‹ ğ‘–

ğ‘— with

âˆ’ to â„(ğ¼ h

âˆ’), i.e., ğ¼ h

âˆ’ be ğ¼ h restricted to terms ğ‘‹ ğ‘–

ğ‘– > ğ‘˜ is injective. Follows from (8), for the same ğ‘˜, and (2).
If we now let ğ¼ h

âˆ’) and â„2 must be an isomorphism from â„1 (ğ¼ h
âˆ’). Therefore, ğ‘¡ğ‘¤ (ğ¼ h

ğ‘— with ğ‘– > ğ‘˜, we obtain
âˆ’ (cid:27) â„(ğ¼ h
that â„ is an isomorphism from ğ¼ h
âˆ’). Since
â„ = â„2 â—¦ â„1, this means that â„1 must be an isomorphism from ğ¼ h
âˆ’ to
â„1 (ğ¼ h
âˆ’) to â„2 (â„1 (ğ¼ h
âˆ’)) =
â„(ğ¼ h
âˆ’))) (*). Now,
for any given ğ‘› âˆˆ N with ğ‘› > ğ‘˜, take Tğ‘›Ã—ğ‘› = {ğ‘‹ ğ‘–
| ğ‘› + 1 â‰¤ ğ‘– â‰¤
ğ‘—
2ğ‘› and 0 â‰¤ ğ‘– â‰¤ ğ‘› âˆ’ 1} âŠ† terms(ğ¼ h). Consequently, Tğ‘›Ã—ğ‘› witnesses
that ğ¼ h
âˆ’ contains a ğ‘› Ã— ğ‘› grid. Yet, as ğ‘› can be chosen arbitrarily
large, ğ¼ h
âˆ’ contains grids of arbitrary size and thus cannot have
finite treewidth, i.e., ğ‘¡ğ‘¤ (ğ¼ h
âˆ’) âˆ‰ N (**). From these insights, we can
conclude

âˆ’)) = ğ‘¡ğ‘¤ (â„2 (â„1 (ğ¼ h

âˆ’) = ğ‘¡ğ‘¤ (â„1 (ğ¼ h

ğ¼ h
âˆ’ âŠ† ğ¼ h =â‡’ â„1 (ğ¼ h

âˆ’) âŠ† â„1 (ğ¼ h) âŠ† ğ‘ˆ

âˆ’)) â‰¤ ğ‘¡ğ‘¤ (ğ‘ˆ )

(*)
=â‡’ ğ‘¡ğ‘¤ (ğ¼ h

âˆ’) â‰¤ ğ‘¡ğ‘¤ (ğ‘ˆ )

Fact 1
=â‡’ ğ‘¡ğ‘¤ (â„1 (ğ¼ h
(**)
=â‡’ ğ‘¡ğ‘¤ (ğ‘ˆ ) âˆ‰ N.

â–¡

C PROOFS OF SECTION 7
Proposition 8. The following hold:
(1) Every ğ¼ v
(2) ğ¼ v
(3) For every core chase sequence (ğ¹ğ‘– )ğ‘– âˆˆN for Kv, there is an un-
: N â†’ N such that, for every

ğ‘› has a treewidth of at least âŒˆğ‘›/3âŒ‰ + 1.

ğ‘› is a core.

bounded monotonic function ğ‘“
ğ‘› âˆˆ N, ğ¼ v

ğ‘“ (ğ‘›) is isomorphic to a subset of ğ¹ğ‘›.

(4) For every core chase sequence (ğ¹ğ‘– )ğ‘– âˆˆN for Kv and any ğ‘š âˆˆ N

exists a ğ‘˜ âˆˆ N such that tw(ğ¹ğ‘– ) â‰¥ ğ‘š for all ğ‘– â‰¥ ğ‘˜.

Proof. We show these claims consecutively.

(1) It is straightforward to check that ğ¼ v

0 is a core. To show that ğ¼ v
ğ‘›
is a core for every ğ‘› > 0, pick an arbitrary retraction ğœ of ğ¼ v
ğ‘› .
Toward showing that ğœ is the identity, first note that it must be
column-preserving (i.e., satisfy ğœ (ğ‘‹ ğ‘–
â„“ â€² ), since for any two
ğ‘‹ ğ‘–
ğ‘˜, ğ‘‹ ğ‘—
â€¢ they are connected by a v-path exactly if ğ‘– = ğ‘—,
â€¢ if there is an h connection from the former to the latter, then

â„“ ) = ğ‘‹ ğ‘–

â„“ âˆˆ Î”v

ğ‘› hold:

ğ‘– + 1 = ğ‘—,

ğ‘˜ â€², ğ‘‹ ğ‘—

â„“ â€² ) âˆˆ ğ¼ v
â€¢ if ğ‘– + 1 = ğ‘—, then there are ğ‘˜â€² and â„“ â€² satisfying h(ğ‘‹ ğ‘–
ğ‘› .
ğ‘˜ âˆˆ Î”v
Yet then, for every ğ‘‹ ğ‘–
ğ‘›, the corresponding column (the
substructure of ğ¼ v
ğ‘› induced by all ğ‘‹ ğ‘—
â„“ with ğ‘— = ğ‘–) has an retrac-
tion obtained by restricting ğœ accordingly. Yet, each of these
column-wise retractions must map the unique elements carry-
ing f and c to themselves, which also forces all other elements
(on the intermediate directed v-path) to be identically mapped.
Consequently, every row-wise retraction must be the identity
function. Yet then, ğœ as a whole must be the identity as well.
(2) This claim is a consequence of Fact 2, since, for every ğ‘›, the
ğ‘˜ with âŒŠ2ğ‘›/3âŒ‹ + 1 â‰¤ ğ‘– â‰¤ ğ‘› + 1 and ğ‘› â‰¤ ğ‘˜ â‰¤ âŒˆ4ğ‘›/3âŒ‰
ğ‘› contains a (âŒŠğ‘›/3âŒ‹ + 1) Ã— (âŒŠğ‘›/3âŒ‹ + 1)-grid.

elements ğ‘‹ ğ‘–
witness that ğ¼ v

ğ‘— ) = ğ‘‹ ğ‘–

2âŒŠ ğ‘—/2âŒ‹, ğ‘‹ ğ‘–

ğ‘—+1) âˆˆ ğ¼ v

(3) Without loss of generality, we assume the considered core chase
employs the same naming scheme as ğ¼ v. Therefore, any inter-
mediate atomset of the considered chase can be described by
a subset of ğ¼ v. We first observe that ğ¼ v
0 = ğ¹ v, thus the claim
is satisfied for ğ‘› = 0 once we set ğ‘“ (0) = 0. We proceed itera-
tively for larger ğ‘›. For any subsequent ğ‘›, we can assume that
ğ¹ğ‘›âˆ’1 contains some ğ¼ v
ğ‘š. Therefore, the only interesting case is
if, upon producing ğ¹ğ‘›, nulls of ğ¹ğ‘›âˆ’1 are removed through the
non-trivial retraction ğœğ‘›. Among the nulls removed, let ğ‘‹ ğ‘–
ğ‘— be
the one with maximal ğ‘— and (among all these) the one with
minimal ğ‘–. By construction (observing ğ¼ v), removal of nulls will
always simultaneously affect all nulls in a row, leaving behind
only those of the form ğ‘‹ ğ‘˜
2ğ‘˜ . Therefore, we obtain ğ‘– = âŒŠ ğ‘—/2âŒ‹ + 1.
Also, by maximality of ğ‘— and the fact that there are no row-
decreasing v-atoms, we know that ğœğ‘› (ğ‘‹ ğ‘–
ğ‘—+1 (note that
retractions must be column-preserving, as argued before). Then,
for ğœğ‘› to be a retraction, we require h(ğ‘‹ ğ‘– âˆ’1
ğ‘›âˆ’1.
Yet, as row-increasing h-edges can only be the consequence of a
(potentially iterated) prior application of ğ‘…v
7 , the atom f(ğ‘‹ ğ‘–
ğ‘—+1)
must occur in some atomset preceding ğ¼ v
ğ‘› . Yet, this can only be
the consequence of the iterated application of ğ‘…v
7 propagating f
from â€œright to leftâ€, starting from f(ğ‘‹ ğ‘—+2
ğ‘—+1 ). The latter
atom must, in turn have been created through iterated appli-
5 , propagating d â€œtop-downâ€ starting from d(ğ‘‹ ğ‘—+2
cation of ğ‘…v
2ğ‘—+4)
which must have been created through application of ğ‘…v
4 to
2ğ‘—+4). Yet, the only way to produce the latter is through ğ‘…v
c(ğ‘‹ ğ‘—+2
1
following iterated application of ğ‘…v
2 preceded by an application
of ğ‘…v
), and v(ğ‘‹ ğ‘—+1
ğ‘—+1 ). This argument
can then be repeated for columns further left, leading to the
insight that removal of ğ‘‹ ğ‘–
ğ‘—+1 must
have previously existed in the derivation. Among those, the
facts involving nulls ğ‘‹ ğ‘˜
â„“ with â„“ > ğ‘—, cannot have been removed
by our maximality assumption. The remaining facts of ğ¼ v
ğ‘—+1 are
indefinitely exempt from removal because the participating
nulls are column-wise unique wrt carrying c. We can therefore
conclude that upon removal of ğ‘‹ ğ‘–
ğ‘— toward the creation of ğ¹ğ‘›,
the latter must contain ğ¼ v
Finally, we observe that, as an indirect consequence of fairness,
every ğ‘‹ ğ‘–
ğ‘— with ğ‘— â‰  2ğ‘– will be removed in some derivation step,
leading to the consequence that ever growing elements ğ¼ v
ğ‘—+1 will
come into operation.

ğ‘— requires that all facts from ğ¼ v

ğ‘—+1 ), d(ğ‘‹ ğ‘—+2

3 to d(ğ‘‹ ğ‘—+1

), f(ğ‘‹ ğ‘—+1

, ğ‘‹ ğ‘—+1

ğ‘—+1.

ğ‘—

ğ‘—

ğ‘—

(4) This claim is a direct consequence of Item 2 and Item 3, given
â–¡

monotonicity of treewidth (Fact 1).

PODS â€™23, June 18â€“23, 2023, Seattle, WA, USA

Jean-FranÃ§ois Baget, Marie-Laure Mugnier, and Sebastian Rudolph

ğœ0

ğ¹

ğ¹0

ğœŒ0

ğº0

ğ´1
ğœŒ0

ğ´â€²
1

ğœ1

ğœ1

ğœ â€²
1

ğœ1

ğœŒ0
ğ¹ â€²
1
ğœŒğœ â€²
1

ğ¹1

ğœŒ1

ğº1

ğ´2
ğœŒ1

ğ´â€²
2

ğœ2

ğœ2

ğœ â€²
2

ğœ2

ğœŒ1
ğ¹ â€²
2
ğœŒğœ â€²
2

ğ¹2

ğœŒ2

ğº2

ğ´2
ğœŒ2

ğ´â€²
3

ğœ3

ğœ3

ğœ â€²
3

ğœ3

ğœŒ2
ğ¹ â€²
3
ğœŒğœ â€²
3

ğ¹2

ğœŒ3

ğº3

Figure 6: Depiction of the inductive definition of the robust sequence (Definition 15). Also useful to follow proof of Proposition 11.

D PROOFS OF SECTION 8
Lemma 1. Let (ğºğ‘– )ğ‘– âˆˆâ„‘ be the robust sequence associated with a deriva-
tion D. If ğ´ is a finite subset of D âŠ›
, then there exists some ğ‘˜ âˆˆ â„‘
such that, for every ğ‘Ÿ â‰¥ ğ‘˜ âŠ† â„‘, ğ´ âŠ† ğºğ‘Ÿ .

Proof. We first prove (i) for every ğ‘– > 0 âˆˆ â„‘, Â¯ğœ (ğºğ‘– âˆ’1) âŠ†
Â¯ğœ (ğºğ‘– ). Indeed, since ğœğ‘– is a homomorphism from ğºğ‘– âˆ’1 to ğºğ‘– , then
ğœğ‘– (ğºğ‘– âˆ’1) âŠ† ğºğ‘– and thus for any ğ‘— > ğ‘– âˆˆ â„‘, Â¯ğœ ğ‘—
ğ‘– (ğºğ‘– ),
meaning Â¯ğœ (ğºğ‘– âˆ’1) âŠ† Â¯ğœ (ğºğ‘– ).

ğ‘– (ğœğ‘– (ğº ğ‘— âˆ’1)) âŠ† Â¯ğœ ğ‘—

Then we prove (ii) for every Â¯ğœ (ğº ğ‘— ), there exists some ğ‘˜ â‰¥ ğ‘— such
that for every ğ‘Ÿ â‰¥ ğ‘˜, Â¯ğœ (ğº ğ‘— ) âŠ† ğºğ‘Ÿ . For every variable ğ‘‹ in ğº ğ‘— , there
is some ğ‘˜ğ‘‹ âˆˆ â„‘ such that Â¯ğœ (ğ‘‹ ) = ğœğ‘˜ğ‘‹
(ğ‘‹ ) is stable in all atomsets
ğ‘—
(Proposition 10). If we take ğ‘˜ = maxğ‘‹ âˆˆvars (ğº ğ‘— )ğ‘˜ğ‘‹ , then
after ğºğ‘˜ğ‘‹
for every ğ‘Ÿ â‰¥ ğ‘˜, ğœğ‘Ÿ
ğ‘— = ğœğ‘Ÿ
ğ‘— = Â¯ğœ is a homomorphism from ğº ğ‘— to
ğºğ‘Ÿ , and thus Â¯ğœ (ğº ğ‘— ) âŠ† ğºğ‘Ÿ .

ğ‘˜ â—¦ ğœğ‘˜

Finally, since ğ´ is finite and the successive Â¯ğœ (ğºğ‘– ) form a mono-
tonic sequence (see (i)), there exists ğ‘— âˆˆ â„‘ such that ğ´ âŠ† Â¯ğœ (ğº ğ‘— ).
Then (ii) there exists ğ‘˜ â‰¥ ğ‘— such that for every ğ‘Ÿ â‰¥ ğ‘˜, Â¯ğœ (ğº ğ‘— ) âŠ† ğºğ‘Ÿ
â–¡
and thus ğ´ âŠ† ğºğ‘Ÿ .

E PROOFS OF SECTION 9
Theorem 1. CQ entailment is decidable for the class of KBs having a
recurringly treewidth-bounded core chase sequence.

Proof. Let â„­ be the class of KBs having a recurringly treewidth-
bounded core chase sequence. The proof closely follows arguments
from previous work [3, 7]. An algorithm deciding K |= ğ‘„ for a
given K âˆˆ â„­ and conjunctive query ğ‘„ can be devised from two
semi-decision procedures (which, when executed in parallel give
rise to a decision algorithm): one guaranteed to detect K |= ğ‘„
after finite time and another detecting K Ì¸|= ğ‘„. For the former, we
can evoke the fact that thanks to the completeness of first-order
logic [12], the consequences of a first-order theory are recursively
enumerable. So, the first part of the algorithm can just enumerate
the consequences of K and terminate answering â€œyesâ€ as soon as ğ‘„
is found among the consequences. It remains to be shown that there
is a semi-decision procedure detecting K Ì¸|= ğ‘„. By assumption, K
has a finitely universal model ğ¼ with ğ‘¡ğ‘¤ (ğ¼ ) âˆˆ N. From ğ¼ being finitely
universal for K and K Ì¸|= ğ‘„, we can conclude ğ¼ Ì¸|= ğ‘„. But then we
obtain ğ¼ |= ğ¹ âˆ§ ((cid:211) Î£) âˆ§ (Â¬ğ‘„) (assuming that ğ¹ and ğ‘„ are represented
as first-order sentences and Î£ as a set of first-order sentences). This
means, whenever K Ì¸|= ğ‘„, then there exists some ğ‘˜ (namely ğ‘¡ğ‘¤ (ğ¼ ))
such that the first-order sentence ğ¹ âˆ§((cid:211) Î£)âˆ§(Â¬ğ‘„) is satisfiable over

the class of structures of treewidth ğ‘˜. Fortunately, as previously
observed [3, 7], satisfiability of monadic second-order logic â€“ and
thus also of first-order logic â€“ over classes of structures with a
treewidth bounded by a given ğ‘˜ is decidable. This allows to design
a semi-decision procedure that increases ğ‘˜ stepwise and in each
step applies the decision procedure that checks if ğ¹ âˆ§ ((cid:211) Î£) âˆ§ (Â¬ğ‘„)
has a model of treewidth ğ‘˜. If so, the procedure terminates with the
output â€œnoâ€, since we have shown that ğ‘„ cannot be a consequence
of K. If not, we increment ğ‘˜ and repeat. Clearly, thanks to the
above assumption, this semi-decision procedure will output â€œnoâ€
â–¡
and terminate exactly if K Ì¸|= ğ‘„.

Proposition 13. CQ entailment is decidable for any ruleset that is
core-bts. Moreover, core-bts subsumes both finite expansion sets (fes)
and bounded treewidth sets (bts), which are mutually incomparable.

Proof. Decidability follows from Theorem 2. We sucessively

prove the following items:
â€¢ fes and bts are incomparable,
â€¢ fes is subsumed by core-bts.
â€¢ bts is subsumed by core-bts.

For the first bullet point, note that the singleton ruleset {r(ğ‘‹, ğ‘Œ ) â†’
âˆƒğ‘ .r(ğ‘Œ, ğ‘ )} is bts but not fes, whereas the singleton ruleset {r(ğ‘‹, ğ‘Œ )âˆ§
r(ğ‘Œ, ğ‘ ) â†’ âˆƒğ‘‰ .r(ğ‘‹, ğ‘‹ ) âˆ§ r(ğ‘‹, ğ‘ ) âˆ§ r(ğ‘, ğ‘‰ )} is fes but not bts.

For the second bullet point, recall that finite extension sets guar-
antee core-chase termination. Yet, for any finite sequence of finite
structures one can find a uniform finite bound on the treewidth, it
suffices to pick maxğ‘– âˆˆâ„‘ |T (ğ¹ğ‘– )|.

ğ‘– )ğ‘– âˆˆâ„‘ as follows: Let ğœ â€²

ğ‘– where ğœ â€²
ğ‘–+1 (ğ¹ğ‘–+1) = ğ¹ â€²

0 (ğ¹0) = ğœ â€²
ğ‘– , and ğœ â€²
ğ‘–+1 such that ğœ â€²

For the third bullet point, we observe that any treewidth-bounded
restricted chase sequence (ğ¹ğ‘– )ğ‘– âˆˆâ„‘ can be transformed into a core-
chase sequence (ğ¹ â€²
0 be an endomorphism
turning ğ¹0 into a core and let ğ¹ â€²
0 = ğœ â€²
0 (ğ¹ ). From this
starting point, we can always use ğ¹ğ‘– , ğ¹ â€²
ğ‘– (ğ¹ğ‘– ) = ğ¹ â€²
ğ‘–
is a core, to define ğœ â€²
ğ‘–+1 and ğ¹ â€²
ğ‘–+1 is a
ğœğ‘–+1 be an
core as follows: assuming ğ¹ğ‘–+1 = ğ›¼ (ğ¹ğ‘–, (ğ‘…, ğœ‹)), we let
(cid:101)
endomorphism of ğ›¼ (ğœ â€²
ğ‘– (ğ¹ğ‘– ), (ğ‘…, ğœ â€²
ğ‘– â—¦ ğœ‹)) producing a core, which we
choose as ğ¹ â€²
ğ‘–+1 is also a core of ğ¹ğ‘–+1 = ğ›¼ (ğ¹ğ‘–, (ğ‘…, ğœ‹))
witnessed by the endomorphism ğœ â€²
ğ‘– )ğ‘– âˆˆâ„‘
is indeed a core chase sequence, except for some elements being
repeated, which can be removed. Now given that there exists a
bound ğ‘ greater than the treewidth of each element of (ğ¹ğ‘– )ğ‘– âˆˆâ„‘, the
same must hold for (ğ¹ â€²
ğ‘– )ğ‘– âˆˆâ„‘, given that ğ¹ â€²
ğ‘– âŠ† ğ¹ğ‘– for all ğ‘– âˆˆ â„‘. Thus
(ğ¹ â€²
ğ‘– )ğ‘– âˆˆâ„‘ (and any pruned subsequence of it) is uniformly (and hence
â–¡
also recurrently) treewidth-bounded.

ğ‘–+1. Clearly then ğ¹ â€²

ğ‘– . Note that (ğ¹ â€²

ğœğ‘–+1 â—¦ ğœ â€²

ğ‘–+1 = (cid:101)

